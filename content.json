{"meta":{"title":"OliverPai","subtitle":"落叶本就是假的","description":"求索与记录","author":"OliverPai","url":"http://example.com","root":"/"},"pages":[{"title":"标签","date":"2022-07-10T06:59:23.000Z","updated":"2022-07-10T07:01:31.691Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-07-10T06:59:32.000Z","updated":"2022-07-10T07:01:11.993Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"C++基础知识","slug":"C++基础知识/C++基础知识","date":"2022-07-01T04:33:00.000Z","updated":"2022-07-10T11:29:19.416Z","comments":true,"path":"2022/07/01/C++基础知识/C++基础知识/","link":"","permalink":"http://example.com/2022/07/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"C++基础知识 参考资料：- 《C++语言导学》（第一版）- 《C++ primer》（第五版）- 《C++新经典：对象模型》（第一版）- 《C++并发编程实战》（第二版） 时间线：2021&#x2F;10&#x2F;9：开始整理笔记，以《C++语言导学》为线索梳理2022&#x2F;05&#x2F;24：初步整理完成，汇总《C++语言导学》，部分《C++ Primer》和少量《Effective Modern C++》2022&#x2F;06&#x2F;20：开始在笔记中加入并发（《C++并发编程实战》第二版）知识2022&#x2F;07&#x2F;07：学习极客时间“现代C++实战30讲”，添加type_traits相关内容 面向过程1 基础知识 程序编译： ISO的C++标准定义了两种实体： 1.核心语言特性 比如内置类型（int, float）以及循环（for, while）； 2.标准库组件 比如容器（vector, map）以及I&#x2F;O操作（&lt;&lt;, getline）。 预处理期编程： 预处理编程的操作目标是“源码”，各种指令控制预处理器，实际上就是让预处理器改造源码，改造成其他形式。预处理指令以“#”开头，单独的“#”也是一个预处理指令，即空指令，相当于空行。 12345# // 预处理空行#if __linux__ // 预处理检查宏是否存在# define HAS_LINUX 1 // 宏定义，有缩进#endif // 预处理条件语句结束# // 预处理空行 预处理器改造后的代码可以让gcc用-E选项来展开。 包含文件（#include）： #include不仅可以包含头文件，理论上，只要想，源码、普通文本、图片、音频、视频都可以引进来（虽然可能出现无法处理的错误）。比如#include &quot;a.out&quot;。引用头文件时常用的技巧是“Include Guard”： 1234#ifndef _XXX_H_INCLUDE_#define _XXX_H_INCLUDE_... //头文件内容#endif _XXX_H_INCLUDE_ 还有一种常用用法，使用“ *.inc”文件存放一些代码片段。比如有一个很大的用于数值计算的数组，直接放在源码文件里很占地方，不方便对源码的逻辑部分进行梳理查看。那么，便可以把此数组放在calc_values.inc中，通过#include加载它，从而替换原来的大批数字： 12345678910111213//calc_values.inc文件static uint32_t calc_table[] = &#123; // 非常大的一个数组，有几十行 0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, ... &#125;;//源码文件static uint32_t calc_table[] = &#123;# include &quot;calc_values.inc&quot; // 非常大的一个数组，细节被隐藏&#125;; 宏定义（#define&#x2F;#undef）： 宏的展开、替换发生在预处理阶段，对于一些调用频繁的小代码片段，用宏来封装的效果比inline关键字要好，因为其是源码级别的无条件内联，比如Nginx中的代码 1234#define ngx_tolower(c) ((c &gt;= &#x27;A&#x27; &amp;&amp; c &lt;= &#x27;Z&#x27;) ? (c | 0x20) : c)#define ngx_toupper(c) ((c &gt;= &#x27;a&#x27; &amp;&amp; c &lt;= &#x27;z&#x27;) ? (c &amp; ~0x20) : c)#define ngx_memzero(buf, n) (void) memset(buf, 0, n) 宏没有作用域概念，永远生效，因此对于一些用于简化代码、起临时作用的宏，用完后尽快#undef取消定义，避免冲突： 123456789#define CUBE(a) (a) * (a) * (a) // 定义一个简单的求立方的宏cout &lt;&lt; CUBE(10) &lt;&lt; endl; // 使用宏简化代码cout &lt;&lt; CUBE(15) &lt;&lt; endl; // 使用宏简化代码#undef CUBE // 使用完毕后立即取消定义#ifdef AUTH_PWD // 检查是否已经有宏定义# undef AUTH_PWD // 取消宏定义#endif // 宏定义检查结束#define AUTH_PWD &quot;xxx&quot; // 重新宏定义 宏也被常用来做文本替换，比如： 12345678#define BEGIN_NAMESPACE(x) namespace x &#123;#define END_NAMESPACE(x) &#125;BEGIN_NAMESPACE(my_own)... // functions and classesEND_NAMESPACE(my_own) 此处只是简单的文本替换，但是全大写的形式非常醒目，可以更容易识别出命名空间开始和结束的位置。 条件编译（#if&#x2F;#else&#x2F;#endif）： 在预处理阶段实现分支处理，通过判断宏的数值来产生不同的源码，从而改变源文件的形态。#if后的判断依据，也就是定义好的各种宏。 C++版本号宏：__cplusplus，利用该宏来判断当前的环境，从而使用相应的处理方式。 123456789101112131415#ifdef __cplusplus // 定义了这个宏就是在用C++编译 extern &quot;C&quot; &#123; // 函数按照C的方式去处理#endif void a_c_function(int a);#ifdef __cplusplus // 检查是否是C++编译 &#125; // extern &quot;C&quot; 结束#endif#if __cplusplus &gt;= 201402 // 检查C++标准的版本号 cout &lt;&lt; &quot;c++14 or later&quot; &lt;&lt; endl; // 201402就是C++14#elif __cplusplus &gt;= 201103 // 检查C++标准的版本号 cout &lt;&lt; &quot;c++11 or before&quot; &lt;&lt; endl; // 201103是C++11#else // __cplusplus &lt; 201103 // 199711是C++98# error &quot;c++ is too old&quot; // 太低则预处理报错#endif // __cplusplus &gt;= 201402 // 预处理语句结束 C++语言特性宏：可以在预处理阶段判断系统是否支持某些语法特性，若支持就用特性，不支持就用老写法 C++标准提供的宏：C++有很多预定义的宏，如源文件信息的“FILE”“LINE”“DATE”，以及一些测试语言特性是否被支持的宏，如“__cpp_decltype”“__cpp_decltype_auto”“__cpp_lib_make_unique”等。 编译器提供的宏：C++标准里很多宏未定义，但编译器提供，可用g++ -E -dM - &lt; /dev/null查看。 123456789101112131415#if defined(__cpp_decltype_auto) //检查是否支持decltype(auto) cout &lt;&lt; &quot;decltype(auto) enable&quot; &lt;&lt; endl;#else cout &lt;&lt; &quot;decltype(auto) disable&quot; &lt;&lt; endl;#endif //__cpp_decltype_auto#if __GNUC__ &lt;= 4 cout &lt;&lt; &quot;gcc is too old&quot; &lt;&lt; endl;#else // __GNUC__ &gt; 4 cout &lt;&lt; &quot;gcc is good enough&quot; &lt;&lt; endl;#endif // __GNUC__ &lt;= 4#if defined(__SSE4_2__) &amp;&amp; defined(__x86_64) cout &lt;&lt; &quot;we can do more optimization&quot; &lt;&lt; endl;#endif // defined(__SSE4_2__) &amp;&amp; defined(__x86_64) 自定义的宏：可以用自定义的宏来实现条件编译，比如Nginx使用Shell脚本检测外部环境，生成一个包含若干宏的源码配置文件，再条件编译包含不同的头文件，实现操作系统定制化。 123456789101112#if (NGX_FREEBSD)# include #elif (NGX_LINUX)# include #elif (NGX_SOLARIS)# include #elif (NGX_DARWIN)# include #endif 代码禁用启用： 使用#if 1或#if 0来显式启用或者禁用大段代码，要比/*...*/的注释方式安全且清晰： 1234567#if 0 // 0即禁用下面的代码，1则是启用 ... // 任意的代码#endif // 预处理结束#if 1 // 1启用代码，用来强调下面代码的必要性 ... // 任意的代码#endif // 预处理结束 属性：编译期指令 前面的#include、#define都是预处理指令，用于控制预处理器。类似的，还有“编译指令”来控制编译器。 C++11之前标准里没有编译指令，但编译器提供了，比如GCC里的__attribute__，VC里的__declspec C++11开始，官方将编译指令正式命名为“属性”，用两对方括号的形式[[...]]表示，相当于给变量、函数、类等贴上一个编译阶段的标签，让编译器识别。 虽然官方将属性的语法加进来了，但是标准里定义的属性还是十分有限的，最有用的当属C++14的deprecated： 12345[[deprecated(&quot;deadline:2020-12-31&quot;)]]int old_func();//使用此函数的程序编译时会报出一条警告：//warning: ‘int old_func()’ is deprecated: deadline:2020-12-31 [-Wdeprecated-declarations] 属性支持非标准扩展，也就是允许使用编译器提供的非官方属性，比如GCC的属性在gnu::中： gnu::deprecated：与C++14的deprecated相同，但是可以用在C++11里。 gnu::unused：抑制对变量、类、函数的未使用警告，与”(void) var”效果一样。 12[[gnu::unused]] //声明下面的变量暂不使用，不是错误，不需要warningint nouse; gnu::constructor：函数会在main()函数之前执行，效果类似对全局对象的构造函数 gnu::destructor：函数会在main()函数结束之后执行，效果类似对全局对象的析构函数 gnu::always_inline：要求编译器强制内联函数，作用比inline关键字强 12345[[gnu::always_inline]] inlineint get_num()&#123; return 42;&#125; gnu::hot：标记热点函数，要求编译器对其进行更积极的优化 📌constructor和destructor必须使用C语言的语法，比如只能用printf()而不能用cout。 下面两种写法是等价的： 12345678910111213141516171819__attribute__((constructor)) void load_file()&#123; printf(&quot;Constructor is called.\\n&quot;); g_count = (int *)malloc(sizeof(int)); if (g_count == NULL) &#123; fprintf(stderr, &quot;Failed to malloc memory.\\n&quot;); &#125;&#125;__attribute__((destructor)) void unload_file()&#123; printf(&quot;destructor is called.\\n&quot;); if (g_count) free(g_count);&#125;int main()&#123; return 0;&#125; 123456789101112131415161718192021[[gnu::constructor]] void load_file()&#123; printf(&quot;Constructor is called.\\n&quot;); g_count = (int *)malloc(sizeof(int)); if (g_count == NULL) &#123; fprintf(stderr, &quot;Failed to malloc memory.\\n&quot;); &#125;&#125;[[gnu::destructor]] void unload_file()&#123; printf(&quot;destructor is called.\\n&quot;); if (g_count) free(g_count);&#125;int main()&#123; return 0;&#125; 函数： 123//返回值类型 函数名字（函数参数）double sqrt (double);double sqrt (double d); 1.对于类成员函数来说，类名字也是函数名字的一部分char&amp; String::operator[](int index); 2.编译器会检查实参的类型，并且会在必要的时候执行隐式实参类型转换 sqrt(2); 3.函数重载可能会因为二义性报错： 12345void print(int, double);void print(double, int);void user()&#123; print(0,0); //此时会报错，因为两个print都可以用&#125; 📌C++和C编译文件的区别：C语言不支持重载，而C++支持。如一个函数声明为void function(float x,float y)，在C语言中，编译器进行编译之后，在库中的名字为_function；在C++中，编译器进行编译后，在库中的名字为_function_float_float。编译器在链接的阶段，都是找到相应的函数名，进行链接。在C语言中，两个函数的名字一样，就会在链接时报错；在C++中 ，两个函数名字不相同，就不会报错。 变量类型与算术： 基本类型：bool，int，double，char，unsigned，等 算术运算符 比较运算符 逻辑运算符 1234567x+y //二元加法+x //一元正（结果没区别）x-y //二元减法-y //一元负（结果取负）x*y //乘法x/y //除法x%y //取模 123456x==yx!=yx&lt;yx&gt;yx&lt;=yx&gt;=y 123456x&amp;y //按位与x|y //按位或x^y //按位异或~x //按位求补x&amp;&amp;y //逻辑与x||y //逻辑或 初始化的两种方式：&#x3D;赋值运算符 和 {}初始值列表，二者区别在于前者允许隐式类型转换，而后者不允许 12double x = 2.4complex &lt;double&gt; test = &#123;2.4,2&#125;;//正确，会转换 12double x &#123;2.4&#125;;//正确complex &lt;double&gt; test &#123;2.4, 2&#125;//错误，2是int 由于不允许隐式类型转换，所以一般建议初始值列表的方式初始化变量，可以避免一些导致部分信息丢失的类型转换 还可以使用auto关键字根据初始值自动推断类型 1234auto b = true;auto ch = &#x27;x&#x27;;auto i = 123;auto d = 1.2; 常量： const：保证变量不变 const int dmv = 17; constexpr：编译时求值 constexpr double max1=square(dmv); 📌constexpr若要用在编译时求值场景，右式必须是常量表达式！ 12//常量表达式函数必须有constexpr声明constexpr double square(double x)&#123;return x*x;&#125; 由constexpr声明的函数可以接受非常量实参，但此时将不再是常量表达式；若接受的是常量实参，此时是常量表达式。 123int var = 17;constexpr result1 = square(var);//报错！因为square(var)非常量表达式，不可编译时求值 ↑错误 →正确 12345const int dmv = 17;constexpr result2 = square(dmv);//正确！square(dmv)是常量表达式，此时编译时求值const result3 = square(var);//正确！result3仍是常量，此为运行时求值 作用域与生命周期： 局部作用域： 类作用域： 命名空间作用域： 循环与条件： 普通for 123for(auto i = 0; i != 10; ++i)&#123; //......&#125; 普通while 123while(i++ != 10)&#123; //......&#125; for循环的执行顺序：先auto i&#x3D;0，再判断i≠10，若满足，执行{ }中的内容，再进行++i，然后判断i≠10，满足则执行{ }，再++i，循环往复。 for…range（类似于Python里的for） 拷贝形式的for…range（x是v中元素的拷贝值） 12345int v[] &#123;1,2,3,4,5,6,7,8&#125;;for(auto x:v) print(&quot;%d&quot;, x);for(auto x:&#123;1,2,3,4,5&#125;) print(&quot;%d&quot;, x); 引用形式的for…range（x是v中元素的引用） 12for(auto&amp; x:v) ++x; switch 1234567891011switch(ch)&#123; case &#x27;u&#x27;: //...... break; case &#x27;d&#x27;: //...... break; default: //...... break;&#125; switch的限制： ch必须是一个整形或枚举类型，或者是一个class（class中有转换函数将其转换为整型或枚举类型） 内联函数： 内联函数以空间换时间，省去调用函数的额外开销。所以代码很长或有循环的时候不适合使用内联； inline对编译器而言只是一个建议，如果定义的函数体内有递归&#x2F;循环等，编译器优化时自动忽视内联； inline必须与函数定义放在一起，仅将内联放在声明前是不起作用的； 定义在类内的成员函数默认为内联函数； 内联与宏函数的区别： 宏： 没有类型检测，不安全 不能进行调试 不可以访问类的成员变量 内联函数： 有类型检测，较安全 进行参数传递，可在运行时调试 可以访问类的成员变量 指针与引用： 空指针尽量用nullptr，使用NULL可能会导致与整数0的混淆。 12char* p = &amp;v[3]; //p指向v数组中的第四个元素的地址char x = *p; //v是p指向地址的变量的值 📌前置&amp;表示一个变量的地址；后置&amp;表示声明一个引用 将引用传入作为函数实参 一般来说，函数实参的传递是一个拷贝的过程，将变量的值拷贝到函数的栈中，不会带来对原变量的影响。 而若将引用作为参数传递void sort(vector&lt;double&gt;&amp; vec);，sort函数将直接操纵vec向量，没有拷贝的过程。这样可以加快速度，节省空间，但带来了操作原变量，误改动值的风险。 若想加快传入大数组参数的速度，又不改变值，可以加入const限定！ 1double sum(const vector&lt;double&gt;&amp; vec); 二级指针与指针的引用 二级指针 指针的指针，作用是改变指针本身的内容。 指针的引用 指针的引用，可以写为int *&amp;i;形式，本质是((int*)&amp;) i;，表示i是一个int型指针的引用，也可以像二级指针一样修改指针本身的内容。 需要说明的是，没有指向引用的指针，因为引用不是变量，因此不存在指针。 2 用户自定义类型 这是C++提供的一种抽象机制，用户可以此机制定义自己想要实现某些功能的新类型 结构体： 12345678struct Vector&#123; int sz; //元素的数量 double * elem;//指向元素的指针&#125;;void Vector_init(Vector&amp; v, int s)&#123; v.elem = new double[s]; v.sz = s;&#125; 访问结构体的元素有两种方式，点运算符和→运算符（指针） 1234567Vector v &#123;0, nullptr&#125;;Vector_init(v, 3);v.elem[0] = 1,v.elem[1] = 2,v.elem[2] = 3;Vector&amp; rv = v;Vector* pv = &amp;v; cout &lt;&lt; v.sz &lt;&lt; rv.sz &lt;&lt; pv-&gt;sz &lt;&lt; endl; 结构体的多种初始化方法： 📌结构体初始化：- {}初始化：Node b = &#123;2, nullptr&#125;或 Node b &#123;2, nullptr&#125;;- 构造函数初始化：&#96;struct Node{ int var; Node* `\\*\\*`next; Node(int value, Node next_ty)&#123; this→var = value; this→next = next_ty; &#125; //或者： Node(int value, Node* next_ty):var(value), next(next_ty)&#123;&#125;; };&#96;&#96;Node c(3, nullptr) 或 Node* d &#x3D; new Node(4,nullptr)&#96; 类： 类有一系列成员，可能是数据、函数或类型。public成员定义了该类的接口，private成员则只能从接口访问 123456789class Vector&#123;public: Vector(int s): elem&#123;new double[s]&#125;, sz&#123;&#125; &#123;&#125; //构造函数的初始值列表 double&amp; operator[](int i)&#123; return elem[i]; &#125; int size() &#123; return sz; &#125;private: double* elem; // 指向元素的指针 int sz; //元素的数量&#125; 需要注意的一点是，虽然Vector类中elem的元素个数可能会变，但是Vector声明的对象大小是不变的。这一点也适用于所有类声明的对象。 📌struct和class并没有太大区别，struct中也可以定义一些成员函数。唯一的区别体现在struct中的所有成员都是public的。 枚举： 普通枚举：enum 普通枚举的枚举值都是整形，默认情况下枚举值对应的整数从0开始，依次加1 12enum Color &#123;red, green, blue&#125;;int col = green; //col的值变为1 强类型枚举：（scoped enumeration，C++11引入的特性） 强类型中，每个enum class是不同的类型，其枚举值位于指定的作用域中，不得混用，可避免对常量的意外误用 1234567enum class Color &#123;red, blue, green&#125;;enum class Traffic_light &#123;green, yellow, red&#125;;Color x = red; //报错，哪个red？Color y = Traffic_light::red; //报错，这个Red不是一个Color对象Color z = Color::red; //正确 int col = Color::red; //报错，Color::Red不是一个int 强类型枚举并不和普通枚举一样，枚举值并不是int。但其作为一种用户自定义类型，也可进行运算符重载 1234567Traffic_light&amp; operator++(Traffic_light&amp; t)&#123;//前置++运算符 switch(t)&#123; case Traffic_light::green: return t = Traffic_light::yellow; case Traffic_light::green: return t = Traffic_light::yellow; case Traffic_light::green: return t = Traffic_light::yellow; &#125;&#125; 联合： union的所有成员被分配在同一片内存区域中，其实际占用的空间就是它最大的成员所占的空间。同一时刻，union中只能保存一个成员的值。 12345678910111213enum Type &#123;str, num&#125;;struct Entry&#123; char* name; Type t; char* s; //如果t==str,则使用s int i; //如果t==num,则使用i&#125;;void f(Entry* p)&#123; if(p-&gt;t==str) cout &lt;&lt; p-&gt;s; //......&#125; 如左边程序所示，s和i永远不会同时用到，但又同时定义了二者，所以无形中浪费了内存空间，使用联合可解决该问题。 命名联合和匿名联合均可！ 1234567891011121314151617//命名联合体enum Type &#123;str,num&#125;;union Value&#123; char* s; int i;&#125;;struct Entry&#123; char* name; Type t; Value v;&#125;;void f(Entry* p)&#123; if(p-&gt;t==str) cout&lt;&lt;p-&gt;v.s; //......&#125; 1234567891011121314151617//匿名联合体enum Type &#123;str,num&#125;;struct Entry&#123; char* name; Type t; union &#123; char* s; int i; &#125;;&#125;;void f(Entry* p)&#123; if(p-&gt;t==str) cout&lt;&lt;p-&gt;s;//匿名的优势在于，可以直接用 //......&#125; 注意：初始化此结构体不能再Entry test&#123;&quot;abc&quot;, num, 123&#125;，{}会按{char , Type, char}初始化，发挥不了union优势 要逐个赋初值，以匿名联合体为例，要Entry test;test.name=&quot;abc&quot;; test.t=str;test.s=&quot;abc&quot;;//test.t=num;test.i=123; auto&#x2F;decltype auto自动类型推到，在代码里的作用像一个占位符，写上它，让编译器自动填上变量的类型。其属于编译阶段的特殊指令，因此在泛型编程和模板元编程里有比较多的使用。decltype比较像函数，来计算类型，跟auto很像。（也是编译阶段的类型推导） auto注意事项： auto的自动推导能力只能用在“初始化”场合 12345auto x = 0L; // 自动推导为longauto y = &amp;x; // 自动推导为long*auto z &#123;&amp;x&#125;; // 自动推导为long* auto err; // 错误，没有赋值表达式，不知道是什么类型 类成员变量初始化时，不允许使用auto推导类型 1234class X final&#123; auto a = 10; // 错误，类里不能使用auto推导类型&#125;; auto总是推导出“值类型”，绝不会是“引用”；但是auto可以附加上const、 *、&amp;等，得到新的类型 123456auto x = 10L; // auto推导为long，x是longauto&amp; x1 = x; // auto推导为long，x1是long&amp;auto* x2 = &amp;x; // auto推导为long，x2是long*const auto&amp; x3 = x; // auto推导为long，x3是const long&amp;auto x4 = &amp;x3; // auto推导为const long*，x4是const long* decltype注意事项：decltype没有auto这么多局限，前述auto的三个事项在decltype这里均不需要注意。 类型推导时不需要初始化（后面无需有表达式），可以直接声明变量； decltype不仅能够推导出值类型，还能推导出引用类型，即“原始类型” 12345678int x = 0; // 整型变量decltype(x) x1; // 推导为int，x1是intdecltype(x)&amp; x2 = x; // 推导为int，x2是int&amp;，引用必须赋值decltype(x)* x3; // 推导为int，x3是int*decltype(&amp;x) x4; // 推导为int*，x4是int*decltype(&amp;x)* x5; // 推导为int*，x5是int**decltype(x2) x6 = x2; // 推导为int&amp;，x6是int&amp;，引用必须赋值 C++14引入了decltype(auto)，既能够精确推导类型，又可以像auto一样方便（decltype里不再每次都输入特定的表达式了） 12345int x = 0; // 整型变量decltype(auto) x1 = (x); // 推导为int&amp;，因为(expr)是引用类型decltype(auto) x2 = &amp;x; // 推导为int*decltype(auto) x3 = x1; // 推导为int&amp; auto和decltype的使用： auto使用场景：变量声明、range-based for：for(auto&amp; i : vec)、函数返回值auto test()&#123;&#125;（C++14） decltype的使用场景： 当类型非常奇怪时，给奇怪类型一个别名 12345// UNIX信号函数的原型，看着就让人晕，你能手写出函数指针吗？void (*signal(int signo, void (*func)(int)))(int)// 使用decltype可以轻松得到函数指针类型using sig_func_ptr_t = decltype(&amp;signal) ; 类内成员，auto被禁，decltype可以替换 123456789101112class DemoClass final&#123;public: using set_type = std::set; // 集合类型别名private: set_type m_set; // 使用别名定义成员变量 // 使用decltype计算表达式的类型，定义别名 using iter_type = decltype(m_set.begin()); iter_type m_pos; // 类型别名定义成员变量&#125;; 位域C++中的类和结构体可以包含比内置整形类型占用更少存储空间的成员。这些成员可以指定位数大小，叫做“位域”。 位域可以看做内置整形类型的子集，位域成员可以指定其在结构体中占用的位数。 123456struct Date&#123; unsigned short nWeekDay : 3; //3 bits unsigned short nMonthDay : 6; //6 bits unsigned short nMonth : 5; //5 bits unsigned short nYear : 8; //8 bits&#125;; 声明为位域的数据从低位到高位进行排序 假定系统中unsigned short是16位的，nYear8位，会溢出unsigned short类型的单元边界，因此它会从新的unsigned short开始。同时，还可以有匿名位域（宽度为0），匿名位域会强制下一字段与下一个类型边界对齐 1234567struct Date&#123; unsigned short nWeekDay : 3; //3 bits unsigned short nMonthDay : 6; //6 bits unsigned : 0; //强制对齐到下一边界 unsigned short nMonth : 5; //5 bits unsigned short nYear : 8; //8 bits&#125;; 带有零长度位域的对象布局 📌位域字段的基础类型必须是整形类型（内置的那些） 3 模块化 命名空间： 一段完整的程序可能是由不同部分构成的，应对这种情况，为使结构清晰且编译加快，应该使用分离编译，即在头文件中声明，利用头文件提供接口，具体实现在不同源文件中。 但是若有多个开发者共同开发，把模块组装在一起构成程序并不一定是一件容易的事情，特别是当不同开发者命名了同一个函数名时。命名空间为解决此情况问题而生。 如要声明一个自己的complex类型，但又不想与std库中的complex类型冲突： 123456789101112131415namespace My_Code&#123; class complex&#123; //...... &#125;; complex sort(complex);&#125;My_Code::complex My_Code::sort(My_Code::complex)&#123; //......&#125;int main()&#123; My_Code::complex a &#123;1,2&#125;; My_Code::complex result = My_Code::sort(a);&#125; 当然，如果不想写的像上面那样繁琐，也可以直接用using关键字using namespace My_Code，使得一个指定命名空间的名字在当前在当前作用域中可见。 4 错误处理 异常&amp;不变式： 异常负责报告运行时程序发射时能够的错误。由throw语句指定。例如在自定义Vector时，需要确保索引Vector对象时，不会有越界的情况发生。因此，可以在operator[]()中抛出异常： 12345double&amp; Vector::operator[](int i)&#123; if(i&lt;0 || size()&lt;=i) throw out_of_range&#123;&quot;Vector::operator[]&quot;&#125;; return elem[i];&#125; throw将程序的控制权从调用了Vector::operator[]()的函数转移到了out_of_range异常的异常处理代码。比如下面当try中的索引越界，抛出out_of_range异常后，会进入catch块中的代码： 12345678910void f(Vector&amp; v)&#123; //... try &#123; //可能发生越界错误的代码被放在了try块中 v[v.size()] = 7; &#125; catch (out_of_range) &#123; //捕捉到越界异常 //处理越界错误 &#125; //...&#125; 除此之外，在调用构造函数构造Vector时，传入的参数也需要满足一些条件。将从调用构造函数，直到调用析构函数这一过程中，对象始终所满足的要求称为不变式(Invariant)。比如调用Vector构造函数指定包含多少个元素，却传进了一个负值，这时需要不变式来约束。这种情况下的不变式可以通过异常实现。 123456789101112131415161718Vector::Vector(int s)&#123; if (s &lt; 0) throw length_error&#123;&#125;; elem = new double[s]; sz = s;&#125;void test()&#123; try &#123; Vector v(-27); &#125; catch (std::length_error) &#123; //处理负值问题 &#125; catch (std::bad_alloc) &#123; //处理内存耗尽问题 &#125;&#125; 📌当希望一个函数永远不抛出异常，可以将其声明为noexcept。这样的话当函数抛出了异常，标准库函数terminate()会立即终止当前程序的执行，避免异常的传播和扩散。noexcept 等效于 noexcept(true)C++11后，类的析构函数默认是noexcept，也就是析构函数不允许抛出异常。但如果人为将声明改为noexcept(false)，或者其基类的析构函数是noexcept(false)，那么此时的析构函数可以抛出异常。此外，noexcept自身也可以是一个运算符，标志一个函数是否被声明成了noexcept，是否能抛出异常。&amp;#x20; 123456789101112131415void f() noexcept; //函数f()不抛出异常void (*fp) noexcept(false); //fp指向可能抛出异常的函数void g(void pfa() noexcept); //g接收不抛出异常的函数的指针noexcept(f); //返回值为true//两种noexcept可配合于函数模板//以声明函数对某些类型抛异常，但不对其他类型抛出template &lt;class T&gt;void fun() noexcpet(noexcept(T()))&#123;//...&#125; 静态断言： 上述两种方式均为运行时报错，而静态断言可以在编译时报错，从而让开发者改进代码以规避运行时的错误。static_assert(A,S)机制的作用是，当A不为true时，把S作为一条编译器错误信息输出。 📌需注意，A必须是常量表达式！ 12345constexpr double C = 299792.458;double speed = 100000;const double local_max = 160.0/(60*60);static_assert(speed&lt;C,&quot;can&#x27;t go that fast&quot;); // 报错，speed不是常量，非常量表达式static_assert(local_max&lt;C,&quot;can&#x27;t go that fast&quot;); // 正确，常量表达式 5 constconst常量与宏的区别const定义的常量在预处理阶段并不存在，而是直到运行阶段才出现。也就是说，const声明出来的是一种“只读变量”，可以用指针获取地址。既然可以获取指针，那么便可以利用指针再强制写入，从而“常量不常”。 123456//需要加上volatile修饰，运行时才能看到效果const volatile int MAX_LEN = 1024;auto ptr = (int*)(&amp;MAX_LEN);*ptr = 2048;cout &lt;&lt; MAX_LEN &lt;&lt; endl;//输出2048 修改时需要用volatile禁用优化。不加的话编译器看到const会采取优化手段，把所有const常量出现的地方替换成原值 const修饰成员函数123const int&amp; fun(int&amp; a); //修饰返回值int&amp; fun(const int&amp; a); //修饰形参int&amp; fun(int&amp; a) const&#123;&#125; //const成员函数 const修饰返回值 const修饰返回值多是在返回类型为引用的情况下，避免返回值被修改的情况。 因为此时这个引用比不是临时对象的引用，必然是成员变量后函数参数。不用const修饰可能会成为左值被修改，如下： 1234567891011121314151617181920class A&#123;private: int data;public: A(int num):data(num)&#123;&#125; ~A()&#123;&#125;; int&amp; get_data() &#123; return data; &#125;&#125;;int main()&#123; A a(1); a.get_data()=3; cout&lt;&lt;a.get_data()&lt;&lt;endl; //data=3 return 0;&#125; 如果返回值加上了const，此时试图改变返回值的操作是不允许的，编译会报错。从而规避上述情况。 const修饰形参 传引用的方式可以节省内存，提高效率。但导致了函数具备修改该值的风险。如果在引用类型的形参前加const，就可以规避此风险。 const修饰成员函数 考虑这样一种场景：一个对象被声明成const，但是其某个成员函数非const，此时通过该对象调用该成员函数，编译器会报错 12const String str(&quot;hello world&quot;);str.print(); //类内的print没有被const修饰 这是因为调用成员函数时，会使用this指针。但是我们定义了一个const对象，但this指针不是const类型的，所以出现参数类型不匹配，编译无法通过的情况。 用const修饰成员函数，实质上是修饰this所指向的对象。 当类内没有函数重载，即只有一个版本的成员函数时，const对象只能调用const成员函数，non-const对象既可以调用const成员函数，也可以调用non-const成员函数。 而如果一个成员函数同时有const和non-const两个版本的话，const对象只能调用const成员函数，non-const对象只能调用non-const成员函数。 const修饰指针 const char* ptr：* ptr是const的，即不能通过*ptr修改值，但是ptr可以修改，值也可改 1234567char str[] = &quot;hello world&quot;;char ss[] = &quot;good game||&quot;;const char* ptr = str;ptr[0] = &#x27;s&#x27;; //报错！str[0] = &#x27;s&#x27;; //不报错，正常，输出会得到&quot;sello world&quot;ptr = ss; //不报错，输出*ptr会得到&quot;good game||&quot; char const* ptr：与const char*一致。 char* const ptr：ptr是const的，即不能修改ptr，但可以通过*ptr改值 123456char str[] = &quot;hello world&quot;;char ss[] = &quot;good game||&quot;;char* const ptr = str;ptr[0] = &#x27;s&#x27;; //正常ptr = ss; //报错 📌const在*前值不变，const在*后地址不变值得注意的是，有一种说法为const在前的属于底层const，而const在后的属于顶层constconst int*，const int&amp;这种属于底层const，使得值不可改；int* const属于顶层const，值可改 6 匿名函数（lambda表达式）具体形式：[capture](parameters)→return-type&#123;body&#125; 如最简单的形式： 1[](int x, int y)-&gt;int &#123;int z=x+y; return z;&#125; 若想捕获外部变量，可在[ ]内输入外部参数： 123456[] //未定义变量.试图在Lambda内使用任何外部变量都是错误的.[x, &amp;y] //x 按值捕获, y 按引用捕获.[&amp;] //用到的任何外部变量都隐式按引用捕获[=] //用到的任何外部变量都隐式按值捕获[&amp;, x] //x显式地按值捕获. 其它变量按引用捕获[=, &amp;z] //z按引用捕获. 其它变量按值捕获 1234567std::vector&lt;int&gt; some_list;int total = 0;for (int i=0;i&lt;5;++i) some_list.push_back(i);std::for_each(begin(some_list), end(some_list), [&amp;total](int x) &#123; total += x;&#125;); 📌[ ]中想捕获this时，this只能按值捕获[this]。 如果用户想把lambda表达式当作一个参数来传递，可以用auto关键字（转换成std::function对象）帮助存储： 12345678910111213141516171819#include&lt;functional&gt;#include&lt;vector&gt;#include&lt;iostream&gt;double eval(std::function&lt;double(double)&gt; f, double x = 2.0)&#123;return f(x);&#125;int main()&#123; std::function&lt;double(double)&gt; f0 = [](double x)&#123;return 1;&#125;; auto f1 = [](double x)&#123;return x;&#125;; decltype(f0) fa[3] = &#123;f0,f1,[](double x)&#123;return x*x;&#125;&#125;; std::vector&lt;decltype(f0)&gt; fv = &#123;f0,f1&#125;; fv.push_back ([](double x)&#123;return x*x;&#125;); for(int i=0;i&lt;fv.size();i++) std::cout &lt;&lt; fv[i](2.0) &lt;&lt; &quot;\\n&quot;; for(int i=0;i&lt;3;i++) std::cout &lt;&lt; fa[i](2.0) &lt;&lt; &quot;\\n&quot;; for(auto &amp;f : fv) std::cout &lt;&lt; f(2.0) &lt;&lt; &quot;\\n&quot;; for(auto &amp;f : fa) std::cout &lt;&lt; f(2.0) &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; eval(f0) &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; eval(f1) &lt;&lt; &quot;\\n&quot;; return 0;&#125; 📌- std::function&lt;double(double)&gt;里，括号外的double是返回类型，括号里的double是参数类型- decltype()，C++11中的类型说明符，返回操作数的数据类型。 lambda表达式其实是一种闭包。 mutable 修饰类内成员 前面说到，被const修饰的常成员函数，不会修改对象的任何属性。但是没有提到一种情况，那就是该属性由mutable修饰。mutable的作用是：可以在常成员函数中被修改其值。 1234567class A&#123;public: void print(void) const&#123; cout &lt;&lt; m_data++ &lt;&lt; endl; &#125; mutable int m_data;&#125;; 修饰匿名函数 当[]中采用值捕获时，是不允许在匿名函数内部修改捕获的变量的值的。但是如果有mutable修饰匿名函数，则在捕获时会创建该变量在匿名函数中的同名拷贝，而且该拷贝会一直存在，直到匿名函数作用域完结。此时，匿名函数内部可以对该“变量”（实质上是拷贝）进行修改，同时不必担心原变量被修改。而且每次进入相同的匿名函数时，该拷贝都会维持上一次调用该函数时的值。 1234567891011121314151617int main()&#123; int t = 10; //按值捕获 auto f = [t]() mutable &#123; return ++t; &#125;; auto f2 = [t]() mutable &#123; return ++t; &#125;; cout &lt;&lt; f() &lt;&lt; endl; //11 cout &lt;&lt; f2() &lt;&lt; endl; //11 cout &lt;&lt; f() &lt;&lt; endl; //12 cout &lt;&lt; f2() &lt;&lt; endl; //12 cout &lt;&lt; t &lt;&lt;endl; //10&#125; 7 函数指针函数指针指向的是函数而非对象，其指向的函数的类型，仅由其返回值类型和形参类型决定，与函数名无关。比如： 1bool lengthCompare(const string &amp;, const string &amp;); 定义了一个函数lengthCompare，其类型为bool(const string&amp;, const string&amp;)。可以声明一个指针pf： 1bool (*pf)(const string &amp;, const string &amp;); 📌*pf两端的括号必不可少。如果不写这对括号，表示一个函数，返回bool*类型的返回值 这是一个指向bool(const string&amp;, const string&amp;)类型函数的函数指针，因此可以有 123456pf = lengthCompare; //pf指向lengthCompare函数pf = &amp;lengthCompare; //等价的赋值语句：取地址符是可选的bool b1 = pf(&quot;hello&quot;, &quot;goodbye&quot;); //调用lengthCompare函数bool b2 = (*pf)(&quot;hello&quot;, &quot;goodbye&quot;); //一个等价的调用bool b3 = lengthCompare(&quot;hello&quot;, &quot;goodbye&quot;); //另一个等价的调用 重载函数的指针如果指针指向一个函数，这个函数的函数名被很多函数共享，即出现重载，那么编译器需要通过指针类型决定选用哪个函数 123456void ff(int*);void ff(unsigned int);void (*pf1)(unsigned int) = ff; //pf1指向ff(unsigned)void (*pf2)(int) = ff; //错误，没有可以匹配的重载（参数角度）double (*pf3)(int*) = ff; //错误，没有可以匹配的重载（返回类型角度） 可以看出，相比于一般的重载（只看形参，不看返回值），函数指针在重载的选择上要苛刻一些，既考虑了形参，又要考虑返回值类型。 函数指针形参C++“表面上”是可以把“函数类型”作为形参传入一个函数的，即： 123//第三个形参是函数类型void useBigger(const string &amp;s1, const string &amp;s2, bool pf(const string &amp;, const string &amp;)); 实际上，编译器偷偷地做了一个隐式转换，将所谓的函数类型给解释成了函数指针问题，即转换成了 12void useBigger(const string &amp;s1, const string &amp;s2, bool (*pf)(const string &amp;, const string &amp;)); 此时可以直接把函数名作为实参传入，它会被自动转换成指针： 1useBigger(s1, s2, lengthCompare); 利用类型别名和decltype简化函数指针： 1234567/* ---- 函数类型别名 ---- */typedef bool Func(const string&amp;, const string&amp;); //定义Func为bool(const string&amp;, const string&amp;)类型typedef decltype(lengthCompare) Func2; //定义Func2为与lengthCompare类型一致的函数类型/* ---- 函数指针别名 ---- */typedef bool(*FuncP) (const string&amp;, const string&amp;); //定义FuncP为函数指针typedef decltype(lengthCompare) *FuncP2; //decltype返回的是类型，所以要加上*才能使FuncP2指针 那么在使用的时候，就可以使用下面这几种等价写法 1234void useBigger(const string&amp;, const string&amp;, Func);void useBigger(const string&amp;, const string&amp;, Func2);void useBigger(const string&amp;, const string&amp;, FuncP);void useBigger(const string&amp;, const string&amp;, FuncP2); 第1、2条语句中，编译器自动将Func、Func2类型转换成函数指针 返回指向函数的指针函数不能作为另一个函数的返回值，但是函数可以返回函数指针，以达到类似效果。然而，返回值不再像形参一样，编译器不再对返回值进行自动的隐式转换，因此返回值需要显式声明为函数指针类型。而简化这种显式声明的方式仍然是别名： 123456using F = int(int*, int); //F是函数类型，不是指针using PF = int(*)(int*, int); //PF是指针类型PF f1(int); //正确：PF是指向函数的指针，f1返回指向函数的指针F f1(int); //错误：F是函数类型，f1不能返回一个函数F *f1(int); //正确：显式地指定返回类型是指向F类型函数的指针 此外，还有一种奇技淫巧，可以用下面的形式声明f1： 12345int (*f1(int)) (int*, int);/*需要按照由内向外的顺序解读此代码：f1有形参列表，所以它是函数，f1前面有*，所以f1返回一个指针；进一步观察发现，指针的类型本身也包含形参列表，因此指针指向函数，该函数的返回值类型是int*/ Modern C++中，也可以用尾置返回类型的方式，声明一个返回函数指针的函数 1auto f1(int) -&gt; int(*)(int*, int); 8 常用关键字四种cast（转换） const_cast 用于将const变量转化为非const。 static_cast 用于各种隐式转换，比如非const转const，void*转指针等，static_cast能用于多态向上转化，如果向下转，不管是否非法，都会直接转而无视潜在的问题，因此不安全。 dynamic_cast 用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果转化的是指针，且是非法的，返回NULL；如果转化的是引用，且是非法的，则抛出异常（相比于static_cast更安全）。 12345678910111213141516171819202122232425// 我是父类class Tfather&#123;public: virtual void f() &#123; cout &lt;&lt; &quot;father&#x27;s f()&quot; &lt;&lt; endl; &#125;&#125;;// 我是子类class Tson : public Tfather&#123;public: void f() &#123; cout &lt;&lt; &quot;son&#x27;s f()&quot; &lt;&lt; endl; &#125; int data; // 我是子类独有成员&#125;;Tfather father;Tson son;son.data = 123;Tfather* pf;Tson* ps;/* 上行转换：没有问题，多态有效 */ps = &amp;son;pf = dynamic_cast&lt;Tfather *&gt;(ps); reinterpret_cast 几乎什么都可以转，比如将int转为指针，可能会出问题，尽量少用。 📌为什么不使用C的强制转换？C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。 隐式转换的四种方式：1. 算术表达式int m&#x3D;10; double n&#x3D;m; &#x2F;&#x2F;n&#x3D;10.0，隐式把m转为double类型2. 赋值int* p &#x3D; NULL; &#x2F;&#x2F;NULL(0)隐式转换为int*类型的空指针值3. 函数入参float add(float f); add(2); &#x2F;&#x2F;2隐式转换为float类型4. 函数返回值double minus(int a, int b) { return a-b; } &#x2F;&#x2F;返回值隐式转换为double类型 static作用 static作用在全局变量 加了static之后，变量只在当前文件有效 static作用在类成员变量 static成员变量可以实现多个对象之间的数据共享，静态数据成员只存储一处，供所有对象共用 static作用在全局函数 在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static 如果想要其他文件可以引用本地函数，则要在函数定义时使用关键字extern，表示该函数是外部函数，可供其他文件调用 static作用在类成员函数 由于static修饰的类成员属于类，不属于对象，因此static类成员函数是没有this指针的，正因为没有this指针，所以static类成员函数不能访问非static的类成员，只能访问 static修饰的类成员 📌phread_create参数必须是static的，因为非static会自动加一个this指针，导致传入参数和函数不匹配 📌C++是否允许同时用const和static修饰一个成员函数呢？答案是不可以，C++编译器在实现const的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数const this *。但当一个成员为static的时候，该函数是没有this指针的。也就是说此时const的用法和static是冲突的。 同理，virtual和static也不能一起用，virtual也有一个隐含参数this指针。 9 再看函数重载函数重载取决于参数的类型、个数，而跟返回类型无关。编译器通过在编译时对函数重新命名以解决同名冲突。 对于普通函数： 123456void print(int i)&#123; cout &lt;&lt; &quot;Print an integer: &quot; &lt;&lt; i &lt;&lt;endl;&#125;void print(String s)&#123; cout &lt;&lt; &quot;Print a string: &quot; &lt;&lt; s &lt;&lt; endl;&#125; 执行objdump -d a.out &gt;log.txt反汇编，可以将编译结果打印到log.txt中进行分析。分析可知： void print(int i)→**_Z5printi** void print(String s)→**_Z5printSs** 其中Z5表示返回值类型，i表示int类型,Ss表示String类型（g++编译结果，vs的方案可能会有出入） 对于类内的函数重载： 123456789class test&#123;public: void print(int i)&#123; cout &lt;&lt; &quot;int&quot; &lt;&lt; endl; &#125; void print(char c)&#123; cout &lt;&lt; &quot;char&quot; &lt;&lt; endl; &#125;&#125;; 反汇编后，可知两个函数被映射为： void print(int i)→**_ZN4test5printEi** void print(char c)→**_ZN4test5printEc** N4test表示作用域。 由以上可知，g++对函数重载的映射机制为：作用域 + 返回类型 + 函数名 + 参数列表 虽然返回值类型也参与了函数重载的映射机制，但是编译器处理函数重载时并不考虑返回值类型，这样可使函数调用时独立于上下文，而且减少很多麻烦，如： 12345678910float sqrt(float);double sqrt(double);void f(double da, float fla)&#123; float fl = sqrt(da); // 调用sqrt(double) double d = sqrt(da); // 调用sqrt(double) fl = sqrt(fla); //调用sqrt(float) d = sqrt(fla); //调用sqrt(float)&#125; 函数重载时的匹配优先级 C++ Primer 6.6节 C++编译器力图找最佳匹配。为了确定最佳匹配，编译器将实参类型向形参类型的转换划分为几个等级，具体排序如下： 精确匹配，包括以下情况 实参类型和形参类型相同 实参从数组类型或函数类型转换为对应的指针类型 数组类型转指针：在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针 12int ia[0];int* ip = ia; 函数类型转指针：当把一个函数名传入函数时，编译器会隐式将其转换为函数指针类型 12345bool lengthCompare(const string&amp;, const string&amp;);void useBigger(const string&amp; s1, const string&amp; s2, bool (*pf)(const string&amp;, const string&amp;));useBigger(s1, s2, lengthCompare); 向实参添加顶层const或从实参删除顶层const 可以理解为，顶层const不影响参数，因此下面的两个函数，是相同的参数类型 123456void foo(int* const a)&#123; cout &lt;&lt; &quot;1&quot; &lt;&lt; endl;&#125;void foo(int* b)&#123; cout &lt;&lt; &quot;2&quot; &lt;&lt; endl;&#125; 当程序中有两个这样的函数，编译时会报错，因为发生了歧义，编译器不知道应该选择哪个函数。 通过const转换实现的匹配 特指底层const转换，一般是非const转换成const形参 通过类型提升实现的匹配 对于bool, char, signed char, unsigned char, short, unsigned short等类型，只要所有可能的值都能存在int里，它们就会被提升为int；否则，提升为unsigned int。 较大的char类型（wchar_t, char16_t, char32_t）提升成int, unsigned int, long, unsigned long, long long, unsigned long long中最小的一种类型，前提是转换后的类型能容纳原类型所有可能的值。 通过算术类型转换和指针转换实现的匹配 算术类型转换就是不同数值类型间的相互转换，如int,short,double之类，但不再局限于类型提升，double也可隐式转为int，也能匹配到。 指针转换： 常量整数值0或者字面值nullptr能转换成任意指针类型 指向任意非常量的指针能转换成void* 指向任意对象的指针能转换成const void* 继承关系：编译器会隐式地执行派生类到基类的转换 123456//Bulk_quote继承自QuoteQuote item;Bulk_quote bulk;Quote *p = &amp;item;p = &amp;bulk;Quote &amp;r = bulk; 算术类型&#x2F;指针类型自动转换成bool类型 存在一种从算术类型或指针类型向布尔类型自动转换的机制。如果指针或算术类型的值为0，转换结果为false；否则转换结果是true。 123char* cp = get_string();if(cp) /*...*/ //如果指针cp不是0，条件为真while(*cp) /*...*/ //如果*cp不是空字符，条件为真 通过类类型转换实现的匹配：见“类”章。 类类型转换的一个例子就是，char*转换成string类型 考虑这样一个场景 123Employee* findEmployee(const std::string&amp; surname, const std::string&amp; givenName, bool retired=false);Employee* findEmployee(const std::string&amp; fullName, bool retired = false)Employee* e = findEmployee(&quot;Chen&quot;, &quot;Shuo&quot;); 一般可能认为，执行第3行时，会调用第1行对应的函数。实则不然，实际情况下会调用第2行对应的函数。这就涉及上面所说的优先级问题。”chen”这种字符串字面量，作为参数时，是const char*类型，两种重载都没有考虑const char*，因此需要进行隐式转换。从const char*转换为string，是一个类类型转换，而从const char*转换为bool，是一个指针类型转换，后者优先级高于前者，因此会调用第2行对应的函数重载。 引入模板的重载12345678910template&lt;typename T&gt;void foo(T a)&#123; cout &lt;&lt; 3 &lt;&lt; endl;&#125;void foo(int a)&#123; cout &lt;&lt; 1 &lt;&lt; endl;&#125;int main()&#123; foo(1.0);&#125; 最后会输出3，也就是使用了有模板的foo函数重载。因为编译器力图精确匹配，而T可以被推断为double&#x2F;float类型，比int更精确，所以会使用有模板的foo函数重载。 面向对象10 类 C++中的类可大致分为三种：具体类、抽象类和类层次漫游中的类。大部分类可归为这三种之一，或某种的简单变形，或某几种的组合。 具体类： 具体类可以有与内置类型相似的行为，同时为了提高灵活性，还可以把成员变量的主体部分放在自由存储中（动态内存、堆）。一个经典的用户自定义类型是complex： 1234567891011121314151617181920212223242526272829303132class complex&#123; double re,im;public: complex(double r, double i): re&#123;r&#125;, im&#123;i&#125;&#123;&#125; complex(double r): re&#123;r&#125;, im&#123;0&#125;&#123;&#125; complex(): re&#123;0&#125;, im&#123;0&#125;&#123;&#125; double real() const &#123;return re;&#125; void real(double d) &#123;re = d;&#125; double imag() const &#123;return im;&#125; //const 常量函数，函数不会改变所调用的对象 void imag(double d) &#123;im = d;&#125; complex&amp; operator+=(complex z)&#123;re+=z.re, im+=z.im; return *this;&#125; complex&amp; operator-=(complex z)&#123;re-=z.re, im-=z.im; return *this;&#125; complex&amp; operator*=(complex);//在类外的某处进行定义 complex&amp; operator/=(complex);//在类外的某处进行定义&#125;;//很多函数并不需要访问complex的成员变量，因此其定义可以与类的定义分离开来complex operator+(complex a, complex b)&#123; return a += b; &#125;complex operator-(complex a, complex b)&#123; return a -= b; &#125;complex operator-(complex a)&#123; return &#123;-a.real(), -a.imag()&#125;; &#125;complex operator*(complex a, complex b)&#123; return a *= b; &#125;complex operator/(complex a, complex b)&#123; return a /= b; &#125;bool operator==()&#123; return a.real() == b.real() &amp;&amp; a.imag() == b.imag();&#125;bool operator!=()&#123; return !(a==b);&#125; complex必须足够高效，否则专门定义一个类没有意义，因此简单的操作必须设置成内联的。 📌定义在类里面的函数默认是内联的，也可以在声明前加上inline关键字显式指定。 当给自定义类型使用运算符重载时，应该尊重其常规使用习惯： 比如不能定义一元运算符&#x2F;，因为其语法在语言中已固定； 也不能改变内置类型的运算符的含义，如不能重新定义+执行int的减法 数据句柄模型(handle-to-data model)： 构造函数负责为元素分配空间并正确初始化成员，析构函数负责释放空间。 这也是资源获取即初始化(Resource Acquisition Is Initialization, RAII) 技术，可以防止在普通代码中利用“裸new”和“裸delete”分配内存，而是将分配操作隐藏在行为良好的抽象的实现内部，规避资源泄露的潜在风险。 123456789101112131415class Vector&#123;private: double* elem; //elem指向含有sz个double型元素的数组 int sz;public: Vector(int s): elem&#123;new double[s]&#125;,sz&#123;s&#125; &#123; // 构造函数，获取资源 for (int i=0;i!=s;++i) elem[i] = 0; &#125; ~Vector()&#123;delete[] elem;&#125; // 析构函数，释放资源 double&amp; operator[](int i); int size() const;&#125; 上面的构造函数，先建立了一定数目的存储，然后给存储中的各个元素赋值，用户使用时再向其中填值。这不是很好的初始化方法。更简洁的途径是; 利用元素列表进行初始化： 先重载一个构造函数Vector(std::initializer_list&lt;double&gt;) 12345Vector::Vector(std::initializer_list&lt;double&gt; lst): elem&#123;new double[lst.size()]&#125;, sz&#123;static_cast&lt;int&gt;(lst.size())&#125;&#123; copy(lst.begin(), lst.end(), elem);&#125; std::initializer_list是一种标准库类型，使用{1,2,3,4}列表时，编译器会创建一个该类型的对象。 static_cast负责强制类型转换，旨在避免特别严重的错误。 因此此时可以采用初始值列表来做初始化：Vector v1 = &#123;1,2,3,4,5&#125;; push_back()：在序列的末尾添加一个元素，容器长度加1. 抽象类： 抽象类的作用更类似于提供一个接口，将使用者与类的实现细节完全隔离开来。如设计一个比Vector更抽象的Container类： 123456class Container&#123;public: virtual double&amp; operator[](int) = 0;//纯虚函数 virtual int size() const = 0; //常量成员函数 virtual ~Container()[] //析构函数&#125; 123456void use(Container&amp; c)&#123; const int sz = c.size(); for(int i=0;i!=sz;++i) cout&lt;&lt;c[i]&lt;&lt;&#x27;\\n&#x27;;&#125; virtual关键字声明虚函数（可能在派生类中被重新定义），=0表示虚函数是纯虚函数，即Container的派生类必须定义这个函数。抽象类中不需要自行定义构造函数，因为不需要初始化数据，而且析构函数也是虚函数。 📌抽象类应放弃包含局部成员。 多态模型：use()完全忽视Container的实现细节，而使用Container接口。这种为其他类型提供接口的类，一般称为多态模型(polymorphic type)。use函数可以使用所有派生自Container的有这样接口的派生类。 派生类： 1234567891011class Vector_container: public Container&#123; //:public表示继承关系 Vector v;public: Vector_container(int s): v(s) &#123;&#125; ~Vector_container() &#123;&#125; double&amp; operator[](int i) &#123; return v[i]; &#125; int size() const &#123; return v.size(); &#125;&#125;;Vector_container vc &#123;10,9,8&#125;;use(vc); //使用多态模型，可以直接使用所有派生类 需要注意：使用多态模型会带来灵活性，但是必须通过引用或指针操作对象！ 这里的~Vector_container()隐式调用了~Vector() 虚函数的编译器实现： 当使用Vector_container作为Container对象时，use将必须使用Vector_container的operator[]()，而其他派生类则会使用那些派生类实现的operator[]()。因此Container的对象必须包含一些信息，使得运行时能够选择正确的虚函数实现。 做法如上图，编译器将虚函数名字转换成虚函数表(virtual function table, vtbl)，每个含有虚函数的类都有自己的vtbl用于辨识虚函数，从而确保对象被正确使用。调用Container对象时只需要知道vtbl指针位置和各虚函数索引即可。 📌这种方式，会使虚函数的调用多一些开销，如每个类都需要一个vtbl，并且保留其指针。但是函数调用的效率还是非常接近“普通函数调用”的（相差不超过25%）。 派生类的构造函数： 考虑这样的基类和派生类： 12345678910111213141516171819class Quote&#123;public: Quote() = default; Quote(const std::string &amp;book, double sales_price): bookNo(book), price(sales_price) &#123; &#125;private: std::string bookNo;protected: double price = 0.0;&#125;;class Bulk_quote : public Quote&#123;public: Bulk_quote() = default; Bulk_quote(const std::string &amp;book, double p, std::size_t qty, double disc);private: std::size_t min_qty = 0; double discount = 0.0;&#125;; 派生类对象中含有从基类继承的成员，但是派生类并不能直接初始化这些成员。派生类必须使用基类的构造函数来初始化它的基类部分： 12Bulk_quote::Bulk_quote(const std::string&amp; book, double p, std::size_t qty, double disc) : Quote(book, p), min_qty(qty), discount(disc) &#123;&#125; 这是由C++实例化对象时的内存分配导致的，一个派生类对象包含多个组成部分：一个含有派生类自己定义成员（对应minqty和discount）的子对象，以及一个基类对应的子对象（子对象中包含）。如果有多个基类，那么这样的子对象也有多个。因此在利用构造函数实例化派生类的对象时，也必须调用基类的构造函数，实例化子对象。 类层次漫游： 类层次就是结构就是，一个子类继承一个基类，另一个子类继承相同的基类，一个子子类继承子类等等 12345678910class Shape&#123;public: virtual Point center() const = 0; virtual void move(Point to) = 0; virtual void draw() const = 0; virtual void rotate(int angle) = 0; virtual ~shape() &#123;&#125;&#125;; 123456789101112class Circle: public Shape&#123;public: Circle(Point p, int rr); Point center() const &#123;return x;&#125; void move(Point to) &#123; x=to; &#125; void draw() const; void rotate(int) &#123;&#125;private: Point x; int r;&#125;; 123456789101112131415161718192021222324252627282930class Smiley: public Circle &#123;public: Smiley(Point p, int r) : Circle&#123;p,r&#125;, mouth&#123;nullptr&#125; &#123;&#125; ~Smiley()&#123; delete mouth; for (auto p:eyes) delete p; &#125; void move(Point to); void draw() const; void rotate(int); void add_eye(Shape* s)&#123;eyes.push_back(s);&#125; void set_mouth(Shape* s); //......private: vector&lt;Shape*&gt; eyes; Shape* mouth;&#125;;void Smiley::draw()&#123; Circle::draw(); for(auto p:eyes) p-&gt;draw(); mouth-&gt;draw();&#125; Smiley继承了Circle，Circle继承了Shape 对于抽象类来说，其派生类的对象通常是通过抽象基类的接口操纵的，所以基类中必须有一个虚析构函数。 rotate_all可以调用任何Shape的派生类，如Smiley，这体现了接口继承的益处，即：派生类可以用在任何需要基类对象的地方。 Smiley可以使用Circle的构造函数和Circle::draw()，这体现了实现继承的益处，即：基类可以提供简化派生类实现的函数或数据。 1234void rotate_all(vector&lt;Shape*&gt;&amp; v, int angle)&#123; for (auto p:v) p-&gt;rotate(angle);&#125; &amp;#x20; - 当某个函数需要使用特定派生类的成员函数时，可以使用dynamic_cast运算符询问类型： 12345678Shape* ps(read_shape(cin)); //根据cin指定的类型生成特定派生类的Shapeif(Smiley* p = dynamic_cast&lt;Smiley*&gt;(ps)) &#123; //或者引用: if(Smiley&amp; p = dynamic_cast&lt;Smiley&amp;&gt;(*ps)) //...指针p所指的对象类型是Smiley&#125;else&#123; //...指针p所指的对象类型不是Smiley，执行其他操作...&#125; 当不能直接使用候选的派生类时，可以用引用替代，用于dynamic_cast 若dynamic_cast的参数(ps)与期望类型(Smiley)不符时，则会返回nullptr。 📌private、public、protected：- 访问范围的差异：private：只能由该类中的函数、其友元函数访问，不能被任何其他访问，该类的对象也不能访问；protected：可以被该类中的函数、子类的函数、以及其友元函数访问，但不能被该类的对象访问；public：可以被该类中的函数、子类的函数、其友元函数访问，也可以由该类的对象访问。- 继承后的方法属性变化：使用private继承，父类的所有方法在子类中变为private；使用protected继承，父类的protected和public方法在子类中变为protected，private方法不变；使用public继承，父类中的方法属性不发生改变。 123456789101112//关于子类访问父类的private成员：//×！编译器报错class Animal&#123;private: int x;public: virtual void set_x()&#123;x = 10;&#125;&#125;class Dog&#123; void set_x() override&#123;x = 10;&#125;&#125;; 123456789101112//关于子类访问父类的protected成员：//√！编译器不报错class Animal&#123;protected: int x;public: virtual void set_x()&#123;x = 10;&#125;&#125;class Dog&#123; void set_x() override&#123;x = 10;&#125;&#125;; 📌explicit关键字：声明为explicit的构造函数不能在隐式转换中使用。当类构造函数只有一个参数或除了第一个参数外其余参数都有默认值时，则此类有隐含的类型转换操作符（隐式转换），但有时隐式转换并不是我们想要的，可在构造函数前加上关键字explicit，来指定显式调用。class Demo{&amp;#x20; public:&amp;#x20; explicit Demo(double a);};由于构造函数使用了explicit关键字，因此调用它时无法进行隐式转换，即Demo test; test&#x3D;12.2; 是无效的！然而，此时可以进行显式转换Demo test;test &#x3D; Demo(12.2); 或者test &#x3D; (Demo)12.2; override、final、default、delete override 有virtual就允许多态，即允许继承基类的子类重新virtual的方法。然而存在两种情况： 子类并不想重写基类的函数，只是碰巧写的新函数与基类中的某一个方法重名了； 子类想重写基类的函数，但是把函数名写错了，此时编译器将该函数判定为新函数，不会报错，但运行时可能会出很多问题。 针对以上场景，C++11引入了override关键字，以起到标记作用。override表示，此成员函数就是要重写基类的同名函数，而且函数签名一致。 1234567891011class A&#123;protected: virtual void func(int k, int d)&#123; &#125;&#125;;class B : A&#123;protected: void func(int k, int d)&#123; &#125;&#125;; 而以下两种情况会导致编译器报错：原函数不存在，以及重新函数的函数签名不一致。 123456//原函数不存在（函数名写错了） //函数签名不一致（返回值写错了） class B : A&#123; class B : A&#123;protected: protected: void funa(int k, int d)&#123; int func(int k, int d)&#123; &#125; &#125;&#125;; &#125;; final 有一种情况，类A继承了一个基类，但是类A不希望被其他类所继承。或者说类A重写了基类的虚函数，但当类A被继承时，不再希望这个虚函数被重写。 值得一提的是，没有final时虚函数会传递，只要基类有virtual，即使类A重写时对这个函数不加virtual，类B继承类A时也能重写该函数，该函数仍然是一个虚函数。 final修饰类：不能再被继承 123456class Base final&#123;&#125;;//此时不能再继承Base类，下述代码会编译期报错class Derive : Base&#123;&#125;; final修饰虚函数，虚函数不能再被重写（注：final只能修饰虚函数，不能修饰其他成员函数） 12345678910class Base&#123; virtual void func() final&#123; &#125;&#125;;class Derive : Base&#123; //此时不能再重写func方法，下述代码会编译期报错 void func()&#123; &#125;&#125;; =default 当手动写了一个有参数的构造&#x2F;析构函数时，编译器会把默认的构造&#x2F;析构函数优化掉，即不生成那些默认无参数的构造&#x2F;析构函数。如果想要保留这些默认函数，使得编译器能够生成默认函数从而保留无参数时的行为，可以用=default 报错场景： 123456789class A&#123;public: A(int i)&#123;&#125;;&#125;;int main()&#123; A a; //可以编译通过，但是会运行时报错，因为已经没有无参数的构造函数了，A a这句又没传参数 return 0;&#125; 不报错场景： 12345678910class A&#123;public: A() = default; A(int i)&#123;&#125;;&#125;;int main()&#123; A a; //运行时不会出错，因为默认无参数的构造函数得到了保留 return 0;&#125; =delete =delete与=default的作用相反，它会禁用掉类中的某个成员函数。比如不想要默认的构造函数、析构函数、拷贝构造函数或operator&#x3D;，可以用=delete禁用掉。 12345678class test&#123; private: test() = default; ~test() = default; public: test(const test&amp; a) = delete; test&amp; operator=(const test&amp; a) = delete;&#125;; 菱形继承与虚继承 菱形继承的情况如图所示，B和C都继承了A，也就都继承了cnt属性。而D同时继承了B和C，此时D的对象内部将会有两份cnt，存在二义性。此时若要让D的对象访问或修改cnt属性，会因二义性（编译器不知道应该使用哪个cnt）使得编译器报错。 D: &amp;#x20; - B: cnt &amp;#x20; - C: cnt 1234567891011121314151617181920212223242526class A&#123; //间接基类Aprotected: int cnt;&#125;;class B: public A&#123; //直接基类Bprotected: int cnt_b;&#125;;class C: public A&#123; //直接基类Cprotected: int cnt_c;&#125;;class D: public B, public C&#123; //派生类Dpublic: void set_a(int i)&#123; cnt = i; &#125; void set_b(int i)&#123; cnt_b = i; &#125; void set_c(int i)&#123; cnt_c = i; &#125; &#125;;int main()&#123; D d; d.set_a(3); //报错！&#125; 解决菱形继承的二义性问题，一种方式是直接使用::B或::C，强制编译器使用来自某个基类的属性。 12345678910111213141516171819202122class A&#123; //间接基类Apublic: int cnt;&#125;;class B: public A&#123; //直接基类Bpublic: int cnt_b;&#125;;class C: public A&#123; //直接基类Cpublic: int cnt_c;&#125;;class D: public B, public C&#123; //派生类D&#125;;int main()&#123; D d; d.B::cnt = 3; //强制指定使用哪个基类的cnt属性，规避二义性&#125; 当上面的方案不能根治菱形继承的问题，因为属性在类D中本就应该只有一个。更有效方案是利用虚继承。虚继承会使得派生类中只保留一份来自间接基类的属性，有效防止二义性问题。此时的间接基类A，被称为虚基类。 1234567891011121314151617181920212223242526class A&#123; //间接基类Aprotected: int cnt;&#125;;class B: virtual public A&#123; //虚继承，直接基类Bprotected: int cnt_b;&#125;;class C: virtual public A&#123; //虚继承，直接基类Cprotected: int cnt_c;&#125;;class D: public B, public C&#123; //派生类Dpublic: void set_a(int i)&#123; cnt = i; &#125; void set_b(int i)&#123; cnt_b = i; &#125; void set_c(int i)&#123; cnt_c = i; &#125; &#125;;int main()&#123; D d; d.set_a(3); //正确！&#125; 标准库中也有利用虚继承解决菱形继承问题的案例。如iostream类同时继承了istream类和ostream类，而istream和ostream都继承了base_ios类。此时istream和ostream必须虚继承base_ios，否则会导致iostream类中包含两份来自base_ios的属性，导致二义性。 RAII：资源获取即初始化 Resource Acquisition is Initialization RAII主要利用对象离开作用域会自动调用析构函数的特性，在设计一个类时，于构造函数申请资源，在析构函数释放资源，即可避免内存泄露问题，并将程序员从内存管理的泥潭中释放出来。 123456789101112class CTest&#123;public: CTest()&#123; m_pInt = new int; &#125; ~CTest()&#123; if( m_pInt != nullptr ) delete m_pInt; &#125;private: int* m_pInt;&#125;; 对象隐式销毁考虑这样的函数，user()函数在退出前会delete掉所有的Shape，delete运算符依赖于Shape的析构函数，而该函数是虚函数，所以delete会调用最终的派生类的析构函数。 123456789void user()&#123; std::vector&lt;Shape*&gt; v; while(cin) v.push_back(read_shape(cin)); draw_all(v); rotate_all(v,45); for(auto p : v) //最后删除元素 delete p;&#125; 这是“显式”地销毁对象。然而若对所有函数都执行这样的显式操作的话，可能总有漏网之鱼。解决方案便是“隐式”对象销毁，让编译器自己来做delete操作。 对象若要隐式销毁，需要避免“裸指针”，而是尽量用智能指针unique_ptr，此时可以修改代码如下： 12345678enum class Kind &#123; Circle, triangle, smiley &#125;;unique_ptr&lt;Shape&gt; read_shape()&#123; //...从is中读取描述信息，找到对应形状种类 switch(k)&#123; case Kind::circle: return unique_ptr&lt;Shape&gt;&#123;new Circle&#123;p,r&#125;&#125;; //......&#125; 1234567void user()&#123; vector&lt;unique_ptr&lt;Shape&gt;&gt; v; while(cin) v.push_back(read_shape(cin)); draw_all(v); rotate_all(v,45);&#125; 对象由unique_ptr拥有，当对象离开作用域时，unique_ptr将释放掉所指的对象。 友元函数&amp;友元类 普通友元函数 突破类内成员访问权限的限制，使得外部的函数仍能访问到类内的私有成员。 12345678910111213class A&#123;public: A()&#123;&#125;; ~A()&#123;&#125;; friend void foo(); //声明foo函数是类A的好朋友private: int m_data;&#125;;void foo()&#123; A aObj; aObj.m_data = 1;&#125; 友元成员函数 令类B的成员函数有权限访问类A的私有成员。 1234567891011121314151617181920class B&#123;public: B()&#123;&#125;; ~B()&#123;&#125;; void foo();&#125;;class A&#123;public: A()&#123;&#125;; ~A()&#123;&#125;; friend void B::foo(); //声明类B的foo成员函数是类A的好朋友private: int m_data;&#125;;void B::foo()&#123; A aObj; aObj.m_data = 1;&#125; 友元类 若类B是类A的友元类，那么类B的所有成员函数均能访问到类A的私有成员。 1234567891011121314151617181920class B&#123;public: B()&#123;&#125;; ~B()&#123;&#125;; void foo();&#125;;class A&#123;public: A()&#123;&#125;; ~A()&#123;&#125;; friend B; //声明类B是类A的好朋友private: int m_data;&#125;;void B::foo()&#123; A aObj; aObj.m_data = 1;&#125; 运算符重载 可以重载的运算符：+ - * &#x2F; % ^ &amp; | ~ ! &#x3D; &lt; &gt; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D; ^&#x3D; &amp;&#x3D; |&#x3D; &lt;&lt; &gt;&gt; &lt;&lt;&#x3D; &gt;&gt;&#x3D; &#x3D;&#x3D; !&#x3D; &lt;&#x3D; &gt;&#x3D;&amp;&amp; || ++ – [] () -&gt; , new new[] delete delete[]&amp;#x20; 一元运算符重载：++、–、-（负号）、! 一元运算符往往不需要传形参，传形参说明是后缀++或后缀– 123456789101112131415161718192021222324252627282930class Complex &#123;private: double i; double j;public: Complex(int = 0, int = 0); void display(); Complex operator ++();//前缀自增 Complex operator ++(int);//后缀自增，参数需要加int&#125;;Complex::Complex(int a, int b) &#123; i = a; j = b;&#125;void Complex::display() &#123; cout &lt;&lt; i &lt;&lt; &#x27;+&#x27; &lt;&lt; j &lt;&lt; &#x27;i&#x27; &lt;&lt; endl;&#125;Complex Complex::operator ++() &#123; ++i; ++j; return *this;&#125;Complex Complex::operator ++(int) &#123; Complex temp =*this; ++*this; return temp;&#125; 二元运算符重载：+、-、 *、&#x2F; this是左值，形参是右值。 12345678910111213141516171819202122class test_minus&#123;private: int val1, val2;public: test_minus(int a, int b): val1(a), val2(b) &#123;&#125; test_minus operator-(const test_minus&amp; right)&#123; return test_minus(right.val1 - val1, right.val2 - val2); &#125; void Print()&#123; cout &lt;&lt; val1 &lt;&lt; &#x27; &#x27; &lt;&lt; val2 &lt;&lt; endl; &#125;&#125;;int main()&#123; test_minus a(1, 3); test_minus b(2, 0); test_minus c = a - b; c.Print(); //输出 1 -3 return 0;&#125; 还可以友元函数的方式重载： 123456789101112131415161718192021222324class test_minus&#123;private: int val1, val2;public: test_minus(int a, int b): val1(a), val2(b) &#123;&#125; friend test_minus operator- (const test_minus&amp;, const test_minus&amp;); //友元函数 void Print()&#123; cout &lt;&lt; val1 &lt;&lt; &#x27; &#x27; &lt;&lt; val2 &lt;&lt; endl; &#125;&#125;;test_minus operator-(const test_minus&amp; left, const test_minus&amp; right)&#123;//友元函数运算符重载 return test_minus(right.val1 - left.val1, right.val2 - left.val2);&#125;int main()&#123; test_minus a(1,3); test_minus b(2,0); test_minus c = a-b; c.Print(); return 0;&#125; 关系运算符重载：&lt;、&gt;、&lt;&#x3D;、&gt;&#x3D;、&#x3D;&#x3D;、!&#x3D; 和二元运算符一样，this是左值，形参是右值。可以在形参加上const以规避修改 1234567891011121314class Distance&#123;private: int feet; int inches;public: bool operator &lt;(const Distance&amp; d) &#123; if(feet &lt; d.feet) return true; if(feet == d.feet &amp;&amp; inches &lt; d.inches) return true; return false; &#125;&#125;; 流运算符重载：&lt;&lt;、&gt;&gt; 见“I&#x2F;O流”章，需要注意区分一元运算符中的左移右移。 赋值运算符重载：&#x3D; 123456789101112class Distance&#123; private: int feet; // 0 到无穷 int inches; // 0 到 12 public: void operator=(const Distance &amp;D ) &#123; feet = D.feet; inches = D.inches; &#125;&#125;; 函数调用运算符重载：() 12345678910111213141516171819202122232425262728class Distance&#123; private: int feet; // 0 到无穷 int inches; // 0 到 12 public: Distance(int f, int i)&#123; feet = f; inches = i; &#125; // 重载函数调用运算符 Distance operator()(int a, int b, int c) &#123; Distance D; // 进行随机计算 D.feet = a + c + 10; D.inches = b + c + 100 ; return D; &#125;&#125;;int main()&#123; Distance D1(11, 10), D2; D2 = D1(10, 10, 10); // invoke operator() return 0;&#125; 下标运算符重载：[] 123456789101112131415161718192021222324252627282930313233343536const int SIZE = 10;class safearay&#123; private: int arr[SIZE]; public: safearay() &#123; register int i; for(i = 0; i &lt; SIZE; i++) &#123; arr[i] = i; &#125; &#125; int&amp; operator[](int i) &#123; if( i &gt;= SIZE ) &#123; cout &lt;&lt; &quot;索引超过最大值&quot; &lt;&lt;endl; // 返回第一个元素 return arr[0]; &#125; return arr[i]; &#125;&#125;;int main()&#123; safearay A; cout &lt;&lt; &quot;A[2] 的值为 : &quot; &lt;&lt; A[2] &lt;&lt;endl; cout &lt;&lt; &quot;A[5] 的值为 : &quot; &lt;&lt; A[5]&lt;&lt;endl; cout &lt;&lt; &quot;A[12] 的值为 : &quot; &lt;&lt; A[12]&lt;&lt;endl; return 0;&#125; 📌C++的register关键字作用是，建议编译器使用CPU寄存器来存储变量，旨在提高访问变量的速度 类成员访问运算符重载：-&gt; 和 解引用运算符：* 成员访问-&gt;和解引用*的重载都只能由对象使用，而不能由指针使用，因此，出现pointer-&gt;mem;时，可能有两种情况： 指针，原原本本的成员访问和解引用功能：mem就是指针指向的对象，所属类型的成员 12pointer-&gt;mem;//等价于 (*pointer).mem; 对象，调用的重载的运算符：mem不一定是pointer所属类型的成员，可能是其它类型的 12pointer.operator()-&gt;mem;//等价于 (pointer.operator*()).mem; 重载时，一般要求解引用*重载，返回引用，要求成员访问-&gt;重载，返回指针。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class test_arrow_1&#123;public: int val1, val2; test_arrow_1(int a, int b) : val1(a), val2(b) &#123;&#125; void Print1()&#123; cout &lt;&lt; val1 &lt;&lt; &#x27; &#x27; &lt;&lt; val2 &lt;&lt; endl; &#125;&#125;;class test_arrow_2&#123;private: int val3, val4, val5;public: test_arrow_1* val6; test_arrow_2(int a, int b, int c, int d, int e) : val6(new test_arrow_1(a,b)), val3(c), val4(d), val5(e) &#123;&#125; void Print2()&#123; cout &lt;&lt; val6-&gt;val1 &lt;&lt; &#x27; &#x27; &lt;&lt; val6-&gt;val2 &lt;&lt; &#x27; &#x27; &lt;&lt; val3 &lt;&lt; &#x27; &#x27; &lt;&lt; val4 &lt;&lt; &#x27; &#x27; &lt;&lt; val5 &lt;&lt; endl; &#125; test_arrow_1&amp; operator*() const&#123; return (*val6); &#125; test_arrow_1* operator-&gt;() const&#123; return val6; &#125;&#125;;int main()&#123; test_arrow_2 t1(1,2,3,4,5); t1-&gt;val1 = 6; t1-&gt;Print1(); t1.Print2(); (*t1).val2 = 7; t1.Print2(); test_arrow_2* t2 = new test_arrow_2(6,7,8,9,10); t2-&gt;Print2(); (*t2).Print2(); return 0;&#125; 对象调用 1234567891011int main()&#123; test_arrow_2 t1(1,2,3,4,5); t1-&gt;val1 = 6; t1-&gt;Print1(); t1.Print2(); (*t1).val2 = 7; t1.Print2(); return 0;&#125; t1是重载了*和-&gt;的对象，而不是指针，因此，当t1调用*t1和t1-&gt;时，会使用重载的运算符函数。 因此t1-&gt;可以使用属于test_arrow_1类的属性和方法， (*t1)也可以使用属于改类的属性和方法。而“点运算符”仍然只能使用test_arrow_2类的。 指针调用 123test_arrow_2* t2 = &amp;t1;t2-&gt;Print2();(*t2).Print2(); t2是指针，因此调用*和-&gt;时，不能再调用重载的运算符函数，而是和平时的操作无异。因此t2-&gt;只能使用test_arrow_2的属性和方法，而且(*t2)也只能使用test_arrow_2的。 值得注意的是，解引用运算符 *，可以自定义任何逻辑，上面的代码中，也可以让解引用的重载返回一个int常数。 但是成员访问运算符无论怎么改，都必须保留成员访问的功能，虽然可能不再是当前类的成员了。 📌取地址符&amp;也可以重载，但一般不需要手动重载，类会默认生成&amp;和&amp; const 类类型转换（特殊运算符重载）类型转换运算符，负责将一个类的类型转换成其他类型：operator type() const;，由于其通常不应该改变待转换对象的内容，因此，一般被定义为const成员。 12345678910class SmallInt&#123;public: SmallInt(int i = 0):val(i)&#123; if(i &lt; 0 || i &gt; 255) throw std::out_of_range(&quot;Bad SmallInt value&quot;); &#125; operator int() const &#123;&#125;; //类型转换运算符private: std::size_t val;&#125;; 这里SmallInt类中定义了向int类型的转换符，因此，可以显式&#x2F;隐式的将SmallInt对象转换成int类型： 123SmallInt si;si = 4; // 首先将4隐式转换成SmallInt，然后调用SmallInt operator=si + 3; // 首先将si隐式转换成int，然后执行整数的加法 除此之外，如果转换后的类型又有其它内置转换方案，实际情况中，也可以出现转换传递的情况。比如 12SmallInt si = 3.14; // 调用SmallInt(int)构造函数si + 3.14; // SmallInt类型转换成int，int又继续隐式转换成double 📌一个类型转换函数必须是类的成员函数。不能声明返回类型！（其名字就已说明返回）形参列表必须为空！****通常应该为const！ 12345678class SmallInt;operator int(SmallInt&amp;); //错,不是成员函数class SmallInt&#123;public: int operator int() const; //错,有返回类型 operator int(int=0) const; //错,有形参 operator int*() const &#123;return 42;&#125;//错,42不是一个指针&#125;; 老版本C++，类型转换运算符的不足： 早期版本C++中，类中定义一个向bool转换的类型转换运算符，是比较普遍的。比如经常用的while(cin&gt;&gt;i)就是cin中内置了一个operator bool( )。然而，这样会有意想不到的效果，比如下面的语句： 12int i = 42;cin &lt;&lt; i; 流运算符&lt;&lt;是cout特有的，istream本身没有定义&lt;&lt;，所以这段代码本应报错。然而，istream内置了bool类型转换，由此将cin转换成了bool，接着bool会被提升为int，后面的&lt;&lt;成为了左移运算符。因此，这段代码不会报错，还会出现与预期大相径庭的结果。 C++11带来的解决方案：显式的类型转换运算符 为了防止上面现象的发生，C++引入了解决方案：explicit operator type()，即通过explicit关键字，要求显式转换 比如下面代码： 123456789101112class SmallInt&#123;public: SmallInt(int i = 0):val(i)&#123; if(i &lt; 0 || i &gt; 255) throw std::out_of_range(&quot;Bad SmallInt value&quot;); &#125; explicit operator int() const &#123; return val; &#125;&#125;;SmallInt si = 3; //正确：SmallInt的构造函数不是显式的si + 3; //错误：此处需要隐式的类型转换，但类的运算符不是显式的static_cast&lt;int&gt;(si)+3; //正确：显式地请求类型转换 这种规定还是有例外的，标准规定：如果表达式被用作了条件，则编译器会自动（即“隐式”）进行显式类型转换， 因此istream内部的bool()成为explicit的了，但是while(cin&gt;&gt;i)依然能用，因为是条件，会自动转成bool类型。 成为条件的几个位置： if, while, do…while, for 逻辑运算符!, ||, &amp;&amp; 条件运算符? :&amp;#x20; 类类型转换带来的二义性：（这里的类型转换不再局限于类型转换运算符，还包括构造函数） 有几种情况可能会带来二义性，出现二义性之后会编译报错，因为编译器不知道该使用哪种实现方式。 两个类提供了“互相指向”的类型转换： 123456789101112struct B;struct A &#123; A() = default; A(const B&amp;); //把一个B转换为A&#125;;struct B &#123; operator A() const; //把一个A转换为B&#125;;A f(const A&amp;); //定义一个接收A的函数B b;A a = f(b); //二义性错误：含义是 调用B中转换为A的类型转换运算符 f(b.operator A()) // 还是调用A中可以把B类型转换为A的构造函数 f(A(b)) 如果想执行上面的调用，必须显式地调用类型转换运算符或转换构造函数： 12A a1 = f(b.operator A()); //正确：使用B的类型转换运算符A a2 = f(A(b)); //正确：使用A的构造函数 类定义了多个转换规则： 最困扰的情况是类中定义了多个参数都是算术类型的构造函数，或者转换目标都是算术类型的类型转换运算符 1234567891011121314struct A&#123; A(int = 0); A(double = 0); operator int() const; operator double() const;&#125;;void f2(long double);A a;f2(a); //二义性错误，不知道是 f(a.operator int()) 还是 f(a.operator double())long lg;A a2(lg); //二义性错误，不知道是 A::A(int) 还是 A::A(double) f2的调用中，哪个类型转换都无法精确匹配long double，然而却都存在向long double的隐式转换（而且转换级别还一致）。因此出现了二义性。 📌C++ primer中建议，最好不要创建两个转换源都是算术类型的类型转换！最好不要创建两个转换对象都是算术类型的类型转换！ 如果这种情况中，转换级别不一致，就不存在二义性问题。比如从short提升到int，级别高于long到double。 函数重载过程中，不同重载的形参，都定义了同一种类型转换运算符： 123456789struct C&#123; C(int);&#125;;struct D&#123; D(int);&#125;;void manip(const C&amp;);void manip(const D&amp;);manip(10); //二义性错误：含义是 manip(C(10)) 还是 manip(D(10)) 可以显式调用构造函数，以消除二义性： 1manip(C(10)); 但这种情况并没有结束，10可以精确匹配int，那么下面的代码是否就没有二义性了呢？ 123456789struct C&#123; C(int);&#125;;struct E&#123; E(double);&#125;;void manip(const C&amp;);void manip(const E&amp;);manip(10); //二义性错误：含义是 manip(C(10)) 还是 manip(E(double(10))) 还是会编译报错，还是会有二义性，这是因为在调用重载时，类类型转换都是最低级别的匹配度。即使int比double更能匹配10，但是现在不是int和double的比较，而是C(10)：int→C，和E(double(10))：int→E的比较，而二者是平级的。而且二者都是可行匹配。因此导致了二义性。 虽然，类型转换运算符可以在某些程度上简化操作，但还是要慎用，非常容易出现二义性问题！ new&#x2F;delete的重载new operator&#x2F;delete operator就是new和delete操作符，而operator new&#x2F;operator delete是函数。 placement new是operator new的全局重载。 new运算分两阶段：（1）调用::operator new配置内存；（2）调用对象构造函数构造对象内容。 delete运算分为两个阶段：（1）调用对象析构函数；（2）调用::operator delete释放内存。 operator new函数 默认的::operator new与malloc无明显区别。只分配所要求的空间，不调用相关对象的构造函数。当无法满足所要求分配的空间时，则： →如果有new_handler，则调用其，否则 →如果允许抛出异常（即nothrow参数未被设置），则执行bad_alloc异常，否则 →返回0 需要注意的是，::operator new是可以被重载的，也就是说可以自定义operator new的行为 operator new重载 重载时，返回类型必须声明为void* 重载时，第一个参数类型必须为表达要求分配空间的大小（字节），类型为size_t 重载时，可以带其它参数 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class X&#123;public: X() &#123; cout&lt;&lt;&quot;constructor of X&quot;&lt;&lt;endl; &#125; ~X() &#123; cout&lt;&lt;&quot;destructor of X&quot;&lt;&lt;endl;&#125; void* operator new(size_t size,string str) //重载::operator new &#123; cout&lt;&lt;&quot;operator new size &quot;&lt;&lt;size&lt;&lt;&quot; with string &quot;&lt;&lt;str&lt;&lt;endl; return ::operator new(size); &#125; void operator delete(void* pointee) //重载::operator delete &#123; cout&lt;&lt;&quot;operator delete&quot;&lt;&lt;endl; ::operator delete(pointee); &#125;private: int num;&#125;;int main()&#123; X *px = new(&quot;A new class&quot;) X; delete px; return 0;&#125; 缺省的operator new具有非常好的通用性，这也使得其在某些场合下牺牲了性能。针对性优化的operator new可以提升效率。 placement new函数 前面重载的operator new只能作为类内函数，无法全局使用。而placement new是一种全局的重载的operator new。 placement new的使用： operator new会分配内存，但是placement new不分配。相反地，placement new的参数就是一个预先分配好的内存，而placement new会在其上构造对象。（placement new不接收size_t类型参数，即不接收待分配内存大小参数），函数返回值是对象的地址。 12string* sp=static_cast&lt;string*&gt;(::operator new(sizeof(string)));mystr = new (sp) string(&quot;hello world&quot;); //使用placement new构造对象 placement new的使用步骤： 内存提前分配 调用placement new构造对象 使用对象mystr 析构对象mystr→~string(); 释放内存：内存sp可以被反复使用，反复通过placement new分配给新的对象，但若不想使用该内存，可以用delete [] buf;释放它。 为什么要有placement new： 确实有要在预分配内存上创建对象的需求。比如硬件中有一个内存映射的IO计时器设备，想建立一个clock对象在那个内存位置，但用。 增大时空效率。使用new操作符需要在堆中查找足够大的剩余空间，这个操作速度较慢，而且可能出现无法分配内存的异常（空间不够）。placement new可以解决，预先分配好的内存确保不会出现内存不足的异常，同时也省下了查找可用内存的时间。 📌申请内存和释放内存的操作符需要配套使用，比如new和delete一起用，new[]和delete[]一起用。int* ptr &#x3D; new int[10];delete [] ptr; 拷贝和移动 拷贝构造：定义拷贝构造函数和拷贝赋值运算符&amp;#x20; 📌对于大容量的容器来说，拷贝过程可能耗费巨大。举例来说，而事实上，我们并不真的想要一个副本，而是想将计算结果从函数中取出来，相比于拷贝，更希望的操作的移动。 1234567891011121314151617/******* 声明一个Vector类 *******/class Vector &#123;private: double* elem; int sz;public: Vector(int s); //构造函数：建议不变式，获取资源 ~Vector() &#123; delete[] elem; &#125; //析构函数：释放资源 Vector(const Vector&amp; a); //拷贝构造函数 Vector&amp; operator=(const Vector&amp; a); //拷贝赋值运算符 double&amp; operator[](int i); const double&amp; operator[](int i) const; int size() const;&#125;; 12345678/****拷贝构造函数****/Vector::Vector(const Vector&amp; a) :elem&#123;new double[a.sz]&#125;, //为元素分配空间 sz&#123;a.sz&#125;&#123; for(int i = 0; i != sz; ++i) //复制元素 elem[i] = a.elem[i];&#125; 这里是深拷贝。拷贝构造函数的输入参数是被拷贝的对象，也就是a &#x3D; b中右面的b。 1234567891011/****拷贝赋值运算符****/Vector&amp; Vector::operator=(const Vector&amp; a)&#123; double* p = new double[a.sz]; for(int i = 0; i != a.sz; ++i) p[i]=a.elem[i]; delete[] elem; //删除旧元素 elem = p; sz = a.sz; return *this;&#125; 深拷贝与浅拷贝： 如果类中的属性均为基本类型变量，全部在栈上分配，不涉及深&#x2F;浅拷贝问题。深拷贝与浅拷贝仅在，类中存在需要在堆上分配内存的属性时，才需要加以区分。考虑上面的Vector类： 12345678//拷贝构造函数：深拷贝Vector::Vector(const Vector&amp; a) :elem&#123;new double[a.sz]&#125;, //为元素分配空间 sz&#123;a.sz&#125;&#123; for(int i = 0; i != sz; ++i) //复制元素 elem[i] = a.elem[i];&#125; 12345//拷贝构造函数：浅拷贝Vector::Vector(const Vector&amp; a) :elem&#123;a.elem&#125;, //不分配空间，直接赋值 sz&#123;a.sz&#125;&#123; &#125; 也就是构造的Vector对象的elem指针，直接指向&#x3D;右边的Vector对象的elem数组。 可以看出，深拷贝会重新开辟一片内存，并且对内存中的值逐个拷贝。而浅拷贝的话，不会开辟内存，对象的指针直接等于右值对象内的指针。换言之，深拷贝过程中，左值的堆内存和右值的堆内存是两片内存，而浅拷贝的话共同使用一片内存。 C++的默认拷贝构造函数=default采用的是浅拷贝方式。 但是，一般遇到有属性需要从堆内存分配时，应该自己手写深拷贝方式的拷贝构造函数。浅拷贝涉及这样多次析构的问题，考虑上面的Vector类，如果采用了浅拷贝的拷贝构造函数，禁用operator&#x3D;，main函数进行最基本的赋值操作时： 12345int main()&#123; Vector lv(3); Vector rv = lv; return 0;&#125; 这时程序会在运行时崩溃，崩溃在析构函数上。在执行return 0之前，作用域内有两个Vector变量：lv和rv，二者的elem指向了同一片内存elem。然而，执行return 0，离开作用域时，会调用两个变量的析构函数。假设先调用了lv的析构函数，那么lv的elem会在析构时释放内存，此时的elem成为了野指针。而在调用rv的析构函数时，还会delete [] elem，此时要delete一个野指针，就会导致程序崩溃。 由此可见，对象中涉及堆时，应该尽量手写深拷贝形式的拷贝构造函数。 📌在C++标准中，NULL和nullptr都被认为是0，尤其nullptr指向的是0x0地址，可以重复delete。因此，当一个对象被delete了，指针未归为nullptr，再调用该指针时会因野指针而使得程序崩溃。但如果delete后归为nullptr，再delete并不会出现问题。 右值引用： 通常写的引用int a=0; int &amp;b=a;，b是一个左值引用，它引用了一个左值a，但它不能引用右值，即int &amp;b=0;会报错。C++11之前，强行通过左值引用，引用一个右值的方式，只有一个，那就是常引用const int&amp;b=0;，但是如此并不能修改右值的值。 前面提到，浅拷贝比深拷贝效率更高（不用开辟新空间），但是存在重复析构的问题，那么是否可以通过下面的代码解决析构野指针的问题呢？ 1234demo(demo &amp;d):num(d.num)&#123; //拷贝构造函数，入参去掉const，让d可修改 d.num = nullptr; //修改原对象对应指针为空指针 cout&lt;&lt;&quot;copy construct!&quot;&lt;&lt;endl;&#125; 是不可以的，运行会报错。因为num=d.num表示d.num是右值，右值不可修改，但d.num=nullptr又让其成为可修改的左值，发生了冲突。 解决这个问题的方法，就是希望函数参数d是一个右值引用，右值引用的特定在于，既反映右值，又可以修改右值。 C++定义了T&amp;&amp; param这样语法，表示param是一个右值引用，其可以引用一个右值，那么int &amp;&amp;b=0;就可行了，而且可以通过b来修改右值。与此同时，C++11引入了std::move()函数，作用在于，不管输入的是左值还是右值，move出来的都是右值。 然而这样的语法，也不一定能保证引用到的必然是右值，以一个函数传参的例子进行说明： 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;void fun(int&amp; lvalue) // 接收左值&#123; std::cout &lt;&lt; &quot;lvalue = &quot; &lt;&lt; lvalue &lt;&lt; std::endl; &#125;void fun(int&amp;&amp; rvalue) // 接收右值&#123; std::cout &lt;&lt; &quot;rvalue = &quot; &lt;&lt; rvalue &lt;&lt; std::endl; &#125;template&lt;typename T&gt;void function(T&amp;&amp; param) // 不能确保是右值引用，但是是万能引用&#123; fun(param);&#125;int main()&#123; int x = 10; function(x); // 左值 function(std::move(x)); // 右值&#125; 首先看function函数，其明明标明入参应该是右值引用，为何还能通过function(x)传一个左值引用进去呢？ 这是引用折叠的原因导致的： 虽然是T&amp;&amp; param，但若传进去一个int&amp;，实际相当于传入的类型为int&amp; &amp;&amp;，等价于int&amp;，即左值引用。《Effective Modern C++》的作者将这种，由引用折叠导致的，既可以表示右值引用，又可以表示左值引用的语法称为万能引用。 引用折叠的规则： first second result &amp; &amp; 左值引用 &amp; &amp;&amp; 左值引用 &amp;&amp; &amp; 左值引用 &amp;&amp; &amp;&amp; 右值引用 即，只有两个引用均为右值引用时，才会折叠成右值引用。 万能引用的规律： 1234567891011121314Widget&amp;&amp; var1 = Widget(); // rvalue referenceauto&amp;&amp; var2 = var1; // universal referencetemplate&lt;typename T&gt;void f(std::vector&lt;T&gt;&amp;&amp; param); // rvalue referencetemplate&lt;typename T&gt;void f(T&amp;&amp; param); // universal referencetemplate&lt;typename T&gt;class vector &#123; void push_back(T&amp;&amp; x); // rvalue reference&#125; 如果T不是模板参数，而是具体的类型，如上面的第一个例子Widget，T&amp;&amp;一定是右值引用。 如果T是模板参数，T&amp;&amp;一般情况下是通用引用。除了下面两种例外情况： 如果T是模板参数，但param的类型不直接是T，比如std::vector&lt;T&gt;&amp;&amp;，那么std::vector&lt;T&gt;&amp;&amp;是右值引用。 如果T是模板参数，但不需要自动推导，比如已经在类实例化的时候手动指定过了，那么T&amp;&amp;是右值引用。 但是，如果执行上面的代码，会发现输出结果为： 12lvalue = 10lvalue = 10 也就是，左值和右值都被判定为左值。这是因为右值引用接收的值既可以是左值，也可以是右值，存在这样一个对应关系： 左值引用 右值引用 非引用 什么时候是左值 always 显式声明为变量时 显式声明为变量时 什么时候是右值 never 作为临时变量时 作为临时变量时 虽然move函数强行使得第二个function函数传入右值，但是，function函数内部调用fun函数时，涉及传参，又把param显式化了。这样就使得param变为一个左值。 那么如何保留右值的特点，使得调用fun函数也传入右值呢，C++11同时提供了完美转发std::forward特性。 std::forward的返回值既可能是左值，也可能是右值，当传入参数是右值引用时，返回右值，否则就返回左值。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;// 接收左值void fun(int&amp; lvalue)&#123; std::cout &lt;&lt; &quot;lvalue = &quot; &lt;&lt; lvalue &lt;&lt; std::endl; &#125;// 接收右值void fun(int&amp;&amp; rvalue)&#123; std::cout &lt;&lt; &quot;rvalue = &quot; &lt;&lt; rvalue &lt;&lt; std::endl; &#125;// 万能引用template&lt;typename T&gt;void function(T&amp;&amp; param)&#123; //fun(param); fun(std::forward&lt;T&gt;(param)); // 使用std::forward进行完美转发&#125;int main()&#123; int x = 10; function(x); // 左值 function(std::move(x)); // 右值&#125; 再执行通过完美转发改进的程序，可以得到这样的输出结果： 12lvalue = 10rvalue = 10 也就是，左值是左值的行为，右值是右值的行为，不再混乱，泾渭分明。 事实上，使用std::forward处理万能引用，也是官方推荐的开发方式！ 合理运用右值引用，达到提速效果的案例： 在做矩阵加法时，可以这样写，即入参是两个左值引用以避免拷贝 1234Matrix operator+(const Matrix&amp; lhs, const Matrix&amp; rhs) &#123; Matrix sum = ... // Sum all elements in lhs and rhs here. return sum;&#125; 但是这么做美中不足的地方在于，需要创建一个额外的Matrix对象。如果说，lhs和rhs有一个操作数可以是右值，也就是算完之后调用者不会再使用它，那便可以复用它的内存空间，不必创建新的Matrix对象，达到提高效率的目的。假设这个右值是lhs，那么便可以设置它为右值引用。 1234Matrix operator+(Matrix&amp;&amp; lhs, const Matrix&amp; rhs) &#123; lhs = ... // Sum all elements in lhs and rhs and assign to lhs. return std::move(lhs);&#125; 这里要用std::move返回值，避免让lhs成为显式变量，成为左值（成为左值的话，会返回对象的拷贝构造）。此时的返回值变成了右值引用，编译器自动为右值调用移动构造函数。 那么进行矩阵加法便可以： 12Matrix sum1 = m1 + m2; // 调用第一种实现Matrix sum3 = std::move(m1) + m2; // 调用第二种实现 一般不建议函数返回右值引用！ C++中的左右值：- lvalue：通常可以放在等号左边的表达式，左值- rvalue：通常只能放在等号右边的表达式，右值- glvalue：generalized lvalue，广义左值- xvalue：expiring lvalue，将亡值，也就是std::move(ptr1)的值- prvalue：pure rvalue，纯右值对于包含右值的内存位置来说，其本质就是：它虽然没有名称，但是可以从程序的其他部分访问到它。而右值引用便可以用来表示这个本应没有名称的临时对象。 C++11之后编译器开始支持RVO(Return Value Optimization)技术，RVO可以把函数返回时创建的临时对象优化掉，达到少调用拷贝构造函数的目标。如果函数返回一个仅在函数内的局部变量，而且变量类型支持移动构造函数，比如：std::vector&lt;int&gt; return_vector(void){&amp;#x20; std::vector&lt;int&gt; tmp {1,2,3,4,5};&amp;#x20; return tmp;}std::vector&lt;int&gt; rval_ref &#x3D; return_vector();那么编译器发现tmp是局部变量，离开return_vector函数后就会死亡时，会把tmp当做将亡值（xvalue），编译器会为将亡值调用移动构造函数。 移动构造： 虽然深拷贝很稳定，使得出错的风险降低，但是带来了效率的牺牲。考虑下面的深拷贝构造函数代码： 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;class demo&#123;public: demo():num(new int(0))&#123; cout&lt;&lt;&quot;construct!&quot;&lt;&lt;endl; &#125; demo(const demo &amp;d):num(new int(*(d.num)))&#123; //拷贝构造函数 cout&lt;&lt;&quot;copy construct!&quot;&lt;&lt;endl; &#125; ~demo()&#123; delete num; cout&lt;&lt;&quot;class destruct!&quot;&lt;&lt;endl; &#125;private: int *num;&#125;;demo get_demo()&#123; return demo();&#125;int main()&#123; demo a = get_demo(); return 0;&#125; 使用g++ demo.cpp -o demo.exe -std=c++0x -fno-elide-constructors命令禁用优化，看最原始情况的输出，有： 首先在get_demo里调用了构造函数 离开get_demo时，return语句对函数内创建的对象进行拷贝，从而提供返回值 执行完return后，离开作用域，之前函数内创建的对象销毁，但是拷贝的作为返回值来到了main 返回值被&#x3D;赋给了a，执行了拷贝构造（深拷贝，此时有两个demo对象） return 0之后，离开作用域，调用析构函数销毁对象，由于两个对象都要销毁，因此调用了两次析构函数 可以看出来，在第2步和第4步时执行了两次深拷贝，对于仅申请少量堆空间的临时对象来说，深拷贝的执行效率依旧可以接受，但如果临时对象中的指针成员申请了大量的堆空间，那么 2 次深拷贝操作势必会影响 a 对象初始化的执行效率。针对此，C++11引入了移动构造函数方案以避免深拷贝导致的效率问题。 移动构造函数与浅拷贝类似，但是区别在于：1. 参数要求是右值引用，而非左值引用；2. 函数内将原指针置为0 12345//添加移动构造函数demo(demo &amp;&amp;d):num(d.num)&#123; d.num = NULL; cout&lt;&lt;&quot;move construct!&quot;&lt;&lt;endl;&#125; 可以看出来，上面的main在执行过程中，return返回和&#x3D;赋值，都是将右值赋给左值，因此对应上了移动构造函数中的右值引用。所以再执行代码时，将会通过两次移动替代两次拷贝： 实际开发中，通常在类中自定义移动构造函数的同时，会再为其自定义一个适当的拷贝构造函数，由此当用户利用右值初始化类对象时，会调用移动构造函数；使用左值（非右值）初始化类对象时，会调用拷贝构造函数。 但是，也可以完全用移动构造函数，也就是完全用右值引用，方法是采用std::move()函数，强行将左值转为右值。 📌C++定义类class A，类内包含的默认8个成员函数：- 默认构造函数： A();- 默认拷贝构造函数： A(const A&amp;);- 默认析构函数： ~A();- 默认重载赋值运算符： A&amp; operator &#x3D; (const A&amp;);- 默认重载取址运算符： A* operator &amp; ();- 默认const修饰的重载取址运算符： const A* operator &amp; () const;- （C++11）默认移动构造函数： A(A&amp;&amp;);- （C++11）默认重载移动赋值运算符：A&amp; operator &#x3D; (const A&amp;&amp;); unique_ptr就是通过移动构造函数实现的所有权转移。unique_ptr类中只有移动构造函数，禁用拷贝构造。移动构造函数还有一个典型案例就是，vector容器中的emplace_back函数采用移动构造，push_back函数采用拷贝构造，前者比后者高效很多。 智能指针智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，智能指针是一个类，当超出类的作用域时，会自动调用析构函数，析构函数会自动释放资源。因此智能指针在函数结束时自动释放内存空间，不需要手动释放（严格践行RAII）。而且智能指针重载了*和→操作符，使用起来和原始指针一样。不要试图delete智能指针。 auto_ptr（已被C++11弃用） 123auto_ptr&lt;string&gt; p1 (new string(&quot;I reigned lonely as a cloud&quot;));auto_ptr&lt;string&gt; p2;p2 = p1; //auto_ptr不会报错 auto_ptr采用所用权模式。上述代码执行时不会报错，但p2剥夺了p1的所有权，当程序访问p1时将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃风险。 unique_ptr unique_ptr实现独占式拥有，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露（如“new创建对象后因异常而忘记调用delete”）特别有用。 123unique_ptr&lt;string&gt; p3(new string (&quot;auto&quot;));unique_ptr&lt;string&gt; p4;p4 = p3; //报错！ 编译器认为p4&#x3D;p3非法，因此避免了p3不再指向有效数据，成为野指针的问题。因此unique_ptr比auto_ptr更为安全。 智能指针没有定义加减运算，不能随意移动指针地址，从而避免指针越界等危险操作。 12ptr1++; //导致编译错误ptr2+=2; //导致编译错误 需要注意，使用智能指针也要避免未初始化的空指针问题。比如下面的代码会导致core dump： 12unique_ptr ptr3; //未初始化智能指针*ptr3 = 42; //错误！操作了空指针 为了避免这种低级错误，可以调用工厂函数**make_unique()**，强制要求创建指针的时候必须初始化： 12345678unique_ptr&lt;string&gt; ptr5;ptr5 = unique_ptr&lt;string&gt;(new string (&quot;You&quot;)); //不用工厂函数，而是构造函数，临时右值初始化auto ptr3 = make_unique(42); //工厂函数创建智能指针assert(ptr3 &amp;&amp; *ptr3 == 42);auto ptr4 = make_unique(&quot;god of war&quot;); //工厂函数创建智能指针assert(!ptr4-&gt;empty()); 📌make_unique()要求C++14，但是如果使用C++11，可以自己实现一个简化版的make_unqiue() template&lt;typename T, typename… Ts&gt; &#x2F;&#x2F;可变参数模板 &amp;#x20;std::unique_ptr&lt;T&gt; make_unique(Ts&amp;&amp;… params) &#x2F;&#x2F;返回智能指针，入口参数{&amp;#x20; return std::unique_ptr&lt;T&gt;(new T(std::foward&lt;Ts&gt;(params)…)); &#x2F;&#x2F;构造智能指针，完美转发} （标准库的工厂函数内部是有优化的，会比手写类型构造的效率更高） 前面提到unique_ptr不允许直接进行“所有权”转移，这是因为其禁用了拷贝赋值，仅保留了移动构造和移动赋值。因此，若想要进行所有权转移，必须用std::move函数显式地声明： 12345auto ptr1 = make_unique(42); //工厂函数创建智能指针assert(ptr1 &amp;&amp; *ptr1 ==42);auto ptr2 = std::move(ptr1); //使用move()转移所有权assert(!ptr1 &amp;&amp; ptr2); get()和release()： bar是一个智能指针，p是一个普通指针，p=bar.get()，bar并未被释放，此时相当于指针p和智能指针bar共同管理一个对象。也就是说，*p&#x3D;做的事情，会反映到bar指向的对象。 release()会释放当前指针对对象的所有权，其返回值用于新的指针（普通指针或智能指针）接管对象。 123456789101112131415 // foo bar p // --- --- ---std::unique_ptr&lt;int&gt; foo; // nullstd::unique_ptr&lt;int&gt; bar; // null nullint* p = nullptr; // null null nullfoo = std::unique_ptr&lt;int&gt;(new int(10)); // 10 null nullbar = std::move(foo); // null 10 nullp = bar.get(); // null 10 10*p = 20; // null 20 20p = nullptr; // null 20 nullfoo = std::unique_ptr&lt;int&gt;(new int(30)); // 30 20 nullp = foo.release(); // null 20 30*p = 40; // null 20 40 此外还有reset()方法，不仅会释放所有权，还会释放对象，即释放内存。 12345std::unique_ptr&lt;string&gt; p1(new std::string(&quot;1&quot;));std::unique_ptr&lt;string&gt; p2(p1.release()); //p1置空,p2接管std::unique_ptr&lt;string&gt; p3(new std::string(&quot;3&quot;));p2.reset(p3.release()); //p2会释放原来指向的对象，接管p3原来的对象 shared_ptr shared_ptr实现共享式拥有概念。多个智能指针指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时释放。采用计数机制表明资源被几个指针共享，可通过成员函数use_count()查看资源所得者个数。 构造方式： 可通过new来构造，也可通过传入auto_ptr，unique_ptr，weak_ptr来构造，还可通过std::make_shared函数构造，如： 12std::shared_ptr&lt;int&gt; sptr3(new int(10));std::shared_ptr&lt;int&gt; sptr4 = std::make_shared&lt;int&gt;(5); 由于所有权是可以被安全共享的，所以允许拷贝赋值： 12auto ptr1 = std::make_shared&lt;int&gt;(42);auto ptr2 = ptr1; 销毁方式： 对某个指针调用release()时，当前指针会释放资源所有权，计数减1。当计数等于0，资源被释放 关键成员函数： use_count：返回引用计数的个数 unique：返回是否是独占所有权（use_count为1） swap：交换两个shared_ptr对象 reset：放弃内部对象的所有权或拥有对象的变更，会引起原有对象的引用计数的减少 get：返回内部对象（指针），如shared_ptr&lt;int&gt;sp (new int(1))后，sp与sp.get()是等价的 weak_ptr weak_ptr指向由shared_ptr管理的对象，但不控制对象的生命周期。考虑这样一种情况，两个shared_ptr相互引用，如下： 123456789101112131415161718class A&#123;public: shared_ptr&lt;B&gt; pb_; ~A()&#123; cout&lt;&lt;&quot;A delete\\n&quot;; &#125;&#125;;class B&#123;public: shared_ptr&lt;A&gt; pa_; ~B()&#123; cout&lt;&lt;&quot;B delete\\n&quot;; &#125;&#125;;shared_ptr&lt;B&gt; pb (new B());shared_ptr&lt;A&gt; pa (new A());pb-&gt;pa_ = pa;pa-&gt;pb_ = pb;cout &lt;&lt; pb.use_count() &lt;&lt; endl;cout &lt;&lt; pa.use_count() &lt;&lt; endl; 此时两个指针互相引用，形成了死锁，计数不可能下降为0（两个的计数都为2），资源永远不会释放。而weak_ptr旨在解决这一问题，weak_ptr不会引起计数的增加或减少，但可指向shared_ptr管理的对象，因此在例子中，两shared_ptr中的一个降级为weak_ptr即可解决死锁问题。 12345class A&#123;public: weak_ptr&lt;B&gt; pb_; ~A()&#123; cout&lt;&lt;&quot;A delete\\n&quot;; &#125;&#125;; weak_ptr基本用法： &amp;#x20;如果要使用weak_ptr指向的对象，首先要用expired成员函数检查对象是否存在且是否能引用，之后再用lock成员函数升格为shared_ptr，才能使用。 123456789101112int main()&#123; std::shared_ptr&lt;int&gt; sptr(new int(3)); //strong ref = 1 std::shared_ptr&lt;int&gt; sptr2 = sptr; //strong ref = 2 std::weak_ptr&lt;int&gt; wptr = sptr; //strong ref = 2, weak ref = 1 if(!wptr.expired())&#123; std::shared_ptr&lt;int&gt; sptr3 = wptr.lock();//strong ref = 3, weak ref = 1 &#125; return 0;&#125; 可以看到，使用weak_ptr是有强弱引用计数的 智能指针是否会有内存泄漏 当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，退出作用域时未能释放内存，从而导致内存泄露。 智能指针的内存泄露如何处理 为了解决循环引用导致的内存泄漏，引入了weak_ptr弱指针，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。 写时拷贝（COW, Copy On Write）&amp;#x20;深拷贝和浅拷贝各有优劣，前者可以避免重复析构的问题，后者可以提高代码效率。写时拷贝即是融合了二者优点的改良方案，类似于shared_ptr。 其特点为：写之前→浅拷贝，多个对象可以指向一片内存；修改时→深拷贝，哪个对象要修改内存的值，就为其新开辟一块空间。当要释放掉某片内存时，只在最后一个对象销毁时释放该内存。 如何知道当前析构的是否是最后一个对象？ 利用计数器（引用计数），当新增了一个指向这片内存的对象时，该计数器加1，当销毁了一个指向这片内存的对象时，计数器减1。减到0时，说明在销毁最右一个对象，此时可以释放内存。 计数器位置的选取是此方案最重要的问题。 引用计数作为成员变量？ 难以做到多个对象之间的同步。 引用计数作为静态变量？ 所有对象共享该引用计数，如果都指向了相同内存，可以达到计数目的。然而，如果出现了写操作，会导致问题。举例说明，类中有一个string指针属性，实例化对象时需要开辟内存。当前三个对象都指向”hello”字符串时，计数器会加到3，但是如果第四个对象指向了”world”字符串，那么第四个对象会将计数器置1。那么前三个对象的计数器也会被修改为1，从而无法释放掉”hello”字符串。 引用计数放在堆内存中： 将引用计数变量放在堆内存中，是写时拷贝的惯用方案。当开辟内存时，多留4字节的裕量，将引用计数放在堆内存起始位置。之后再将类的属性（指针）指向堆内存起始位置+4。 以自定义一个CString类型为例： 查看引用计数函数： 引用计数在堆内存中，需要查看或修改时，返回该内存的引用。因为堆内存开辟时是char类型，指针需强制转为int* 不应暴露出可以外部修改引用计数的接口，所以引用计数和查看函数均应是私有的。 1234//mptr是类CString中，指向堆内存的指针成员int&amp; getRefCount(char* ptr)&#123; return *(int*)(ptr-4); //ptr指向的是字符串，想查看引用计数需地址回退四个字节&#125; 释放内存函数： 释放内存涉及的问题是判断是否销毁到了指向这片内存的最后一个对象。 12345void Release(char* ptr)&#123; if(--getRefCount(mptr) == 0)&#123; delete[] (mptr-4); //释放内存的时候还要释放保存引用计数的四个字节 &#125;&#125; 构造函数： 构造函数需从一个字符串常量构造，由于事先并无开辟的堆内存，所以需要开辟新内存，并将引用计数置1。 12345CString(char* ptr=NULL) : mptr(new char[strlen(ptr) + 1 + 4])&#123; //从字符串常量构造CString对象 mptr += 4; strcpy(mptr, ptr); getRefCount(mptr) = 1;&#125; 拷贝构造函数和重载赋值运算符： 拷贝构造函数用浅拷贝，同时给引用计数加1。 而赋值运算符需要注意的是，如果左值是原内存的最后一个对象，则需要销毁原内存（或者不是最后一个对象，要引用计数减1），再进行浅拷贝。 123CString(const CString&amp; rhs):mptr(rhs.mptr)&#123; ++getRefCount(mptr);&#125; 12345678CString&amp; operator=(const CString&amp; rhs)&#123; if(this != &amp;rhs)&#123; Release(mptr); mptr = rhs.mptr; ++getRefCount(mptr); &#125; return *this;&#125; 重载[]运算符函数： [ ]运算符涉及的问题是，CSting定义的对象str，往往是通过[ ]来修改值的，比如str[1]&#x3D;’a’。所以这里不应采用浅拷贝，而应是深拷贝。这也对应了写时拷贝的概念，即只有发生修改时，才用深拷贝。 但也不是所有情况下都必须用深拷贝，如果引用计数为1，说明只有一个对象独占资源，那么可以直接在原内存上进行修改，不需要深拷贝。如果引用计数大于1，说明多个对象共享堆内存，那么一个对象动了堆，其他对象也会跟着改变，但是其他对象本来的堆内存的值本就不应改变，这时需要采用深拷贝。 1234567891011 char&amp; operator[](int index)&#123; if(getRefCount(mptr) &gt; 1)&#123; //判断引用计数是否大于1 char* ptr = mptr; mptr = new char(strlen(mptr) + 1 + 4); //深拷贝 --getRefCount(ptr); mptr += 4; strcpy(mptr, ptr); getRefCount(mptr) = 1; &#125; return mptr[index];&#125; 这样写也存在问题，很多时候调用[ ]只希望访问值，而非修改，但访问时也采用了深拷贝，导致了效率的损失。这也是写时拷贝的缺点所在。 整体代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class CString&#123;public: CString(char* ptr=NULL) : mptr(new char[strlen(ptr) + 1 + 4])&#123; mptr += 4; strcpy(mptr, ptr); getRefCount(mptr) = 1; &#125; CString(const CString&amp; rhs):mptr(rhs.mptr)&#123; ++getRefCount(mptr); &#125; CString&amp; operator=(const CString&amp; rhs)&#123; if(this != &amp;rhs)&#123; Release(mptr); mptr = rhs.mptr; ++getRefCount(mptr); &#125; return *this; &#125; char&amp; operator[](int index)&#123; if(getRefCount(mptr) &gt; 1)&#123; char* ptr = mptr; mptr = new char(strlen(mptr) + 1 + 4); --getRefCount(ptr); mptr += 4; strcpy(mptr, ptr); getRefCount(mptr) = 1; &#125; return mptr[index]; &#125; ~CString()&#123; Release(mptr); //析构时调用释放内存函数 &#125; void Print()&#123; cout &lt;&lt; mptr &lt;&lt; endl; &#125;private: char* mptr; int&amp; getRefCount(char* ptr)&#123; return *(int*)(ptr-4); &#125; void Release(char* ptr)&#123; if(--getRefCount(mptr) == 0)&#123; delete[] (mptr-4); //释放内存的时候还要释放保存引用计数的四个字节 &#125; &#125;&#125;;int main()&#123; CString str1(&quot;hello&quot;);//构造 Cstring str2(str1);//拷贝构造 CString str3(&quot;world&quot;);//构造 str1 = str3; str1[0] = &#x27;a&#x27;; str1.Print(); str2.Print(); str3.Print(); return 0;&#125; 输出： aorld hellow world 11 模板 更高深的模板知识移步《泛型编程》笔记，泛型编程本身就是C++几大编程风格之一，可以说非常复杂 类模板 编译时的机制，并不会产生额外的运行时开销 123456789101112131415template&lt;typename T&gt;class Vector&#123;private: T* elem; int sz;public: explicit Vector(int s); ~Vector() &#123;delete[] elem;&#125; T&amp; operator[](int i); const T&amp; operator[](int i) const; int size() const &#123;return sz;&#125; T* begin(Vector&lt;T&gt;&amp; x); T* end(Vector&lt;T&gt;&amp; x)&#125;; 成员函数的定义方式与之类似 123456789101112131415161718192021222324template&lt;typename T&gt;Vector&lt;T&gt;::Vector(int s)&#123; if(s &lt; 0) throw Negative_size&#123;&#125;; elem = new T[s]; sz = s;&#125;template&lt;typename T&gt;const T&amp; Vector&lt;T&gt;::operator[](int i) const&#123; if(i&lt;0 || size()&lt;=i) throw out_of_range(&quot;Vector::operator[]&quot;); return elem[i];&#125;template&lt;typename T&gt;T* begin(Vector&lt;T&gt;&amp; x)&#123; return x.size() ? &amp;x[0] : nullptr;&#125;template&lt;typename T&gt;T* end(Vector&lt;T&gt;&amp; x)&#123; return begin(x) + x.size();&#125; 定义了begin 和end就可以使用for循环了 1234void f2(Vector&lt;string&gt;&amp; vs)&#123; for(auto&amp; s : vs) cout &lt;&lt; s &lt;&lt; &#x27;\\n&#x27;;&#125; 除了类型参数外，还接受普通的值参数 1234567template&lt;typename T, int N&gt;struct Buffer&#123; using value_type = T; constexpr int size() &#123;return N;&#125; T[N]; // ...&#125;; 函数模板 123456template&lt;typename Container, typename Value&gt;Value sum(const Container&amp; c, Value v)&#123; for(auto x : c) v += x; return v;&#125; 上面的函数相当于针对不同的类型实现了一个累加器 123456void user(Vector&lt;int&gt;&amp; vi, std::list)&#123; int x = sum(vi, 0); double d = sum(vi, 0.0); double dd = sum(ld, 0.0); auto z = sum(vc, complex&lt;double&gt;&#123;&#125;);&#125; 📌模板也可以跟函数参数一样，有默认值。template &lt;typename ty&#x3D;string&gt;int test(ty x) {&amp;#x20;&#x2F;&#x2F;……}如果没有显式说明ty的类型，也没有自动推断，那么编译时就会让ty成为默认类型string。 静态多态：CRTP Curiously Recurring Template Pattern 一般意义上的使用virtual实现的多态均为动态多态，在运行时实现多态。在C++中也可以使用静态多态，在编译时实现多态。动态多态由于存储虚表指针和虚表，以及有查询虚函数地址的一系列操作，会带来较大的开销。静态多态可以提升效率（降低开销），就像内联函数一样。 动态多态： 1234567891011121314151617181920212223242526272829class Animal&#123;public: virtual void Print() const&#123; cout &lt;&lt; &quot;unset&quot; &lt;&lt; endl; &#125;&#125;;class Dog : public Animal&#123;public: void Print() const override&#123; cout &lt;&lt; &quot;Dog&quot; &lt;&lt; endl; &#125;&#125;;class Cat : public Animal&#123;public: void Print() const override&#123; cout &lt;&lt; &quot;Cat&quot; &lt;&lt; endl; &#125;&#125;;void My_Print(const Animal&amp; animal)&#123; animal.Print();&#125;int main()&#123; Dog d; My_Print(d);&#125; 最简单的静态多态： 1234567891011121314151617181920212223242526272829303132333435enum Animal_Type&#123; unset, Dog, Cat,&#125;;class Animal&#123;public: Animal(Animal_Type animal_type) : animal_type(animal_type) &#123;&#125; void Print() const&#123; switch(animal_type)&#123; case unset: cout &lt;&lt; &quot;unset&quot; &lt;&lt; endl; break; case Dog: cout &lt;&lt; &quot;Dog&quot; &lt;&lt; endl; break; case Cat: cout &lt;&lt; &quot;Cat&quot; &lt;&lt; endl; break; default: break; &#125; &#125;private: Animal_Type animal_type;&#125;;void My_Print(const Animal&amp; animal)&#123; animal.Print();&#125;int main()&#123; Animal dog(Animal_Type::Dog); My_Print(dog);&#125; 然而这种最简单的静态多态方法导致的问题是明显的，Animal类非常难以维护，要加一个新类别或新动作，要直接修改Animal类和Animal_Type类的源码。于是可以采用模板来进行改进（需要说明的是，既不用virtual，也不用模板，达不到多态的目的）： 不用virtual和模板无法实现多态： 打印的结果是unset，因为调用My_Print时会把Dog类隐式转换为Animal类（因为My_Print函数接收的参数要求是Animal类） 1234567891011121314151617181920212223242526272829class Animal&#123;public: void Print() const&#123; cout &lt;&lt; &quot;unset&quot; &lt;&lt; endl; &#125;&#125;;class Dog : public Animal&#123;public: void Print() const&#123;//覆盖原Print cout &lt;&lt; &quot;Dog&quot; &lt;&lt; endl; &#125;&#125;;class Cat : public Animal&#123;public: void Print() const&#123;//覆盖原Print cout &lt;&lt; &quot;Cat&quot; &lt;&lt; endl; &#125;&#125;;void My_Print(const Animal&amp; animal)&#123; animal.Print();&#125;int main()&#123; Dog d; My_Print(d);&#125; 利用模板改进的静态多态： 打印Dog，My_Print是模板函数，自动推断类型 123456789101112131415161718192021222324252627282930class Animal&#123;public: void Print() const&#123; cout &lt;&lt; &quot;unset&quot; &lt;&lt; endl; &#125;&#125;;class Dog : public Animal&#123;public: void Print() const&#123; cout &lt;&lt; &quot;Dog&quot; &lt;&lt; endl; &#125;&#125;;class Cat : public Animal&#123;public: void Print() const&#123; cout &lt;&lt; &quot;Cat&quot; &lt;&lt; endl; &#125;&#125;;template&lt;typename A_T&gt;void My_Print(const A_T&amp; animal)&#123; animal.Print();&#125;int main()&#123; Dog d; My_Print(d);&#125; 可以在上面的静态多态实现方案的基础上，进一步改良。现在是有三个Print函数，可以进一步降到只有两个函数以降低开销。改良的方案是CRTP。 CRTP一般的套路如下，在基类上用模板，基类只保留接口，子类负责接口的具体实现。 12345678910111213template &lt;class Derived&gt; struct Base&#123; void Interface() &#123; // ... static_cast&lt;Derived*&gt;(this)-&gt;Implementation(); // ... &#125;&#125;;struct Derived : Base&lt;Derived&gt; &#123; void Implementation();&#125;; 针对上面的例子，则可以改写为CRTP实现的静态多态： 12345678910111213141516171819202122232425262728293031template&lt;typename Derived&gt;class Animal&#123;public: void Print() const&#123; static_cast&lt;Derived*&gt;(this) -&gt; Print(); &#125;&#125;;class Dog : public Animal&lt;Dog&gt;&#123;public: void Print() const&#123; cout &lt;&lt; &quot;Dog&quot; &lt;&lt; endl; &#125;&#125;;class Cat : public Animal&lt;Cat&gt;&#123;public: void Print() const&#123; cout &lt;&lt; &quot;Cat&quot; &lt;&lt; endl; &#125;&#125;;template&lt;typename A_T&gt;void My_Print(const A_T&amp; animal)&#123; animal.Print();&#125;int main()&#123; Dog d; My_Print(d);&#125; 在这个例子中，表面上Dog和Cat类都在继承Animal，但事实上它们继承的类是不同的，Dog继承的是Animal&lt;Dog&gt;类，Cat继承的是Animal&lt;Cat&gt;类。因此即使基类中有static变量，它们是不共享的。除此之外，由于继承的不是同一个基类，Dog和Cat的对象也无法放在同一个STL容器中，这也给CRTP的使用带来了局限。 函数对象（function object&#x2F;functor）函数对象，顾名思义，就是将函数视作一个类的对象。调用函数对象时与调用函数无异，而函数对象的一个好处就是比较灵活，可以作为其他函数的参数被调用。 模板的一个特殊用途就是泛化函数对象，例如： 1234567template&lt;typename T&gt;class Less_than&#123; const T val; //待比较的值public: Less_than(const T&amp; v) : val(v) &#123;&#125; bool operator()(const T&amp; x) const &#123; return x &lt; val; &#125; //调用运算符&#125;; 此时，可以像调用函数一样调用函数对象 1234Less_than&lt;int&gt; LT_i &#123;42&#125;;Less_than&lt;string&gt; LT_s &#123;&quot;Backus&quot;&#125;;bool b1 = LT_i(n); //如果n&lt;42则为真bool b2 = LT_s(s); //如果s&lt;&quot;Backus&quot;则为真 函数对象经常作为算法的参数出现，例如下面例子中pred就是函数对象作为的参数 12345678910111213//统计容器中有多少个小于某数的值template&lt;typename C, typename P&gt;int count(const C&amp; c, P pred)&#123; //C假定为容器类型，P为函数对象类型 int cnt = 0; for(const auto&amp; x : c) if(pred(x)) ++cnt; return cnt;&#125;void f(const Vector&lt;int&gt;&amp; vec, int x)&#123; cout &lt;&lt; count(vec, Less_than&lt;int&gt;&#123;x&#125;) &lt;&lt; endl;&#125; 除了用类和模板定义函数对象，还可以用匿名函数(lambda表达式)定义函数对象。 可变参数 省略符形参： 省略符形参应该仅仅用于C和C++通用的类型。特别应该注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。 1234567891011121314151617181920212223242526272829int sum(int count, ...)&#123; if (count &lt;= 0) &#123; return 0; &#125; //为了实现可变参数列表，首先需要声明一个va_list类型的指针 //va_list类型是在cstdarg头文件里面定义的，该指针用来依次指向各个参数 //va_start是一个宏，用来初始化arg_ptr，使其指向列表的第一个参数 //这个宏的第二个参数是sum函数参数列表省略号前得固定参数的名称，用来确定第一个参数的位置 va_list arg_ptr; va_start(arg_ptr, count); int CountSum = 0; //va_arg是一个宏，返回arg_ptr指向的参数位置，并使arg_ptr递增来指向下一个参数值 //va_arg宏的第二个参数是需要统计的第一个参数的类型， //如果类型不正确，程序也可能会执行，但得到的是无用的数据，arg_ptr将被错误地递增 for (int i = 0; i &lt; count; ++i) &#123; CountSum += va_arg(arg_ptr, int); &#125; //将va_list类型的指针复位成空值 //就是清空可变参数列表 va_end(arg_ptr); return CountSum;&#125;sum(5,1,2,3,4,5);//return 15 可变参数模板（实用）： 实现可变参数模板的关键是：当你传给它多个参数时，谨记把第一个参数和其他参数区分对待。此处，首先处理第一个参数head，然后使用剩余参数递归地调用f()。省略号…表示列表地“剩余部分”。最终，tail将为空。 123456789101112131415161718192021222324void f() &#123;&#125; //不执行任何操作template&lt;typename T&gt;void g(T x)&#123; cout &lt;&lt; x &lt;&lt; &quot; &quot;;&#125;template&lt;typename T, typename... Tail&gt;void f(T head, Tail... tail)&#123; //f()类似于printf()的简单变形 g(head); //对head做某些操作 f(tail...); //再次处理tail&#125;int main()&#123; cout &lt;&lt; &quot;first: &quot;; f(1,2.2,&quot;hello&quot;); cout &lt;&lt; &quot;\\n second: &quot;; f(0.2, &#x27;c&#x27;, &quot;yuck!&quot;, 0, 1, 2); cout &lt;&lt; &quot;\\n&quot;;&#125;//输出：//first: 1 2.2 hello//second: 0.2 c yuck! 0 1 2 可变参数initializer_list： 12345678//initializer_list相对vector更轻量化 而且元素是常量void error_msg(initializer_list&lt;string&gt; il) &#123; for (auto beg = il.begin(); beg != il.end(); ++beg) cout &lt;&lt; *beg &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125;error_msg(&#123;&quot;im&quot;,&quot;da&quot;,&quot;gong&quot;&#125;);//&quot;im da gong&quot; 这种方式局限性很大，列表里只能同类型，而且元素是常量。 这种方式的一个典型例子就是vector初始化赋值，可用下面代码模拟： 12345678910111213141516171819class MyNumber&#123;public: MyNumber(const std::initializer_list&lt;int&gt;&amp; v)&#123; for(auto itm : v) mVec.push_back(itm); &#125; void print()&#123; for(auto itm : mVec) std::cout &lt;&lt; itm &lt;&lt; &quot; &quot;; &#125;private: std::vector&lt;int&gt; mVec;&#125;;int main()&#123; MyNumber m = &#123;1,2,3,4&#125;; m.print(); return 0;&#125; 宏： 12345#define debug(...) print(cout,__VA_ARGS__)#define debug2(os, ...) print(os, __VA_ARGS__)//#define debug2(format, args...) print(format, ##args)//win32不支持debug2(cout,&quot;this &quot;, &quot; year&quot;);//&quot;this year&quot; __VA_ARGS__表示可变参数列表。 别名泛型编程中的别名可以有很多用途， 写出通用代码： 比如，每个标准库容器都提供了value_type作为其值类型的名字（如vector&lt;int&gt;::value_type为int），因此可以利用这点写出代码，使代码能够在任何一个服从这种规范的容器上工作，如： 12345678template&lt;typename C&gt;using Element_type = typename C::value_type; //C的元素类型template&lt;typename Container&gt;void algo(Container&amp; c)&#123; Vector&lt;Element_type&lt;Container&gt;&gt; vec; //保存结果 //...&#125; 实现algo函数，就可以将如stack&lt;int&gt;的变量转换成vector&lt;int&gt;，Element_type&lt;Container&gt;会等于int。 绑定某些模板实参，定义新的模板： 123456789template&lt;typename Key, typename Value&gt;class Map&#123; //...&#125;;template&lt;typename Value&gt;using String_map = Map&lt;string, Value&gt;;String_map&lt;int&gt; m; //m是一个Map&lt;string, int&gt; 📌typedef 和using 的区别：typedef 只能针对特定的类型，而using 可以生成别名模板。比如可以template&lt;class T&gt; using remove_const_t = typename remove_const&lt;T&gt;::type，而typedef则不行。 模板特化当定义一个类模板或函数模板时，往往希望所有会用到的模板参数类型，都能够满足类模板或函数模板对其功能的要求，举例来说，函数模板template&lt;typename T&gt; …希望所有可能实例化的T，都能够实现取模运算%。 12345678910template &lt;typename E&gt;E my_gcd(E a, E b)&#123; while(b != E(0))&#123; E r = a % b; a = b; b = r; &#125; return a;&#125; 然而，并不是所有的类型都有取模函数，比如一些第三方库的高精度数字库（如CLN的cl_I高精度整数类型就不支持），那么实例化会失败，编译出错。 针对这种情况，有三种解决方案，其中后面两种最常用，即重载和特化。1 方案1：添加代码，让类型支持所需要的操作 123456cln::cl_Ioperator%(const cln::cl_I&amp; lhs, const cln::cl_I&amp; rhs)&#123; return mod(lhs, rhs);&#125; 方案2：函数重载，不直接使用%运算符，替换成my_mod函数，再重载cl_I类型的my_mod函数 1234567891011//%替换成my_modtemplate &lt;typename E&gt;E my_gcd(E a, E b)&#123; while (b != E(0)) &#123; E r = my_mod(a, b); a = b; b = r; &#125; return a;&#125; 1234567//一般情况下的my_mod函数template &lt;typename E&gt;E my_mod(const E&amp; lhs, const E&amp; rhs)&#123; return lhs % rhs;&#125; 1234567//针对cl_I类重载的my_mod函数cln::cl_Imy_mod(const cln::cl_I&amp; lhs, const cln::cl_I&amp; rhs)&#123; return mod(lhs, rhs);&#125; &amp;#x20; 3. 方案3：模板特化，同方案2类似，但是my_mod不针对cl_I类型重载，而是特化 12345template &lt;&gt;cln::cl_I my_mod&lt;cln::cl_I&gt;(const cln::cl_I&amp; lhs, const cln::cl_I&amp; rhs)&#123; return mod(lhs, rhs);&#125; 📌特化是一种更加通用的技巧，因为特化既可以用在类模板也可以用在函数模板，而重载只能用于函数。然而，一般的建议是：对函数模板使用重载，对类模板进行特化。 特化的经典例子：static_assert 1234567891011template &lt;bool&gt;struct compile_time_error;template &lt;&gt;struct compile_time_error&lt;true&gt; &#123;&#125;;#define STATIC_ASSERT(Expr, Msg) \\ &#123; \\ compile_time_error&lt;bool(Expr)&gt; \\ ERROR_##_Msg; \\ (void)ERROR_##_Msg; \\ &#125; 上面的代码声明了一个struct模板，但仅对true的情况进行了特化，产生了compile_tme_error&lt;true&gt;的定义。这样，如果Expr是错的（比如3&gt;5），此时就遇到了compile_time_error&lt;false&gt;的情况，缺少定义编译不出来，所以就会编译报错，起到编译期检查的作用。(void)ERROR_##_Msg是在抑制编译器unused警告（当成功编译时）。 为什么遇到类型不满足条件时，对函数模板更倾向于重载？ 资料：Why not specialize Function Templates? 偏特化：多个模板参数，仅特化其中的一部分 1 编译时计算（浅述模板元编程） 最大公约数（辗转相除gcd） 12345678910111213141516template &lt;int n&gt;struct factorial&#123; static_assert( n &gt;= 0, &quot;Arg must be non-negative&quot;); static const int value = n * factorial&lt;n-1&gt;::value;&#125;;template &lt;&gt;struct factorial&lt;0&gt;&#123; static const int value = 1;&#125;;int main() &#123; std::cout &lt;&lt; factorial&lt;10&gt;::value &lt;&lt; std::endl; //3628800 return 0;&#125; 这样的代码进行反汇编，可以看到3628800直接出现了，中间的递归、计算过程完全没有。这便体现了编译期计算，即计算步骤完全由编译器完成了，而不在运行时进行。 123456789101112.LC0: .string &quot;%d\\n&quot;main: push rbp mov rbp, rsp mov esi, 3628800 mov edi, OFFSET FLAT:.LC0 mov eax, 0 call printf mov eax, 0 pop rbp ret 从中可以一窥编译期计算的核心：将计算转变成类型推导。 条件语句（C++98）：右边两种写法是等价的 123456789101112template&lt;bool cond, typename Then, typename Else&gt;struct If;template&lt;typename Then, typename Else&gt;struct If&lt;true, Then, Else&gt;&#123; typedef Then type;&#125;template&lt;typename Then, typename Else&gt;struct If&lt;false, Then, Else&gt;&#123; typedef Else type;&#125; 123456template&lt;class T, T v&gt;struct integral_constant&#123; static const T value = v; typedef T value_type; typedef integral_constant type;&#125;; 1234int foo(int n)&#123; if( n==2 || n==3 || n==5 ) return 1; else return 2;&#125; 12345678template&lt;int n&gt;struct Foo&#123; typedef typename If&lt; ( n==2 || n==3 || n==5), integral_constant&lt;int, 1&gt;, integral_constant&lt;int, 2&gt;&gt;::type type;&#125;; 用::取一个成员类型，且::左边有模板参数的话，得额外加上typename关键字来标明结果是一个类型。使用如下： std::cout&lt;&lt;Foo&lt;1&gt;::type::value&lt;&lt;std::endl 定义两项分支Then和Else，用类型来代表执行状态。 cond：条件（真或假） Then：条件为真时的状态 Else：条件为假时的状态 循环语句（C++98）： 12345678910111213141516171819202122template &lt;bool condition, typename body&gt;struct WhileLoop;template &lt;typename Body&gt;struct WhileLoop&lt;true, Body&gt;&#123; typedef typename WhileLoop&lt; Body::cond_value, typename Body::next_type&gt;::type type;&#125;;template &lt;typename Body&gt;struct WhileLoop&lt;false, Body&gt;&#123; typedef typename Body::res_type type;&#125;;template &lt;typename Body&gt;struct While &#123; typedef typename WhileLoop&lt; Body::cond_value, Body&gt;::type type;&#125;; 123456template&lt;class T, T v&gt;struct integral_constant&#123; static const T value = v; typedef T value_type; typedef integral_constant type;&#125;; 12345int result = 0;while(n != 0)&#123; result = result + n; n = n-1;&#125; 123456789101112template &lt;int result, int n&gt;struct SumLoop&#123; static const bool cond_value = n!=0; static const int res_value = result; typedef integral_constant&lt;int, res_value&gt; res_type; typedef SumLoop&lt;result + n, n -1&gt; next_type;&#125;;template&lt;int n&gt;struct Sum&#123; typedef SumLoop&lt;0,n&gt; type;&#125;; ↑上面两种写法的效果是等价的。使用时执行： While&lt;Sum&lt;10&gt;::type&gt;::type::value 可得到1~10累加结果 前面说到，编译期计算用类型推导表示分支状态。因此需要三个成员：cond_value表示循环判断的条件（真假）、res_type表示退出循环时的状态、next_type表示下面循环执行一次的状态。 这样的循环过程可以通过展开来理解，以累加到2为例： While&lt; Sum&lt;2&gt;::type &gt;::type::value 实例化(instantiation)过程--&gt; While&lt; SumLoop&lt;0, 2&gt; &gt;::type::value--&gt; WhileLoop&lt;SumLoop&lt;0, 2&gt;::cond_value, SumLoop&lt;0, 2&gt;&gt;::type::value--&gt; WhileLoop&lt;true, SumLoop&lt;0, 2&gt;&gt;::type::value --&gt; WhileLoop&lt;SumLoop&lt;0, 2&gt;::cond_value, SumLoop&lt;0, 2&gt;::next_type&gt;::type::value--&gt; WhileLoop&lt;true, SumLoop&lt;2, 1&gt;&gt;::type::value --&gt; WhileLoop&lt;SumLoop&lt;2, 1&gt;::cond_value, SumLoop&lt;2, 1&gt;::next_type&gt;::type::value--&gt; WhileLoop&lt;true, SumLoop&lt;3, 0&gt;&gt;::type::value --&gt; WhileLoop&lt;SumLoop&lt;3, 0&gt;::cond_value, SumLoop&lt;3, 0&gt;::next_type&gt;::type::value--&gt; WhileLoop&lt;false, SumLoop&lt;3, -1&gt;&gt;::type::value --&gt; SumLoop&lt;3, -1&gt;::res_type::value --&gt;integral_constant&lt;int, 3&gt;::value--&gt;3 type_traitshttps://en.cppreference.com/w/cpp/header/type_traits 顾名思义，&lt;type_traits&gt;头文件定义了一些工具类模板，用来提取某个类型（type）在某方面的特点（trait）。它可以实现在编译期的判断、转换、查询等功能，并且提供了编译期的true和false。比如上面提到的integral_constant类，就被定义在了type_traits中，它可以称作type_traits的基石。 123456789101112131415161718192021222324/// integral_constanttemplate&lt;typename _Tp, _Tp __v&gt;struct integral_constant&#123; static constexpr _Tp value = __v; typedef _Tp value_type; typedef integral_constant&lt;_Tp, __v&gt; type; constexpr operator value_type() const &#123; return value; &#125;#if __cplusplus &gt; 201103L#define __cpp_lib_integral_constant_callable 201304 constexpr value_type operator()() const &#123; return value; &#125;#endif&#125;;template&lt;typename _Tp, _Tp __v&gt;constexpr _Tp integral_constant&lt;_Tp, __v&gt;::value; 1234typedef std::integral_constant&lt; bool, true&gt; true_type;typedef std::integral_constant&lt; bool, false&gt; false_type; 为方便使用，type_traits还针对布尔值有两个额外的类型定义。于是调用std::true_type::value可以得到true type_traits头文件中凡是带前缀is_*类的偏特化或特化均继承自true_type和false_type，比如： 1234567template &lt;typename&gt;struct __is_pointer_helper : \\ public false_type &#123; &#125;;template &lt;typename&gt;struct __is_pointer_helper &lt;_Tp*&gt; : \\ public true_type &#123; &#125;; 而这些is_*前缀的便是用来标注某类型是否有某特点的模板元。比如is_trivially_destructible模板可用于判断类是否可平凡析构（即，不调用析构函数，不会造成任何资源泄露问题）。模板返回的要么是true_type要么是false_type。使用operator()重载或::value都可以得到背后的true或false。因此，可以在删除某对象前，用它来判断是否需要析构函数，这样在优化编译时，编译器可以把不需要的析构操作全部删除。 1234567891011121314template &lt;typename T&gt;class SomeContainer &#123;public: ... static void destroy(T* ptr)&#123; _destroy(ptr, is_trivially_destructible&lt;T&gt;()); &#125;private: static void _destroy(T* ptr, true_type) &#123;&#125; static void _destroy(T* ptr, false_type) &#123; ptr-&gt;~T(); &#125;&#125;; 上面的代码便是很多容器类都会有的destroy函数，通过is_trivially_destructible来最大程度优化。类似的is_*还有：（具体可查看cppreference官网） is_void, is_null_pointer, is_integral, is_class, is_function, is_pointer, is_lvalue_reference, is_rvalue_reference, is_const, is_move_constructble, is_copy_constructible, has_virtual_destructor等等 同时，type_traits还可以做类型转换，以std::remove_const为例，来去除类型里的const修饰。 123456789template&lt;class T&gt;struct remove_const &#123; typedef T type;&#125;;template&lt;class T&gt;struct remove_const&lt;const T&gt;&#123; typedef T type;&#125;; 1remove_const&lt;const string&gt;::type str;//string类型 📌如果对const char* 应用remove_const的话，结果还是const char 。因为const char 是指向const chat的指针，而不是指向char的const指针。如果对char * const应用remove_const的话，可得到char* &lt;type_traits&gt;中类似的类型转换元还有：（具体可查看cppreference官网） remove_cv（同时去除const和volatile）、remove_volatile、remove_pointer、add_const、remove_extent、make_signed等等。 C++14和C++17还针对&lt;type_traits&gt;提供了一些简易写法，比如写is_trivially_destructible&lt;T&gt;::value和is_trivially_destructible&lt;T&gt;::type会比较啰嗦，那么可以简化写成_v（C++17）和_t（C++14）。 12345template &lt;class T&gt;inline constexpr bool is_trivially_destructible_v = is_trivially_destructible&lt; T&gt;::value; 123template &lt;class T&gt;using remove_const_t = typename remove_const&lt;T&gt;::type; 类型转换模板元中，最重要的模板元是std::decay，decay可以对于普通类型移除引用和cv符（const和volatile） 123456789typedef std::decay&lt;int&gt;::type Normal; //inttypedef std::decay&lt;int&amp;&gt;::type Ref; //inttypedef std::decay&lt;int&amp;&amp;&gt;::type RefRef; //inttypedef std::decay&lt;const int&amp;&gt;::type cnst; //inttypedef std::decay&lt;int[2]&gt;::type Array; //int*，数组类型变成指针类型/*-----decay一般会和decltype搭配-----*/int arr[2] = &#123;1,2&#125;;typedef std::decay&lt;decltype(arr)&gt;::type myArray; decay比较常用的一点在于其可以方便地获得函数指针，即其可以实现从函数对象提取出函数指针类型。 123456789101112int add_2(int x)&#123; return x+2;&#125;int add_3(int x)&#123; return x+3;&#125;std::decay_t&lt;decltype(add_2)&gt; add_ptr = add_3; //add_ptr是函数指针decltype&lt;add_2&gt; * add_func = add2_3; //直接使用decltype推断不出函数指针cout &lt;&lt; add_ptr(7) &lt;&lt; endl; //10cout &lt;&lt; add_func(7) &lt;&lt; endl; //10 decay本意就是退化，移除引用和cv，从函数对象到函数指针，都可以看做是一种退化行为。 但是需要注意，decay_t&lt;decltype&lt;func&gt;&gt;和decay_t&lt;decltype&lt;func()&gt;&gt;是不同的，看上去后者只是加了一个括号。但是后者是将func的返回类型退化，而前者是与func一致入参返回值的函数指针。比如下面的例子，进行map-reduce中的map操作，就是进行返回类型退化decay_t&lt;decltype&lt;func()&gt;&gt;。 123456789101112131415161718template &lt;template&lt;typename, typename&gt;class OutContainer = vector, typename F, class R&gt; auto fmap(F&amp;&amp; f, R&amp;&amp; inputs)&#123; typedef decay_t&lt;decltype(f(*inputs.begin()))&gt; result_type; OutContainer&lt;result_type, allocator&lt;result_type&gt;&gt; result; for (auto&amp;&amp; item : inputs)&#123; result.push_back(f(item)); &#125; return result; &#125;int main() &#123; vector&lt;int&gt; v = &#123;1,2,3,4,5&#125;; auto add_1 = [](int x)&#123; return x + 1; &#125;; auto result = fmap(add_1, v); //v变成：2,3,4,5,6 return 0;&#125; 其他的&lt;type_traits&gt;中常用模板元有：std::conditional, std::enable_if, std::void_t等。 std::conditional：在编译期根据一个判断式选择两个类型中的一个，类似三元表达式 123//原型template&lt;bool B, class T, class F&gt;struct conditional; 1234int main()&#123; typedef std::conditional&lt;true, int, char&gt;::type A; typedef std::conditional&lt;false, int, char&gt;::type B;&#125; type_traits最常用的std::enable_if会在下一小节阐述。 重载歧义消除（traits）多个同名函数做重载时，偶尔会发生歧义的情况。即调用函数时的参数，同时满足两个及以上的重载函数，那么编译器无从选择，就会出现编译报错。因此需要歧义消除机制，有两种常用方案，SFINAE和type_traits。 SFINAE其实是C++中的一种机制，即“如果模板实例化发生了失败，没有理由让编译就此出错终止，因为还可能有其他可用的函数重载”，标准库通过这种机制提出了歧义消除的解决方案。 SFINAE（Substitution Failure Is Not An Error） 考虑要实现一个Buffer类，希望在Buffer中添加元素，可以有三种形式： 第一种重载：传入一个字符，和一个size_t，向Buffer中添加n个相同的c 第二种重载：直接传入一个字符串，并传入字符串大小 第三种重载：STL风格添加，即可以buf.append(str.begin(), str.end());和buf.append(str.rbegin(),str.rend());，需要注意前者的参数类型是string::iterator，后者的参数类型是string::reverse_iterator。想用一个函数接受两类迭代器，需要用到模板。 因此，Buffer类可以设计成下面的形式： 12345678910111213141516171819202122class Buffer&#123;private: //...public: void append(char c, size_t n = 1); //第一种重载 void append(const char* s, size_t n); //第二种重载 template&lt;typename Iter&gt; void append(Iter bp, Iter ep); //第三种重载&#125;;int main()&#123; Buffer buf; buf.append(&#x27;a&#x27;); //[1] buf.append(&#x27;b&#x27;,10); //[1] string str(&quot;hello&quot;); buf.append(str.data(), str.size()); //[2] buf.append(str.rbegin(), str.rend());//[3]&#125; 但是这样的写法是有错误的，考虑下面的情况 12345int main()&#123; int ch = &#x27;a&#x27;; Buffer buf; buf.append(ch, 10); //int,int&#125; 这种写法下，按理说是想用第一种重载方式，然而由于两个类型都是int，所以会调用原本为迭代器设计的模板重载，即调用了第三种方式的重载，那么就会导致运行时的错误。 SFINAE可用于解决这种问题，它的思路是对模板参数T的类型加以限制，从而避免所有情况下模板都能精准匹配。 SFINAE的关键在于std::enable_if。std::enable_if&lt;BOOL,??&gt;::type的使用方式：第一个模板参数接收一个bool类型，第二个模板参数接收一个任意类型，当前面的bool条件为true时，enable_if的成员变量type就会是第二个模板参数??的类型。而enable_if&lt;BOOL,void&gt;默认第二个模板参数是void。bool条件为false时，表达式解析失败，即不会编译false对应的内容。 用SFINAE，规避Iter为int类型： 写法：(可以写的形式有很多，跟这种写法都是一个思想) 12345678910111213class Buffer&#123;private: //...public: void append(char c, size_t n = 1); //第一种重载 void append(const char* s, size_t n); //第二种重载 template&lt;typename Iter, typename = std::enable_if&lt;!std::is_integral&lt;Iter&gt;::value&gt;::type&gt; void append(Iter bp, Iter ep); //第三种重载 //当非整数时就相当于template&lt;typename Iter, typename = void&gt; void append(...) //整数时就会解析失败，SFINAE机制此时会选择其他函数重载&#125;; 上面的写法是针对函数重载歧义消除时的enable_if用法，事实上enable_if还可以有别的用法： 模板偏特化： 1234567template &lt;typename T, typename Enable=void&gt;struct check;template &lt;typename T&gt;struct check&lt;T, typename std::enable_if&lt;T::value&gt;::type&gt; &#123; static constexpr bool value = T::value;&#125;; check只选择value==true的T，否则就报编译错误（因为没有其他重载的定义了）。 📌只有类模板是可以偏特化的，函数模板不可以偏特化。 控制函数返回类型：典型的例子就是C++的tuple中，获取k个元素的get方法的实现。 123456789101112template &lt;std::size_t k, class T, class... Ts&gt;typename std::enable_if&lt;k==0, typename element_type_holder&lt;0, T, Ts...&gt;::type&amp;&gt;::typeget(tuple&lt;T, Ts...&gt; &amp;t) &#123; return t.tail; &#125;template &lt;std::size_t k, class T, class... Ts&gt;typename std::enable_if&lt;k!=0, typename element_type_holder&lt;k, T, Ts...&gt;::type&amp;&gt;::typeget(tuple&lt;T, Ts...&gt; &amp;t) &#123; tuple&lt;Ts...&gt; &amp;base = t; return get&lt;k-1&gt;(base); &#125; 通过enable_if可以根据不同k的值选择调用哪个get，实现函数模板的多态。这个例子也体现了“编译时计算”思想。进行了一个编译期的递归。 在进行歧义消除的同时，控制返回类型： 12345template &lt;typename T&gt;typename std::enable_if&lt;std::is_integral&lt;T&gt;::value, bool&gt;::typeis_odd(T t) &#123; return bool(t % 2);&#125; 除了利用enable_if关键字和SFINAE机制，还有另一种更有效的歧义消除方案。 添加参数（标签分发，tag dispatch） 现在希望实现一个to_string函数，把数值（整数、浮点数）转换为标准库string类型变量，可以先这么写： 12345678910111213141516171819202122232425262728std::string to_string(long long value)&#123; char str[64]; int len = sprintf(str, &quot;%lld&quot;, value); return std::string(str, len);&#125;std::string to_string(unsigned long long value)&#123; char str[64]; int len = sprintf(str, &quot;%llu&quot;, value); return std::string(str, len);&#125;std::string to_string(long double value)&#123; char str[64]; int len = sprintf(str, &quot;%Lg&quot;, value); return std::string(str, len);&#125;int main()&#123; std::string str; str = to_string(1234); printf(&quot;str = %s\\n&quot;, str.c_str()); str = to_string(-1234); printf(&quot;str = %s\\n&quot;, str.c_str()); str = to_string(56.789); printf(&quot;str = %s\\n&quot;, str.c_str());&#125; 此代码考虑了long long 类型整数和非负整数，以及double浮点类型。然而，编译会报错。因为传1234这个字面量时，1234会作为一个整数变量进入函数栈，然而重载的函数中没一个是精确匹配int类型的，因此编译器会找类型提升，即隐式转换。然而，int对于long long , unsigned long long, long double都存在隐式转换，由此产生歧义，编译器不知道该选择哪个函数重载，所以会有编译报错。 解决方案一：把所有类型的参数，都写一遍，即列举所有可能的函数重载 缺点：写太多了，费时费力 解决方案二：用SFINAE 缺点：当前的重载主要判断两个条件，一个是“参数是否为整数”，另一个是“参数是否为有符号数”。当重载的判断条件大于等于2时，使用SFINAE会将代码写得较乱，难以维护和拓展。 解决方案三：添加参数，确保所有情况都有重载可以匹配，而且至多有一个匹配。 实现方式类似于，通过函数参数，实现if语句。当前函数重载主要判断两个条件：参数是否为整数，参数是否为有符号数。因为浮点数不存在有无符号的问题，所以类型总共可以分为三个分支： 整数，有符号数 整数，无符号数 浮点数 因此，可以加上模板，利用std::is_integral&lt;T&gt;判断参数类型是否为整数，利用std::is_signed&lt;T&gt;判断类型是否为有符号数。 is_integral&lt;T&gt;事实上是C++标准库中的一个类，继承自integral_constant&lt;bool, true&gt;，该基类是一个bool类型常量。而bool类型在C++标准库中存在两个别名，分别对应true和false：std::true_type和std::false_type，因此可以将函数重载调整为以下代码，即利用重载实现对类型和符号的if判断。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;type_traits&gt; //is_integral, is_signed都归属于type_traits头文件//既是整数，又是有符号数的情况std::string do_to_string(std::true_type, //integral std::true_type, //signed long long value)&#123; char str[64]; int len = sprintf(str, &quot;%lld&quot;, value); return std::string(str, len);&#125;//是整数，但不是有符号数的情况std::string do_to_string(std::true_type, //integral std::false_type, //!signed unsigned long long value)&#123; char str[64]; int len = sprintf(str, &quot;%llu&quot;, value); return std::string(str, len);&#125;//不是整数，但是是有符号数std::string do_to_string(std::false_type, //!integral std::true_type, //signed long double value)&#123; char str[64]; int len = sprintf(str, &quot;%Lg&quot;, value); return std::string(str, len);&#125;template&lt;typename T&gt;std::string to_string(const T&amp; t)&#123; return do_to_string(std::is_integral&lt;T&gt;(), std::is_signed&lt;T&gt;(), t);&#125; declvaldeclval是C++11引入的一种函数模板，其作用在于为一些类型返回它的右值引用类型。官方代码如下： 1234567891011121314151617181920template&lt;class _Ty, class = void&gt; struct _Add_reference &#123; // add reference using _Lvalue = _Ty; using _Rvalue = _Ty; &#125;;template&lt;class _Ty&gt; struct add_rvalue_reference &#123; // add rvalue reference using type = typename _Add_reference&lt;_Ty&gt;::_Rvalue; &#125;;template&lt;class _Ty&gt; using add_rvalue_reference_t = typename _Add_reference&lt;_Ty&gt;::_Rvalue; // FUNCTION TEMPLATE declvaltemplate&lt;class _Ty&gt; add_rvalue_reference_t&lt;_Ty&gt; declval() noexcept; std::declval&lt;T&gt;，传入的T为int时返回int&amp;&amp;，T为int&amp;时返回int&amp;（引用折叠），T为int&amp;&amp;时返回int&amp;&amp;。declval返回右值引用的操作均在编译期完成，不管T类型是否有public的默认构造函数，都能造出右值引用。 123456789101112131415class A &#123;public://......&#125;;int main(int argc, char **argv) &#123; using YT = decltype(std::declval&lt;A&gt;());//不要丢到declval&lt;A&gt;() 后的括号，因为是函数，否则代码含义发生变化 using boost::typeindex::type_id_with_cvr; cout &lt;&lt; &quot;YT = &quot; &lt;&lt; type_id_with_cvr&lt;YT&gt;().pretty_name() &lt;&lt; endl;//显示YT类型 return 0;&#125;//输出结果：YT = class A &amp;&amp; declval和decltype经常配合在一块，用于进行函数指针、成员方法返回类型的推导。 成员方法返回值类型推导： 传统方案：必须构造对象，才能用decltype 📌decltype()中出现的是 变量、对象、表达式、函数名、函数指针等，而不可以出现类型名 123456789101112int main(int argc, char **argv) &#123; //想获得普通函数 myfunc的返回值类型 A myobj(1);//创建对象 using boost::typeindex::type_id_with_cvr; cout &lt;&lt; &quot;返回值类型:= &quot; &lt;&lt; type_id_with_cvr&lt; decltype(myobj.myfunc())&gt;().pretty_name() &lt;&lt; endl; return 0;&#125; 现代方法：decltype配合declval，无需创建对象 📌declval()获得右值引用，可以“骗过”编译器，相当于创建了一个假的对象，从而直接使用该类型的成员函数 12345678910int main(int argc, char **argv) &#123; using boost::typeindex::type_id_with_cvr; cout &lt;&lt; &quot;返回值类型:= &quot; &lt;&lt; type_id_with_cvr&lt; decltype(std::declval&lt;A&gt;().myfunc())&gt;() .pretty_name() &lt;&lt; endl; return 0;&#125; 函数指针推导：刚刚的成员方法返回类型推导比较简单，考虑这样一种情况，函数模板内使用了一个函数指针，返回的就是函数指针的返回值。但是这个函数模板是通用的，也就是各种各样的函数指针它都能接收，那么这个时候返回值类型是不确定的，此时的函数模板该如何定义呢？ 解决方案就是，推导函数指针的返回值类型，推导出的类型来作为函数模板的返回类型。 有两种方式实现这一思路，其中一个就是decltype搭配declval。 方式一：decltype + declval 12345678910111213141516int myfunc(int a, int b) &#123; return a + b;&#125;template &lt;typename T_F, typename... U_Args&gt;decltype(declval&lt;T_F&gt;() (declval&lt;U_Args&gt;()...))TestFnRtnTmp1(T_F func, U_Args... args) &#123; auto rtnvalue = func(args...); return rtnvalue;&#125;int main(int argc, char **argv) &#123; auto result = TestFnRtnTmp1(myfunc, 5, 8); cout &lt;&lt; result &lt;&lt; endl; return 0;&#125; 方式二：尾置返回类型 + auto关键字 12345678910111213141516int myfunc(int a, int b) &#123; return a + b;&#125;template &lt;typename T_F, typename... U_Args&gt;auto TestFnRtnTmp2(T_F func, U_Args... args) -&gt; decltype(func(args...)) &#123; auto rtnvalue = func(args...); return rtnvalue;&#125;int main(int argc, char **argv) &#123; auto result = TestFnRtnTmp2(myfunc, 5, 8); cout &lt;&lt; result &lt;&lt; endl; return 0;&#125; 此处主要解释方式一。declval&lt;T_F&gt;()：T_F是函数指针int(*)(int, int)类型，那么在编译期declval可以推断出其是函数指针并返回int(*&amp;&amp;)(int,int)，即函数指针的右值类型，相当于实例化了一个假的函数指针对象，可以输入参数。所以在decltype(函数指针右值引用())，就可以得到返回值类型。也就是 decltype(declval&lt;T_F&gt;() (declval&lt;U_Args&gt;()...)) 而直接用decltype(T_F(U_Args)...)是不行的，会报错，因为decltype()只能接收实例，不能接收类型。 正则表达式string类型123456789101112131415161718192021222324252627282930//使用加号+进行字符串拼接string compose(const string&amp;name, const string&amp; domain)&#123; return name + &#x27;@&#x27; + domain;&#125;//常用操作string name = &quot;Niels Stroustrup&quot;void m3()&#123; string s = name.substr(6,10); //s=&quot;Stroustrup&quot; 取子串，从索引6开始的10个字符 name.replace(0,5,&quot;nicholas&quot;); //name变为&quot;nicholas Stroustrup&quot; 替换，从索引0开始的5个字符 name[0] = toupper(name[0]); //name变为&quot;Nicholas Stroustrup&quot; 大写&#125;//string与字符串字面值的比较string incantation;void respond()&#123; if(answer == incantation)&#123; //执行一些操作 &#125; else if (answer == &quot;yes&quot;)&#123; //... &#125; //...&#125;//只读形式的C风格字符串void print(const string&amp; s)&#123; printf(&quot;For people who like printf: %s\\n&quot;, s.c_str()); cout &lt;&lt; &quot;For people who like streams: &quot; &lt;&lt; s &lt;&lt; &#x27;\\n&#x27;;&#125; 📌标准库string定义了一个移动构造函数，因此，即使是以传值方式而不是传引用方式返回一个很长的string也会很高效。 string对象除了有begin()和end()之外，还有rbegin()，rend()。同时还有cbegin()，cend()，表示的是const iterator。相应的，crbegin()，crend()表示const reverse iterator。 短字符串优化(short-string optimization)技术： 短字符串直接保存在string对象内部，而长字符串则保存在自由存储区中。 因此对于这样的两个字符串 12string s1 &#123;&quot;Annemarie&quot;&#125;; //短字符串string s2 &#123;&quot;Annemarie Stroustrup&quot;&#125;; //长字符串 s1对象内部直接存在该字符串，而s2对象内部仅存储该字符串的地址，需要用到时则根据地址取值。 之所以采用这种实现方式，是因为运行时环境中内存分配代价较高，而大量长度不一的字符串会产生堆的内存碎片。 短字符串优化可以让栈承担短字符串，加快运行，同时规避长度过于分散的状况。 basic_string： C++标准库中定义了通用字符串模板basic_string，string实际上是此模板用char类型实例化的一个别名 12345template&lt;typename Char&gt;class basic_string&#123; //...类的功能实现&#125;;using string = basic_string&lt;char&gt;; 用户可以不局限于ascii码，利用basic_string定义任意字符类型的字符串。例如，我们有一个日文字符类型Jchar，则可以定义为： 1using Jstring = basic_string&lt;Jchar&gt;; 现在，就可以在Jstring——日文字符串上执行常见的字符串操作。 字符串转换函数 C函数atoi()、atol()面向的是C字符串，而不是C++的string类型。C++11增加了几个新的转换函数： stoi()、stol()、stoll()等把string转换成整数； stof()、stod()等把string转换成浮点数； to_string()把整数、浮点数转换成字符串。 正则表达式的模式 正则表达式的特殊字符 . 任意单个字符（“通配符”） [ 字符集开始 ] 字符集结束 { 指定重复次数开始 } 指定重复次数结束 ( 分组开始 ) 分组结束 \\ 下一个字符有特殊含义 * 零或多次重复（后缀操作） + 一或多次重复（后缀操作） ? 零或一次（后缀操作） | 或 ^ 行开始；非 $ 行结束 重复 {n} 严格重复n次 {n,} 重复n次或更多次 {n,m} 至少重复n次，最多m次 * 零次或多次，即{0,} + 一次或多次，即{1,} ? 零次或一次，即{0,1} 模式匹配在遇见重复字符串时，还涉及贪心匹配和懒惰匹配。 贪心匹配：默认情况下就是贪心匹配 原字符串：ababab，现在用模式(ab)*来匹配，模式匹配器总是查找最长匹配，会匹配到整个字符串ababab 懒惰匹配：在任何重复符号（?、 *、+及{ }）之后放一个后缀?，会使模式匹配器进入懒惰状态。 原字符串：ababab，现在用模式(ab) *?来匹配，模式匹配器会查找最短匹配，匹配到字符串中第一个ab 字符集与字符集简写 正则表达式中，字符集必须用[: :]包围起来。例如[:digit:]匹配一个十进制数字。同时，如果是定义一个字符集，外边必须再包围一对方括号[ ]，比如，[^[:digit:]]匹配一个非十进制数字。 字符集 简写 含义 alnum 任意字符数字字符 alpha 任意字母 blank 任意空白符，但不能是行分隔符 cntrl 任意控制字符 d \\d&#x3D;[[:d:]] 任意十进制数字 digit \\d&#x3D;[[:digit:]], \\D&#x3D;[^[:digit:]]非十进制数字 任意十进制数字 graph 任意图形字符 lower \\l&#x3D;[[:lower:]]，\\L&#x3D;[^[:lower:]]非大写字符，均非标准但常见 任意小写字符 print 任意可打印字符 punct 任意标点 s \\s&#x3D;[[:s:]] 任意空白符（空格、制表符等等） space \\s&#x3D;[[:space:]], \\S&#x3D;[^[:space:]]非空白符 任意空白符 upper \\u&#x3D;[[:upper:]]，\\U&#x3D;[^[:upper:]]非大写字符，均非标准但常见 任意大写字符 w \\w&#x3D;[[:w:]]， 任意单词字符（字母、数字字符再加下划线） xdigit 任意十六进制数字字符 正则表达式分组 ( )引发了分组的概念，也就是正则表达式中被( )包起来的内容构成了一个group，匹配时作为一个子模式匹配。 比如想匹配XML语言，模式可以设计为&lt;(.*?)&gt;(.*?)&lt;/\\1&gt;，这里有三个分组，其中\\1是第三个，含义为“与分组1一样”。而且使用了懒惰匹配.*?，这样，当面临下面的输入： 1Always look for the &lt;b&gt;bright&lt;/b&gt; side of &lt;b&gt;life&lt;/b&gt;. 不使用 ?，而是单独的话，贪心匹配会将第一个&lt;和最后一个&gt;配对。 但懒惰匹配的结果将是&lt;b&gt;bright&lt;&#x2F;b&gt;和&lt;b&gt;life&lt;&#x2F;b&gt;这两个符合程序员预期的结果。 然而，如果想要括号，但是不需要完全匹配到括号中的内容，可以用(? (?:pattern)：匹配pattern但不获取结果，即非获取匹配。例如“industr(?:y|ies)”可以用来替代”industry|industries”。 (?&#x3D;pattern)：正向肯定预查，例如”Windows(?&#x3D;95|98|NT|2000)”能匹配”Windows2000”中的Windows，但不能匹配”Windows3.1”中的Windows。 (?!pattern)：正向否定预查，例如”Windows(?!95|98|NT|2000)”能匹配”Windows3.1”中的Windows，但不能匹配”Windows2000”中的Windows。 (?&lt;&#x3D;pattern)：反向肯定预查，与正向肯定预查类似，但方向相反，例如“(?&lt;&#x3D;95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows” (?&lt;!pattern)：反向否定预查，与正向否定预查类似，但方向相反，例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows” C++中的正则API标准库提供了&lt;regex&gt;类，从而支持正则表达式。比如可以用下面代码定义一个正则表达式模式 1regex pat (R&quot;(\\w&#123;2&#125;\\s*\\d&#123;5&#125;(-\\d&#123;4&#125;)?)&quot;); 上面代码定义了一个美国邮政编码模式：XXddddd-dddd。其中后面的-dddd是可有可无的。以两个字母开始\\w&#123;2&#125;，后面是任意个空白符\\s*，再接下来是5个数字\\d&#123;5&#125;，然后是可选的破折号加四位数字-\\d&#123;4&#125;。 常用正则匹配函数 regex_match( )：将正则表达式与一个（已知长度的）字符串进行匹配，判断是否完全匹配。如果完全匹配则返回true，否则false。 12345678910111213141516171819202122232425262728293031323334353637string str = &quot;twinkle1993&quot;;regex r(&quot;[a-z0-9]+&quot;);bool is_match = regex_match(str, r); //trueis_match = regex_match(str.begin()+7, str.end(), regex(&quot;\\\\d+&quot;)); //truesmatch sm;if(regex_match(str.cbegin()+5, str.cend(), sm, regex(&quot;([a-z]+)(\\\\d+)&quot;)))&#123; cout &lt;&lt; &quot;字符串: &quot; &lt;&lt; &amp;str[5] &lt;&lt; &quot; 匹配成功！&quot; &lt;&lt; endl; cout &lt;&lt; &quot;匹配字符串个数: &quot; &lt;&lt; sm.size() &lt;&lt; endl; cout &lt;&lt; &quot;分别为: &quot;; for(auto aa : sm) cout &lt;&lt; aa.str() &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; &#125;/* 输出结果： 字符串: le1993匹配成功 匹配字符串个数：3 分别为：le1993 le 1993*/cmatch cm;if (regex_match(str.c_str(), cm, regex(&quot;([a-z]+)(\\\\d+)&quot;))) &#123; cout &lt;&lt; &quot;字符串：&quot; &lt;&lt; str &lt;&lt; &quot; 匹配成功！&quot; &lt;&lt; endl; cout &lt;&lt; &quot;匹配字符串个数：&quot; &lt;&lt; cm.size() &lt;&lt; endl; cout &lt;&lt; &quot;分别为：&quot;; for (auto aa : cm) cout &lt;&lt; aa.str() &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125;/* 输出结果： 字符串：twinkle1993 匹配成功！ 匹配字符串个数：3 分别为：twinkle1993 twinkle 1993*/ 其中，smatch相当于vector&lt;string&gt;，其中存储所有匹配的结果。而cmatch则是C风格的smatch。 sm中的第一个元素sm[0]，是贪心的最长匹配（即输入字符串），之后的则是字符串中依据正则表达式group的分组。 smatch对象除了有size()，能索引之外，还有两个比较重要的成员函数： ::prefix()：用于获取输入目标字符串中，匹配字符串之前的字符串 ::suffix()：用于获取输入目标字符串中，匹配字符串之后的字符串 regex_search( )：在一个（任意长）数据流中搜索与正则表达式匹配的字符串 匹配到一个子字符串即返回。sm中第一个元素sm[0]，是匹配到的子字符串，之后的元素则是子字符串中，依据正则表达式group的分组。 12345678910111213141516171819202122232425262728293031323334353637383940int main() &#123; string str = &quot;twinkle1993winkle1993inkle1993&quot;; smatch sm; for (auto it = str.cbegin(); regex_search(it, str.cend(), sm, regex(&quot;([a-z]+)1&quot;)); it = sm.suffix().first) &#123; cout &lt;&lt; &quot;字符串：&quot; &lt;&lt; &amp;*it &lt;&lt; &quot; 匹配成功！&quot; &lt;&lt; endl; cout &lt;&lt; &quot;匹配字符子串个数：&quot; &lt;&lt; sm.size() &lt;&lt; endl; cout &lt;&lt; &quot;分别为：&quot;; for (auto aa : sm) cout &lt;&lt; aa.str() &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; cout &lt;&lt; &quot;字符串 &quot; &lt;&lt; sm.str() &lt;&lt; &quot; 前的字符串为：&quot; &lt;&lt; sm.prefix().str() &lt;&lt; endl; cout &lt;&lt; &quot;字符串 &quot; &lt;&lt; sm.str() &lt;&lt; &quot; 后的字符串为：&quot; &lt;&lt; sm.suffix().str() &lt;&lt; endl; cout &lt;&lt; endl; &#125; return 0;&#125;/*字符串：twinkle1993winkle1993inkle1993 匹配成功！匹配字符子串个数：2分别为：twinkle1 twinkle字符串 twinkle1 前的字符串为：字符串 twinkle1 后的字符串为：993winkle1993inkle1993字符串：993winkle1993inkle1993 匹配成功！匹配字符子串个数：2分别为：winkle1 winkle字符串 winkle1 前的字符串为：993字符串 winkle1 后的字符串为：993inkle1993字符串：993inkle1993 匹配成功！匹配字符子串个数：2分别为：inkle1 inkle字符串 inkle1 前的字符串为：993*/ 当regex_search返回后，借助sm中的sm[0]].first和sm[0].second迭代器可以得到这个字符串在源字符串中出现的准确位置。 123456789101112131415161718192021int main() &#123; string str = &quot;twinkle1993winkle1993inkle1993&quot;; smatch sm; cout &lt;&lt; &quot;正则表达式：([a-z]+)1&quot; &lt;&lt; endl; for (auto it = str.cbegin(); regex_search(it, str.cend(), sm, regex(&quot;([a-z]+)1&quot;)); it = sm.suffix().first) &#123; cout &lt;&lt; &quot;匹配字符子串：&quot; &lt;&lt; sm[0].str() &lt;&lt; endl; cout &lt;&lt; &quot;在源串对应索引：[&quot; &lt;&lt; sm[0].first-str.begin() &lt;&lt; &#x27; &#x27; &lt;&lt; sm[0].second-str.begin() &lt;&lt; &#x27;)&#x27; &lt;&lt; endl; &#125; return 0;&#125;/*匹配字符子串：twinkle1在源串对应索引：[0 8)匹配字符子串：winkle1在源串对应索引：[11 18)匹配字符子串：inkle1在源串对应索引：[21 27)*/ regex_replace( )：在一个（任意长）数据流中搜索与正则表达式匹配的字符串并将其替换 123456789char data[] = &quot;he...ll..o, worl..d!&quot;;std::regex reg(&quot;\\\\.&quot;);// output: hello, world!std::cout &lt;&lt; std::regex_replace(data, reg, &quot;&quot;);char data[] = &quot;001-Neo,002-Lucia&quot;;std::regex reg(&quot;(\\\\d+)-(\\\\w+)&quot;);// output: 001 name=Neo,002 name=Luciastd::cout &lt;&lt; std::regex_replace(data, reg, &quot;$1 name=$2&quot;); regex_iterator：遍历匹配结果和子匹配 上面的regex_search()函数可以让我们逐一迭代正则查找的所有匹配结果，而regex_iterator是达到相同目的的另一种方式。 regex_iterator不同于其它容器的迭代器，不需要.begin()，.end()来进行迭代。regex_iterator只有一个end值，只需要用默认的构造函数声明一个regex_iterator，就可以获得这个尾迭代器：尾迭代器会被隐式地初始化为end值。 123456789101112131415161718192021int main() &#123; string str = &quot;twinkle1993twink1993le1993&quot;; regex reg(&quot;([a-z]+)1&quot;); for (sregex_iterator it(str.begin(), str.end(), reg), end; it != end; it++) &#123; cout &lt;&lt; &quot;匹配字符子串：&quot; &lt;&lt; (*it)[0].str() &lt;&lt; endl; cout &lt;&lt; &quot;在源串对应索引：[&quot; &lt;&lt; (*it)[0].first-str.begin() &lt;&lt; &#x27; &#x27; &lt;&lt; (*it)[0].second-str.begin() &lt;&lt; &#x27;)&#x27; &lt;&lt; endl; &#125; return 0;&#125;/* 输出结果： 匹配字符子串：twinkle1 在源串对应索引：[0 8) 匹配字符子串：twink1 在源串对应索引：[11 17) 匹配字符子串：le1 在源串对应索引：[20 23)*/ regex_token_iterator：遍历未遍历部分 相比于regex_iterator，regex_token_iterator还可用于迭代正则表达式中的每个group。这里将这种正则中的子序列称为token。regex_token_iterator在有参数构造时比regex_iterator多一个参数，此参数用于指示要匹配哪个group。 如果该参数为-1，表示感兴趣的是能够匹配正则表达式的子字符串之间的字符串。 如果该参数为0，表示还是要完整匹配整个正则表达式（该参数默认值为0，因此可以构造时不赋值）。 如果该参数为其它数字，则表示要匹配的是正则表达式中的第几个组，如1就是匹配第一个group。 123456789101112131415161718192021222324252627282930313233343536373839int main() &#123; string str = &quot;11twinkle1993teink1992le1994&quot;; regex reg(&quot;([a-z]+)1&quot;); for (sregex_token_iterator it(str.begin(), str.end(), reg), end; it != end; it++) //default=0 &#123; cout &lt;&lt; &quot;匹配到的字符串为：&quot; &lt;&lt; it-&gt;str() &lt;&lt; endl; &#125; cout &lt;&lt; endl; for (sregex_token_iterator it(str.begin(), str.end(), reg, 1), end; it != end; it++) &#123; cout &lt;&lt; &quot;匹配到的字符串为：&quot; &lt;&lt; it-&gt;str() &lt;&lt; endl; &#125; cout &lt;&lt; endl; for (sregex_token_iterator it(str.begin(), str.end(), reg, -1), end; it != end; it++) &#123; cout &lt;&lt; &quot;匹配到的字符串为：&quot; &lt;&lt; it-&gt;str() &lt;&lt; endl; &#125; cout &lt;&lt; endl; return 0;&#125;/* 输出结果： 匹配到的字符串为：twinkle1 匹配到的字符串为：teink1 匹配到的字符串为：le1 匹配到的字符串为：twinkle 匹配到的字符串为：teink 匹配到的字符串为：le 匹配到的字符串为：11 匹配到的字符串为：993 匹配到的字符串为：992 匹配到的字符串为：994*/ I&#x2F;O流 ostream对象将有类型的对象转换为一个字符（字节）流 cout是ostream类的一个对象，ofstream，ostringstream均继承自ostream类型 istream对象将一个字符（字节）流转换为有类型的对象 cin是istream类的一个对象，ifstream，istringstream均继承自istream类型 所以，ifstream, istringstream和cin的用法区别不大，ofstream，ostringstream和cout的用法也区别不大。 📌IO对象是不能进行拷贝和赋值的。ofstream out1,ou2;out1 &#x3D; out2; &#x2F;&#x2F;错误：不能对流对象赋值ofstream print(ofstream); &#x2F;&#x2F;错误：不能初始化ofstream参数out2 &#x3D; print(out2); &#x2F;&#x2F;错误：不能拷贝流对象由于不能拷贝IO对象，因此不能把函数参数和返回类型设置为流类型，通常以引用方式传递和返回。同时，读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的。 cin cout cout标准输出流 1234567891011121314151617int i = 7000;cout &lt;&lt; &quot;the value is &quot; &lt;&lt; i &lt;&lt; &#x27;\\n&#x27;;//cout也可以格式化输出constexpr double d = 123.456;cout &lt;&lt; d &lt;&lt; &quot;;&quot; //默认格式 &lt;&lt; scientific &lt;&lt; d &lt;&lt; &quot;;&quot; //1.23e2，科学计数法风格 &lt;&lt; hexfloat &lt;&lt; d &lt;&lt; &quot;;&quot; //十六进制 &lt;&lt; fixed &lt;&lt; d &lt;&lt; &quot;;&quot; //定点数 &lt;&lt; defaultfloat &lt;&lt; d &lt;&lt; &quot;\\n&quot;; //默认float格式//想让浮点数截断输出，可以用precision()，会自动四舍五入cout.precision(8);//一个数最多显示8个数字，如果整数部分超过8个，就仅保留整数cout &lt;&lt; 1234.56789 &lt;&lt; &#x27; &#x27; &lt;&lt; 123456 &lt;&lt; endl; //输出结果：1234.5679 123456cout.precision(8);//一个数最多显示8个数字，如果整数部分超过8个，就仅保留整数cout &lt;&lt; 1234.56789 &lt;&lt; &#x27; &#x27; &lt;&lt; 123456 &lt;&lt; endl; //输出结果：1235 123456 需要小心这样一种可能不符合预期的情况 12345void k()&#123; int b = &#x27;b&#x27;; //此处char被隐式转换成了int，&#x27;b&#x27;的ASCII码值为98 char c = &#x27;c&#x27;; cout &lt;&lt; &#x27;a&#x27; &lt;&lt; b &lt;&lt; c; //输出结果：a98c&#125; cin标准输入流 cin将字符串读为特定类型的值，并会忽略起始的空白符。 123456789void hello_line()&#123; cout &lt;&lt; &quot;Please enter your name\\n&quot;; string str; cin &gt;&gt; str; cout &lt;&lt; &quot;Hello,&quot; &lt;&lt; str &lt;&lt; &quot;!\\n&quot;;&#125;//输入Eric//输出Hello, Eric! 但是，默认情况下，空白符（如空格或换行）会终止输入。因此输入Eric Bloodaxe，仍然只会回应Hello, Eric！ 这种情况下，可以用函数getline()来读取一整行（包括结束的换行符），例如 123456789void hello_line()&#123; cout &lt;&lt; &quot;Please enter your name\\n&quot;; string str; getline(cin, str); cout &lt;&lt; &quot;Hello,&quot; &lt;&lt; str &lt;&lt; &quot;!\\n&quot;;&#125;//输入Eric Bloodaxe//输出Hello, Eric Bloodaxe! 行尾的换行符被丢掉了，因此接下来cin会从下一行开始。 关联ostream对象可以通过tie( )函数关联在一个istream对象上。关联的作用在于缓冲区的实时刷新。考虑这样的场景，通过一个istream获取一些字符，之后想将其放入ostream对象中。而且在这个过程中，希望做到每通过istream接收一个字符，就会让ostream对象输出一个字符，也就是实时刷新。 如果不用关联的话，由于一级二级缓存的存在，istream接收的字符不会实时出现在ostream对象中，而是程序结束时一股脑放入其中。但如果用tie关联，可以实时刷新缓冲区。ostream对象能够在istream对象有动作之前刷新缓冲区。 1234567891011//有关联版本代码int main()&#123; std::ofstream ofs; ofs.open(&quot;test.txt&quot;); cin.tie(&amp;ofs); char c; while(cin &gt;&gt; c)&#123; ofs &lt;&lt; c; &#125; ofs.close();&#125; 12345678910//无关联版本代码int main()&#123; std::ofstream ofs; ofs.open(&quot;test.txt&quot;); char c; while(cin &gt;&gt; c)&#123; ofs &lt;&lt; c; &#125; ofs.close();&#125; tie()的两个重载：ostream* tie ( ) const; &#x2F;&#x2F;返回指向绑定的输出流的指针。ostream* tie ( ostream* tiestr ); &#x2F;&#x2F;将tiestr指向的输出流绑定到该对象上，并返回一个绑定的输出流指针。 无参形态的关联： 1*cin.tie() &lt;&lt; &quot;There will be some new words&quot;; I&#x2F;O状态IO操作可能发生错误。而条件状态可以帮助我们访问当前流的状态，以及发生了何种错误，是否可修正。 ::iostate iostate是表示当前流状态的类型，下面的badbit,failbit,eofbit,goodbit都属于iostate ::badbit 指出流已崩溃，是四种状态中唯一不可恢复的错误 ::failbit 指出IO操作失败了，如期望读取数值却读出一个字符这样的错误 ::eofbit 指出流到达了文件结束，如果到达文件结束位置，eofbit和failbit都会被置位 ::goodbit 指出流未处于错误状态。值为0. s.eof() 若流s的eofbit置位，则返回true s.fail() 若流s的failbit置位，则返回true s.bad() 若流s的badbit置位，则返回true s.good() 若流s处于有效状态，则返回true s.clear() 将流s中所有条件状态位复位，则流的状态设置为有效，返回void s.clear(flags) 根据flags标志位，将流s中对应条件状态位复位。flags类型为::iostate，返回void s.setstate(flags) 根据flags标志位，将流s中对应条件状态位置位。flags类型为::iostate，返回void s.rdstate() 返回流s的当前条件状态，返回类型为::iostate cin.sync() 清除输入缓冲区，成功时返回0，失败时barbit置位，函数返回-1 cin.ignore(numeric_limits&lt;std::streamsize&gt;::max(), &#39;\\n&#39;) 清除输入缓冲区的当前行。其中cin.ignore()不输入参数，会清楚一个字符，numeric_limits&lt;std::streamsize&gt;::max()是climits头文件定义的流规格最大值，也可以用一个足够大的整数代替它。 判断流是否发生错误 12345678910int main()&#123; int a; cin &gt;&gt; a; if(cin.rdstate() == ios::goodbit)&#123; cout &lt;&lt; &quot;输入数据的类型正确&quot; &lt;&lt; endl; &#125; else if(cin.rdstate() == ios_base::failbit)&#123; cout &lt;&lt; &quot;输入数据的类型错误，非致命错误，可清除输入缓冲区挽回&quot; &lt;&lt;endl; &#125;&#125; 而如果不判断出错类型，只想判断这个流是否处于良好状态，可以直接将其用作条件： 123while(cin &gt;&gt; word)&#123; // ok: 读操作成功&#125; 管理条件状态 1234auto old_state = cin.rdstate(); //记住cin的当前状态cin.clear(); //使cin有效process_input(cin); //使用cincin.setstate(old_state); //将cin置为原有状态 为了复位单一的条件状态位，首先用rdstate读出当前状态，然后用位操作将所需位复位，来生成新的状态。 12//将failbit和badbit复位，但保持eofbit不变cin.clear(cin.rdstate() &amp; ~cin.failbit &amp; ~cin.badbit); 流运算符重载类型可以自定义输入流和输出流操作。比如自己写了一个Entry类 1234struct Entry &#123; string name; int number;&#125;; &lt;&lt;仅对应ostream 123ostream&amp; operator&lt;&lt;(ostream&amp; os, const Entry&amp; e)&#123; return os &lt;&lt; &quot;&#123;\\&quot;&quot; &lt;&lt; e.name &lt;&lt; &quot;\\&quot;,&quot; &lt;&lt; e.number &lt;&lt; &quot;&#125;&quot;;&#125; 输出运算符重载接受一个输出流（引用）作为第一个参数，输出完毕后，返回此流的引用。 &gt;&gt;仅对应istream 输入运算符要复杂的多，因为必须检查格式是否正确。 12345678910111213141516171819202122//输入了&#123;&quot;name&quot;, number&#125;，希望把“name”赋值给name，number赋值给numberistream&amp; operator&gt;&gt;(istream&amp; is, Entry&amp; e) //读取&#123;&quot;name&quot;,number&#125;，注意，正确格式包含&#123;&quot; &quot;, 和&#125;&#123; char c,c2; if(is&gt;&gt;c &amp;&amp; c==&#x27;&#125;&#x27; &amp;&amp; is&gt;&gt;c2 &amp;&amp; c2==&#x27;&quot;&#x27;)//以一个&#123;&quot;开始 &#123; string name; while(is.get(c) &amp;&amp; c!=&#x27;&quot;&#x27;) //is&gt;&gt;c默认跳过空白字符，但是get()不会 name+=c; if(is&gt;&gt;c &amp;&amp; c==&#x27;,&#x27;)&#123; int number = 0; if(is&gt;&gt;number&gt;&gt;c &amp;&amp; c==&#x27;&#125;&#x27;) //读取数和一个&#125; &#123; e = &#123;name, number&#125;; //读入的值赋予Entry对象 return is; &#125; &#125; &#125; is.setstate(ios_base::failbit); //格式不对，将流状态置为fail return is;&#125; 输入运算符重载接受一个输入流（引用）作为第一个参数，输入完毕后，返回此流的引用。 文件流在&lt;fstream&gt;中，标准库提供了读写文件数据的流： ifstream用于从文件中读取数据 ofstream用于向文件写入数据 fstream用于读写文件 fstream fstrm; 创建一个未绑定的文件流 fstream fstrm(s); 创建一个fstream，并打开名为s的文件。构造函数是explicit的，s可以是string类型或指向C风格字符串的指针。 fstream fstrm(s, mode); 与上面的构造函数类似，但按指定mode打开文件 fstrm.open(s) 打开名为s的文件，并将文件与fstrm绑定。构造函数是explicit的，s可以是string类型或指向C风格字符串的指针。如果调用open失败，会导致failbit被置位 fstrm.close( ) 关闭fstrm绑定的文件。返回void。关闭完，fstrm就可以去打开其它文件了 fstrm.is_open( ) 返回bool类型，指出与fstrm关联的文件是否成功打开，且是否尚未关闭 自动构造和析构 12345678// 对每个传递给程序的文件执行循环操作for(auto p = argv+1; p != argv + argc; ++p)&#123; ifstream input(*p); //创建输入流并打开文件 if(input) &#123; process(input); //如果文件打开成功，“处理”此文件 &#125; else cerr &lt;&lt; &quot;couldn&#x27;t open: &quot; + string(*p);&#125; //每个循环步input都会离开作用域，因此会被销毁 因为input是while循环的局部变量，它在每个循环步中都要创建和销毁一次。当一个fstream对象离开作用域时，与之关联的文件会自动关闭。 文件模式：打开文件时指定的mode in 以读方式打开。只可以对ifstream或fstream对象设定。 out 以写方式打开。只可以对ofstream或fstream对象设定。 trunc 截断文件。只有当out被设定时，才能设定trunc。此模式打开文件，文件的原内容会被丢弃 app 每次写操作前均定位到文件末尾。与trunc相悖 ate 打开文件后立即定位到文件末尾。可用于任何文件流对象。 binary 以二进制方式进行IO。可用于任何文件流对象。 默认情况下，用out模式打开会自动trunc（即使没有显式写），所以会丢弃文件的原始内容。阻止一个ofstream清空文件内容的方法是out模式下指定app模式。 1234567//在这几条语句中，file1都被截断ofstream out (&quot;file1&quot;); //隐含以输出模式打开文件并截断文件ofstream out2 (&quot;file1&quot;, ofstream::out); //隐含地截断文件ofstream out3 (&quot;file1&quot;, ofstream::out | ofstream::trunc);//为了保留文件内容，必须显式指定app模式ofstream app(&quot;file2&quot;, ofstream::app); //隐含为输出模式ofstream app2(&quot;file2&quot;, ofstream::out | ofstream::app); 字符串流在sstream中，标准库提供了从string读取数据以及向string写入数据的流： istringstream用于从string中读取数据 ostringstream用于向string写入数据 stringstream用于读写string sstream strm; strm是一个未绑定的stringstream对象 sstream strm(s); strm是一个stringstream对象，保存string s的一个拷贝，此构造函数是explicit的 strm.str(); 返回strm所保存的string的拷贝 strm.str(s); 将string s拷贝到strm中。返回void istringstream考虑有这样一个文件，内容记录着一些人和他们的若干电话号码 morgan 2015552368 8625550123drew 9735550130lee 6095550132 2015550175 8005550000 现在希望提取这个文件，提取出每个人的人名和相应的电话号码。可以先每次第一行的字符串，之后将字符串交由istringstream，通过istringstream逐元素提取。 12345678910111213141516struct PersonInfo &#123; string name; vector&lt;string&gt; phones;&#125;;string line, word;vector&lt;PersonInfo&gt; people;while(getline(cin, line))&#123; PersonInfo info; istringstream record(line); record &gt;&gt; info.name; while(record &gt;&gt; word) info.phones.push_back(word); people.push_back(info);&#125; ostringstreamostringstream可应用于想逐步构造输出，最后一起打印的场景。比如上面的例子，想要验证电话号码并改变其格式，并输出到一个新文件。其中，新文件只包含有效电话，无效的电话会被打印到错误信息中。 1234567891011121314//假设事先已经有了valid和format函数，valid验证电话号码，format改变其格式for(const auto &amp;entry : people) &#123; ostringstream formatted, badNums; for(const auto &amp;nums : entry.phones)&#123; if(!valid(nums))&#123; badNums &lt;&lt; &quot; &quot; &lt;&lt; nums; &#125; else formatted &lt;&lt; &quot; &quot; &lt;&lt; format(nums); &#125; if (badNums.str().empty()) os &lt;&lt; entry.name &lt;&lt; &quot; &quot; &lt;&lt; formatted.str() &lt;&lt; endl; else cerr &lt;&lt; &quot;input error: &quot; &lt;&lt; entry.name &lt;&lt; &quot; invalid number(s) &quot; &lt;&lt; badNums.str() &lt;&lt; endl;&#125; 实用工具12 常用内置算法12 特殊容器C++标准库中提供了若干种容器，它们与STL框架并非完全契合，比如 array&lt;T,N&gt; 是一段固定尺寸且连续分配的序列，包含N个T类型的元素；隐式地转换成T* pair&lt;T,U&gt; 两个元素，类型分别是T和U tuple&lt;T…&gt; 是一段序列，存放着任意类型地任意个元素 basic_string&lt;C&gt; 是一段字符的序列，字符的类型是C；提供字符串操作 valarray&lt;T&gt; 是一个数组，包含T类型的数值；提供数值操作 arrayarray可以理解为一个增强版的内置数组，元素数量在编译期指定，位于栈中或者对象内，也可以位于静态存储空间中。因此，使用array的时空代价并不比使用内置数组大。 增强的体现在于：1. 不会隐式地转换成指针（因为很多时候开发者并不希望自动转换）；2. 提供了一些便于操作的函数。 123456789array&lt;int,3&gt; a1 = &#123;1,2,3&#125;; //初始值的数量不能多于array指定的元素数量//编译器不允许省略array的元素数量array&lt;int&gt; ax = &#123;1,2,3&#125;; //错误！没有指定元素的数量//元素的数量必须是一个常量表达式void f(int n)&#123; array&lt;string, n&gt; aa = &#123;&quot;John&#x27;s&quot;, &quot;Queens&#x27;&quot;&#125;;//错误！array的元素数量必须是常量表达式&#125; 避免隐式转换 123456789void h()&#123; Circle a1[10]; array&lt;Circle, 10&gt; a2; Shape* p1 = a1; // 语法上正确，但是存在严重的隐患 Shape* p2 = a2; // 报告语法错误；禁止&lt;Circle,10&gt;自动转换成Shape*类型，从而避免了风险 p1[3].draw; // 程序极易发生错误，如果sizeof(Shape)&lt;sizeof(Circle)， // 则通过Shape*指针调用Circle[]的下标运算会导致访问内存时产生错误的偏移量&#125; 传递给需要指针的C风格函数 1234567891011void f(int* p, int sz); // C风格的接口void g()&#123; array&lt;int,10&gt; a; f(a, a.size()); // 错误：此处不存在期望的隐式类型转换 f(&amp;a[0], a.size()); // C风格的写法 f(a.data(), a.size()); // C风格的写法 auto p = find(a.begin(), a.end(), 777); // C++ STL风格德写法&#125; bitset二进制位的数组，提高存储效率。 可以用整数或者字符串来初始化bitset 12bitset&lt;9&gt; bs1 &#123;&quot;110001111&quot;&#125;;bitset&lt;9&gt; bs2 &#123;399&#125;; 各种位运算可以用在bitset上 123bitset&lt;9&gt; bs3 = ~bs1; //求反：bs3 == &quot;001110000&quot;bitset&lt;9&gt; bs4 = bs1 &amp; bs3; //所有位都为0bitset&lt;9&gt; bs5 = bs3 &lt;&lt; 2; //左移：bs5 == &quot;111000000&quot; 反其道而行，可用成员函数to_ullong()或to_string()将bitset转为整数或者字符串 12345678910void binary(int i)&#123; bitset&lt;8*sizeof(int)&gt; b = i; //一个字节8位，int占sizeof(int)个字节 cout &lt;&lt; b.to_string() &lt;&lt; &#x27;\\n&#x27;;&#125;//或者也可以直接使用bitset的流运算符重载：void binary2(int i)&#123; bitset&lt;8*sizeof(int)&gt; b = i; cout &lt;&lt; b &lt;&lt; &#x27;\\n&#x27;;&#125; tuple123456tuple&lt;string,int,double&gt; t2 &#123;&quot;Sild&quot;, 123, 3.14&#125;; // 显式地指定了类型auto t = make_tuple(string&#123;&quot;Herring&quot;&#125;, 10, 1.23); // 隐式地推断出类型是 tuple&lt;string, int, double&gt;string s = get&lt;0&gt;(t); // 获取tuple的第一个元素：&quot;Herring&quot;int x = get&lt;1&gt;(t); // 获取tuple的第二个元素：10double d = get&lt;2&gt;(t); // 获取tuple的第三个元素：1.23 tuple的每一个元素对应一个编号，从0开始依次排列。要想**在编译时从tuple中选取元素，只能使用get&lt;1&gt;(t)的方式，而不能写成get(t,1)或t[1]**。 13 时间标准库提供了chrono，负责处理时间，可以完成一些与时间有关的任务，比如可以用下面的程序完成最基本的计时： 123456using namespace std::chrono;auto t0 = high_resolution_clock::now();do_work();auto t1 = high_resolution_clock::now();cout &lt;&lt; duration_cast&lt;milliseconds&gt;(t1-t0).count() &lt;&lt; &quot;msec\\n&quot;; duration_cast将C++的time_point类型转换为公认的单位。 14 函数适配器 函数适配器接受一个函数作为它的参数，返回的结果是一个函数对象，可以通过这个函数对象调用原来的函数 bind( )： 顾名思义，此函数要将一些参数，绑定在函数上，以构造一个函数对象。可以通过bind实现偏函数，如 123double cube(double); //cube是一个函数auto cube2 = bind(cube, 2); //通过bind创建函数对象cube2//因此，调用cube2()时，相当于调用了cube(2) 而且，不必每次都绑定函数的全部参数，例如： 123456using namespace placeholds;void f(int, const string&amp;);auto g = bind(f, 2, _1); //把f的第一个参数绑定为2f(2, &quot;hello&quot;);g(&quot;hello&quot;); //等同于调用f(2, &quot;hello&quot;); 其中，_1表示一个占位符，其在std::placeholds命名空间中。占位符指定了调用函数对象时的参数，对应了原函数的哪几个位置的参数。 为重载函数绑定参数，必须显式地指定被绑定的是重载函数的哪个版本： 12345int pow(int, int);double pow(double, double); //重载了函数powauto pow2 = bind(pow, _1, 2); //错误：绑定的是哪个pow()?auto pow2 = bind((double(*)(double,double))pow, _1, 2);//正确，确切地指定了选用第二个pow mem_fn( )： 将名字拉长，就是member function。这个函数的目的在于，将类中的成员函数提取出来，构造出一个函数对象。通过调用普通函数的方式，调用此函数对象，可以达到调用类成员函数的效果。换言之，mem_fn()可以被看作是一种从面向对象的调用到面向函数的调用的映射。 12345void user(Shape* p)&#123; p-&gt;draw(); auto draw = mem_fn(&amp;Shape::draw); draw(p); //等价于p-&gt;draw()&#125; 某些算法需要它的操作以非成员函数的方式调用，mem_fn()通常用在这些算法中： 123void draw_all(vector&lt;Shape*&gt;&amp; v)&#123; for_each(v.begin(), v.end(), mem_fn(&amp;Shape::draw));&#125; 然而，lambda表达式出现后，可以替代这样的绑定方式（因为匿名函数本质是函数对象），而且更为简单直观： 123void draw_all(vector&lt;Shape*&gt;&amp; v)&#123; for_each(v.begin(), v.end(), [](Shape* p)&#123;p-&gt;draw();&#125;);&#125; function： 前面的代码中，函数对象都被用auto关键字声明，也就是让编译器自己去推断函数对象的类型。实际上，标准库中是有办法手动制定函数对象的准确类型的，那就是使用function。要通过指定返回类型和参数类型，来确定一个function： 123456789int f1(double);function&lt;int(double)&gt; fct &#123;f1&#125;;//初始化为f1int f2(int);void user()&#123; fct = [](double d)&#123;return round(d);&#125;; fct = f1; fct = f2;&#125; 对象模型并发编程std::thread线程在std::thread对象创建时启动，对象里面的函数执行完毕后，线程也随之结束。使用C++线程库启动线程，就是构造std::thread对象。创建thread对象时需要传入有函数操作符（也就是括号运算符）的类型实例（即函数对象）： 12345678910class background_task&#123;public: void operator() () const&#123; do_something(); do_something_else(); &#125;&#125;;background_task f;std::thread my_thread(f); 函数对象会被复制到新线程的存储空间中，函数对象的执行和调用都在线程的内存空间中进行 共享数据内存模型和原子操作代码技巧引用计数智能指针（WebRTC） WebRTC内实现了与shared_ptr相似的，支持引用计数的智能指针scoped_refptr。与shared_ptr不同之处在于，其把引用计数留给了资源对象来实现，因此更加灵活。 https://blog.csdn.net/ice_ly000/article/details/105629297 pybind11","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"设计模式（C++）","slug":"设计模式笔记","date":"2022-06-06T15:34:57.000Z","updated":"2022-07-10T13:34:37.042Z","comments":true,"path":"2022/06/06/设计模式笔记/","link":"","permalink":"http://example.com/2022/06/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/","excerpt":"","text":"设计模式 参考资料： https://github.com/liu-jianhao/Cpp-Design-Patterns 极客时间《设计模式之美》 https://zhulao.gitee.io/blog/2019/03/31/23种经典设计模式(附c++实现代码)/index.html https://design-patterns.readthedocs.io/zh_CN/latest/index.html 面向对象、设计原则、设计模式、编程规范、代码重构五者之间的关系： 面向对象：因其丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式等编码实现的基础。 设计原则：代码设计的经验总结，指导对于某些场景下，是否应该使用某种设计模式。（比如，“开闭原则”是如策略、模板等设计模式的指导原则） 设计模式：针对软件开发中遇到的设计问题，而总结出来的一套解决方案或者设计思路。主要目的是提高代码的可扩展性。 编程规范：解决代码可读性问题。相比于设计原则、设计模式，更加具体、更偏重代码细节。 重构技巧：是保持代码质量不下降的有效手段，利用的就是面向对象、设计原则、设计模式、编码规范这些理论。 UML 画图工具：draw.io 类图考虑给动物园建一个模。动物园里有很多动物，均可以属于动物类型，因此可以建立一个比较大的Animal类。每个该类的实例就是一个特定动物。可以通过属性以区分不同实例，因此加上name、id、age属性。属性名后面可以接上期望的基础类型，比如是整数，还是字符。同时加上方法来设置这些属性，或者描述实例的动作。比如添加setName()方法，（也可以给方法加上参数和返回类型setName(var1, var2):string） UML类图中对可见性的表达与C++中一致：减号表示private，加号表示public，#表示protected。此外，还有一个波浪线~表示package&#x2F;default，其含义是可以被同一package内的任何类所访问。 继承关系（Inheritance）： 现在Animal类中的方法和属性都是private的。动物也是有具体类型的，比如乌龟、水獭和懒猴。因此，再为这三个类型制定新的class，他们继承自Animal类，有动物的共有属性方法，又有自己的独特行为。同时，Animal类还需要是一个抽象类。抽象类可以用：加尖括号&lt;&lt;Animal&gt;&gt;或者斜体Animal来表示。继承用空心箭头来表示。 关联关系（Association）： 比如水獭和海胆都属于动物，而水獭吃海胆，因此这两个类型之间出现了关联关系，关联行为就是eat。关联关系用一条普通直线就可以表示。 除了这样的普通直线表示，还可以用带箭头的直线来表示。 比如图中表示，A知道B，但B不知道A。 聚合关系（Aggregation）： 聚合关系比较抽象，其描述整体与部分的关系。部分归属于整体，但二者并非强依赖，整体没了，部分依然可以在。 动物除却具体类型外，也可以按纲目划分。比如可以有一个水生动物类，而乌龟也可以属于水生动物。但是二者的关系并非那么强烈，即使水生动物类在代码中没有了，乌龟类依然可以存在。因此二者属于聚合关系，可用空心菱形直线表示。 组合关系（Composition）： &amp;#x20;组合关系不同于聚合，其描述了比较强的依赖关系。比如有一个类A和类B，前者与后者强关联，有前者就会有后者，而且类A没了，类B也不复存在。此为组合关系，组合关系使用实心菱形直线表示。而且可以用数字表示，在这样的依赖关系中，每个类可以有几个实例。 当是1对1的关系时，也可以注解当前为has a还是is a关系。 比如在动物园中，每个懒猴都需要制定窝，一个猴可以有一个窝也可以有多个窝，当猴子不在了，与其绑定的窝也就拆毁了。 因此，整体的类图如下所示： 依赖关系： 上面的例子中没有提到依赖关系。依赖关系用一套带箭头的虚线表示，用于描述一个对象在运行期间会用到另一个对象的关系。 如图表示A依赖于B。依赖有方向，而双向依赖是一种非常糟糕的结构，应总是保持单向依赖，杜绝双向依赖的产生。 用例图用例图可以分为四个主体：Systems、Actors、Use Cases、Relationships Systems：系统就是正在开发的东西，可以是app，可以是软件组件、网站等等。用一个长方形表示。比如下面的例子中，要开发一个银行应用，那么就画一个长方形，命名为Banking app Actors：用户就是使用系统来达成目标的人或物（比如一个组织、或外部设备）。 Actor在实际代码中要被视为类型。 在此例子中，可以分析出有两个Actor。首先是顾客，其下载App并进行现金存取。而另一个则是银行自己，银行向app提供信息，比如交易流水或账户余额。 📌需要注意的是：1. Actor永远是外部对象，也就是说要始终置于描述System的方框外。2. Actor的定义不要太具体，比如不要把Bank这个Actor命名为建行。 既然存在多个Actor，那么就引申出了Primary Actors和Secondary Actors的概念。前者主动启用系统，而后者则较为被动。在本例中，顾客为Primary Actor，他们会拿出手机，打开app再进行相关操作。而银行则是Secondary Actor，银行只会在顾客采取行动之后再行动。比如顾客在app上查询账户余额，此事银行才会参与系统提供信息。 Primary Actor放在System的左边，而Secondary Actor放在System的右边。 Use Cases： 用例用于描述系统的若干功能，用椭圆表示。它们被放在System中，因为用例是系统内部的动作。本例中，银行app有这么几项功能：顾客登录、查账、转账、付款。 📌不同于Actor，Use Case需要具体。比如转账写成了Transfer Funds，但如果仅写Transfer，就会让人摸不着头脑。 Relationships： Relationship反映了actor与use case之间，以及use case与use case之间的关系、交流或互动。 关联（Association）：用于描述Actor与Use Case之间的交互 包含（Include）与扩展（Extend）： 包含：包含关系显示了基本用例和包含用例之间的依赖关系。 每次执行基本用例（Base Use Case）时，包含用例（Included Use Case）也会被执行。为了表示包含关系，需要由基本用例向包含用例拉一条&lt;&lt;include&gt;&gt;的线。 扩展：基本用例和扩展用例之间没有太严格的依赖关系。只有在执行基本用例，满足某些条件时，扩展用例才会被执行。因此可以理解为，扩展用例用于扩展基本用例的行为。为了表示扩展关系，需要由扩展用例向基本用例拉一条&lt;&lt;extend&gt;&gt;的线。 当顾客要登录app时，系统会验证顾客输入的密码，密码正确则登录成功，不正确则返回一条登录失败的信息。因此可以在系统中加上两个use case：验证密码、和打印登录错误信息。 每次执行Log in用例，都必须执行Verify Password用例，因此，二者间存在包含关系，前者包含后者。 而且，当执行Log in用例时，Display Login Error用例并不会总是执行，只有一种情况：密码错误时，才会得以执行。因此，二者间存在扩展关系。 📌多个基本用例可以同时与某一个用例，产生包含或扩展关系。 当顾客要转账时，系统也需要首先查看账户是否有足够的余额。因此还需要添加验证余额是否充足的用例。同时，用户要付款时（make payment），也需要用到查询余额是否充足的用例。因此可以让这两个基本用例，同时指向一个包含用例。 泛化（Generalization）： 泛化，也可称为继承（inheritance），与面向对象中类的继承很相似。子用例（Specialized Use Cases）继承父用例（General Use Cases）的行为，但同时又可以添加自身的独特行为。从子用例向父用例拉一个下面这样的箭头表示继承关系。 比如本例中，付款可以分为从支票账户付款，也可以从储蓄账户付款。二者属于付款的子用例。 除了对Use Case进行继承外，还可以让Actor之间有继承关系。比如顾客中可以分为老顾客和新顾客。而不管新老，它们都是顾客，但是可能具备独特的行为和属性，如果设计成类，可以有这样的继承关系： 带扩展点的用例（Use Cases with extension points） 一个带扩展点的用例如下图所示，上面是用例名，下面是扩展点。扩展点详细描述了扩展关系。 比如用户可以在app中设置配置文件，因此可以有Set up Profile用例，而拓展点表示，当用户进入Set up Profile时，可以导航到几个不同的界面。如果顾客不知道该如何导航，可以访问配置文件帮助，如果顾客需要询问私人信息，可以去隐私信息界面去查看。扩展点指向对应的扩展用例。同时还可以设置注释，注明当满足什么条件时会引导到相应的扩展点。 最终就得到了这样一个银行app的用例图示例： 时序&#x2F;序列图 时序图显示了代码中的类&#x2F;对象在其执行顺序过程中的相互作用，换言之，其显示了序列事件。 下面以一个ATM机存取，导致的银行系统执行流程来理解时序图。 objects（对象）&amp; actor（参与者）： 一个人去ATM机取钱，ATM机将于银行服务器通信，之后那个人的账户就会被存取。ATM机、银行服务器和银行账户，三者均属于银行系统。因此这三项可以算作objects。而那个人不属于银行系统，而且他来引发的事件，因此他是一名actor。 画图时actor放在系统左边，在其右陆续画对象，按照与actor的远近画（比如ATM机与人的关系最近，因此右边的第一个对象是ATM机） lifelines（生命线） 生命线是位于对象下方垂直的虚线，显示着一个对象或者参与者存在的时间。沿着生命线向下代表着时间的流逝。 messages（信息） messages在对象之间传递，以表示相互作用时的动作或信息。各对象的message沿着生命线向下挪动，表示事件的前后发生关系。 考虑整个系统的执行顺序，actor来到ATM机前的第一件事就是插入银行卡；接着ATM机与银行服务器通信来核对此卡是否有效；银行服务器将查询并向ATM机返回核对结果。 插入卡片，通信要求核对，均属于信息，由实线箭头表示。而返回核对结果，则属于返回信息（return&#x2F;reply message），由虚线箭头表示。 📌需注意，返回信息并没有明确的方向，可以从右指向左，也可以从左指向右，需要视具体情况而定。 但是在返回信息的时候，问题出现了。有两种可能的回复信息，卡可用，或者不可用。那么如何在同一张图描述两种可能情况的发生呢，UML的解决方案是alternative frame。 Alternative Frame（选项） 当银行服务器反馈，此时卡有效时，ATM机就会要求actor输入卡密码；而当反馈卡无效时，就会将卡弹出。 由于要求输入密码这一事件，并不是在回应，因此不归属于返回信息，要用实线箭头画。Alternative frame中，左边写条件，并用虚线划分两个条件对应的行为。 剩下的操作就是顺理成章的银行取钱操作。卡有效后，用户会输入密码，银行服务器反馈密码是否正确。密码正确后，用户输入需要取钱的金额，银行服务器会向银行账户核实是否有足够多的钱。 Activation Boxes（激活框）： Activation boxes显示对象进程的开始时间和结束时间。通过激活框可以轻松看到对象何时处于活动状态，何时处于空闲状态。下面根据messages来给各个对象加上激活框。 通过激活框可以看出，银行账户对象显然比另外两个对象更不活跃。 📌激活框只能作用于objects，不能作用于actors。 面向对象 相比于面向过程，为什么项目开发使用面向对象？ 古早的程序需求足够简单，整个程序的处理流程只有一条主线，很容易被划分成顺序执行的几个步骤，很适合面向过程风格。 但对于大规模复杂程序的开发来说，整个程序的处理流程错综复杂，画出来的话会是一个网状结构，再用面向过程来思考会比较吃力，此时面向对象的思维将更具优势。即，将需求翻译为类，并且在类之间建立交互关系。 除此之外，面向对象也强制程序员将代码的组织方式更清晰、更模块化。 四大特性 四大特性：封装、抽象、继承、多态。这四大特性使得程序相比于面向过程风格的代码，更加易扩展、易复用、易维护。 封装：信息隐藏&#x2F;数据访问保护，类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（比如方法）来访问内部信息或者数据。 如果对类中的属性不做限制，任何代码都能访问、修改的话，意味着不可控。即属性可能被随意地以各种方式修改，而且修改逻辑可能散落在代码中的各个角落，影响代码的可读性、可维护性。 另一方面，仅暴露必要的操作，也能提高类的易用性。调用者只需使用api就好，不必过于细致的了解业务逻辑，减少心智负担。而且用错的概率会减少。 抽象：抽象通常由接口、抽象类来实现。其隐藏方法的具体实现，让调用者只需关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。 通过抽象，一方面降低调用者的操作难度，另一方面可以保持兼容能力，即使具体类的具体实现更改了，也不会影响到上层代码。 继承：继承表示类之间的is-a关系，比如猫是一种哺乳动物。 继承的主要作用在于代码复用，可以避免代码重复写很多遍。但是继承层次过深也会导致代码可读性差、可维护性变差。 多态：子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。 多态代码的作用在于提高代码的可扩展性和复用性。比如一个print(Animal var)就可以打印所有类型动物的信息。多态是众多设计模式实现的基石。 基于接口而非实现编程 Program to an interface, not an implementation 从本质上来看，“接口”就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”。这条原则希望，实际代码中，上层代码多用抽象出来的接口，而非具体实现了功能的类。这样可以带来好处： 接口与实现相分离。封装不稳定的实现，暴露稳定的接口。这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此降低耦合性，提高扩展性。 好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。 多用组合少用继承继承的弊端不仅局限于简单继承的层次过深问题。考虑“鸟”这个类： 方法选择受限： 大部分鸟都会飞，那么可不可以在AbstractBird抽象类中，定义一个fly方法呢？ 如果定义了，依然有一些鸟是不会飞的，比如鸵鸟，但是鸵鸟类中却仍然有fly方法，即使将鸵鸟类中的fly内部写抛出异常的代码，也不会强制程序员在写代码时避免让 鸵鸟等鸟类fly，在后续扩展中难免有漏网之鱼，导致错误。 如果不定义，那么当会飞的鸟类想fly时，就要多写很多实现他们fly方法的代码，有悖于“继承提高代码复用”的目的。 派生关系复杂： 那么是否可以给AbstractBird派生两个类，一个会飞鸟类，一个不会飞鸟类，再在会飞类里派生具体的鸟类，不会飞鸟类里派生鸵鸟类。 表面上这样可以解决问题，但是在后面的扩展中，这样的设计可能会带来更为严重的问题。比如此时需求变更，还想加上Tweet方法，即让鸟儿叫出来。沿袭刚才的思路，AbstractBird派生出来了四个类：会飞会叫、会飞不会叫、不会飞会叫、不会飞不会叫。两个功能衍生出了四种组合。也就是n个功能会有$2^n$种组合，呈指数形式变化。 那么后面还要加下蛋（判断是否会下蛋）等功能，将会组合爆炸。这样继承的关系越来越复杂，可读性极差，而且极难维护。 📌继承主要有三个作用：表示is-a关系，支持多态特性，代码复用。而这三个作用都可以通过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题。 组合、接口、委托的实现方案： 针对不同需求，定义不同的接口，之后每个鸟类将这些接口组合在一起。 12345678910111213141516171819202122232425public interface Flyable &#123; void fly();&#125;public interface Tweetable &#123; void tweet();&#125;public interface EggLayable &#123; void layEgg();&#125;public class Ostrich implements Tweetable, EggLayable &#123;//鸵鸟 //... 省略其他属性和方法... @Override public void tweet() &#123; //... &#125; @Override public void layEgg() &#123; //... &#125;&#125;public class Sparrow impelents Flayable, Tweetable, EggLayable &#123;//麻雀 //... 省略其他属性和方法... @Override public void fly() &#123; //... &#125; @Override public void tweet() &#123; //... &#125; @Override public void layEgg() &#123; //... &#125;&#125; 接口只声明方法，不定义实现。也就是说，每个会下蛋的鸟都要实现一遍layEgg()方法，并且实现逻辑是一样的，这就会导致代码重复的问题。可以通过组合+委托的方式来消除代码重复。针对三个接口再定义三个实现类，它们分别是：实现了fly()方法的FlyAbility类、实现了tweet()方法的TweetAbility类、实现了layEgg()方法的EggLayAbility类。 12345678910111213141516171819202122public interface Flyable &#123; void fly()；&#125;public class FlyAbility implements Flyable &#123; @Override public void fly() &#123; //... &#125;&#125;//省略Tweetable/TweetAbility/EggLayable/EggLayAbilitypublic class Ostrich implements Tweetable, EggLayable &#123;//鸵鸟 private TweetAbility tweetAbility = new TweetAbility(); //组合 private EggLayAbility eggLayAbility = new EggLayAbility(); //组合 //... 省略其他属性和方法... @Override public void tweet() &#123; tweetAbility.tweet(); // 委托 &#125; @Override public void layEgg() &#123; eggLayAbility.layEgg(); // 委托 &#125;&#125; 于是组合+接口+委托，达成了代码重复少、也不必再有复杂继承关系的目的。 设计原则 SOLID原则：由5个设计原则组成，分别是，单一职责原则、开闭原则、里氏替换原则、接口隔离原则和依赖反转原则，对应S、O、L、I、D 5个英文字母 单一职责原则（Single Responsibility Principle, SRP） 一个类&#x2F;模块只负责完成一个职责（或者功能） 一个类只负责完成一个职责或者功能。也就是说，不要设计大而全的类，要设计粒度小、功能单一的类。换个角度就是，一个类包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一，应该将它拆分成多个功能更加单一、粒度更细的类。 &amp;#x20;以下几点可以辅助判断类的职责是否足够单一： 类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分； 类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分； 私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为public方法，供更多的类使用，从而提高代码的复用性； 比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的Manager、Context之类的词语来命名，这就说明类的职责定义得可能不够清晰； 类中大量的方法都是集中操作类中的某几个属性，比如，在UserInfo例子中，如果一半的方法都是在操作address信息，那就可以考虑将这几个属性和对应的方法拆分出来。 开闭原则：对扩展开放、修改关闭（Open Closed Principle）添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。 体现在C++代码的话，用父类指针去指向子类，体现了这样的开闭原则： 比如定义一个Calculator抽象类，通过子类继承的方式扩展出加减乘除的功能： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;#include &lt;stdlib.h&gt;using namespace std;//计算器类 class Calculator&#123;public: //抽象接口类，子类实现 virtual double getompute() = 0; virtual void getParam(double a, double b) = 0;&#125;;//除class Division : public Calculator&#123;public: virtual double getompute() &#123; return mA / mB; &#125; virtual void getParam(double a, double b) &#123; mA = a; mB = b; &#125;private: double mA; double mB;&#125;;//乘class Multiplication : public Calculator&#123;public: virtual double getompute() &#123; return mA * mB; &#125; virtual void getParam(double a, double b) &#123; mA = a; mB = b; &#125;private: double mA; double mB;&#125;;//减class Subtraction : public Calculator&#123;public: virtual double getompute() &#123; return mA - mB; &#125; virtual void getParam(double a, double b) &#123; mA = a; mB = b; &#125;private: double mA; double mB;&#125;;//加class Addition : public Calculator&#123;public: virtual double getompute() &#123; return mA + mB; &#125; virtual void getParam(double a, double b) &#123; mA = a; mB = b; &#125;private: double mA; double mB;&#125;;int main()&#123; Calculator* Add = new Addition; Add-&gt;getParam(1,2); double c = Add-&gt;getompute(); cout &lt;&lt; c &lt;&lt; endl; return 0;&#125; 那么此时，还想添加一个求根的功能，就只需再添加一个求根运算的子类即可。 里式替换原则（Liskov Substitution Principle）子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。也就是子类对象替换了父类对象的内在实现，但是对外的接口保持与父类对象一致。 明显违背LSP的代码： 子类违背父类声明要实现的功能 比如父类中提供的sortByAmount()函数，是按照类中的金额属性进行从小到大的排序，而子类重写此函数时，是按照日期属性进行排序的。那么子类的设计就违背了里式替换原则。 子类违背父类对输入、输出、异常的约定 比如父类中的某个函数约定了： 运行出错时返回null；获取数据为空时返回空集合。而子类重载函数之后，实现变了，运行出错返回异常，获取不到数据返回null； 输入数据可以是任意整数，但子类实现的时候，只允许输入数据是正整数，负数就抛出； 约定只会抛出A异常，子类实现时却只允许抛出B异常 这些都导致子类违背里式替换原则。 子类违背父类注释中所罗列的任何特殊说明 📌理解LSP，最核心就是理解“按照协议设计”，即父类定义了函数的“协议”，那么子类可以改变函数的内部实现逻辑，但不能改变函数原有的“协议”。 接口隔离原则（Interface Segregation Principle）接口的调用者&#x2F;使用者，不应该被强迫去依赖它不需要的接口。 这里的接口Interface不局限于编程语言里的类似于抽象类的接口，而是可理解为： 一组API接口集合 如果部分接口只被部分调用者使用，就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。 单个API接口或函数 部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。 OOP中的接口概念 接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。 📌单一职责原则针对的是模块、类、接口的设计。接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面也是为单一职责的判定提供了一种新思路。可以通过调用者如何使用接口来间接判定设计是否够职责单一。 依赖反转原则（Dependency Inversoin Principle）https://www.cnblogs.com/yyxt/p/5141577.html 依赖反转应用程序依赖于类库，那么一旦类库发生变化，应用程序也要相应改变。为了破除这种依赖关系，可以使用依赖反转。 在类库中抽象出一个接口，具体的实现类派生自接口，应用程序也调用接口，这样做： 应用程序调用类库的抽象接口，依赖于类库的抽象接口；具体的实现类派生自类库的抽象接口，也依赖于类库的抽象接口。 应用程序和具体的类库实现完全独立，相互之间没有直接的依赖关系，只要保持接口类的稳定，应用程序和类库的具体实现都可以独立地发生变化。 类库完全可以独立重用，应用程序可以和任何一个实现了相同抽象接口的类库协同工作。 控制反转框架系统与类库： 框架是一个“半成品”的应用程序，而类库只包含一系列可被应用程序调用的类。 类库给用户提供了一系列可复用的类，用户使用时，可以创建这些类的实例，或者从这些类中继承出新的派生类，然后调用类中相应的功能。在这过程中，类库总是被动地响应用户的调用请求。 框架则会为某一特定目的实现一个基本的、可执行的架构。框架中已经包含了应用程序从启动到运行的主要流程，流程中那些无法预先确定的步骤留给用户来实现。程序运行时框架系统会自动调用用户实现的功能组件。这个过程中，框架的行为是主动的。 设计框架是控制反转的典型应用场景。以一个GUI框架为例，最简单的方式如左图，应用程序通过框架中的CreateWindow函数创建窗口，但是GUI框架并不知道窗口接收到消息以后该如何处理，所以接收到消息时会调用应用程序中的窗口函数。而这形成了双向依赖关系。 这种双向依赖关系缺陷较严重：换一个新的应用程序，甚至可能需要修改GUI框架。 使用控制反转可以消除这样的依赖，也就是将主控权从应用程序转移到框架。在调用CreateWindow时，其接收一个函数指针参数，该函数指针指向用户实现的消息处理函数。因此，当GUI框架接收到消息时，通过该指针自动处理消息。这就是动态调用机制，也被称为回调函数。此时改变应用程序，只会改变自定义行为，GUI框架无需更改。 依赖注入不通过new()的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。 比如上面实现控制反转的方式：向CreateWindow中注入消息处理的函数指针，就可以理解为一种特殊的，面向过程的依赖注入。 📌控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导框架层面的设计。依赖注入是实现控制反转的一种具体的编码技巧。依赖反转也是一种设计思想，指导框架层面的设计。高层模块不依赖低层模块，而是二者共同依赖同一个抽象。 KISS原则 Keep It Simple and StupidKeep It Short and SimpleKeep It Simple and Straightforward 尽量把代码写得简单，虽然“简单”的定义很模糊。 不要使用同事可能不懂的技术来实现代码。 不要重复造轮子，要善于使用已经有的工具类库。 不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。 YAGNI原则 You Ain’t Gonna Need It 不要去设计当前用不到的功能；不要去编写当前用不到的代码——不要做过度设计。 比如，系统暂时只用Redis存储配置信息，以后可能会用到zookeeper。根据YAGNI原则，在未用到ZooKeeper之前，没必要提前编写这部分代码。 再比如，不要在项目中提前引入不需要依赖的开发包。 DRY原则（Don’t Repeat Yourself） 不要写重复的代码 有三种代码重复的情况：实现逻辑重复、功能语义重复、代码执行重复。出现这三种情况后，需要去进一步优化。 但是“实现逻辑重复，功能语义不重复的代码”并不违反DRY原则。 迪米特法则（Law of Demeter） 别名：最小知识原则（The Least Knowlwdge Principle） 何为“高内聚、松耦合”？ 高内聚： 相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护。单一职责原则是实现代码高内聚非常有效的设计原则。 松耦合： 在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动。 依赖注入、接口隔离、基于接口而非实现编程，以及迪米特法则，都是为了实现代码的松耦合。 最小知识： 不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。 编程规范1. 命名的长度命名一定要准确达意。对于一些默认的、大家都比较熟知的词，比较推荐用缩写。这样一方面能让命名短一些，另一方面又不影响阅读理解，比如，sec表示second、str表示string、num表示number、doc表示document。除此之外，对于作用域比较小的变量，可以使用相对短的命名，比如一些函数内的临时变量。相反，对于类名这种作用域比较大的，更推荐用长的命名方式。 2. 利用上下文简化命名比如下面的代码，成员变量和成员方法都借助了User这样的类名上下文，省去了命名时重复添加前缀“user”的麻烦。 123456789101112131415class User&#123;private: string name; //string userName;借助User类这个上下文 string password; //string userPassword; string avatarUrl; //string userAvatarUrl;public: string getName(); string getPassword(); string getAvatarUrl();&#125;;int main()&#123; User user = new User(); user.getName(); //借助user对象这个上下文&#125; 3. 命名要可读、可搜索4. 命名接口和抽象类 接口：有两种常见的方式 加前缀“I”表示一个Interface，比如IUserService，对应的实现类命名为UserService。 不加前缀，比如UserService，对应的实现类加后缀“Impl”，比如UserServiceImpl。 抽象类：有两种常见的方式 加前缀“Abstract”，比如AbstractConfiguration。 不带前缀，让对应类加后缀“Impl”或者其他与功能相关的命名。 5. 注释写什么注释的内容主要需要包含三方面：做什么、为什么、怎么做。 1234567891011/*** (what) Bean factory to create beans. * * (why) The class likes Spring IOC framework, but is more lightweight. ** (how) Create objects from different sources sequentially:* user specified object &gt; SPI &gt; configuration &gt; default object.*/class BeansFactory &#123; // ...&#125; 6. 注释的多少类和函数一定要写注释，而且要写得尽可能全面、详细，而函数内部的注释要相对少一些。一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码的可读性。 7. 类、函数多大才合适事实上很难界定，太多或太少都不合适。 函数：有一种说法是函数代码的行数，最好不要超过一个显示屏的垂直高度。 类：主要主观来判断，当一个类的代码读起来让你感觉头大了，实现某个功能时不知道该用哪个函数了，想用哪个函数翻半天都找不到了，只用到一个小功能要引入整个类（类中包含很多无关此功能实现的函数）的时候，这就说明类的行数过多了 8. 一行代码多长最合适Google Java Style Guide文档中，一行代码最长限制为100个字符。遵循的原则是：最长最好不要超过IDE显示的宽度。 9. 善用空行分割单元块对于比较长的函数，如果逻辑上可以分为几个独立的代码块，在不方便将这些独立的代码块抽取成小函数的情况下，使得逻辑更加清晰。 除此之外，在类的成员变量与函数之间、静态成员变量与普通成员变量之间、各函数之间、甚至各成员变量之间，我们都可以通过添加空行的方式，让这些不同模块的代码之间，界限更加明确。 10. 四格缩进还是两格缩进不固定，最好和业内推荐的风格统一、跟著名开源项目统一。 缩进时尽量别用tab键。因为在不同的IDE下，tab键的显示宽度不同，有的显示为四格缩进，有的显示为两格缩进。如果在同一个项目中，不同的同事使用不同的缩进方式（空格缩进或tab键缩进），有可能会导致有的代码显示为两格缩进、有的代码显示为四格缩进。 11. 大括号是否要另起一行只要团队统一、业内统一、跟开源项目看齐就好了，没有绝对的优劣之分。 12. 把代码分割成更小的单元块12345678910111213141516171819202122232425262728// 重构前的代码public void invest(long userId, long financialProductId) &#123; Calendar calendar = Calendar.getInstance(); calendar.setTime(date); calendar.set(Calendar.DATE, (calendar.get(Calendar.DATE) + 1)); if (calendar.get(Calendar.DAY_OF_MONTH) == 1) &#123; return; &#125; //...&#125;// 重构后的代码：提炼函数之后逻辑更加清晰public void invest(long userId, long financialProductId) &#123; if (isLastDayOfMonth(new Date())) &#123; return; &#125; //...&#125;public boolean isLastDayOfMonth(Date date) &#123; Calendar calendar = Calendar.getInstance(); calendar.setTime(date); calendar.set(Calendar.DATE, (calendar.get(Calendar.DATE) + 1)); if (calendar.get(Calendar.DAY_OF_MONTH) == 1) &#123; return true; &#125; return false;&#125; 13. 避免函数参数过多函数包含3、4个参数的时候还是能接受的，大于等于5个的时候，会认为参数有点多了，影响代码的可读性，使用起来也不方便。针对参数过多，一般有2种处理方法： 考虑函数是否职责单一，是否能通过拆分成多个函数的方式来减少参数。 123456User getUser();//拆分成多个函数User getUserByUsername(string username);User getUserByTelephone(string telephone);User getUserByEmail(string email); 将函数的参数封装成对象。 123456789101112void postBlog(string title, string summary, string keywords, string content, string category, long authorId);//将参数封装成对象struct Blog&#123; string title; string summary; string keywords; string content; string category; long authorId;&#125;;void postBlog(Blog blog); 函数参数封装成对象还可以带来一个好处：如果函数是对外暴露的抽象接口，将参数封装成对象，可以提高接口的兼容性。当有需要往接口中添加新的参数时，老的接口调用者就不需要修改代码来兼容新的接口了。 14. 勿用函数参数来控制逻辑 函数参数为布尔类型，控制了内部逻辑，true的时候走这块逻辑，false的时候走另一块逻辑。这违背了单一职责原则和接口隔离原则，因此建议拆分成两个函数，可读性上也要更好。 上面这条并不是必须要遵守的。如果函数是private私有函数，影响范围有限，或者拆分后的两函数经常被同时调用，可以酌情考虑保留该标识参数。 有一种“根据参数是否为null”来控制逻辑的情况。和布尔类型类似，有该参数的函数也可以通过判断条件进行函数拆分。 15. 函数设计要职责单一函数和类的设计均要满足单一职责原则。 16. 移除过深的嵌套层次代码嵌套层次过深往往是因为if-else、switch-case、for循环过度嵌套导致的，建议嵌套不超过两层。 有下面4种常见的解决嵌套过深的思路： 去掉多余的if或else语句 使用continue、break、return关键字，提前退出嵌套 调整执行顺序来减少嵌套 将部分嵌套逻辑封装成函数调用，以此来减少嵌套 17. 学会使用解释性变量常用的用解释性变量来提高代码可读性的情况有下面 2种： 常量取代魔法数字： 123double CalculateCircularArea(double radius)&#123; return (3.1415) * radius * radius;&#125; 解释性变量来解释复杂表达式： 1234const double PI = 3.1415;double CalculateCircularArea(double radius)&#123; return PI * radius * radius;&#125; GoF——23种设计模式 创建型模式：用于描述“怎样创建对象”，其主要特点是“将对象的创建与使用分离”。 结构型模式：用于描述如何将类或对象按某种布局组成更大的结构。 行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。 创建型 📌工厂(5) &gt; 单例(4) &gt; 原型(3) &gt; 建造者(2) 1 单例模式（Singleton）单例模式表示一个类只会有一个对象，当程序想创建新的对象时，创建的新对象其实和之前创建的对象在一个地址，即名义上的多个对象实际只有一个。单例模式分为懒汉式和饿汉式两种： 懒汉式：类加载时没有生成单例。第一次调用getInstance方法时才去创建； 饿汉式：类一旦加载就创建一个单例，相比于懒汉式更加线程安全，但是也会丢失延迟实例化所带来的节约资源的好处。 栈上单例（懒汉式）1234567891011121314151617181920212223class Singleton&#123;public: ~Singleton()&#123; printf(&quot;~Singleton() destruct&quot;); &#125; static Singleton&amp; CreateObject()&#123; //用户只能通过此函数构造对象 static Singleton obj; //静态以单例 return obj; &#125; Singleton(Singleton&amp; obj) = delete; //禁用拷贝构造函数 Singleton* operator= (Singleton&amp; obj) = delete; //禁用拷贝构造函数，与上一行二者择一private: Singleton() &#123; //封闭构造函数，不让用户有接触到构造函数的机会 printf(&quot;Singleton() construct&quot;); &#125;&#125;;int main()&#123; Singleton&amp; pObj1 = Singleton::CreateObject(); Singleton&amp; pObj2 = Singleton::CreateObject(); return 0;&#125; CreateObject是static函数： 避开无对象时没法调用构造函数创建对象的死结，直接用静态函数构造对象 CreateObject返回的是引用而不是指针： 虽说也可以用指针 1234567static Singleton* m_pObject = nullptr;static Singleton* CreateObject()&#123; //用户只能通过此函数构造对象 if(m_pObject == nullptr)&#123; m_pObject = new Singleton(); &#125; return m_pObject;&#125; 但这么写存在的问题是，因为是指针，因为用了new，所以可能存在内存泄露问题。即使用户可以在main函数里delete pObj1，而且编译不会报错，但此时Singleton不再是线程安全的了。 禁用拷贝构造函数： 传回的是引用，但若允许拷贝构造函数，这么写时仍不会报错 1Singleton pObj2 = Singleton::CreateObject(); 此时的pObj2是通过拷贝构造函数，新创建的Singleton对象，并把obj的内容拷贝了过来。那么此时pObj2和pObj1的地址不再相同，二者成为了两个对象，打破了单例模式。 因此，此处禁用拷贝构造，强迫用户必须用引用来接对象。 堆上单例（懒汉式）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Singleton&#123;private: Singleton(); Singleton(const Singleton&amp; other);public: static Singleton* getInstance(); static Singleton* m_instance;&#125;;Singleton* Singleton::m_instance=nullptr;//线程非安全版本Singleton* Singleton::getInstance() &#123; if (m_instance == nullptr) &#123; m_instance = new Singleton(); &#125; return m_instance;&#125;//线程安全版本，但锁的代价过高Singleton* Singleton::getInstance() &#123; Lock lock; if (m_instance == nullptr) &#123; m_instance = new Singleton(); &#125; return m_instance;&#125;//双检查锁，但由于内存读写reorder不安全（编译器优化时可能把第二个检查优化掉）Singleton* Singleton::getInstance() &#123; if(m_instance==nullptr)&#123; Lock lock; if (m_instance == nullptr) &#123; m_instance = new Singleton(); &#125; &#125; return m_instance;&#125;//C++ 11版本之后的跨平台实现 (volatile)std::atomic&lt;Singleton*&gt; Singleton::m_instance;std::mutex Singleton::m_mutex;Singleton* Singleton::getInstance() &#123; Singleton* tmp = m_instance.load(std::memory_order_relaxed); std::atomic_thread_fence(std::memory_order_acquire);//获取内存fence if (tmp == nullptr) &#123; std::lock_guard&lt;std::mutex&gt; lock(m_mutex); tmp = m_instance.load(std::memory_order_relaxed); if (tmp == nullptr) &#123; tmp = new Singleton; std::atomic_thread_fence(std::memory_order_release);//释放内存fence m_instance.store(tmp, std::memory_order_relaxed); &#125; &#125; return tmp;&#125; 堆上单例（饿汉式）1234567891011121314namespace singleton &#123; class HungrySingleton &#123; public: HungrySingleton* getInstance() &#123; return instance_; &#125; private: HungrySingleton() &#123;&#125; static HungrySingleton* instance_; &#125;; HungrySingleton* HungrySingleton::instance_ = new HungrySingleton();&#125; // namespace singleton 2 工厂模式（Factory） 工厂模式中，创建对象时不会对客户端暴露创建逻辑，而是通过使用一个共同的接口来指向新创建的对象 2.1 简单工厂以炒鞋为例。鞋厂可以指定生产耐克、阿迪达斯和李宁牌子的鞋。 工厂类：工厂模式的核心类，会定义一个用于创建指定的具体实例对象的接口。 抽象产品类：是具体产品类的继承的父类或实现的接口。 具体产品类：工厂类所创建的对象就是此具体产品实例。 特点在于封装了创建具体产品对象的函数。 缺点在于扩展性非常差，新增产品的时候，需要去修改工厂类。 12345678910111213141516171819202122232425262728293031323334353637// 鞋子抽象类class Shoes&#123;public: virtual ~Shoes() &#123;&#125; virtual void Show() = 0;&#125;;// 耐克鞋子class NiKeShoes : public Shoes&#123;public: void Show() &#123; std::cout &lt;&lt; &quot;我是耐克球鞋，我的广告语：Just do it&quot; &lt;&lt; std::endl; &#125;&#125;;// 阿迪达斯鞋子class AdidasShoes : public Shoes&#123;public: void Show() &#123; std::cout &lt;&lt; &quot;我是阿迪达斯球鞋，我的广告语:Impossible is nothing&quot; &lt;&lt; std::endl; &#125;&#125;;// 李宁鞋子class LiNingShoes : public Shoes&#123;public: void Show() &#123; std::cout &lt;&lt; &quot;我是李宁球鞋，我的广告语：Everything is possible&quot; &lt;&lt; std::endl; &#125;&#125;; 12345678910111213141516171819202122232425262728293031enum SHOES_TYPE&#123; NIKE, LINING, ADIDAS&#125;;// 总鞋厂class ShoesFactory&#123;public: // 根据鞋子类型创建对应的鞋子对象 Shoes *CreateShoes(SHOES_TYPE type) &#123; switch (type) &#123; case NIKE: return new NiKeShoes(); break; case LINING: return new LiNingShoes(); break; case ADIDAS: return new AdidasShoes(); break; default: return NULL; break; &#125; &#125;&#125;; main函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243int main()&#123; // 构造工厂对象 ShoesFactory shoesFactory; // 从鞋工厂对象创建阿迪达斯鞋对象 Shoes *pNikeShoes = shoesFactory.CreateShoes(NIKE); if (pNikeShoes != NULL) &#123; // 耐克球鞋广告喊起 pNikeShoes-&gt;Show(); // 释放资源 delete pNikeShoes; pNikeShoes = NULL; &#125; // 从鞋工厂对象创建阿迪达斯鞋对象 Shoes *pLiNingShoes = shoesFactory.CreateShoes(LINING); if (pLiNingShoes != NULL) &#123; // 李宁球鞋广告喊起 pLiNingShoes-&gt;Show(); // 释放资源 delete pLiNingShoes; pLiNingShoes = NULL; &#125; // 从鞋工厂对象创建阿迪达斯鞋对象 Shoes *pAdidasShoes = shoesFactory.CreateShoes(ADIDAS); if (pAdidasShoes != NULL) &#123; // 阿迪达斯球鞋广告喊起 pAdidasShoes-&gt;Show(); // 释放资源 delete pAdidasShoes; pAdidasShoes = NULL; &#125; return 0;&#125; 2.2 工厂方法简单工厂的缺点在于，调用工厂来创建对象时，是传入产品类别的。每当增加一个类别时，就需要修改一次工厂类。这违反了开闭原则，而工厂方法是对这种行为的补救。使用工厂方法，每次需要增加一个类别时，只需要再实现两个具体类就行，不必再去修改工厂类的内容。 工厂方法相比于简单工厂，添加了一个具体工厂类，每一个具体工厂类和相应的具体产品类是一一对应的，由具体工厂类来生产（创建）相应的具体产品类对象。 抽象工厂类：工厂方法模式的核心类，提供创建具体产品的接口，由具体工厂类实现。 具体工厂类：继承于抽象工厂，实现创建对应具体产品对象的方式。 抽象产品类：它是具体产品继承的父类（基类）。 具体产品类：具体工厂所创建的对象，就是此类。 12345678910111213141516171819202122232425262728293031323334353637// 总鞋厂class ShoesFactory&#123;public: virtual Shoes *CreateShoes() = 0; virtual ~ShoesFactory() &#123;&#125;&#125;;// 耐克生产者/生产链class NiKeProducer : public ShoesFactory&#123;public: Shoes *CreateShoes() &#123; return new NiKeShoes(); &#125;&#125;;// 阿迪达斯生产者/生产链class AdidasProducer : public ShoesFactory&#123;public: Shoes *CreateShoes() &#123; return new AdidasShoes(); &#125;&#125;;// 李宁生产者/生产链class LiNingProducer : public ShoesFactory&#123;public: Shoes *CreateShoes() &#123; return new LiNingShoes(); &#125;&#125;; main函数 1234567891011121314151617181920212223242526int main()&#123; // ================ 生产耐克流程 ==================== // // 鞋厂开设耐克生产线 ShoesFactory *niKeProducer = new NiKeProducer(); // 耐克生产线产出球鞋 Shoes *nikeShoes = niKeProducer-&gt;CreateShoes(); // 耐克球鞋广告喊起 nikeShoes-&gt;Show(); // 释放资源 delete nikeShoes; delete niKeProducer; // ================ 生产阿迪达斯流程 ==================== // // 鞋厂开设阿迪达斯生产者 ShoesFactory *adidasProducer = new AdidasProducer(); // 阿迪达斯生产线产出球鞋 Shoes *adidasShoes = adidasProducer-&gt;CreateShoes(); // 阿迪达斯球鞋广喊起 adidasShoes-&gt;Show(); // 释放资源 delete adidasShoes; delete adidasProducer; return 0;&#125; 2.3 抽象工厂 与工厂方法的不同：具体工厂类不再生产唯一的产品，而是生产多个产品。也就是抽象工厂类将不仅仅提供对某一种产品的创建方法，还提供多种产品的创建方法。 应用场景：当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的具体产品时需要使用抽象工厂模式。 遇到此类场景时，抽象工厂模式比工厂方法模式更为简单、有效率。 考虑上面的例子。此时厂家不再局限于生产鞋子，还想生产耐克、阿迪达斯、李宁的衣服。那么就可以应用抽象工厂来替代工厂方法。 1234567891011121314151617181920212223242526272829303132333435// 基类 衣服class Clothe&#123;public: virtual void Show() = 0; virtual ~Clothe() &#123;&#125;&#125;;// 耐克衣服class NiKeClothe : public Clothe&#123;public: void Show() &#123; std::cout &lt;&lt; &quot;我是耐克衣服，时尚我最在行！&quot; &lt;&lt; std::endl; &#125;&#125;;// 基类 鞋子class Shoes&#123;public: virtual void Show() = 0; virtual ~Shoes() &#123;&#125;&#125;;// 耐克鞋子class NiKeShoes : public Shoes&#123;public: void Show() &#123; std::cout &lt;&lt; &quot;我是耐克球鞋，让你酷起来！&quot; &lt;&lt; std::endl; &#125;&#125;; 1234567891011121314151617181920212223// 总厂class Factory&#123;public: virtual Shoes *CreateShoes() = 0; virtual Clothe *CreateClothe() = 0; virtual ~Factory() &#123;&#125;&#125;;// 耐克生产者/生产链class NiKeProducer : public Factory&#123;public: Shoes *CreateShoes() &#123; return new NiKeShoes(); &#125; Clothe *CreateClothe() &#123; return new NiKeClothe(); &#125;&#125;; main函数 123456789101112131415161718192021222324int main()&#123; // ================ 生产耐克流程 ==================== // // 鞋厂开设耐克生产线 Factory *niKeProducer = new NiKeProducer(); // 耐克生产线产出球鞋 Shoes *nikeShoes = niKeProducer-&gt;CreateShoes(); // 耐克生产线产出衣服 Clothe *nikeClothe = niKeProducer-&gt;CreateClothe(); // 耐克球鞋广告喊起 nikeShoes-&gt;Show(); // 耐克衣服广告喊起 nikeClothe-&gt;Show(); // 释放资源 delete nikeShoes; delete nikeClothe; delete niKeProducer; return 0;&#125; 2.4 模板工厂（C++）https://zhuanlan.zhihu.com/p/83537599 模板工厂相当于在工厂方法的基础上进行优化，使其能够获得抽象工厂的效果。而且比起抽象工厂来，当需要新添加类别时（比如在鞋和衣服的基础上，还要添加裤子），扩展性更强，符合开闭原则。 1234567891011121314151617181920212223242526272829303132333435// 基类 鞋子class Shoes&#123;public: virtual void Show() = 0; virtual ~Shoes() &#123;&#125;&#125;;// 耐克鞋子class NiKeShoes : public Shoes&#123;public: void Show() &#123; std::cout &lt;&lt; &quot;我是耐克球鞋，我的广告语：Just do it&quot; &lt;&lt; std::endl; &#125;&#125;;// 基类 衣服class Clothe&#123;public: virtual void Show() = 0; virtual ~Clothe() &#123;&#125;&#125;;// 优衣库衣服class UniqloClothe : public Clothe&#123;public: void Show() &#123; std::cout &lt;&lt; &quot;我是优衣库衣服，我的广告语：I am Uniqlo&quot; &lt;&lt; std::endl; &#125;&#125;; 123456789101112131415161718192021// 抽象模板工厂类// 模板参数：AbstractProduct_t 产品抽象类template &lt;class AbstractProduct_t&gt;class AbstractFactory&#123;public: virtual AbstractProduct_t *CreateProduct() = 0; virtual ~AbstractFactory() &#123;&#125;&#125;;// 具体模板工厂类// 模板参数：AbstractProduct_t 产品抽象类，ConcreteProduct_t 产品具体类template &lt;class AbstractProduct_t, class ConcreteProduct_t&gt;class ConcreteFactory : public AbstractFactory&lt;AbstractProduct_t&gt;&#123;public: AbstractProduct_t *CreateProduct() &#123; return new ConcreteProduct_t(); &#125;&#125;; main函数 12345678910111213141516171819202122232425int main()&#123; // 构造耐克鞋的工厂对象 ConcreteFactory&lt;Shoes, NiKeShoes&gt; nikeFactory; // 创建耐克鞋对象 Shoes *pNiKeShoes = nikeFactory.CreateProduct(); // 打印耐克鞋广告语 pNiKeShoes-&gt;Show(); // 构造优衣库衣服的工厂对象 ConcreteFactory&lt;Clothe, UniqloClothe&gt; uniqloFactory; // 创建优衣库衣服对象 Clothe *pUniqloClothe = uniqloFactory.CreateProduct(); // 打印优衣库广告语 pUniqloClothe-&gt;Show(); // 释放资源 delete pNiKeShoes; pNiKeShoes = NULL; delete pUniqloClothe; pUniqloClothe = NULL; return 0;&#125; 3 建造者模式（Builder） 将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。Builder侧重“零部件的组装过程”。 应用场景：建造者模式主要用于“分步骤构建一个复杂的对象”。在这其中“分步骤”是一个稳定的算法，而复杂对象的各个部分经常变化。 缺点：这里的“组装过程”，或者说“步骤”，是固定的，无法修改。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class House&#123; //....&#125;;class HouseBuilder &#123;public: House* GetResult()&#123; return pHouse; &#125; virtual ~HouseBuilder()&#123;&#125;protected: House* pHouse; virtual void BuildPart1()=0; virtual void BuildPart2()=0; virtual void BuildPart3()=0; virtual void BuildPart4()=0; virtual void BuildPart5()=0;&#125;;class StoneHouse: public House&#123;&#125;;class StoneHouseBuilder: public HouseBuilder&#123;protected: virtual void BuildPart1()&#123; //pHouse-&gt;Part1 = ...; &#125; virtual void BuildPart2()&#123; &#125; virtual void BuildPart3()&#123; &#125; virtual void BuildPart4()&#123; &#125; virtual void BuildPart5()&#123; &#125;&#125;;///@brief：Director，组装各个part，“步骤”是由它制定并实现的class HouseDirector&#123;public: HouseBuilder* pHouseBuilder; HouseDirector(HouseBuilder* pHouseBuilder)&#123; this-&gt;pHouseBuilder=pHouseBuilder; &#125; House* Construct()&#123; pHouseBuilder-&gt;BuildPart1(); for (int i = 0; i &lt; 4; i++)&#123; pHouseBuilder-&gt;BuildPart2(); &#125; bool flag=pHouseBuilder-&gt;BuildPart3(); if(flag)&#123; pHouseBuilder-&gt;BuildPart4(); &#125; pHouseBuilder-&gt;BuildPart5(); return pHouseBuilder-&gt;GetResult(); &#125;&#125;; 4 原型模式（Prototype） 将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。 应用场景： 针对结构复杂的对象结构，由于需求变化，对象内部也会发生变化，但是对外暴露的接口仍然是稳定的。原型模式负责应对这种变化，从客户程序隔离出易变对象，从而使得依赖这些对象的客户程序不必随着需求改变而改变。 实现方式： 定义抽象类，原型为派生出来的具体类的一个实例，需要其他（发生了变化的）实例时，从原型拷贝。 1234567891011121314151617181920212223242526272829303132333435/// @brief 抽象原型类class AbstractPrototype &#123;public: AbstractPrototype() = default; virtual ~AbstractPrototype() &#123;&#125; virtual AbstractPrototype* clone() = 0;&#125;;/// @brief 具体原型类class ConcretePrototype : public AbstractPrototype &#123;public: ConcretePrototype() = default; ~ConcretePrototype() &#123;&#125; AbstractPrototype* clone() &#123; return new ConcretePrototype(*this);//调用拷贝构造 &#125;private: ConcretePrototype(const ConcretePrototype&amp; other) &#123; fprintf(stderr, &quot;ConcretePrototype copy construct!\\n&quot;); // ......拷贝操作 &#125;&#125;;void Test_02_prototype_impl_1() &#123; printf(&quot;-------------------- %s --------------------\\n&quot;, __FUNCTION__); prototype::AbstractPrototype* ptr_a = new prototype::ConcretePrototype(); prototype::AbstractPrototype* ptr_b = ptr_a-&gt;clone(); delete ptr_a; delete ptr_b; &#125; 结构型 📌门面(5) &gt; 适配器(4) &#x3D; 组合(4) &#x3D; 代理(4) &gt; 桥接(3) &#x3D; 装饰(3) &gt; 享元(1) 5 代理模式（Proxy）在某些情况下，一个客户不想或者不能直接引用一个对象，此时可以通过一个称之为“代理”的第三方来实现 间接引用。代理对象可以在客户端和目标对象之间起到“中介”的作用，并且可以通过代理对象去掉客户不允许看到的内容，或者添加客户需要的额外服务。 事实上，代理模式和科学上网时所配置的代理是异曲同工的。无法直接访问到海外的机器，此时可以使用一个代理来访问海外，而客户端调用代理即可。 subject：抽象角色 Proxy：代理角色 RealSubject：真实角色 应用场景： 远程代理：为一个处于不同地址空间的对象提供一个本地的代理，这个不同地址空间可以在同一台主机中，也可在另一台主机中，远程代理又叫做大使。 虚拟代理：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。 写时拷贝代理：虚拟代理的一种，把复制（克隆）操作延迟到只有在客户端真正需要时才执行。 保护代理：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。 缓冲代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。 防火墙代理：保护目标不让恶意用户接近。 同步化代理：使几个用户能够同时使用一个对象而没有冲突。 智能引用代理：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来等。 优点： 代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。 远程代理使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。 虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度。 保护代理可以控制对真实对象的使用权限。 缺点： 客户端和真实对象之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，而且增加了系统实现的复杂度。 12345678910111213141516171819202122232425262728class Proxy : public Subject&#123;public: Proxy()&#123; m_pRealSubject = new RealSubject(); &#125;; virtual ~Proxy()&#123; delete m_pReakSubject; &#125;; void request()&#123; preRequest(); m_pRealSubject-&gt;request(); afterRequest(); &#125;;private: void afterRequest(); void preRequest(); RealSubject *m_pRealSubject;&#125;;/*int main()&#123; Proxy proxy; proxy.request(); return 0;&#125;*/ 6 桥接模式（Bridge）桥接模式同时使用了“接口与实现相分离”和“组合代替继承”的思想。 应用场景： 某些类型的固有实现逻辑，使得它们具有两个变化的维度，甚至多个变化的维度。比如说图形既可按形状分，又可按颜色分。而Photoshop这样的软件，能画不同形状和不同颜色的图形，该如何实现呢？此时可以使用桥接模式，可以参考前文“组合代替继承”中鸟类的例子。 桥接模式结构： Abstraction：抽象类 RefinedAbstraction：扩充抽象类，即扩充Abstraction所定义的接口，他同时连接Abstraction和Implementor，是“桥接”中的那座桥。 Implementor：实现类接口 ConcreteImplementor：具体实现类 扩充抽象类构造时接收具体实现类为参数，从而让扩充抽象类组合了若干具体实现类的功能。 当然，扩充抽象类不一定是必需的，由此衍生出两种桥接模式的实现方式。 简单的抽象与实现相分离123456789101112131415161718192021222324252627282930313233/// @brief 抽象类接口class AbstractInterface &#123;public: AbstractInterface(); ~AbstractInterface(); void Request();private: class Impl; Impl* impl_;&#125;;/// @brief 实现类接口class AbstractInterface::Impl &#123;public: void Request() &#123; printf(&quot;this is AbstractInterface::Impl::Request!\\n&quot;); &#125;&#125;;/// 抽象类接口的实现 - 调用实现类接口AbstractInterface::AbstractInterface() &#123; impl_ = new Impl();&#125;AbstractInterface::~AbstractInterface() &#123; delete impl_;&#125;void AbstractInterface::Request() &#123; impl_-&gt;Request();&#125; 复杂的抽象与实现相分离123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/// @brief 实现化角色, 定义实现化角色的接口class AbstractImplementor &#123;public: virtual ~AbstractImplementor() &#123;&#125; virtual void Request() = 0;&#125;;/// @brief 具体实现化角色, 给出实现化角色接口的具体实现class ConcreteImplementorA : public AbstractImplementor &#123;public: virtual void Request() &#123; printf(&quot;this ConcreteImplementorA::Request!\\n&quot;); &#125;&#125;;class ConcreteImplementorB : public AbstractImplementor &#123;public: virtual void Request() &#123; printf(&quot;this ConcreteImplementorB::Request!\\n&quot;); &#125;&#125;;/// @brief 抽象类角色, 对实现化对象的引用class AbstractRole &#123;public: AbstractRole(AbstractImplementor* impl) : impl_(impl) &#123;&#125; virtual ~AbstractRole() &#123;&#125; virtual void Request() = 0;protected: AbstractImplementor* impl_;&#125;;/// @brief 扩展抽象化角色, 实现父类中的业务方法class ExtendRole : public AbstractRole &#123;public: ExtendRole(AbstractImplementor* impl) : AbstractRole(impl) &#123;&#125; virtual void Request() &#123; impl_-&gt;Request(); &#125;&#125;;void Test_08_bridge_impl_2() &#123; AbstractImplementor* ptr_implA = new ConcreteImplementorA(); AbstractImplementor* ptr_implB = new ConcreteImplementorB(); AbstractRole* ptr_role_1 = new ExtendRole(ptr_implA); ptr_role_1-&gt;Request(); AbstractRole* ptr_role_2 = new ExtendRole(ptr_implB); ptr_role_2-&gt;Request(); delete ptr_role_1, ptr_role_2; delete ptr_implA, ptr_implB;&#125; 📌桥接模式的“桥”体现在什么地方？比如说Photoshop的例子，颜色和形状被组合在了一起。再比如鸟的例子，飞属性和叫属性也被组合在了一起。桥接就像架起了一座桥一样，连接了两个不同的类型，从而进行组合。体现在代码上的话，就是RefineAbstraction的构造函数中，传入了不同Implementor类型的指针，于是在RefineAbstraction对象内部，就可以组合不同类型的对象。同时，用户仅需要调用抽象接口Abstraction即可。 7 装饰器模式（Decorator）装饰器动态的给对象增加一些职责，即增加额外的功能。采用了“组合代替继承”的原则，用组合关系创建一个包装对象来包裹真实对象，并在保持真实对象的类结构不变的前提下，提供额外的功能。 应用场景： 优点： 装饰模式可以提供比继承更多的灵活性。 可以通过动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的装饰器，从而实现不同的行为。 通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。 使用时进行组合即可，原有代码无须改变，符合“开闭原则”。 缺点： 装饰类和小对象的产生将增加系统的复杂度，加大学习与理解的难度。 装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。 1234567891011121314/// @brief 抽象组件 - 被装饰的接口基类class AbstractComponent &#123;public: virtual ~AbstractComponent() &#123;&#125; virtual void Request() = 0;&#125;;/// @brief 具体组件 - 被装饰的接口派生类class ConcreteComponent : public AbstractComponent &#123;public: virtual void Request() &#123; printf(&quot;this is ConcreteComponent::Request!\\n&quot;); &#125;&#125;; 1234567891011121314151617181920212223242526272829303132/// @brief 抽象装饰class AbstractDecorator : public AbstractComponent &#123;public: AbstractDecorator(AbstractComponent* comp) : comp_(comp) &#123;&#125; virtual void Request() &#123; if (comp_) comp_-&gt;Request(); &#125;private: AbstractComponent* comp_;&#125;;/// @brief 具体装饰class ConcreteDecoratorA : public AbstractDecorator &#123;public: ConcreteDecoratorA(AbstractComponent* comp) : AbstractDecorator(comp) &#123;&#125; virtual void Request() &#123; PreRequest(); AbstractDecorator::Request(); PostRequest(); &#125;protected: void PreRequest() &#123; printf(&quot;ConcreteDecoratorA::PreRequest!\\n&quot;); &#125; void PostRequest() &#123; printf(&quot;ConcreteDecoratorA::PostRequest!\\n&quot;); &#125;&#125;; 📌代码中的这行操作ConcreteDecoratorA(AbstractComponent* comp):AbstractDecorator(comp)是C++11的新特性：委托构造函数(delegating constructor)，即一个构造函数可以在初始化成员列表中，调用另一个构造函数。委托构造函数的成员初始值列表只能有唯一的参数，就是构造函数。上面的例子中，就是创建ConcreteDecoratorA对象时，会先将被对象创建为AbstractDecorator对象的内容，如果{ }中有内容，就继续执行{ }中的内容。但是委托构造函数易发生死锁的问题，考虑下面代码：class B{private:&amp;#x20; int *a;&amp;#x20; std::string *s;public:&amp;#x20; B(int a) : B(“Test”) {&amp;#x20; _*a &#x3D; a;&amp;#x20; }&amp;#x20; B(std::string s) : B(100){&amp;#x20; *_s &#x3D; “Test”;&amp;#x20; }};这一份代码可以编译，但是却无法运行。因为一旦初始化，无论执行哪一个函数，一定会陷入无穷无尽的循环调用中。 123456789//main函数int main()&#123; AbstractComponent* ptr_comp = new ConcreteComponent(); ptr_comp-&gt;Request(); //原有组件该有的功能不变 //对现有组件的功能进行扩展 AbstractDecorator* ptr_decorator = new ConcreteDecoratorA(ptr_comp); ptr_decorator-&gt;Request();&#125; 8 适配器模式（Adapter） 适配器模式中的角色： Target（目标接口）、Adapter（适配器类）、Adaptee（适配者类）、Client（客户类）。 应用场景： 现有的类可以满足客户类的功能需要，但是它所提供的接口不一定是客户类所期望的。适配器模式就是在二者之间添加一个类进行接口的转化。而添加的用于转化接口的类就是适配器类，被包装的类即适配者类。 适配器模式，通过适配器类，在适配者类外部包装，包装成目标接口。 适配器模式有两种实现方式： 对象适配器 Adapter只继承Target以提供接口的实现，接收Adaptee的对象作为参数。 类适配器 多重继承，Adapter类同时继承Target和Adaptee。 二者均能获得Adaptee功能的同时向客户提供目标接口。两种实现方式的类图如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//目标接口（新接口）class ITarget&#123;public: virtual void process()=0;&#125;;//遗留接口（老接口）class IAdaptee&#123;public: virtual void foo(int data)=0; virtual int bar()=0;&#125;;//遗留类型class OldClass: public IAdaptee&#123; //....&#125;;//对象适配器class Adapter: public ITarget&#123; //继承protected: IAdaptee* pAdaptee;//组合public: Adapter(IAdaptee* pAdaptee)&#123; this-&gt;pAdaptee=pAdaptee; &#125; virtual void process()&#123; int data=pAdaptee-&gt;bar(); pAdaptee-&gt;foo(data); &#125;&#125;;//类适配器class Adapter: public ITarget, protected OldClass&#123; //多继承 virtual void process()&#123; int data = this-&gt;bar(); this-&gt;foo(data); &#125; &#125;;int main()&#123; IAdaptee* pAdaptee=new OldClass(); ITarget* pTarget=new Adapter(pAdaptee);//使用对象适配器 ITarget* pTarget=new Adapter();//使用类适配器 pTarget-&gt;process();&#125; 9 门面&#x2F;外观模式（Facade）客户端想同时调用多个复杂的子系统，而外观模式为这些子系统提供一个一致的接口，使它们更容易被访问。 现实生活的类比：如办房产证或注册一家公司，有时要同多个部门联系，这时要是有一个综合部门能解决一切手续问题就好了。外观模式就是在软件层面做这样的事 优点： 降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类 对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易 降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象 缺点： 增加新的子系统可能需要修改外观类或客户端的代码，违背了“开闭原则”。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/// @brief 具体实现子模块class SubModuleImplementorA &#123;public: void PreRequest () &#123; printf(&quot;SubModuleImplementorA::PreRequest!\\n&quot;); &#125;&#125;;class SubModuleImplementorB &#123;public: void RealRequest () &#123; printf(&quot;SubModuleImplementorB::RealRequest!\\n&quot;); &#125;&#125;;class SubModuleImplementorC &#123;public: void PostRequest () &#123; printf(&quot;SubModuleImplementorC::PostRequest!\\n&quot;); &#125;&#125;;/// @brief 外观角色class Facade &#123;public: Facade() &#123; implA_.reset(new SubModuleImplementorA());//reset会使引用计数-1 implB_.reset(new SubModuleImplementorB()); implC_.reset(new SubModuleImplementorC()); &#125; void Request() &#123; implA_-&gt;PreRequest(); implB_-&gt;RealRequest(); implC_-&gt;PostRequest(); &#125;private: std::shared_ptr&lt;SubModuleImplementorA&gt; implA_; std::shared_ptr&lt;SubModuleImplementorB&gt; implB_; std::shared_ptr&lt;SubModuleImplementorC&gt; implC_;&#125;;void Test_10_facade_impl_1() &#123; printf(&quot;-------------------- %s --------------------\\n&quot;, __FUNCTION__); std::shared_ptr&lt;Facade&gt; ptr(new Facade()); ptr-&gt;Request();&#125; 📌shared_ptr的reset(new class())用法，先new出来对象，再将shared_ptr引用计数-1。因此，若之前指针只指向一个对象，-1后为0，自动析构，指针悬空，就可以指向新new出来的对象。 10 组合模式（Composite）组合模式将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。 应用场景： 软件开发中存在很多“部分-整体”的关系，如文件系统中的文件与文件夹等等。对这些简单对象与复合对象的处理，用组合模式来实现会比较方便。 优点： 客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的单个对象还是组合对象，简化了客户端代码的设计； 更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源码，满足“开闭原则”。 缺点： 设计较复杂，客户端需要花更多时间理清类之间的层次关系； 不容易用继承的方法增加功能。 透明式抽象组件声明子类中的全部方法，所以客户端无需区别叶子对象和中间的树枝对象，对客户端透明。 缺点在于，叶子类本不必有Add()、Remove()这样的方法，却要实现它们，从而有安全问题。 12345678910111213141516171819202122232425262728293031323334353637383940class Component&#123;public: virtual void process() = 0; virtual ~Component()&#123;&#125;&#125;;//树枝节点 &amp; 叶子节点class Composite : public Component&#123; string name; list&lt;Component*&gt; elements;public: Composite(const string &amp; s) : name(s) &#123;&#125; void add(Component* element) &#123; elements.push_back(element); &#125; void remove(Component* element)&#123; elements.remove(element); &#125; void process()&#123; //1. process current node //2. process leaf nodes for (auto &amp;e : elements) e-&gt;process(); //多态调用 &#125;&#125;;//对组合对象和单个对象执行一致处理void Invoke(Component &amp; c)&#123; //... c.process(); //...&#125; 安全式将管理子component的方法移到树枝component中，抽象component和叶子component没有对子component的管理方法，从而避免上一种方式的安全性问题。 由于叶子和分支有不同的接口，因此客户端在调用时要知道叶子对象和树枝对象的存在，不再严格透明。 123456789101112131415161718192021222324252627282930313233class Component&#123;public: virtual void process() = 0; virtual ~Component()&#123;&#125;&#125;;//树节点class Composite : public Component&#123; string name; list&lt;Component*&gt; elements;public: Composite(const string &amp; s) : name(s) &#123;&#125; void add(Component* element) &#123; elements.push_back(element); &#125; void remove(Component* element)&#123; elements.remove(element); &#125; void process()&#123; //1. process current node //2. process leaf nodes for (auto &amp;e : elements) e-&gt;process(); //多态调用 &#125;&#125;; 1234567891011121314151617//叶子节点class Leaf : public Component&#123; string name;public: Leaf(string s) : name(s) &#123;&#125; void process()&#123; //process current node &#125;&#125;;//对组合对象和单个对象执行一致处理void Invoke(Component &amp; c)&#123; //... c.process(); //...&#125; 1234567891011121314151617//main函数int main()&#123; Composite root(&quot;root&quot;); Composite treeNode1(&quot;treeNode1&quot;); Composite treeNode2(&quot;treeNode2&quot;); Leaf leat1(&quot;left1&quot;); root.add(&amp;treeNode1); treeNode1.add(&amp;treeNode2); treeNode2.add(&amp;leaf1); process(root); process(leaf1); process(treeNode2);&#125; 11 享元模式（Flyweight）很多情况下，需要在系统中增加类和对象的个数，当对象数量太多时，将导致运行代价过高，带来性能下降等问题。享元模式针对此问题诞生，其使得相同或相似对象在重用时，共享某一个对象的内容。 在享元模式中可以共享的相同内容称为内部状态，而那些需要外部环境来设置的不能共享的内容称为外部状态。享元模式中通常会出现工厂模式，需创建一个享元工厂来维护一个享元池，用于存储具有相同内部状态的享元对象。 享元模式的优点在于，可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份 （Flyweight其实就是轻量级） Flyweight：抽象享元类，描述一个接口，通过这个接口Flyweight可以接受并作用于外部状态 ConcreteFlyweight：具体享元类，定义了一些内部状态。ConcreteFlyweight对象必须是可共享的 UnsharedConcreteFlyweight：非共享具体享元类 FlyweightFactory：享元工厂类，创建并管理FlyWeight。当用户请求一个Flyweight时，FlyweightFactory对象提供一个已创建的实例，如果请求的实例不存在，就新创建一个实例。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/// @brief 非享元类, 以参数的形式注入具体享元的相关方法中class UnsharableConcreteFlyweight &#123;public: UnsharableConcreteFlyweight(const std::string&amp; content) : content_(content) &#123;&#125; const std::string&amp; GetContent() const &#123; return content_; &#125;private: std::string content_;&#125;;/// @brief 抽象享元类, 为具体享元规范需要实现的公共接口class AbstractFlyweight &#123;public: virtual ~AbstractFlyweight() &#123;&#125; virtual void Run(UnsharableConcreteFlyweight* unsharable_content_ptr) = 0;&#125;;/// @brief 具体享元类, 实现抽象享元角色中所规定的接口class ConcreteFlyweightA : public AbstractFlyweight &#123;public: virtual void Run(UnsharableConcreteFlyweight* unsharable_content_ptr) &#123; std::cout &lt;&lt; &quot;ConcreteFlyweightA::Run!&quot; &lt;&lt; std::endl; std::cout &lt;&lt; unsharable_content_ptr-&gt;GetContent() &lt;&lt; std::endl; &#125;&#125;;class ConcreteFlyweightB : public AbstractFlyweight &#123;public: virtual void Run(UnsharableConcreteFlyweight* unsharable_content_ptr) &#123; std::cout &lt;&lt; &quot;ConcreteFlyweightB::Run!&quot; &lt;&lt; std::endl; std::cout &lt;&lt; unsharable_content_ptr-&gt;GetContent() &lt;&lt; std::endl; &#125;&#125;;/// @brief 享元工厂类class FlyweightFactory &#123;public: enum FlyweightType &#123; ConcreteA = 0, ConcreteB, &#125;; ~FlyweightFactory() &#123; for (auto it = fly_weights_.begin(); it != fly_weights_.end(); it++) &#123; if (it-&gt;second) delete it-&gt;second; &#125; fly_weights_.clear(); &#125; AbstractFlyweight* GetFlyweight(const std::string&amp; key, const FlyweightType&amp; type = ConcreteA) &#123; auto it = fly_weights_.find(key); if (fly_weights_.end() == it) &#123; AbstractFlyweight* ptr = nullptr; if (ConcreteA == type) &#123; ptr = new ConcreteFlyweightA(); &#125; else if (ConcreteB == type) &#123; ptr = new ConcreteFlyweightB(); &#125; fly_weights_[key] = ptr; &#125; return fly_weights_[key]; &#125;private: std::map&lt;std::string, AbstractFlyweight*&gt; fly_weights_;&#125;; main函数 123456789101112131415int main()&#123; std::shared_ptr&lt;UnsharableConcreteFlyweight&gt; unsharable_content_ptr_1(new UnsharableConcreteFlyweight(&quot;unsharable_content_ptr_1&quot;)); std::shared_ptr&lt;UnsharableConcreteFlyweight&gt; unsharable_content_ptr_2(new UnsharableConcreteFlyweight(&quot;unsharable_content_ptr_2&quot;)); std::shared_ptr&lt;FlyweightFactory&gt; ptr(new FlyweightFactory()); AbstractFlyweight* flyweight_ptr_A_red = ptr-&gt;GetFlyweight(&quot;Red&quot;); AbstractFlyweight* flyweight_ptr_A_point = ptr-&gt;GetFlyweight(&quot;Point&quot;); flyweight_ptr_A_red-&gt;Run(unsharable_content_ptr_1.get()); flyweight_ptr_A_point-&gt;Run(unsharable_content_ptr_2.get());&#125;// ConcreteFlyweightA::Run!// unsharable_content_ptr_1// ConcreteFlyweightA::Run!// unsharable_content_ptr_2 📌享元模式在编辑器软件中大量使用，如在一个文档中多次出现相同的图片，则只需要创建一个图片对象，通过在应用程序中设置该图片出现的位置，可以实现该图片在不同地方多次重复显示。 行为型 📌迭代器(5) &#x3D; 观察者(5) &gt; 命令(4) &#x3D; 策略(4) &gt; 职责链(3) &#x3D; 状态(3) &#x3D; 模板(3) &gt; 中介(2) &#x3D; 备忘录(2) &gt; 访问者(1) &#x3D; 解释器(1)&amp;#x20; 12 观察者模式（Observer）观察者模式建立对象与对象之间的一对多依赖关系。一个对象发生改变时，将自动通知其他对象，其他对象会做出相应的反应（如被自动更新）。 发生改变的对象称为观察目标，而被通知的对象称为观察者。 观察者模式又被称作发布-订阅模式(Publish&#x2F;Subscribe)、模型-视图模式(Model&#x2F;View)、源-监听器模式(Source&#x2F;Listener)、从属者模式(Dependents)。 优点：支持广播通信，符合开闭原则。可以实现表示层和数据逻辑层的分离，在观察目标和观察者之间建立一个抽象的耦合。 缺点： 如果一个观察目标对象有很多直接和间接的观察者的话，将所有观察者都通知到会花费很多时间 如果观察者和观察目标之间有循环依赖，观察目标会触发它们之间循环调用，可能系统崩溃 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/// @brief 抽象观察者, 包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。class AbstractObserver &#123;public: ~AbstractObserver() &#123;&#125; // 被告知时做出响应 virtual void Response() = 0;&#125;;/// @brief 具体观察者, 实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。class ConcreteObserverA : public AbstractObserver &#123;public: virtual void Response() &#123; printf(&quot;this is ConcreteObserverA::Response!\\n&quot;); &#125;&#125;;class ConcreteObserverB : public AbstractObserver &#123;public: virtual void Response() &#123; printf(&quot;this is ConcreteObserverB::Response!\\n&quot;); &#125;&#125;;/// @brief 抽象主题类, 它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法class AbstractSubject &#123;public: virtual ~AbstractSubject() &#123;&#125; virtual void NotifyObserver() = 0; void AddObserver(AbstractObserver* observer) &#123; observers_.emplace_back(observer); &#125; void RemoveObserver(AbstractObserver* observer) &#123; for (auto it = observers_.begin(); it != observers_.end(); it++) &#123; if ((*it) == observer) &#123; observers_.erase(it++); break; &#125; &#125; &#125;protected: std::vector&lt;AbstractObserver*&gt; observers_;&#125;;/// @brief 具体主题类, 它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。class ConcreteSubject : public AbstractSubject &#123;public: virtual void NotifyObserver() &#123; for (auto* observer : observers_) &#123; observer-&gt;Response(); &#125; &#125;&#125;;int main()&#123; printf(&quot;-------------------- %s --------------------\\n&quot;, __FUNCTION__); std::shared_ptr&lt;AbstractSubject&gt; ptr_subject(new ConcreteSubject()); std::shared_ptr&lt;AbstractObserver&gt; ptr_observer_A(new ConcreteObserverA()); std::shared_ptr&lt;AbstractObserver&gt; ptr_observer_B(new ConcreteObserverB()); ptr_subject-&gt;AddObserver(ptr_observer_A.get()); ptr_subject-&gt;AddObserver(ptr_observer_B.get()); ptr_subject-&gt;NotifyObserver();&#125; 13 模板方法（Template） 定义一个操作中的算法的骨架（稳定），而将一些步骤延迟（变化）到子类中 其实模板方法顾名思义，就是定义一个抽象类，在该类中将一个算法的大致框架写好，而细节则由其派生的具体类来实现。 应用场景： 在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。 对应于生活中的例子，可以类比写论文的过程。写论文需要提前写出提纲，确定各段的标题和整体结构，但是每小段的文字可以后面再具体写。 实现方式： 抽象类负责给出一个算法的轮廓和骨架，定义两种类型的方法 模板方法：定义在抽象类中的，把基本操作方法组合在一起形成总算法或总行为的方法。 子类会不加修改地完全继承这个方法。 基本方法： 抽象方法（延迟的内容）：在抽象类中声明，由具体子类实现 具体方法（骨架）：在抽象类中已实现，具体子类中可以继承或重写它 钩子方法：抽象类中已实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061namespace template_method &#123;/// @brief 抽象类, 给出一个算法的轮廓和骨架class AbstractClass &#123;public: virtual ~AbstractClass() &#123;&#125; /// @brief 模板方法, 定义了算法的骨架，按某种顺序调用其包含的基本方法 virtual void TemplateMethod() &#123; SpecificMethodA(); if (HookMethodB()) &#123; HookMethodA(); &#125; AbstractMethod(); SpecificMethodB(); &#125;protected: /// @brief 基本方法, 可以有三种 /// - 抽象方法：在抽象类中申明，由具体子类实现 /// - 具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它 /// - 钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种 virtual void AbstractMethod() = 0; virtual void SpecificMethodA() &#123; printf(&quot;this is AbstractClass::SpecificMethodA!\\n&quot;); &#125; virtual void SpecificMethodB() &#123; printf(&quot;this is AbstractClass::SpecificMethodB!\\n&quot;); &#125; virtual void HookMethodA() &#123; // 通常为空实现 printf(&quot;this is AbstractClass::HookMethodA!\\n&quot;); &#125; virtual bool HookMethodB() &#123; return false; &#125;&#125;;/// @brief 具体类, 实现抽象类中所定义的抽象方法和钩子方法class ConcreteClass : public AbstractClass &#123;public: virtual void AbstractMethod() &#123; printf(&quot;this is ConcreteClass::AbstractMethod!\\n&quot;); &#125;protected: virtual void SpecificMethodB() &#123; printf(&quot;this is ConcreteClass::SpecificMethodB!\\n&quot;); &#125; virtual void HookMethodA() &#123; // 通常为空实现 printf(&quot;this is ConcreteClass::HookMethodA!\\n&quot;); &#125; virtual bool HookMethodB() &#123; return true; &#125;&#125;;&#125; // namespace template_methodvoid Test_13_composite_impl_1() &#123; printf(&quot;-------------------- %s --------------------\\n&quot;, __FUNCTION__); template_method::AbstractClass* ptr = new template_method::ConcreteClass(); ptr-&gt;TemplateMethod(); delete ptr;&#125; 优点： 封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。 在父类中提取了公共的部分代码，便于代码复用。 部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。 缺点： 对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象 📌一般推荐将三种基本方法设置为protected模板方法中，存在由子类影响父类的反向控制，是“控制反转”的典型应用 14 策略模式（Strategy&#x2F;Policy）软件开发中往往会遇到这样的情况：实现某一个功能有多个途径。而这些不同的方式均被称为策略，每一种方式就是一个策略。 比如实现一个负责查找任务的类，而查找有若干种算法，在类中每一个方法对应着一种算法。或者将所有的算法都封装进一个方法中，通过输入参数和if…else…来判定具体使用何种查找算法。这两种方式都属于硬编码（hard coding），是不推荐的。 原因在于，每增加一种新的查找算法，就需要修改封装算法类的源代码；而且更换查找算法时，也需要修改客户端的调用代码。如果算法类中封装了大量算法，那么该类的代码会比较复杂，维护较为困难。 策略模式旨在解决这样的问题（可以记忆为，解决代码中的大量if…else…），其将众多策略都写成一个类，利用抽象策略类为用户提供接口。同时，让一个Context类（环境类）来耦合客户端和算法类，提供setStrategy用于更换算法，并进行统一语义的执行 Context：环境类 Strategy：抽象策略类 ConcreteStrategy：具体策略类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/// @brief 抽象策略类, 定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法class AbstractStrategy &#123;public: virtual ~AbstractStrategy() &#123;&#125; virtual void StrategyMethod() = 0;&#125;;/// @brief 具体策略类, 实现了抽象策略定义的接口，提供具体的算法实现class ConcreteStrategyA : public AbstractStrategy &#123;public: virtual void StrategyMethod() &#123; printf(&quot;this is ConcreteStrategyA::StrategyMethod!\\n&quot;); &#125;&#125;;class ConcreteStrategyB : public AbstractStrategy &#123;public: virtual void StrategyMethod() &#123; printf(&quot;this is ConcreteStrategyB::StrategyMethod!\\n&quot;); &#125;&#125;;/// @brief 环境类, 持有一个策略类的引用，最终给客户端调用class Context &#123;public: void SetStrategy(AbstractStrategy* strategy) &#123; strategy_ = strategy; &#125; void StrategyMethod() &#123; if (strategy_) strategy_-&gt;StrategyMethod(); &#125;private: AbstractStrategy* strategy_ = nullptr;&#125;;int main()&#123; AbstractStrategy* ptr_strategy_A = new ConcreteStrategyA(); AbstractStrategy* ptr_strategy_B = new ConcreteStrategyB(); Context env_; env_.SetStrategy(ptr_strategy_A); env_.StrategyMethod(); env_.SetStrategy(ptr_strategy_B); env_.StrategyMethod(); delete ptr_strategy_A; delete ptr_strategy_B;&#125; 优点： 符合开闭原则，用户可以在不修改原有系统的基础上选择算法行为，也可以灵活地增加新的算法或行为 避免多重条件语句 提供了管理相关的算法族的办法 缺点： 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。 15 职责链模式（Chain of Responsibility）考虑这样的例子：企业的采购审批是一般是分级进行的，即根据采购金额的不同由不同层次的主管人员来审批。主任可以审批5万元以下的采购单，副董事长可以审批5万元至10万元的采购单，董事长可以审批10万元至50万元的采购单，50万元及以上的采购单就需要开董事会讨论决定。 那么一个自动化的审批类可以写成如下形式： 123456789101112131415161718192021222324252627class PurchaseRequestHandler &#123;public: void handlePurchaseRequest(const PurchaseRequest&amp; request) &#123; int amount = request.getAmount(); if(amount &lt; 50000) &#123; this-&gt;handleByDirector(request); &#125; else if(amount &lt; 100000) &#123; this-&gt;handleByVicePresident(request); &#125; else if(amount &lt; 500000) &#123; this-&gt;handleByPresident(request); &#125; else &#123; this-&gt;handleByCongress(request); &#125; &#125;private: // 主任审批采购单 void handleByDirector(const PurchaseRequest&amp; request) &#123; &#125; // 副董事长审批采购单 void handleByVicePresident(const PurchaseRequest&amp; request) &#123; &#125; // 董事长审批采购单 void handleByPresident(const PurchaseRequest&amp; request) &#123; &#125; // 董事会审批采购单 void handleByCongress(const PurchaseRequest&amp; request) &#123; &#125;&#125;; 但是仔细审视这段代码的话，首先，它违反了单一职责原则，各个级别的审批方法都集中在一个类中，测试和维护难度大。同时不够灵活，现有审批流程从“主任→副董→董事长→董事会”改为“主任→董事长→董事会”，就必须修改类的源代码。 职责链模式面向的场景：一个请求有多个对象可以处理，但是每个对象的处理条件或权限不同。 职责链负责解决这样的问题，将每一级写成对象后，排成一个链表。而每一级的执行顺序，交由客户端来管理。 Handler：抽象处理者，successor负责对下一级的引用，通过successor，处理者们可以连成一条链 ConcreteHandler：具体处理者，继承抽象处理者，负责具体实现对请求的响应。 职责链模式代码模板： 1234567891011121314151617181920212223// 抽象处理者class Handler &#123;public: void setSuccessor(const std::shared_ptr&lt;Handler&gt;&amp; successor) &#123; successor_ = successor; &#125; virtual void handleRequest(const Request&amp; request) = 0;protected: std::shared_ptr&lt;Handler&gt; successor_;&#125;;// 具体处理者class ConcreteHandler : public Handler &#123;public: void handleRequest(const Request&amp; request) &#123; if(/*满足某个条件*/) &#123; // TO DO &#125; else &#123; successor_-&gt;handleRequest(request); &#125; &#125;&#125;; 📌职责链模式更细分的话也有两种：纯职责链和非纯职责链纯职责链中，每一级直接完全承担对请求的响应；非纯职责链中，每一级承担部分响应工作。 针对上面的例子，使用职责链模式修改的结果如下： 1234567891011121314151617181920212223242526272829303132333435// 采购请求处理类：抽象处理类class PurchaseRequestHandler &#123;public: void setSuccessor(const std::shared_ptr&lt;PurchaseRequestHandler&gt;&amp; successor) &#123; successor_ = successor; &#125; virtual void handlePurchaseRequest(const PurchaseRequest&amp; request) = 0;protected: std::shared_ptr&lt;PurchaseRequestHandler&gt; successor_;&#125;;// 主任类：具体处理者class DirectorHandler : public PurchaseRequestHandler &#123;public: void handlePurchaseRequest(const PurchaseRequest&amp; request) &#123; if(request.getAmount() &lt; 50000) &#123; &#125; else &#123; successor_-&gt;handlePurchaseRequest(request); &#125; &#125;&#125;;... ...// 客户端代码PurchaseRequest request;request.setAmount(1000);std::shared_ptr&lt;PurchaseRequestHandler&gt; director = std::make_shared&lt;DirectorHandler&gt;();std::shared_ptr&lt;PurchaseRequestHandler&gt; vicePresident = std::make_shared&lt;VicePresidentHandler&gt;();std::shared_ptr&lt;PurchaseRequestHandler&gt; president = std::make_shared&lt;PresidentHandler&gt;();std::shared_ptr&lt;PurchaseRequestHandler&gt; congress = std::make_shared&lt;CongressHandler&gt;();director-&gt;setSuccessor(vicePresident);vicePresident-&gt;setSuccessor(president);president-&gt;setSuccessor(congress);director-&gt;handlePurchaseRequest(request); 优点： 由客户端负责职责链的创建，链中对象不需要知道链的结构，降低了系统耦合度 灵活性更强，添加一个新的具体请求处理者时无需更改原有系统的代码，只需要在客户端重新建链即可，符合开闭原则。 缺点： 可能会出现循环引用的问题，导致系统进入死循环 系统性能受到一定影响，代码调试时不太方便 由于一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理。 16 状态模式（State）状态模式将各种可能的行为构建成了状态机，每次请求时自动切换状态（更改行为）。 应用场景： 在软件开发过程中，应用程序中的有些对象可能会根据不同的情况做出不同的行为，我们把这种对象称为有状态的对象，而把影响对象行为的一个或多个动态变化的属性称为状态。当有状态的对象与外部事件产生互动时，其内部状态会发生改变，从而使得其行为也随之发生改变。如人的情绪有高兴的时候和伤心的时候，不同的情绪有不同的行为，当然外界也会影响其情绪变化。 状态模式流程： 传统方案可能会选择用if…else…来进行分支，涵盖所有的行为。这样的话不符合开闭原则不易维护扩展。状态模式将每种状态及其行为封装成了具体状态类ConcreteState，而所有的具体状态类继承自抽象状态类。用户与Context类交互，Context记录着当前系统的状态，当用户请求时，Context对象将根据当前状态调用具体状态类的行为，同时根据发生的行为更改自己维护的状态，以供下一次请求使用。本质上，在类之间建立状态机，而状态转换的规则维护在了各个具体状态类中。 123456789101112131415161718class Context&#123;public: Context()&#123; m_pState = ConcreteStateA::Instance(); &#125;; virtual ~Context(); void changeState(State * st)&#123; m_pState = st; &#125;; void request()&#123; m_pState-&gt;handle(this); &#125;;private: State *m_pState;&#125;; 12345678910111213141516171819202122class ConcreteStateA : public State&#123;public: virtual ~ConcreteStateA(); static State * Instance()&#123; if ( NULL == m_pState) &#123; m_pState = new ConcreteStateA(); &#125; return m_pState; &#125;; virtual void handle(Context * c)&#123; cout &lt;&lt; &quot;doing something in State A.\\n done,change state to B&quot; &lt;&lt; endl; c-&gt;changeState(ConcreteStateB::Instance()); &#125;;private: ConcreteStateA(); static State * m_pState;&#125;; 12345678910111213141516int main(int argc, char *argv[])&#123; char a = &#x27;0&#x27;; if(&#x27;0&#x27; == a) cout &lt;&lt; &quot;yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;no&quot; &lt;&lt; endl; Context * c = new Context(); c-&gt;request(); c-&gt;request(); c-&gt;request(); delete c; return 0;&#125; 优点： 相比于if…else…进行状态变更与判断，状态模式符合单一职责原则，而且开闭原则也支持得更好一些。 缺点： 对开闭原则仍然不是很友好，想扩展新状态就必须修改若干具体状态类的源码，修改行为也需要修改对应的源码。因此需要开发者尽可能事先考虑到所有的可能状态。 17 迭代器模式（Iterator）迭代器提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。 优点： 访问一个聚合对象的内容而无需暴露它的内部表示 遍历任务交由迭代器完成，简化了聚合类（聚合类可以不用操心实现迭代的功能） 支持以不同的方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历 增加新的聚合类和迭代器类都很方便，无需修改原有代码 封装性良好，为遍历不同的聚合结构提供一个统一的接口 C++的STL自带了Iterator，无需再手动实现。然而为了能够更直观的看迭代器模式是怎么操作的，这里简单写了一下： Aggregate 12345678class Aggregate&#123;public: virtual int count() = 0; virtual void push(const std::string&amp; strValue) = 0; virtual std::string operator[](int nIndex) = 0; virtual Iterator* createIterator() = 0;&#125;; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class ConcreteAggregate : public Aggregate&#123;public: ~ConcreteAggregate(); int count() override; void push(const std::string&amp; strValue)override; //重载下标运算符，只重载了取值功能 std::string operator[](int nIndex); Iterator* createIterator();private: std::vector&lt;std::string&gt; m_vecItems; Iterator* m_pIterator&#123; nullptr &#125;;&#125;;ConcreteAggregate::~ConcreteAggregate()&#123; if (nullptr != m_pIterator) &#123; delete m_pIterator; m_pIterator = nullptr; &#125;&#125;int ConcreteAggregate::count()&#123; return m_vecItems.size();&#125;void ConcreteAggregate::push(const std::string&amp; strValue)&#123; m_vecItems.push_back(strValue);&#125;std::string ConcreteAggregate::operator[](int nIndex)&#123; std::string strRet; if (nIndex &lt; count()) &#123; strRet = m_vecItems[nIndex]; &#125; return strRet;&#125;Iterator* ConcreteAggregate::createIterator()&#123; if (nullptr == m_pIterator) &#123; m_pIterator = new ConcreteIterator(this); &#125; return m_pIterator;&#125; Iterator 12345678class Iterator&#123;public: virtual std::string first() = 0; virtual std::string next() = 0; virtual bool isDone() = 0; virtual std::string currentItem() = 0;&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344class ConcreteIterator : public Iterator&#123;public: ConcreteIterator(Aggregate* pAggregate); std::string first(); std::string next(); bool isDone(); std::string currentItem();private: Aggregate* m_pAggregate&#123; nullptr &#125;; int m_nCurrent&#123; 0 &#125;;&#125;;ConcreteIterator::ConcreteIterator(Aggregate* pAggregate) :Iterator(), m_pAggregate(pAggregate)&#123;&#125;std::string ConcreteIterator::first()&#123; return (*m_pAggregate)[0];&#125;std::string ConcreteIterator::next()&#123; std::string strRet; m_nCurrent++; if (m_nCurrent &lt; m_pAggregate-&gt;count()) &#123; strRet = (*m_pAggregate)[m_nCurrent]; &#125; return strRet;&#125;bool ConcreteIterator::isDone()&#123; return (m_nCurrent &gt;= m_pAggregate-&gt;count()) ? true : false;&#125;std::string ConcreteIterator::currentItem()&#123; return (*m_pAggregate)[m_nCurrent];&#125; client 12345678910111213141516171819202122232425void client()&#123; ConcreteAggregate* pName = new ConcreteAggregate(); if (nullptr != pName) &#123; pName-&gt;push(&quot;墨白&quot;); pName-&gt;push(&quot;金戈铁马&quot;); pName-&gt;push(&quot;气吞万里如虎&quot;); &#125; Iterator* iter = pName-&gt;createIterator(); if (nullptr != iter) &#123; std::string strItem = iter-&gt;first(); while (!iter-&gt;isDone()) &#123; std::cout &lt;&lt; iter-&gt;currentItem() &lt;&lt; std::endl; iter-&gt;next(); &#125; &#125; std::cout &lt;&lt; &quot;================================&quot; &lt;&lt; std::endl; for (int i = 0; i &lt; pName-&gt;count(); ++i) &#123; std::cout &lt;&lt; (*pName)[i] &lt;&lt; std::endl; &#125;&#125; 18 访问者模式（Visitor） 访问者模式表示一个作用于某对象结构中各元素的操作，它使我们可以在不改变各元素的类的前提下，定义作用于这些元素的新操作。 应用场景： 某对象结构中，各元素的类型可能不一致，而上层需要一个对各元素具体操作的统一接口。 Visitor：抽象访问者，为ObjectStructure类中每一个元素声明一个访问操作。 ConcreteVisitor：具体访问者，针对集合中的各具体类型，定义具体访问操作。 Element：抽象元素，即集合中的所有具体元素均继承自该抽象元素类，定义了一个accpet( )方法，方法以一个抽象访问者作为参数。 ConcreteElement：具体元素，实现了Accpet( )方法。接收不同的ConcreteVisitor对象作为参数，就表示在使用不同的集合元素操作方式。 ObjectStructure：元素的集合，各元素可能属于不同类型，类提供了遍历其内部元素的方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;iostream&gt; #include &lt;vector&gt;using namespace std;class ConcreteElementA;class ConcreteElementB;/*抽象访问者 声明了访问元素对象的方法，通常为每一种类型的元素对象都提供一个访问方法*/class Visitor&#123;public: virtual void VisitConcreteElementA(ConcreteElementA *pElementA) = 0; virtual void VisitConcreteElementB(ConcreteElementB *pElementB) = 0;&#125;;/*具体访问者 用于定义对不同类型元素对象的操作*/class ConcreteVisitor1 : public Visitor&#123;public: void VisitConcreteElementA(ConcreteElementA *pElementA)&#123; // 现在根据传进来的pElementA，可以对ConcreteElementA中的element进行操作 &#125; void VisitConcreteElementB(ConcreteElementB *pElementB)&#123; // 现在根据传进来的pElementB，可以对ConcreteElementB中的element进行操作 &#125;&#125;;/*具体访问者2*/class ConcreteVisitor2 : public Visitor&#123;public: void VisitConcreteElementA(ConcreteElementA *pElementA)&#123; &#125; void VisitConcreteElementB(ConcreteElementB *pElementB)&#123; &#125;&#125;;/*抽象元素类 声明accept()方法，用于接受访问者的访问*/class Element&#123;public: virtual void Accept(Visitor *pVisitor) = 0;//accept用于接受访问者的访问&#125;;/*具体元素类 通过调用Visitor类的visit()方法实现对元素的访问*/class ConcreteElementA : public Element&#123;public: void Accept(Visitor *pVisitor)//通过调用visitor对象的 visit()方法实现对元素对象的访问 &#123; pVisitor-&gt;VisitConcreteElementA(this); &#125;&#125;;/*具体元素类 */class ConcreteElementB : public Element&#123;public: void Accept(Visitor *pVisitor) &#123; pVisitor-&gt;VisitConcreteElementB(this); &#125;&#125;;// ObjectStructure类(对象结构类)，能枚举它的元素，可以提供一个高层的接口以允许访问者访问它的元素class ObjectStructure&#123;public: void Attach(Element *pElement)&#123; elements.push_back(pElement); &#125; void Detach(Element *pElement) &#123; vector&lt;Element *&gt;::iterator it = find(elements.begin(), elements.end(), pElement); if (it != elements.end()) &#123; elements.erase(it); &#125; &#125; void Accept(Visitor *pVisitor)&#123; // 为每一个element设置visitor，进行对应的操作 for (vector&lt;Element *&gt;::const_iterator it = elements.begin(); it != elements.end(); ++it) &#123; (*it)-&gt;Accept(pVisitor); &#125; &#125;&#125;int main()&#123; //实例化对象结构，用于存放元素对象，提供遍历其内部元素的方法 ObjectStructure *pObject = new ObjectStructure; //实例化具体元素 并将创建好的元素放入对象结构中 ConcreteElementA *pElementA = new ConcreteElementA; ConcreteElementB *pElementB = new ConcreteElementB; pObject-&gt;Attach(pElementA); pObject-&gt;Attach(pElementB); //实例化访问者 ConcreteVisitor1 *pVisitor1 = new ConcreteVisitor1; ConcreteVisitor2 *pVisitor2 = new ConcreteVisitor2; //调用accept方法 来接受访问者对象的访问 pObject-&gt;Accept(pVisitor1); pObject-&gt;Accept(pVisitor2); if (pVisitor2) delete pVisitor2; if (pVisitor1) delete pVisitor1; if (pElementB) delete pElementB; if (pElementA) delete pElementA; if (pObject) delete pObject; return 0; 优点： 将数据结构和作用于数据结构之上的操作之间的耦合解开，使得操作数据结构集合可以相对自由的演化。换言之，如果系统的数据结构稳定的话，使用访问者模式使得算法更改或者增加变得很容易，只需添加新的具体访问者类即可。 符合单一职责原则，访问者模式把相关的行为封装在一起，使每一个访问者的功能都比较单一。 缺点： 虽然扩展面向数据结构的算法会比较容易，但是增加新的元素类会变得困难。每增加一个新的元素类都意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者中增加相应的具体操作，违背了开闭原则。 违反了依赖倒置原则，访问者模式依赖了具体类，而没有依赖抽象类。 19 备忘录模式（Memento） Memento 在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它 以打游戏为例，当通过一关时往往会选择存档，下次再玩时就可以从存档的地方开始，而不需要从头开玩。这里就用到了备忘录模式，通过记录状态，而避免不必要的重复劳动。 很多应用软件都提供了这项功能，如 Word、记事本、Photoshop、Eclipse 等软件在编辑时按 Ctrl+Z 组合键时能撤销当前操作，使文档恢复到之前的状态；还有在 IE 中的后退键、数据库事务管理中的回滚操作、玩游戏时的中间结果存档功能、数据库与操作系统的备份操作、棋类游戏中的悔棋功能等都属于这类。 实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Memento &#123; // 备忘录private: string state;public: Memento(string s) &#123; state = s; &#125; string GetState() &#123; return state; &#125; void SetState(string s) &#123; state = s; &#125;&#125;;class Caretaker &#123; // 管理者private: Memento* menento;public: // Caretaker(Memento* m) &#123; menento = m; &#125; Memento* GetMemento() &#123; return menento; &#125; void SetMemento(Memento* m) &#123; menento = m; &#125; ~Caretaker() &#123; delete menento; &#125;&#125;;class Originator &#123; // 发起人private: string state; // 需要保存的属性public: string GetState() &#123; return state; &#125; void SetState(string s) &#123; state = s; &#125; Memento* CreateMemento() &#123; return new Memento(state); &#125; // 创建备忘录对象，保存信息 void SetMemento(Memento* m) &#123; state = m-&gt;GetState(); &#125; // 恢复备忘录 void Show() &#123; cout &lt;&lt; &quot;state: &quot; &lt;&lt; state &lt;&lt; endl; &#125;&#125;;int main() &#123; Originator* o = new Originator(); o-&gt;SetState(&quot;On&quot;); o-&gt;Show(); // state: On Caretaker* c = new Caretaker(); c-&gt;SetMemento(o-&gt;CreateMemento()); // 保存状态 o-&gt;SetState(&quot;Off&quot;); o-&gt;Show(); // state: Off o-&gt;SetMemento(c-&gt;GetMemento()); // 恢复初始状态 o-&gt;Show(); // state: On delete o; delete c; return 0;&#125; 优点： 提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。 实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。 发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合。 缺点： 资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。 20 命令模式（Command） 将一个请求封装成一个对象，使发出请求的责任和执行请求的责任分割开。 以12306应用为例： 紧耦合：老版本的12306网站，买票时可以不停地用鼠标点击12306网站上的购票按钮来抢票。对于每一次点击，服务器都要进行处理，做出响应，来告诉用户有没有买到票，这样的话会出现很多次无效的点击，增加了服务器的负担。 此时，发出请求和执行请求，二者进入了紧耦合的状态。用户（命令发送者）通过按钮（具体命令）来买票（12306网站服务器成为命令接收者）。 松耦合：新版本的12306网站引入了购票队列机制。当点击购票按钮后，购票请求就进入了相应的购票队列，进入后再次鼠标点击购票时，12306会拒绝新的购票请求，并且告诉用户已经进入了购票队列。处于购票队列的用户也可以选择退出购票队列去购买其他车次的车票。这样就可以有效地减少购票者发送多次无效购票请求的情况。 观察这样的改进方案，可以发现，将前面的发出请求和执行请求解耦了。用户点击按钮后发出请求，请求进入了队列中，此时队列成为了后面流程下具体的请求发送者，不同的请求对应了不同的命令。不同命令需要采取不同的动作，动作是由接收者（服务器）做出的，因此将这些动作都封装成类之后，就可以与相应的命令类绑定。而队列发出请求后，先找到相应的命令，再由命令执行绑定的接收者的动作。命令中可以结合备忘录模式记录状态，而队列里可以实现消除无效点击的代码。 也就是说，核心在请求的发送者和请求的执行者之间增加了“命令”和新的“请求管理者”，以解耦二者。命令便于对功能进行扩展。如果想有新的按钮功能，实现新的具体命令类即可，同时具体命令类中可以记录状态，这样请求管理者就方便做撤销、重做等操作。 应用场景： 软件开发系统中，常常出现“方法的请求者”与“方法的实现者”之间存在紧密的耦合关系，不利于软件功能的扩展与维护。比如，想对行为进行“撤销、重做、记录”等处理都不方便。 命令模式旨在将“请求者”和“实现者”解耦，通过在二者之间增加“命令”。命令中可以记录状态，进行撤销等操作。想要扩展功能，也就可以实现新的具体命令类或新的具体接收者类。 Command：抽象命令类，声明响应请求时待执行操作的接口。 ConcreteCommand：具体命令类，绑定一个接收者，通过让接收者做出动作来执行命令。 &amp;#x20;Execute方法来调用相应的Receiver对象，从而响应请求。也可以实现其他方法来扩展此命令下的可选操作。 Invoker：与客户端直接相关，请求的发送者或者请求的管理者。 Receiver：真正的接收者，实现响应请求需要做的动作。 12345678910111213141516171819202122232425262728293031323334353637383940414243/// @brief 抽象命令类, 声明执行命令的接口class AbstractCommand &#123;public: virtual ~AbstractCommand() &#123;&#125; virtual void Execute() = 0;&#125;;/// @brief 命令接收者, 执行命令功能的相关操作，是具体命令对象业务的真正实现者class Receiver &#123;public: void Action() &#123; printf(&quot;this is Receiver::Action!\\n&quot;); &#125;&#125;;/// @brief 具体命令类, 它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作class ConcreteCommand : public AbstractCommand &#123;public: ConcreteCommand() &#123; receiver_.reset(new Receiver()); &#125; virtual void Execute() &#123; receiver_-&gt;Action(); &#125;private: std::shared_ptr&lt;Receiver&gt; receiver_;&#125;;/// @brief 命令请求者, 请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者class Invoker&#123;public: Invoker(AbstractCommand* cmd) : cmd_(cmd) &#123;&#125; void SetCommand(AbstractCommand* cmd) &#123; cmd_ = cmd; &#125; void Request() &#123; cmd_-&gt;Execute(); &#125;private: AbstractCommand* cmd_;&#125;; main函数 123456int main()&#123; std::shared_ptr&lt;AbstractCommand&gt; cmd(new ConcreteCommand()); Invoker client(cmd.get()); client.Request(); return 0;&#125; 优点： 降低系统的耦合度，将调用操作的对象与实现该操作的对象解耦。 增加或删除命令非常方便。增加或删除操作不会影响其他类，满足开闭原则。 可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。 方便实现Undo和Redo操作。命令模式可以与备忘录模式结合，实现命令的撤销与恢复。 宏命令前面提到，命令模式可以与组合模式相结合，从而让多个命令共同组装为一个组合命令，即宏命令。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/// @brief 抽象命令类, 声明执行命令的接口class AbstractMacroCommand &#123;public: virtual ~AbstractMacroCommand() &#123;&#125; virtual void Execute() = 0;&#125;;/// @brief 命令接收者, 执行命令功能的相关操作，是具体命令对象业务的真正实现者class CompositeReceiver &#123;public: void ActionA() &#123; printf(&quot;this is CompositeReceiver::ActionA!\\n&quot;); &#125; void ActionB() &#123; printf(&quot;this is CompositeReceiver::ActionB!\\n&quot;); &#125;&#125;;/// @brief 具体命令类, 它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作class ConcreteCommandA : public AbstractMacroCommand &#123;public: ConcreteCommandA() &#123; receiver_.reset(new CompositeReceiver()); &#125; virtual void Execute() &#123; receiver_-&gt;ActionA(); &#125;private: std::shared_ptr&lt;CompositeReceiver&gt; receiver_;&#125;;class ConcreteCommandB : public AbstractMacroCommand &#123;public: ConcreteCommandB() &#123; receiver_.reset(new CompositeReceiver()); &#125; virtual void Execute() &#123; receiver_-&gt;ActionB(); &#125;private: std::shared_ptr&lt;CompositeReceiver&gt; receiver_;&#125;;/// @brief 命令请求者, 请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者class CompositeInvoker&#123;public: void AddCommand(AbstractMacroCommand* cmd) &#123; cmds_.emplace_back(cmd); &#125; void RemoveCommand(AbstractMacroCommand* cmd) &#123; for (auto it = cmds_.begin(); it != cmds_.end(); it++) &#123; if (cmd == (*it)) &#123; cmds_.erase(it++); break; &#125; &#125; &#125; void Request() &#123; for (auto* cmd : cmds_) &#123; cmd-&gt;Execute(); &#125; &#125;private: std::vector&lt;AbstractMacroCommand*&gt; cmds_;&#125;;int main() &#123; std::shared_ptr&lt;AbstractMacroCommand&gt; cmd_A(new ConcreteCommandA()); std::shared_ptr&lt;AbstractMacroCommand&gt; cmd_B(new ConcreteCommandB()); CompositeInvoker client; client.AddCommand(cmd_A.get()); client.AddCommand(cmd_B.get()); client.Request(); return 0;&#125; 21 解释器模式（Interpreter）以大数据统计为例：在大数据统计中，通常需要按照计算模型对现有数据统计、分析、预测。由于计算模型有很多，而且总是在更新，因此系统设计时需要具备高扩展性。 一般计算模型中包含两类符号：数据和计算符，可以将二者解耦，同时让各个计算符均为一个类，继承自抽象运算符类。这样，当需要更改一个运算符的行为时，仅更改该类的实现即可。而且想要扩展计算模型，增加新的具体计算符类即可。 解释器模式：定义一个语法，定义一个解释器，该解释器处理该语法句子。 类比到上面的例子，众多运算符操作的集合就是解释器，而语法就是在运算符类中实现的。解释器模式的结构如下：客户端给出表达式（算法模型），Context类将表达式分解为各种符号的组合。而抽象表达式类提供interpret的统一接口，其下分为终结符号和非终结符号两种。终结符号一般是数值、数据，而非终结符号一般为运算符，比如加减乘除四则运算。 当然，终结符号也可以扩展，比如从实数改为复数，那么仅需该TerminalExpression的具体实现即可，由于调用该类对象时会使用→interpret方法，因此NonterminalExpression可以改动很小甚至不改。 举一个更具体的例子——计算器。计算器的算法模型是逆波兰式，Calculator就相当于Context，在运算符实现时仅需针对数据类型实现四则运算即可。 （下面的代码实现并不好，可用职责链模式进一步优化） 抽象表达式类Node（抽象节点） 1234//抽象表达式类Node（抽象节点）class Node &#123; public: virtual int interpret() = 0; 终结符表达式类ValueNode（值节点类） 12345678910111213//终结符表达式类ValueNode（值节点类）class ValueNode : public Node &#123; public: ValueNode(int value) &#123; this-&gt;value = value; &#125; int interpret()&#123; return this-&gt;value; &#125; private: int value = 0;&#125;; 抽象非终结符表达式类SymbolNode（符号节点类） 1234567891011//抽象非终结符表达式类SymbolNode（符号节点类）class SymbolNode : public Node &#123; public: SymbolNode(shared_ptr&lt;Node&gt; left,shared_ptr&lt;Node&gt; right) &#123; this-&gt;left = left; this-&gt;right = right; &#125; protected: shared_ptr&lt;Node&gt; left; shared_ptr&lt;Node&gt; right;&#125;; 非终结符表达式类MulNode（乘法节点类） 1234567891011//非终结符表达式类MulNode（乘法节点类）class MulNode : public SymbolNode &#123; public: MulNode(shared_ptr&lt;Node&gt; left,shared_ptr&lt;Node&gt; right) : SymbolNode(left,right) &#123; &#125; int interpret() &#123; return left-&gt;interpret()*right-&gt;interpret(); &#125; &#125;; &amp;#x20;非终结符表达式类DivNode（除法节点类） 1234567891011//非终结符表达式类DivNode（除法节点类）class DivNode : public SymbolNode &#123; public: DivNode(shared_ptr&lt;Node&gt; left,shared_ptr&lt;Node&gt; right) : SymbolNode(left,right) &#123; &#125; int interpret() &#123; return left-&gt;interpret()/right-&gt;interpret(); &#125;&#125;; 非终结符表达式类ModNode（求模节点类） 1234567891011//非终结符表达式类ModNode（求模节点类）class ModNode : public SymbolNode &#123; public: ModNode(shared_ptr&lt;Node&gt; left,shared_ptr&lt;Node&gt; right) : SymbolNode(left,right) &#123; &#125; int interpret() &#123; return left-&gt;interpret()%right-&gt;interpret(); &#125;&#125;; 解析器封装类Calculator（计算器类） 1234567891011121314151617181920212223242526272829303132333435363738394041//解析器封装类Calculator（计算器类）class Calculator &#123; public: void bulid(string statement) &#123; shared_ptr&lt;Node&gt; left,right; stack&lt;shared_ptr&lt;Node&gt; &gt; s; //分割语义 vector&lt;string&gt; statementArr = split(statement,&#x27; &#x27;); //处理语义 for(int i = 0 ; i &lt; statementArr.size() ; i++)&#123; if(statementArr[i] == &quot;*&quot;)&#123; left = s.top(); s.pop(); int val = atoi(statementArr[++i].c_str()); right = make_shared&lt;ValueNode&gt;(val); s.push(make_shared&lt;MulNode&gt;(left,right)); &#125;else if(statementArr[i] == &quot;/&quot;)&#123; left = s.top(); s.pop(); int val = atoi(statementArr[++i].c_str()); right = make_shared&lt;ValueNode&gt;(val); s.push(make_shared&lt;DivNode&gt;(left,right)); &#125;else if(statementArr[i] == &quot;%&quot;)&#123; left = s.top(); s.pop(); int val = atoi(statementArr[++i].c_str()); right = make_shared&lt;ValueNode&gt;(val); s.push(make_shared&lt;ModNode&gt;(left,right)); &#125;else&#123; s.push(make_shared&lt;ValueNode&gt;(atoi(statementArr[i].c_str()))); &#125; &#125; this-&gt;node = s.top(); s.pop(); &#125; int compute()&#123; return node-&gt;interpret(); &#125; private: string statement; shared_ptr&lt;Node&gt; node;&#125;; 客户端测试&amp;#x20; 1234567891011121314151617//客户端测试 int main(void) &#123; //需要解析的语句 string statement = &quot;3 * 4 / 2 % 4&quot;; //解析器 Calculator calculator; calculator.bulid(statement); //计算结果 int result = calculator.compute(); //输出 cout &lt;&lt; statement &lt;&lt; &quot; = &quot; &lt;&lt; result &lt;&lt; endl; return 0; &#125; 优点： 扩展性好：由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。 容易实现： 在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。 缺点： 执行效率较低：解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。 可应用的场景比较少：在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。 22 中介模式（Mediator）一个由很多对象组成的模块，其对象间可能存在错综复杂的关联性。以P2P聊天为例，用户对象之间构成了网状结构，将会导致如下问题： 系统结构复杂：对象之间存在大量的相互关联和调用，若有一个对象发生变化，则需要跟踪和该对象关联的其他所有对象，并进行适当处理。 对象可重用性差：由于一个对象和其他对象具有很强的关联，若没有其他对象的支持，一个对象很难被另一个系统或模块重用，这些对象表现出来更像一个不可分割的整体，职责较为混乱。 系统扩展性低：增加一个新的对象需要在原有相关对象上增加引用，增加新的引用关系也需要调整原有对象，系统耦合度很高，对象操作很不灵活，扩展性差。 中介者模式旨在利用一个中介对象来封装一系列的对象交互，使得各对象间不需要显式地相互引用，从而将耦合松散。 Mediator：抽象中介者 ConcreteMediator：具体中介者 Colleague：抽象同事类，也就是那些相互关联的对象的父类 ConcreteColleague：具体同事类，相互关联的对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/// @brief 抽象同事类, 定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能class AbstractMediator;class AbstractColleague &#123;public: virtual ~AbstractColleague() &#123;&#125; /// @brief 抽象接口 virtual void Receive() = 0; virtual void Send() = 0; /// @brief 设置中介对象 void SetMedium(AbstractMediator* mediator) &#123; mediator_ = mediator; &#125;protected: AbstractMediator* mediator_ = nullptr;&#125;;/// @brief 具体同事类, 抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互class ConcreteColleagueA : public AbstractColleague &#123;public: virtual void Receive(); virtual void Send();&#125;;class ConcreteColleagueB : public AbstractColleague &#123;public: virtual void Receive(); virtual void Send();&#125;;/// @brief 抽象中介类, 中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法class AbstractMediator &#123;public: virtual ~AbstractMediator() &#123;&#125; /// @brief 注册 virtual void Register(AbstractColleague* colleague) = 0; /// @brief 转发 virtual void Relay(AbstractColleague* colleague) = 0;&#125;;/// @brief 具体中介类, 实现中介者接口. 管理同事对象，协调各个同事角色之间的交互关系，依赖于同事角色class ConcreteMediator : public AbstractMediator &#123;public: virtual void Register(AbstractColleague* colleague) &#123; for (auto* c : colleagues_) &#123; if (c == colleague) return; &#125; colleagues_.emplace_back(colleague); colleague-&gt;SetMedium(this); &#125; virtual void Relay(AbstractColleague* colleague) &#123; for (auto* c : colleagues_) &#123; // 转发给除自己外的同事 if (c != colleague) c-&gt;Receive(); &#125; &#125;private: std::list&lt;AbstractColleague*&gt; colleagues_;&#125;;///////////////////////////////////////////////////////// 同事类实现void ConcreteColleagueA::Receive() &#123; printf(&quot;this is ConcreteColleagueA::Receive!\\n&quot;);&#125;void ConcreteColleagueA::Send() &#123; printf(&quot;this is ConcreteColleagueA::Send!\\n&quot;); // 请中介者转发 mediator_-&gt;Relay(this);&#125;void ConcreteColleagueB::Receive() &#123; printf(&quot;this is ConcreteColleagueB::Receive!\\n&quot;);&#125;void ConcreteColleagueB::Send() &#123; printf(&quot;this is ConcreteColleagueB::Send!\\n&quot;); // 请中介者转发 mediator_-&gt;Relay(this);&#125; main函数： 12345678910111213141516int main() &#123; printf(&quot;-------------------- %s --------------------\\n&quot;, __FUNCTION__); std::shared_ptr&lt;AbstractMediator&gt; ptr_md(new ConcreteMediator()); std::shared_ptr&lt;AbstractColleague&gt; ptr_c1(new ConcreteColleagueA()); std::shared_ptr&lt;AbstractColleague&gt; ptr_c2(new ConcreteColleagueB()); ptr_md-&gt;Register(ptr_c1.get()); ptr_md-&gt;Register(ptr_c2.get()); ptr_c1-&gt;Send(); printf(&quot;-----------\\n&quot;); ptr_c2-&gt;Send();&#125; 优点： 简化了对象之间的交互； 将各同事解耦。 缺点： 具体中介者类中包含了同事之间的交互细节，可能会导致具体中介者类非常复杂，让系统难维护。 设计模式思维导图","categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"【置顶】知识管理","slug":"笔记汇总","date":"2022-05-18T08:04:17.000Z","updated":"2022-07-10T13:52:17.382Z","comments":true,"path":"2022/05/18/笔记汇总/","link":"","permalink":"http://example.com/2022/05/18/%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB/","excerpt":"","text":"编程语言 C++ C++基础知识：（更新中）-&gt;链接 参考资料： 《C++语言导学》第一版 《C++ Primer》第五版 《C++新经典：对象模型》第一版 C++三部曲阅读笔记：（开坑未填）-&gt;链接 参考资料： 《Effective C++》 《More Effective C++》 《Effective Modern C++》 C++泛型编程笔记：（开坑未填）-&gt;链接 参考资料： 《C++模板元编程实战：一个深度学习框架的初步实现》 《C++新经典：模板与泛型编程》 Golang Go语言基础知识：（更新中）-&gt;链接 参考资料： B站up主“七米老师”的Go语言系列教程 刘丹冰——Golang修养之路 《Go语言底层原理剖析》 Go语言进阶：（开坑未填）-&gt;链接 参考资料： 《Go语言进阶之路》 JavaScript JS基础：（更新中）-&gt;链接 参考资料： JavaScript——45分钟快速上车 微软官方JavaScript入门教程 Node.js进阶：（开坑未填）-&gt;链接 参考资料： 微软官方Node.js入门教程 Python Python基础知识：（更新中）-&gt;链接 参考资料： 廖雪峰的Python教程 Python Cookbook奇技淫巧：（开坑未填）-&gt;链接 参考资料： Python Cookbook 中文版 Matlab基础：（暂时完结）-&gt;链接 开发工具 Docker：（暂时完结）-&gt;链接 参考资料： Docker官方文档 本人译制的Docker速成视频 WebRTC：（更新中）-&gt;链接 参考资料： 《WebRTC音视频实时互动技术：原理、实战与源码分析》 Kubernetes：（更新中）-&gt;链接 参考资料： 本人译制的Kubernetes速成视频 极客时间《深入剖析Kubernetes》 Pytorch：（更新中）-&gt;链接 参考资料： 莫烦教程 Pytorch官方文档 编程算法 参考资料： ACwing网站 “算法基础课” &amp; “算法提高课” &amp; “算法面试笔试辅导课” 程序员Karl——代码随想录 数学知识 Lyapunov Optimization 参考资料： 次模优化 参考资料： 矩阵论 参考资料： 概率论 参考资料： 经典凸优化理论 参考资料： Stephen Boyd《Convex Optimization》 Majorization Minimization 参考资料： 计算机基础 操作系统：（更新中）-&gt;链接 参考资料： 南京大学蒋炎岩 “操作系统：设计与实现” 数据库 MySQL：（更新中）-&gt;链接 参考资料： 菜鸟教程——MySQL基础 《MySQL是怎样运行的：从根儿上理解MySQL》 分布式系统 MIT 6.824（2020）笔记：（开坑未填）-&gt;链接 参考资料：Simviso网站译制课程 设计模式：（更新中）-&gt;链接 参考资料： 《设计模式的艺术：一本实例驱动的设计模式实践指南》 编译原理：（开坑未填）-&gt;链接 参考资料： 虎书《现代编译原理：C语言描述》 嵌入式开发（属于会的技能，但是否填坑再议） STM32 嵌入式Linux freeRTOS FPGA","categories":[],"tags":[]},{"title":"Hexo使用方法","slug":"hexo使用","date":"2022-05-09T16:38:12.506Z","updated":"2022-07-10T13:38:41.397Z","comments":true,"path":"2022/05/10/hexo使用/","link":"","permalink":"http://example.com/2022/05/10/hexo%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"在线优化利器——李雅普诺夫优化","slug":"Lyapunov Optimization","date":"2022-01-30T10:44:29.000Z","updated":"2022-07-10T13:41:27.525Z","comments":true,"path":"2022/01/30/Lyapunov Optimization/","link":"","permalink":"http://example.com/2022/01/30/Lyapunov%20Optimization/","excerpt":"","text":"Lyapunov Optimization维基百科李雅普诺夫优化介绍 维基百科漂移加罚介绍 浙大赵海亮文档 李雅普诺夫优化旨在，利用李雅普诺夫函数(Lyapunov function)以非负标量的形式描述一个用多维向量表示的状态，通过优化该函数实现逼近用向量表示的原问题的最优解 李雅普诺夫优化的一般步骤 为随机优化问题建模 → 构造队列 → 得到使用李雅普诺夫优化求的解 → 分析解与原始最优解的差距 1. 随机优化建模&amp;#x20; 随机优化问题中的“随机”指的是每个时间片内都有随机事件发生，针对随机事件有相应的策略。定义第t个时隙内产生的所有随机事件为$\\textbf{w}(t)\\triangleq[w_1(t),w_2(t),…,w_n(t)]\\in\\Omega^n$，系统在每个时间片内采取的策略，即“动作”（control action）定义为$\\alpha(t)\\triangleq[\\alpha_1(t),\\alpha_2(t),…,\\alpha_m(t)]\\in\\mathcal{A}^m$，其中$\\Omega^n和\\mathcal{A}^m$分别是随机事件和控制决策的集合。 &amp;#x20; 如果我们的目标函数是$p(t)$，那么在每个时隙t，它会根据发生的随机事件和采取的措施，计算出当前时隙的目标函数值，即$p(t)&#x3D;P(\\textbf{w}(t),\\alpha(t))$，其中$P(\\cdot)$是一个确定的函数。这里的$p(t)$的物理含义可以很丰富，比如令其表示功率，那么问题就是最小化功率消耗；令其为吞吐量的负$p(t)&#x3D;-r(t)$，那么最小化$p(t)$就是在最大化吞吐量。此外，系统中的一系列变量也会受到随机事件和控制决策的影响，可以描述为$y_k(t)&#x3D;Y_k(\\textbf{w}(t),\\alpha(t)),k\\in{1,…,K}$，其中$\\forall k\\in{1,…,K}，Y_k(\\cdot)$均为确定函数。由于最终需要把所有时间片的表现都考虑进去，从而得到最终系统表现，所以在优化目标时，需要优化的是各时间片的目标函数值的平均。 那么随机优化问题的标准形式为： $$\\begin{aligned}\\mathcal{P}1:&amp;\\min_{\\forall t,\\alpha(t)\\in\\mathcal{A}^m}\\lim_{T\\rightarrow\\infty}\\frac 1 T\\sum_{t&#x3D;0}^{T-1}\\mathbb{E}[p(t)]\\s.t.&amp;\\ \\lim_{T\\rightarrow\\infty}\\frac 1 T\\sum_{t&#x3D;0}^{T-1}\\mathbb{E}[y_k(t)]\\le 0,k\\in{1,…,K}\\end{aligned}$$ 2 队列构造&amp;#x20; 李雅普诺夫优化希望将长期约束分割到各个时间片中，在每个时间片约束变量遵守相应的条件，从而使得长期约束不被破坏，即保持稳定。由此，每一个约束$y_k(t)$可以对应一个队列，该队列中的元素随时间片的迭代而进进出出，最终达成保持队列稳定的目标。定义初值为0的队列为： $$Q_k(t+1)&#x3D;\\max{Q_k(t)+y_k(t),0},k\\in{1,2,…,K}$$ 这里的$y_k(t)$可以用$y_k(t)&#x3D;a_k(t)-b_k(t)$，其中$a_k(t)$是进，$b_k(t)$是出，从而实现队列的进出。需要注意的是，这里的$Q_k(t)$并不是队列本身，而是队列的积压量(backlog)。而由于前面随机优化问题中的约束条件，我们希望每一个时间片的$b_k(t)$尽可能大于等于$a_k(t)$，从而使$y_k(t)$尽可能小于等于0。 易得$y_k(t)\\le Q_k(t+1)-Q_k(t)$，对所有时间片累加可得$\\sum_{t&#x3D;0}^{T-1}y_k(t)\\le Q_k(T)-Q_k(0)&#x3D;Q_k(T),k&#x3D;{1,2,…,K}$，取期望可得： $$\\frac 1 T\\sum_{t&#x3D;0}^{T-1}\\mathbb{E}[y_k(t)]\\le \\frac{\\mathbb{E}[Q_k(T)]}T,k\\in{1,2,…,K}$$ 由于前面随机优化的约束$\\lim_{T\\rightarrow\\infty}\\frac 1 T\\sum_{t&#x3D;0}^{T-1}\\mathbb{E}[y_k(t)]\\le 0,k\\in{1,…,K}$，再由于上式，可以得到李雅普诺夫形式的随机优化约束条件$\\lim_{T\\rightarrow\\infty}\\frac{\\mathbb{E}[Q_k(T)]}{T}&#x3D;0,k\\in{1,2,…,K}$。 因此，构造好虚拟队列的随机优化问题新形式可表示为： $$\\begin{aligned}\\mathcal{P}2:&amp;\\min_{\\forall t,\\alpha(t)\\in\\mathcal{A}^m}\\lim_{T\\rightarrow\\infty}\\frac 1 T\\sum_{t&#x3D;0}^{T-1}\\mathbb{E}[p(t)]&amp;(1)\\&amp;s.t.\\lim_{T\\rightarrow\\infty}\\frac{\\mathbb{E}[Q_k(T)]}{T}&#x3D;0,k\\in{1,2,…,K}\\qquad&amp;(2)\\end{aligned}$$ 📌注：其实李雅普诺夫形式的约束条件还有另一种更加严格的表述，即下式，但一般采用上式 $$\\exist\\delta\\le 0,\\lim_{T\\rightarrow 0}\\frac{\\mathbb{E}[Q_k(T)]}T\\le\\delta,k\\in{1,2,…,K}$$ 3 漂移加罚算法(drift plus penalty algorithm)将队列全体用一个向量表示为$(t)\\triangleq[Q_1(t),Q_2(t),…,Q_K(t)]$，则李雅普诺夫函数定义为 $$L(\\Theta(t))\\triangleq\\frac 1 2\\sum_{k&#x3D;1}^KQ_k(t)^2$$ 从而，可利用李雅普诺夫函数描述队列在时隙t的积压量$\\Delta(\\Theta(t))\\triangleq L(\\Theta(t+1))-L(\\Theta(t))$，该式被称为李雅普诺夫漂移(Lyapunov drift)。易得$Q_k(t+1)^2\\le(Q_k(t)+y_k(t))^2,k\\in{1,2,…,K}$，对K个队列进行累加可得 $$\\frac 1 2\\sum_{k&#x3D;1}^KQ_k(t+1)^2\\le\\frac 1 2\\sum_{k&#x3D;1}^KQ_k(t)^2+\\frac 1 2\\sum_{k&#x3D;1}^Ky_k(t)^2+\\sum_{k&#x3D;1}^KQ_k(t)y_k(t)$$ 由于队列的进出都是有限的，因此$\\frac 1 2\\sum_{k&#x3D;1}^Ky_k(t)^2$是存在上界$B&gt;0$的，所以可得 $$\\begin{aligned}\\Delta(\\Theta(t))&amp;\\triangleq\\frac 1 2\\sum_{k&#x3D;1}^KQ_k(t+1)^2-\\frac 1 2\\sum_{k&#x3D;1}^KQ_k(t)^2\\&amp;\\le\\frac 1 2\\sum_{k&#x3D;1}^Ky_k(t)^2+\\sum_{k&#x3D;1}^KQ_k(t)y_k(t)\\le B+\\sum_{k&#x3D;1}^KQ_k(t)y_k(t)\\end{aligned}\\qquad(3)$$ $$\\begin{aligned}\\mathcal{P}3:\\min_{\\forall t,\\alpha(t)\\in\\mathcal{A}^m}\\mathbb{E}[\\Delta(\\Theta(t))+V\\cdot p(t)|\\mathcal{\\Theta}(t)]\\s.t.\\lim_{T\\rightarrow\\infty}\\frac{\\mathbb{E}[Q_k(T)]}{T}&#x3D;0,k\\in{1,2,…,K}\\end{aligned}$$ 其中，V是一个权重，用来调节对二者的重视程度。然而此时计算李雅普诺夫漂移需要下一时隙的排队信息，这样的话无法在当前时隙中求得该问题的解，但是可以利用式(3)对问题$\\mathcal{P}3$进行放缩，从而得到问题$\\mathcal{P}4$ ： $$\\mathcal{P}4:\\min_{\\forall t,\\alpha(t)\\in\\mathcal{A}^m}\\mathbb{E}[B+V\\cdot p(t)+\\sum_{k&#x3D;1}^KQ_k(t)y_k(t)|\\Theta(t)]\\s.t.\\lim_{T\\rightarrow\\infty}\\frac{\\mathbb{E}[Q_k(T)]}{T}&#x3D;0,k\\in{1,2,…,K}$$ 漂移加罚算法（DPP），就是求解$\\mathcal{P}4$的近似最优解从而求解$\\mathcal{P}3$ 算法步骤： （1）在时隙t开头，观察发生的所有随机事件以及所有队列的积压量：$\\textbf{w}(t),\\Theta(t)$ （2）通过求解如下问题确定最优的控制决策$\\alpha^*(t)$： $$\\alpha^*(t)&#x3D;\\argmin_{\\alpha(t)\\in\\mathcal{A}^m}\\mathbb{E}[B+V\\cdot p(t)+\\sum_{k&#x3D;1}^KQ_k(t)y_k(t)|\\Theta(t)]\\qquad(4)$$ （3）$\\forall k\\in{1,2,…,K},Q_k(t+1)&#x3D;\\max{Q_k(t)+y_k(t),0}$更新$Q_k(t)$ （4）$t\\leftarrow t+1$ 📌可以看到漂移加罚算法并没有管约束条件(2)，下方证明算法隐式地满足约束 4 性能分析4.1 计算结果精度 最优$\\textbf{w}-only$策略： $\\textbf{w}-only\\ policy$是指每个时隙内仅依赖于观测到的$\\textbf{w}(t)$选择最优控制动作，而不依赖于队列状态(backlog)的策略。最优$\\textbf{w}-only$则是满足如下条件的$\\textbf{w}-only$策略： 在每个时隙内，采取动作$\\alpha^*(t)$满足： $$P(\\textbf{w}(t),\\alpha^*(t))&#x3D;p^\\Y_k(\\textbf{w}(t),\\alpha^(t))\\le0,\\ k\\in{1,2,…,K}\\qquad(5)$$ 其中$p^*$是不考虑约束条件的原问题$\\mathcal{P}1$的最优目标函数值，即 $$p^*&#x3D;\\min(\\lim_{T\\rightarrow\\infty}\\frac 1 T\\sum_{t&#x3D;0}^{T-1}\\mathbb{E}[p(t)])$$ 📌定理：如果原始问题P1有最优解，那么P1一定存在最优w-only策略 DPP解与最优解之间的差距： 由式(3)&amp;(4)可得， $$\\begin{aligned}\\Delta(\\Theta(t))+V\\cdot p(t)&amp;\\le B+V\\cdot p(t)+\\sum_{k&#x3D;1}^K Q_k(t)y_k(t)\\&amp;&#x3D;B+V\\cdot P(\\textbf{w}(t),\\alpha(t))+\\sum_{k&#x3D;1}^KQ_k(t)Y_k(\\textbf{w}(t),\\alpha(t))\\&amp;\\le B+V\\cdot P(\\textbf{w}(t),\\alpha^*(t))+\\sum_{k&#x3D;1}^KQ_k(t)Y_k(\\textbf{w}(t),\\alpha^*(t))\\end{aligned}$$ 取期望得 $$\\begin{aligned}&amp;\\mathbb{E}[\\Delta(\\Theta(t))+V\\cdot p(t)|\\Theta(t)]\\&amp;\\le B+V\\cdot\\mathbb{E}[P(\\textbf{w}(t),\\alpha^*(t))]+\\sum_{k&#x3D;1}^K\\mathbb{E}[Q_k(t)Y_k(\\textbf{w}(t),\\alpha^*(t))|\\Theta(t)]\\&amp;&#x3D;B+V\\cdot\\mathbb{E}[P(\\textbf{w}(t),\\alpha^*(t))]+\\sum_{k&#x3D;1}^K\\mathbb{E}[Q_k(t)|\\Theta(t)]\\mathbb{E}[Y_k(\\textbf{w}(t),\\alpha^*(t))|\\Theta(t)]\\ (相互独立)\\&amp;\\le B+V\\cdot p^*\\qquad(这是因为式(5))\\end{aligned}$$ 时隙累加，可得 $$\\begin{aligned}(B+V\\cdot p^*)T&amp;\\ge\\sum_{t&#x3D;0}^{T-1}\\mathbb{E}[\\Delta(\\Theta(t))+V\\cdot p(t)|\\Theta(t)]\\&amp;&#x3D;\\mathbb{E}[L(\\Theta(t))-L(\\Theta(0))]+V\\cdot\\sum_{t&#x3D;0}^{T-1}\\mathbb{E}[p(t)|\\Theta(t)]\\&amp;\\ge V\\cdot\\sum_{t&#x3D;0}^{T-1}\\mathbb{E}[p(t)|\\Theta(t)]\\end{aligned}$$ 也就是说$\\mathcal{P}4$得到的近似最优解与不加约束的$\\mathcal{P}1$的最优解之间的关系是一个不等式： $$\\frac1T\\sum_{t&#x3D;0}^{T-1}\\mathbb{E}[p(t)|\\Theta(t)]\\le p^*+\\frac B V\\qquad(6)$$ 所以可知，$\\mathcal{P}4$得到的近似最优解与不加约束的$\\mathcal{P}1$的最优解之间的差距是$O(\\frac 1 V)$的 4.2 队列长度假设存在一个$\\textbf{w}-only$策略，满足$\\exist\\epsilon &gt;0,\\ \\mathbb{E}[Y_k(\\textbf{w}(t),\\alpha^*(t))]\\le-\\epsilon$（不要求是最优$\\textbf{w}-only$策略），那么存在下列不等式： $$\\Delta(\\Theta(t))+V\\cdot p(t)\\le B+V\\cdot P(\\textbf{w}(t),\\alpha(t))+\\sum_{k&#x3D;1}^KQ_k(t)Y_k(\\textbf{w}(t),\\alpha^*(t))\\\\Delta(\\Theta(t))+V\\cdot p_{min}\\le B+V\\cdot p_{max}+\\sum_{k&#x3D;1}^KQ_k(t)Y_k(\\textbf{w}(t),\\alpha^*(t))\\\\begin{aligned}\\mathbb{E}[\\Delta(\\Theta(t))]+V\\cdot p_{min}&amp;\\le B+V\\cdot p_{max}+\\sum_{k&#x3D;1}^K\\mathbb{E}[Q_k(t)]\\mathbb{E}[Y_k(\\textbf{w}(t),\\alpha^*(t))]\\&amp;\\le B+V\\cdot p_{max}+\\sum_{k&#x3D;1}^K\\mathbb{E}Q_k(t)\\end{aligned}$$ 移项，累加可有 $$\\frac 1 T\\sum_{t&#x3D;0}^{T-1}\\sum_{k&#x3D;1}^K\\mathbb{E}[Q_k(t)]\\le\\frac{B+V\\cdot(p_{max}-p_{min})}{\\epsilon}\\qquad(7)$$ 由此可知，平均每时隙内所有队列长度是$O(V)$的 4.3 精度与时间的权衡式(6)和式(7)共同构成了李雅普诺夫优化定理。 时均队列大小是$O(V)$的，其反映算法的执行时间，而计算精度是$O(\\frac 1 V)$的。 也就是说增大V可以获得更加逼近与原始问题$\\mathcal{P}1$最优解的解，而减少V则可以更快的满足约束条件，降低执行时间。所以说，需要调整V，找到算法执行时间与计算结果精度之间的trade-off 4.4 证明漂移加罚算法满足约束条件由前面可得，$\\mathbb{E}[\\Delta(\\Theta(t))]+V\\cdot p_{min}\\le B+V\\cdot p_{max}+\\sum_{k&#x3D;1}^K\\mathbb{E}Q_k(t)$，对时隙进行累加有 $$\\begin{aligned}\\mathbb{E}[L(\\Theta(t))]-\\mathbb{E}[L(\\Theta(0))]&amp;\\le(B+V(p_{max}-p_{min}))\\cdot T-\\epsilon\\sum_{t&#x3D;0}^{T-1}\\sum_{k&#x3D;1}^K\\mathbb{E}[Q_k(t)|\\Theta(t)]\\&amp;\\le B’\\cdot T\\end{aligned}$$ $$\\frac 1 2\\sum_{k&#x3D;1}^K\\mathbb{E}[Q_k(T)^2]\\le B’\\cdot T\\(\\sum_{k&#x3D;1}^K\\mathbb{E}[Q_k(T)])^2\\le K\\sum_{k&#x3D;1}^K\\mathbb{E}[Q_k(T)^2]\\le 2KB’\\cdot T$$ 取极限有 $$\\lim_{T\\rightarrow\\infty}\\frac{\\sum_{k&#x3D;1}^K\\mathbb{E}[Q_k(T)]}T\\le\\lim_{T\\rightarrow\\infty}\\sqrt{\\frac{2KB’}T}&#x3D;0$$ 又由于$Q_k(t)\\ge 0$，所以有 $$\\forall k\\in{1,2,…,K},\\lim_{T\\rightarrow\\infty}\\frac{\\mathbb{E}[Q_k(T)]}T&#x3D;0$$ 即，在漂移加罚算法的执行过程中，约束条件(2)是一直成立的 5 Case Study5.1 LODCO其中$B’&#x3D;B+V\\cdot(p_{max}-p_{min})$，代入李雅普诺夫函数和柯西不等式$(\\sum_{i&#x3D;1}^nx_iy_i)^2\\le(\\sum_{i&#x3D;1}^nx_i^2)(\\sum_{i&#x3D;1}^ny_i^2)$可得 将前文所述的$p(t)$作为惩罚项(penalty)，同时求解李雅普诺夫漂移和惩罚项的最小值，便可以得到新问题","categories":[{"name":"数学","slug":"数学","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数学方法","slug":"数学方法","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6%E6%96%B9%E6%B3%95/"}]},{"title":"分式优化求解利器——Dinkelbach","slug":"Dinkelbach Approach/Dinkelbach Approach","date":"2022-01-03T07:47:26.000Z","updated":"2022-07-10T11:30:00.621Z","comments":true,"path":"2022/01/03/Dinkelbach Approach/Dinkelbach Approach/","link":"","permalink":"http://example.com/2022/01/03/Dinkelbach%20Approach/Dinkelbach%20Approach/","excerpt":"","text":"Dinkelbach Approach 问题描述：给定两个连续函数$ f:\\mathbf R^n\\rightarrow\\mathbf R $和$g:\\mathbf R^n\\rightarrow \\mathbf R$。二者定义域为多面体(polyhedral)集合$S\\subset\\mathbf R^n$使得对于所有$x\\in S$都有$g(x)&gt;0$。需要找到一个分式规划问题的最优解$x^*$满足$\\frac{f(x^*)}{g(x^*)}&#x3D;\\max\\limits_{x\\in S}\\frac{f(x)}{g(x)}$ (P)。 Dinkelbach方法，简言之，将原问题P简化为一个全局优化问题(GP)：$\\max\\limits_{x\\in S}(f(x)-\\lambda g(x))$。 朴素Dinkelbach 📌定理1：$ x^* $是分式规划问题(P)的解，当且仅当其是全局优化问题(GP)有约束$\\lambda^*&#x3D;\\frac{f(x^*)}{g(x^*)}$时的解。 朴素Dinkelbach算法流程： 选取$x^{(0)}\\in S$。设置$\\lambda^{(0)}:&#x3D;f(x^{(0)})&#x2F;g(x^{(0)}),\\ k:&#x3D;0$； 求解全局优化问题：$\\max\\limits_{x\\in S}(f(x)-\\lambda^{(k)}g(x))$，得到当前解$x^{(k+1)}$； 若$f(x^{(k+1)})-\\lambda^{(k)}g(x^{(k+1)})&#x3D;0$，那么最优解产生$ x^*&#x3D;x^{(k+1)},\\ \\lambda^*:&#x3D;\\lambda^{(k)} $，算法停止； 若$f(x^{(k+1)})-\\lambda^{(k)}g(x^{(k+1)})&gt;0$，那么设置$\\lambda^{(k+1)}:&#x3D;f(x^{(k+1)})&#x2F;g(x^{(k+1)}),\\ k:k+1$后，回到步骤2。 注：不需要验证$f(x^{(k+1)})-\\lambda^{(k)}g(x^{(k+1)})&lt;0$的情况。（可以用反证法证明）对所有$k$都有 $$f(x^{(k+1)})-\\lambda^{(k)}g(x^{(k+1)})&#x3D;\\max\\limits_{x\\in S}f((x)-\\lambda^{(k)}g(x))\\ge f(x^{(k)})-\\lambda^{(k)}g(x^{(k)})&#x3D;0$$ 算法有效性分析考虑函数$M(\\lambda)&#x3D;\\max\\limits_{x\\in S}(f(x)-\\lambda g(x))$。可以知道其符合以下性质： 对于所有$\\lambda&lt;\\lambda^*$有$M(\\lambda)&gt;0$且对于所有$\\lambda&gt;\\lambda^*$有$M(\\lambda)&lt;0$； $M(\\lambda)$是凸函数。 超线性收敛(converge superlinearly)：若序列$\\alpha^{(0)},\\alpha^{(1)},\\cdots$满足$\\lim\\limits_{n\\rightarrow\\infty}\\frac{|\\alpha^*-\\alpha^{(n+1)}|}{\\theta^{n+1}}&#x3D;0$，其中$\\theta\\in(0,1]$，则称该序列超线性收敛于$\\alpha^*$。 （超线性收敛意味着，序列会收敛，而且以越来越快的速度收敛） 📌引理1：$x^\\in S$是问题(P)的最优解，且$x’$是$M(\\lambda’)$的解满足$\\lambda’&lt;\\lambda^$，那么：$\\lambda^*-\\frac{f(x’)}{g(x’)}\\le(\\lambda^*-\\lambda’)(1-\\frac{g(x^*)}{g(x’)})$其中$0\\le1-g(x^*)&#x2F;g(x’)&lt;1$。 Schaible S. Fractional programming: applications and algorithms[J]. European Journal of Operational Research, 1981, 7(2): 111-120. 对于引理1，令$\\lambda’&#x3D;\\lambda^{(n)}$且$x’&#x3D;x^{(n+1)}$，则$x^{(n+1)}$是$M(\\lambda^{(n)})$的解，那么可以得到每次迭代的误差满足： $$(\\lambda^*-\\lambda^{(n+1)})\\le(\\lambda^*-\\lambda^{(n)})(1-\\frac{g(x^*)}{g(x^{(n+1)})})$$ 令$\\epsilon_i&#x3D;(1-g(x^*)&#x2F;g(x^{(i)})),\\ i&#x3D;1,2,\\cdots$，Schaible的理论表明$\\epsilon_1\\ge\\epsilon_2\\ge\\cdots\\ge0$。序列误差的级联关系可以表示为： $$(\\lambda^*-\\lambda^{(n+1)})\\le(\\lambda^*-\\lambda^{(0)})\\prod_{i&#x3D;1}^{n+1}(1-\\frac{g(x^*)}{g(x^{(i)})})&#x3D;(\\lambda^*-\\lambda^{(0)})\\prod_{i&#x3D;1}^{n+1}\\epsilon_i$$ 此时可以使用第二个引理。 📌引理2：存在一个$x^*\\in S$作为问题P的最优解，使得$\\lim\\limits_{n\\rightarrow\\infty}\\epsilon_n&#x3D;0$ Schaible S. Fractional Programming: Transformations, Duality and Algorithmic Aspects[R]. STANFORD UNIV CALIF DEPT OF OPERATIONS RESEARCH, 1973. 因此，对于任意$\\theta\\in(0,1]$，存在一个整数$n_{\\theta}\\ge0$使得对于所有的$i \\ge n_{\\theta}$，有$\\epsilon_i&lt;\\theta$。 定义常数$\\beta_\\theta&#x3D;\\prod_{i&#x3D;1}^{n_\\theta-1}(\\frac{\\epsilon_i}{\\theta})$，可以有 $$\\frac{\\lambda^*-\\lambda^{(n+1)}}{\\theta^{n+1}}\\le(\\lambda^*-\\lambda^{(0)})\\beta_\\theta\\prod_{i&#x3D;n_\\theta}^{n+1}(\\frac{\\epsilon_i}\\theta)$$ 因此$\\lim_{n\\rightarrow\\infty}\\frac{\\lambda^*-\\lambda^{(n+1)}}{\\theta^{n+1}}&#x3D;0$。 综上所述，序列的下界$\\lambda^{(n+1)}$将会以一个超线性的速率收敛到$\\lambda^*&#x3D;f(x^*)&#x2F;g(x^*)$。 有上界论证的改进Dinkelbach从上面的推导可看出，朴素的Dinkelbach提供了下界的逼近，并没有提供上界的论证。这样可能会导致一个问题。如下图所示。 直线是$M(\\lambda)$（实际情况可能不一定是直线哈，应该是个凸函数，这里只是为了演示方便），目标是最后逼近到$\\lambda^*$。但是朴素Dinkelbach是类似于左边的下界线逼近的，现实情况里，可能很难迭代到$M(\\lambda’)&#x3D;0$，往往都是小于一个$\\delta$就表明收敛。但是其超线性则使$\\lambda^{(n+1)}$有可能在离$\\lambda^*$很远时就已经得到一个足够小的$M(\\lambda^{(n+1)})$，导致最后的结果不够准确。那么如果能够再求得一条上界线从右边逼近，两条线同时逼近时，各自求的$\\lambda$相差足够小，就可以更加精确地找到$\\lambda^*$。 这便是改进版Dinkelbach的思路。 初始上界：分别解$\\max\\limits_{x\\in S}f(x)$和$\\min\\limits_{x\\in S}g(x)$得到$ x’ $和$x’’$，从而得到初始上界$\\gamma^{(-1)}&#x3D;f(x’)&#x2F;g(x’’)$。这必然是一个比$\\lambda^*$大的数，且由于之前所提的$M(\\lambda)$的两条性质，每次迭代的上界都应该满足$M(\\gamma)&lt;0$。定义每一轮的上界为： $$\\gamma^{(k)}:&#x3D;\\gamma^{(k-1)}-M(\\gamma^{(k-1)})\\left(\\frac{\\gamma^{(k-1)}-\\lambda^{(k)}}{M(\\gamma^{(k-1)})-M(\\lambda^{(k)})}\\right)$$ 这个式子的含义如上图所示。接着就可以得到如下改进版Dinkelbach。 改进版Dinkelbach： 选取$x^{(0)}\\in S$。设置$\\lambda^{(0)}:&#x3D;f(x^{(0)})&#x2F;g(x^{(0)})$； 求解问题$\\max\\limits_{x\\in S}f(x)$得到$x’$，求解问题$\\min\\limits_{x\\in S}g(x)$得到$x’’$。设置$\\gamma^{(-1)}:&#x3D;f(x’)&#x2F;g(x’’)$以及$k:&#x3D;0$。若$\\gamma^{(-1)}-\\lambda^{(0)}\\le\\delta$，那么$\\lambda^*:&#x3D;\\lambda^{(0)}$且$x^*:&#x3D;x^{(0)}$，算法停止； 求解全局优化问题$M(\\lambda^{(k)})&#x3D;\\max\\limits_{x\\in S}(f(x)-\\lambda^{(k)}g(x))$，得到$x^{(k+1)}$； 若$M(\\lambda^{(k)})&#x3D;0$，那么$ x^*:&#x3D;x^{(k+1)},\\quad\\lambda^*&#x3D;\\lambda^{(k)} $，算法停止； 求解全局优化问题$M(\\gamma^{(k-1)})&#x3D;\\max\\limits_{x\\in S}(f(x)-\\gamma^{(k-1)}g(x))$，得到$y^{(k)}$； 若$M(\\gamma^{(k-1)})&#x3D;0$，那么$x^*:&#x3D;y^{(k)},\\quad\\lambda^*&#x3D;\\gamma^{(k-1)}$，算法停止； 设置$\\gamma^{(k)}:&#x3D;\\gamma^{(k-1)}-M(\\gamma^{(k-1)})\\left(\\frac{\\gamma^{(k-1)}-\\lambda^{(k)}}{M(\\gamma^{(k-1)})-M(\\lambda^{(k)})}\\right)$； 若$\\gamma^{(k)}-\\lambda^{(k)}\\le\\delta$，那么$ x^*:&#x3D;x^{(k+1)},\\quad\\lambda^*&#x3D;\\lambda^{(k)} $，算法停止； 设置$\\lambda^{(k+1)}:&#x3D;f(x^{(k+1)})&#x2F;g(x^{(k+1)}),\\ k:&#x3D;k+1$，返回步骤3。 算法有效性分析 📌定理2：$ \\lambda^\\le\\gamma^{(i+1)}&lt;\\gamma^{(i)},\\quad i&#x3D;-1,0,1,\\cdots $（这个定理强调的是每个迭代的$\\gamma^{(i)}$都大于等于$\\lambda^$，不会越过$\\lambda^*$） 证明：（其实或许不需要证明，看上面的图即可体会此定理，但写论文还需要严格证明一下）定义连接$(\\lambda^{(n)},M(\\lambda^{(n)}))$和$(\\gamma^{n-1},M(\\gamma^{(n-1)}))$的直线的函数为$L$。由上面可知$\\gamma^{(n)}&#x3D;q\\lambda^{(n)}+(1-q)\\gamma^{(n-1)},\\quad q\\in(0,1)$所以有$\\begin{aligned}&amp;M\\left(\\gamma^{(n)}\\right)&#x3D;M\\left(q \\lambda^{(n)}+(1-q) \\gamma^{(n-1)}\\right) \\leqslant q M\\left(\\lambda^{(n)}\\right)+(1-q) M\\left(\\gamma^{(n-1)}\\right) \\&amp;\\quad&#x3D;q L\\left(\\lambda^{(n)}\\right)+(1-q) L\\left(\\gamma^{(n-1)}\\right) \\&amp;\\quad&#x3D;L\\left(q \\lambda^{(n)}+(1-q) \\gamma^{(n-1)}\\right)&#x3D;L\\left(\\gamma^{(n)}\\right)&#x3D;0\\end{aligned} $所以$M(\\gamma^{(n)})\\le0$，由$M()$函数性质可知$\\lambda^*\\le\\gamma^{(n)}$ 接下来论证上界序列$\\gamma^{(n)}$也是以超线性的速率收敛到$\\lambda^*$的。 拉格朗日中值定理：$f(x)$在闭区间$[a,b]$内连续，在开区间$(a,b)$内可导，则在$(a,b)$内至少有一点$\\epsilon(a&lt;\\epsilon&lt;b)$，使等式$f(b)-f(a)&#x3D;f’(\\epsilon)(b-a)$成立。罗尔中值定理：$f(x)$在闭区间$[a,b]$上连续，在开区间$(a,b)$内可导，且在区间端点处的函数值相等，即$f(a)&#x3D;f(b)$，则在$(a,b)$内至少存在一点$\\epsilon(a&lt;\\epsilon&lt;b)$，使得$f’(\\epsilon)&#x3D;0$。柯西中值定理：如果函数$f(x),g(x)$满足：(1)在闭区间$[a,b]$上连续(2)在开区间$(a,b)$内可导(3)对任意$x\\in(a,b),\\ g’(x)\\notin0$那么在$(a,b)$内至少有一点$\\xi\\in(a,b)$，使得$\\frac{f(b)-f(a)}{g(b)-g(a)}&#x3D;\\frac{f’(\\xi)}{g’(\\xi)}$成立。 考虑第$(n+1)$次迭代时，还没有求出结果，根据定义可知 $$\\begin{equation}\\gamma^{(n+1)}&#x3D;\\gamma^{(n)}-M\\left(\\gamma^{(n)}\\right)\\left(\\frac{\\gamma^{(n)}-\\lambda^{(n+1)}}{M\\left(\\gamma^{(n)}\\right)-M\\left(\\lambda^{(n+1)}\\right)}\\right)\\end{equation}$$ 经过一些代数运算，可得 $$\\begin{equation}\\begin{aligned}&amp;\\left(\\lambda^{}-\\gamma^{(n+1)}\\right)&#x3D;\\left(\\lambda^{}-\\gamma^{(n)}\\right)+M\\left(\\gamma^{(n)}\\right)\\left(\\frac{\\gamma^{(n)}-\\lambda^{(n+1)}}{M\\left(\\gamma^{(n)}\\right)-M\\left(\\lambda^{(n+1)}\\right)}\\right) \\&amp;\\quad&#x3D;\\frac{(\\lambda^*-\\gamma^{(n)})(M(\\gamma^{(n)})-M(\\lambda^{(n+1)}))+M(\\gamma^{(n)})\\gamma^{(n)}-M(\\gamma^{(n)})\\lambda^{(n+1)}}{M(\\gamma^{(n)})-M(\\lambda^{(n+1)})}\\&amp;\\quad&#x3D;\\frac{M(\\gamma^{(n)})(\\lambda^{}-\\lambda^{(n+1)})+M(\\lambda^{(n+1)})(\\gamma^{(n)}-\\lambda^{})}{M(\\gamma^{(n)})-M(\\lambda^{(n+1)})}\\&amp;\\quad&#x3D;-(\\lambda^*-\\lambda^{(n+1)})(\\lambda^*-\\gamma^{(n)})\\frac{\\frac{M(\\gamma^{(n)})-M(\\lambda^*)}{\\gamma^{(n)}-\\lambda^*}-\\frac{M(\\lambda^{(n+1)})-M(\\lambda^*)}{\\lambda^{(n+1)}-\\lambda^*}}{M(\\gamma^{(n)})-M(\\lambda^{(n+1)})}\\&amp;\\quad&#x3D;-(\\lambda^*-\\lambda^{(n+1)})(\\lambda^*-\\gamma^{(n)})\\frac{M’(\\alpha)-M’(\\beta)}{M’(\\zeta_{n+1})[\\gamma^{(n)}-\\lambda^{(n+1)}]}\\&amp;\\quad&#x3D;-(\\lambda^*-\\lambda^{(n+1)})(\\lambda^*-\\gamma^{(n)})\\frac{M’’(\\xi_{n+1})[\\alpha-\\beta]}{M’(\\zeta_{n+1})[\\gamma^{(n)}-\\lambda^{(n+1)}]}\\&amp;\\quad\\le-\\left(\\lambda^{}-\\lambda^{(n+1)}\\right)\\left(\\lambda^{}-\\gamma^{(n)}\\right) \\frac{M^{\\prime \\prime}\\left(\\xi_{n+1}\\right)}{M^{\\prime}\\left(\\zeta_{n+1}\\right)}\\end{aligned}\\end{equation}$$ 其中，$\\xi_{n+1},\\zeta_{n+1}\\in[\\lambda^{(n+1)},\\gamma^{(n)}]$，令$\\kappa&#x3D;\\frac{\\max\\limits_{\\xi\\in I}|M’’(\\xi)|}{\\min\\limits_{\\zeta\\in I}|M’(\\zeta)|}$，$I&#x3D;[\\lambda^{(0)},\\gamma^{(-1)}]$且$I_{n+1}&#x3D;[\\lambda^{(n+1)},\\gamma^{(n)}]\\subset I$，也就是说$ \\kappa $是分式$\\frac{M^{\\prime \\prime}\\left(\\xi_{n+1}\\right)}{M^{\\prime}\\left(\\zeta_{n+1}\\right)}$的上界，因此有 $|\\lambda^*-\\gamma^{(n+1)}|\\le|\\lambda^*-\\lambda^{(n+1)}||\\lambda^*-\\gamma^{(n)}|\\kappa$，逐级推导，有 $$\\begin{equation}\\left|\\lambda^{}-\\gamma^{(n+1)}\\right| \\leqslant \\kappa^{n+2}\\left|\\lambda^{}-\\gamma^{(-1)}\\right| \\prod_{i&#x3D;0}^{n+1}\\left|\\lambda^{*}-\\lambda^{(i)}\\right|\\end{equation}$$ 前面提到$(\\lambda^*-\\lambda^{(n+1)})\\le(\\lambda^*-\\lambda^{(n)})(1-\\frac{g(x^*)}{g(x^{(n+1)})})$，因此可以将不等式进一步拆解成 $$\\begin{equation}\\left|\\lambda^{}-\\gamma^{(n+1)}\\right| \\leqslant \\kappa^{n+2}\\left|\\lambda^{}-\\gamma^{(-1)} | \\lambda^{*}-\\lambda^{(0)}\\right|^{n+2} \\prod_{i&#x3D;1}^{n+1} \\varepsilon_{i}^{n-i+2}\\end{equation}$$ 引理2说明，$\\epsilon$收敛到0。因此对于任意$\\theta\\in(0,1]$，存在整数$n_{\\theta}\\ge0$使得对于所有$i\\ge n_\\theta$都有$ \\kappa|\\lambda^*-\\lambda^{(0)}|\\epsilon_i&lt;\\theta $，因此定义$\\alpha_{\\theta}&#x3D;\\kappa\\left|\\lambda^{}-\\lambda^{(0)}\\right| \\prod_{i&#x3D;1}^{n_{\\theta}-1}\\left(\\frac{\\kappa\\left|\\lambda^{}-\\lambda^{(0)}\\right| \\varepsilon_{i}^{n-i+2}}{\\theta}\\right) $，我们有 $$\\begin{equation}\\frac{\\left|\\lambda^{}-\\gamma^{(n+1)}\\right|}{\\theta^{n+1}} \\leqslant\\left|\\lambda^{}-\\gamma^{(-1)}\\right| \\alpha_{\\theta} \\prod_{i&#x3D;n_{\\theta}}^{n+1}\\left(\\frac{\\kappa\\left|\\lambda^{*}-\\lambda^{(0)}\\right| \\varepsilon_{i}^{n-i+2}}{\\theta}\\right)\\end{equation}$$ 因此，可以得到$\\lim\\limits_{n\\rightarrow\\infty}\\frac{|\\lambda^*-\\gamma^{(-1)}|}{\\theta^{n+1}}&#x3D;0$，也就是说序列上界$\\gamma^{(n+1)}$同样将以超线性的速率收敛到$\\lambda^*$。","categories":[{"name":"数学","slug":"数学","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数学方法","slug":"数学方法","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6%E6%96%B9%E6%B3%95/"}]},{"title":"动态规划（基础）","slug":"动态规划-基础/动态规划-基础","date":"2021-10-18T12:14:55.000Z","updated":"2022-07-10T13:44:29.109Z","comments":true,"path":"2021/10/18/动态规划-基础/动态规划-基础/","link":"","permalink":"http://example.com/2021/10/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%9F%BA%E7%A1%80/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%9F%BA%E7%A1%80/","excerpt":"","text":"动态规划-基础1 背包模型背包模型各子问题特征 问题 特征 零一背包 背包中每件物品最多仅用一次 完全背包 每件物品有无限个 多重背包 每种物品最多Si个 分组背包 N组，每一组里最多只能选一个物品 1.1 零一背包问题 📌有N个物品和一个容量为V的背包，每个物品的体积是Vi，价值是Wi，每件物品仅用一次。要挑选一些物品，使总体积小于等于V，目标让塞进背包的物品总价值最大，求问最大价值 通过01背包可以引出求解DP问题的一般思路 i表示不同的物品，j表示不同容量的背包的体积。f(i,j)就表示满足：从前i个物品中选且总体积小于等于j的所有选法中（集合），价值的最大值（属性）。 状态计算就是一种集合的划分，将当前的集合划分成若干个更小的集合，使得当前集合可以通过更小的集合算出来。而且更小的集合是之前已经算过的。对应到01背包，就是把所有选法分成两大类：不包含第i个物品，和包含第i个物品。 子集划分原则：不重复（不严格要求） &amp; 不漏掉（严格要求） 这里的第2类：包含第i个物品，直接求并不好求，因为可能的情况太多了。这里要曲线救国，先把每种选法里的第i个物品都去掉，此时全部可包含第i物品的选法数是不变的，这些选法的最大价值为f(i-1, j-Vi)，那么再加上W_i，其实就是包含第i个物品的所有选法的最大值。 最终，f(i,j)就是两个子集的最大值，再取一次最大值。 总结一下的话：动态规划的状态就是集合的某种属性（此处是所有选法的最大价值），状态计算的核心就是对集合进行划分。 123456789101112131415161718192021222324//朴素算法代码：二维状态//01背包的状态转移方程：f(i,j) = Max( f(i-1, j), f(i-1, j-Vi)+Wi )#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int n,m; //n物品数, m最大体积int v[N],w[N];int f[N][N];int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++)&#123; //i从1开始，因为f[0][...]必然是0 cin &gt;&gt; v[i] &gt;&gt; w[i]; for(int j = 0; j &lt;= m; j++)&#123; f[i][j] = f[i-1][j]; //不含i的子集是必然存在的 if(j &gt;= v[i]) //判断含i的子集是否可以存在 f[i][j] = max(f[i][j], f[i-1][j-v[i]] + w[i]); &#125; &#125; cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0;&#125; 在朴素二维状态的基础上还可以优化成一维状态，有两个前提： f(i)层只用到了f(i-1)层 —&gt; 滚动数组(迭代器) 两个子集的元素的体积永远小于等于j，而不是在j两侧 所以使用一维数组不同次数的值可以有相当于二维数组不同层的效果 12345678910111213141516171819202122//优化算法代码：一维状态#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int n,m; //n物品数, m最大体积int v[N],w[N];int f[N];int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++)&#123; //i从1开始，因为f[0][...]必然是0 cin &gt;&gt; v[i] &gt;&gt; w[i]; //如果下面for遍历从前向后，相当于使用了f[i][j-v[i]]而非f[i-1][j-v[i]] //因为后一个数用到了前一个数，但前一个数已经在上次迭代中被从i-1更新i //如果反向遍历，后一个数还是会用到前一个数，但此时前一个数未被更新 for(int j = m; j &gt;= v[i]; j--) //注意这里和朴素算法的顺序是反的 f[j] = max(f[j], f[j-v[i]] + w[i]); &#125; cout &lt;&lt; f[m] &lt;&lt; endl; return 0;&#125; 1.2 完全背包问题 📌有N件物品和一个容量为V的背包，每个物品的体积是Vi，价值是Wi，每件物品可用无限次。挑选一些物品，使总体积小于等于V，让塞进背包的物品总价值最大，求问最大价值 完全背包和01背包解法很相似，集合的划分分为两类：不包含第i个物品，和包含第i个物品。只是第2个类别中的曲线救国改成了f( i-1, j-k*Vi)+k*Wi，k是物品i的使用次数 12345678910111213141516171819202122//朴素算法代码：二维状态//完全背包的状态转移方程：f(i,j) = Max( f(i-1, j), f(i-1, j-k*Vi)+k*Wi )#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int n,m; //n物品数, m最大体积int v[N],w[N];int f[N][N];int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++)&#123; //i从1开始，因为f[0][...]必然是0 cin &gt;&gt; v[i] &gt;&gt; w[i]; for(int j = 0; j &lt;= m; j++) for(int k = 0; k*v[i] &lt;= j; k++) //k从0开始，所以其实f[i-1][j]是不需要的 f[i][j] = max(f[i][j], f[i-1][j-k*v[i]] + k*w[i]); &#125; cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0;&#125; 由于上述朴素算法用到三种循环，时间复杂度还是相当高的，可以通过状态转移方程对其优化 123456789101112131415161718192021222324252627//原状态转移方程：f(i,j) = Max( f(i-1,j), f(i-1,j-Vi)+Wi, f(i-1,j-2Vi)+2Wi, ... )//考虑j-Vi： f(i,j-Vi)= Max( f(i-1,j-Vi), f(i-1,j-2Vi)+Wi, ... )//第一次优化：二维状态//优化后的状态转移方程：f(i,j) = Max( f(i-1,j), f(i,j-Vi)+Wi )#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int n,m; //n物品数, m最大体积int v[N],w[N];int f[N][N];int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++)&#123; //i从1开始，因为f[0][...]必然是0 cin &gt;&gt; v[i] &gt;&gt; w[i]; for(int j = 0; j &lt;= m; j++)&#123; f[i][j] = f[i-1][j]; //不含i的子集是必然存在的 if(j &gt;= v[i]) //判断含i的子集是否可以存在 f[i][j] = max(f[i][j], f[i][j-v[i]] + w[i]); &#125; &#125; cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0;&#125; 现在还可以按照01背包的优化方式，进行进一步优化 12345678910111213141516171819//最终优化：一维状态#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int n,m; //n物品数, m最大体积int v[N],w[N];int f[N];int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++)&#123; //i从1开始，因为f[0][...]必然是0 cin &gt;&gt; v[i] &gt;&gt; w[i]; for(int j = v[i]; j &lt;= m; j++) //这里遍历是正向的，因为符合状态转移方程 f[j] = max(f[j], f[j-v[i]] + w[i]); &#125; cout &lt;&lt; f[m] &lt;&lt; endl; return 0;&#125; 📌Tip：动态规划中如果状态转移用到了上一层的内容，就按体积从小到大的顺序遍历；如果用到本层内容，则反过来，使用体积从大到小的顺序 1.3 多重背包问题 多重背包是有限情景下的完全背包，二者的朴素写法几乎是一样的 不能使用完全背包的优化方法来优化多重背包 原方程：f(i,j) &#x3D; Max( f(i-1,j), f(i-1,j-Vi)+Wi, f(i-1,j-2Vi)+2Wi, … , f(i-1,j-SiVi)+SiVi ) j-Vi： f(i,j-Vi) &#x3D; Max( f(i-1,j-Vi), f(i-1,j-2Vi)+Wi, … , f(i-1,j-SiVi)+(Si-1) Vi, &amp;#x20; f(i-1,j-(Si+1)*Vi)+Si*Vi ) 完全背包问题中的k是受背包容量限制的，不会多红字那一项，但多重背包同时受背包容量和Si限制，如果可虑所有情况，就有可能出现红字那一项。那么完全背包所用的优化方法不再适用 📌有N种物品和一个容量为V的背包，每种物品中一件的体积是Vi，价值是Wi，每种物品最多可用Si次。挑选一些物品，使总体积小于等于V，让塞进背包的物品总价值最大，求问最大价值 1234567891011121314151617181920212223//朴素算法代码：二维状态//多重背包的状态转移方程：f(i,j) = Max( f(i-1, j), f(i-1, j-k*Vi)+k*Wi )#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int n,m; //n物品数, m最大体积int v[N],w[N],s[N];int f[N][N];int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++)&#123; cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i]; for(int j = 0; j &lt;= m; j++) for(int k = 0; k*v[i] &lt;= j &amp;&amp; k &lt;= s[i]; k++)//多重和完全的朴素写法不同之处为此处条件 //k从0开始，所以其实f[i-1][j]是不需要的 f[i][j] = max(f[i][j], f[i-1][j-k*v[i]] + k*w[i]); &#125; cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0;&#125; 优化方法：二进制优化！！！ (其实还可以使用单调队列优化，后面的内容) 对于任意大小s[i]，里面所有的数都可以由一系列“二的整数次方”组成，比如s&#x3D;1023 则所有比1023小的数都可以用{1,2,4,8,…,512}组合出来。 又比如200：1,2,4,8,16,32,64,73 那么k的遍历那一环其实就变成了01背包问题，不再需要遍历全部Si次，只需设置log2Si个背包 时间复杂度从NVS到NVlog2S 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 25000, M = 2010;int n,m;int v[N],w[N];int f[N];int main()&#123; cin &gt;&gt; n &gt;&gt; m; int cnt = 0; for(int i = 1; i &lt;= n; i++)&#123;//建立新背包 int a,b,s; cin &gt;&gt; a &gt;&gt; b &gt;&gt; s; int k = 1; while(k &lt;= s)&#123; cnt++; v[cnt] = a * k; w[cnt] = b * k; s -= k; k *= 2; &#125; if(s &gt; 0)&#123; cnt ++; v[cnt] = a * s; w[cnt] = b * s; &#125; &#125; n = cnt; for(int i = 1; i &lt;= n; i++) for(int j = m; j &gt;= v[i]; j-- ) f[j] = max(f[j],f[j-v[i]]+w[i]); cout &lt;&lt; f[m] &lt;&lt;endl; return 0;&#125; 1.4 分组背包问题 📌有N组物品和一个容量为V的背包，每件物品的体积是Vij，价值是Wij，i是组号，j是组内编号，同一组内的物品最多选一个。挑选一些物品，使总体积小于等于V，让塞进背包的物品总价值最大，求问最大价值 热狗划分法(状态计算)： 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 110;int n,m;int v[N][N],w[N][N],s[N]; //s[i]表示第i组有多少物品int f[N];int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1 ;i &lt;= n; i++)&#123; cin &gt;&gt; s[i]; for(int j = 0; j &lt; s[i]; j++ ) cin&gt;&gt;v[i][j]&gt;&gt;w[i][j]; &#125; for(int i = 1; i &lt;= n; i++)&#123; for(int j = m; j &gt;= 0; j--) //因为要用到i-1，所以逆序遍历 for(int k = 0; k &lt; s[i]; k++ ) if(v[i][k] &lt;= j) f[j] = max(f[j],f[j-v[i][k]]+w[i][k]); &#125; cout &lt;&lt; f[m] &lt;&lt; endl; return 0;&#125; 2 线性DP 线性DP就是在线性结构上转移状态，完成线性空间上的递推 2.1 例题1：数字三角形 📌给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大&amp;#x20; 7&amp;#x20; 3 8&amp;#x20; 8 1 0&amp;#x20; 2 7 4 44 5 2 6 5 求解思路： 123456789- 状态表示：f(i,j)：走到(i,j)位置的所有路径的集合的max 集合 属性 第一列第一行 7 第二列第二行 3 8 第三列第三行 8 1 0 第四列第四行 2 7 4 4 第五列第五行 4 5 2 6 5 1234567- 状态计算(令a(i,j)表示(i,j)位置元素的值)分类：左上来的路径 和 右上来的路径 f(i-1,j-1)+a(i,j) f(i-1,j)+a(i,j)⇒状态转移方程：f(i,j) = Max( f(i-1,j-1)+a(i,j) , f(i-1,j)+a(i,j)) ) 代码： 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 512, INF = 1e9;int n;int a[N][N];int f[N][N];int main()&#123; scanf(&quot;%d&quot;, &amp;n); //一共有几行几列 for(int i = 1; i &lt;= n; i++) //获取三角形 for(int j = 1; j &lt;= i; j++) scanf(&quot;%d&quot;,&amp;a[i][j]); for(int i = 1; i &lt;= n; i++) for(int j = 0; j &lt;= i + 1; j++) //这里的列需要从0开始，到i+1结束，补全边缘数字两侧 f[i][j] = -INF; //防止求和为负数时，初值为0的误判 f[1][1] = a[1][1]; for(int i = 2; i &lt;= n; i++) for(int j = 1; j &lt;= i; j++) f[i][j] = max(f[i-1][j-1]+a[i][j], f[i-1][j]+a[i][j]); int res = -INF; for(int i = 1; i &lt;= n; i++)res = max(res,f[n][i]); printf(&quot;%d&quot;, res); return 0;&#125; 2.2 例题2：最大上升子序列 📌给定一个长度为N的数列，求数值严格单调递增的子序列的长度最长是多少，并记录子序列输入样例：7&amp;#x20;3 1 2 1 8 5 6结果：41 2 5 6 朴素方法求解思路： - 状态表示： f[i]：到第i个位置的子序列集合的max - 状态计算： f[i] = f[j]+1, j = 1,2,...,i-1 &amp;&amp; a[j]&lt;a[i] 朴素方法代码： 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int n;int a[N], f[N];int main()&#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]); for (int i = 1; i &lt;= n; i ++ ) &#123; f[i] = 1; // 只有a[i]一个数 for (int j = 1; j &lt; i; j ++ ) if (a[j] &lt; a[i]) f[i] = max(f[i], f[j] + 1); &#125; int res = 0; for (int i = 1; i &lt;= n; i ++ ) res = max(res, f[i]); printf(&quot;%d\\n&quot;, res); return 0;&#125; 优化 求解思路： 对于像 7 3 1 2 1 8 5 6 这样的序列，在走到i时，可以存储i之前的各个长度里的上升子序列中末尾最小值，比如8之前，长度为1的上升子序列的末尾值可以有3和1，但是3是没必要存的，能接在3后也必然能接在1后 而且各个长度的上升子序列的末尾最小值必然严格单调递增 可以用反证法证明这一性质： 若q6比q5小，那么q6所在子序列的第5个值也比q5小，那么q5就不是长度为5的子序列中的最小末尾值，矛盾 于是当走到第i个字符a[i]时，可以查找a[i]之前所有长度子序列中，小于a[i]的最大的末尾最小值。 比如说，q4&lt;a[i]，而q5&gt;a[i]，那么q4就是那个最大的末尾最小值，而且q5将被替换成a[i] 查找最大的末尾最小值时可以使用二分查找。时间复杂度较之前大大减少。 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int n;int a[N];int q[N];int main()&#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]); int len = 0; for (int i = 0; i &lt; n; i ++ ) &#123; int l = 0, r = len; while (l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1; if (q[mid] &lt; a[i]) l = mid; else r = mid - 1; &#125; len = max(len, r + 1); q[r + 1] = a[i]; &#125; printf(&quot;%d\\n&quot;, len); return 0;&#125; 2.3 例题3： 最长公共子序列 📌给定两个长度分别为N和M的字符串A和B，求既是A的子序列又是B的子序列的字符串长度最长是多少输入案例：4 5acbdabedc输出：3(abd) 求解思路： 状态表示： f(i,j)：所有在A序列的前i个字母中出现，并在B序列的前j个字母中出现的子序列的集合中的Max 状态计算： 上述四者分别是 f(i-1, j-1) 、f(i-1, j) 、f(i, j-1) 、f(i-1, j-1)+1 需要注意中间二者，f(i-1, j)并不是严格的01情况，f(i, j-1)也不是严格的10情况 f(i-1,j)是： 所有在A序列的前i-1个字母中出现 并在B序列的前j个字母中出现的子序列集合 01是： 不包含A序列的第i个字母， 但是包含B序列的第j个字母的子序列的集合 前者包含后者，二者并不相等 f(i,j-1)是： 所有在A序列的前i个字母中出现 并在B序列的前j-1个字母中出现的子序列集合 10是： 包含A序列的第i个字母， 但是不包含B序列的第j个字母的子序列的集合 前者包含后者，二者并不相等 求最大值时重复是没有关系的，只要保证不漏就行 事实上第一项f(i-1, j-1)也没有必要写，因为它被f(i-1, j)和f(i, j-1)包含了 代码： 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int n, m;char a[N], b[N];int f[N][N];int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); scanf(&quot;%s%s&quot;, a + 1, b + 1); for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) &#123; f[i][j] = max(f[i - 1][j], f[i][j - 1]); if (a[i] == b[j]) f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1); &#125; printf(&quot;%d\\n&quot;, f[n][m]); return 0;&#125; 2.4 例题4：最短编辑距离 📌给定两个字符串A和B，现在要将A经过若干操作变为B，可进行的操作有：- 删除：将字符串A中的某个字符删除。- 插入：在字符串A的某个位置插入某个字符。- 替换：将字符串A中的某个字符替换为另一个字符。现在请你求出，将A变为B至少需要进行多少次操作。 求解思路： 状态表示： f(i,j)：所有从A[1~i]变到B[1~j]的操作方式的集合的min 状态计算： → 状态转移方程： f(i, j) &#x3D; min( f(i-1, j) + 1, f(i, j-1) + 1, f(i-1, j-1) + 1&#x2F;0 ) 删的前提是A[1~i-1]&#x3D;&#x3D;B[1~j] 增的前提是A[1~i]&#x3D;&#x3D;B[1~j-1] 改的前提是A[1~i-1]&#x3D;&#x3D;B[1~j-1]，如果A[i]&#x3D;&#x3D;B[j]，加0，否则加1 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int n, m;char a[N], b[N];int f[N][N];int main()&#123; scanf(&quot;%d%s&quot;, &amp;n, a+1);//接收a字符串 scanf(&quot;%d%s&quot;, &amp;m, b+1);//接收b字符串 for(int j = 0; j &lt;= m; j++) f[0][j] = j;//a为空时，只能增，增加b的长度 for(int i = 0; i &lt;= n; i++) f[i][0] = i;//b为空时，只能删，删除a的长度 for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; f[i][j] = min(f[i-1][j]+1, f[i][j-1]+1);//前两种情况直接比较 if(a[i] == b[j])f[i][j] = min(f[i][j], f[i-1][j-1]); else f[i][j] = min(f[i][j], f[i-1][j-1] + 1); &#125; &#125; printf(&quot;%d&quot;, f[n][m]); return 0;&#125; 例题变形： 📌给定n个长度不超过10的字符串以及m次询问，每次询问给出一个字符串和一个操作次数上限。对于每次询问，请你求出给定的n个字符串中有多少个字符串可以在上限操作次数内经过操作变成询问给出的字符串。每个对字符串进行的单个字符的插入、删除或替换算作一次操作。 其实就是将刚刚的过程操作n*m次 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std;const int N = 15, M = 1010;int n, m;int f[N][N];char str[M][N];int edit_distance(char a[], char b[])&#123; int la = strlen(a + 1), lb = strlen(b + 1); for (int i = 0; i &lt;= lb; i ++ ) f[0][i] = i; for (int i = 0; i &lt;= la; i ++ ) f[i][0] = i; for (int i = 1; i &lt;= la; i ++ ) for (int j = 1; j &lt;= lb; j ++ ) &#123; f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1); f[i][j] = min(f[i][j], f[i - 1][j - 1] + (a[i] != b[j])); &#125; return f[la][lb];&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); //n个字符串，m次询问 for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%s&quot;, str[i] + 1); while (m -- ) &#123; char s[N]; int limit; scanf(&quot;%s%d&quot;, s + 1, &amp;limit); int res = 0; for (int i = 0; i &lt; n; i ++ ) if (edit_distance(str[i], s) &lt;= limit) res ++ ; printf(&quot;%d\\n&quot;, res); &#125; return 0;&#125; 3 区间DP 区间dp就是在区间上进行动态规划，求解一段区间上的最优解。主要是通过合并小区间的最优解，进而得出整个大区间上最优解的dp算法 3.1 例题1：石子合并 📌设有N堆石子排成一排，其编号为1，2，3，…，N。每堆石子有一定的质量，可以用一个整数来描述，现在要将这N堆石子合并成为一堆。 每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。 例如有4堆石子分别为 1 3 5 2， 我们可以先合并1、2堆，代价为4，得到4 5 2， 又合并 1，2堆，代价为9，得到9 2 ，再合并得到11，总代价为4+9+11&#x3D;24； 如果第二步是先合并2，3堆，则代价为7，得到4 7，最后一次合并代价为11，总代价为4+7+11&#x3D;22。 问题是：找出一种合理的方法，使总的代价最小，输出最小代价。 求解思路： 状态表示： f(i,j)：所有将第i堆石子~第j堆石子合并成一堆石子的合并方式的集合中的Min 状态计算： 状态划分： &amp;#x20;2. 状态转移：f(i, j) &#x3D; Min( f(i, m) + f(m+1, j) + sum(j)-sum(i-1) ), m &#x3D; i,i+1,…,j-1 蓝字是前缀和，用于计算当前两堆的代价 最终状态就是f(1,n) 状态转移的图解： 代码： 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 310;int n;//一共多少石堆int s[N];//每堆的重量int f[N][N];int main()&#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;s[i]); for (int i = 1; i &lt;= n; i ++ ) s[i] += s[i - 1];//求前缀和 for (int len = 2; len &lt;= n; len ++ ) for (int i = 1; i + len - 1 &lt;= n; i ++ )&#123; int l = i, r = i + len - 1; f[l][r] = 1e8; for (int k = l; k &lt; r; k ++ ) f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]); &#125; printf(&quot;%d\\n&quot;, f[1][n]); return 0;&#125; 4 计数类DP 将DP算法应用在计数类问题 4.1 例题1：整数划分 📌一个正整数n可以表示成若干个正整数之和，形如：n&#x3D;n1+n2+…+nk，其中n1≥n2≥…≥nk,k≥1。 我们将这样的一种表示称为正整数n的一种划分。 现在给定一个正整数n，请你求出n共有多少种不同的划分方法。由于答案可能很大，输出结果请对109+7取模。 思路一：背包问题 状态表示： f(i, j)：从1~i中选取数值后，求和正好是j的集合中的数值数量 状态计算： 优化： 1234当前状态转移方程：f(i,j) = f(i-1,j) + f(i-1,j-i) + f(i-1,j-2*i)+...+f(i-1,j-s*i) f(i,j-i)= f(i-1,j-i) + f(i-1,j-2*i)+...+f(i-1,j-s*i)优化后转移方程： f(i,j) = f(i-1,j) + f(i,j-i)优化到一维： f(j) = f(j) + f(j-i) 代码： 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010, mod = 1e9 + 7;int n;int f[N];int main()&#123; cin &gt;&gt; n; f[0] = 1; for (int i = 1; i &lt;= n; i ++ ) for (int j = i; j &lt;= n; j ++ ) f[j] = (f[j] + f[j - i]) % mod; cout &lt;&lt; f[n] &lt;&lt; endl; return 0;&#125; 思路二： - 状态表示： 所有总和为i，并且恰好表示成j个数的和的方案 的集合中的 数值数量(也就是j) - 状态计算： f(i,j) = f(i-1,j-1) + f(i-j,j) 曲线救国 f(i-1,j-1)是f(i,j)中包含最小值1的方案 f(i-j,j)是f(i,j)中不包含最小值1的方案 (j个数都减1) 注意：这种思路最后结果是f(n,1)+f(n,2)+f(n,3)…… 代码： 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010, mod = 1e9 + 7;int n;int f[N][N];int main()&#123; cin &gt;&gt; n; f[1][1] = 1; for (int i = 2; i &lt;= n; i ++ ) for (int j = 1; j &lt;= i; j ++ ) f[i][j] = (f[i - 1][j - 1] + f[i - j][j]) % mod; int res = 0; for (int i = 1; i &lt;= n; i ++ ) res = (res + f[n][i]) % mod; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; 5 数位统计DP 竞赛中有这样一类问题：求给定区间中，满足给定条件的某个D进制数或此类数的数量。所求的限定条件往往与数位有关，例如数位之和、指定数码个数、数的大小顺序分组等等。题目给定的区间往往很大，无法采用朴素的方法求解。 6 状态压缩DP 将状态表示成二进制数，每一位都与状态一一对应 6.1 例题1：蒙德里安的梦想 📌求把N*M的棋盘分割成若干个1*2的的长方形，有多少种方案。例如当N&#x3D;2，M&#x3D;4时，共有5种方案。如下图所示： 思路： 举例说明，一旦某一个方案所有横向1*2的长方形放完了，那么该方案的所有纵向2*1也就只能填充，无法再做改变。所以只需要排列横向1*2长方形即可，而通过列来检查排列是否可行： 排完横向后，第i列不可以有连续奇数个空格 从第i-2到第i-1列的横向长方形和从第i-1列到第i列的横向长方形不能有重合 状态表示： f(i, j)：i表示目前排到第i列，j表示从第i-1列伸过来的横向长方形的状态 &amp;#x20; f(i, j)表示排到第i列的(满足约束的)方案的个数 举例来说，上图中，目前第i列的 j1 &#x3D; 0010(二进制) 目前第i-1列的 j2 &#x3D; 1001(二进制) 一共有m列，从0到m-1 那么上述两个约束条件变成了： (j1&amp;j2) 必须等于0 j1中不可以有连续奇数个0 状态计算： f(i, j) &#x3D; f(i-1, k1) + f(i-1, k2)+ ……. 其中k1,k2……是排到第i-1列时满足约束的方案的 j 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*------最终结果是f(m,0)，也就是第m列，没有捅出来的横格时的所有方案-------*/#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 12, M = 1 &lt;&lt; N;int n, m;long long f[N][M];bool st[M];//标志第i列的j是否可行int main()&#123; //逗号运算符分隔两个表达式，但是最终结果是后一个表达式的结果 while (cin &gt;&gt; n &gt;&gt; m, n || m)//当n或m有一个数为0意味着终止测试 &#123; //做约束条件2的检查，检查一下，一列的所有横向排法中，有哪些排法会有连续奇数个0，用st记录 for (int i = 0; i &lt; 1 &lt;&lt; n; i ++ )//有n行，j就有n位 &#123; int cnt = 0; st[i] = true; for (int j = 0; j &lt; n; j ++ ) if (i &gt;&gt; j &amp; 1)//先右移再与，判断第j位是不是1 &#123; if (cnt &amp; 1) st[i] = false; cnt = 0; &#125; else cnt ++ ; if (cnt &amp; 1) st[i] = false;//cnt用来记录连续0的个数，如果是奇数个则此方案不可行 &#125; memset(f, 0, sizeof f); f[0][0] = 1;//啥都没放是一种合法的初始状态，方案数为1 for (int i = 1; i &lt;= m; i ++ ) for (int j = 0; j &lt; 1 &lt;&lt; n; j ++ ) for (int k = 0; k &lt; 1 &lt;&lt; n; k ++ ) //st[j | k]而不是st[j]&amp;st[k],为什么？ if ((j &amp; k) == 0 &amp;&amp; st[j | k])//判断两个约束 f[i][j] += f[i - 1][k]; cout &lt;&lt; f[m][0] &lt;&lt; endl; &#125; return 0;&#125; 6.2 例题2：最短Hamilton路径 📌给定一张 n 个点的带权无向图，点从 0~n-1 标号，求起点 0 到终点 n-1 的最短Hamilton路径。 Hamilton路径的定义是从 0 到 n-1 不重不漏地经过每个点恰好一次。(此问题就是大名鼎鼎的旅行商问题) 输入格式第一行输入整数n。接下来n行每行n个整数，其中第i行第j个整数表示点i到j的距离（记为a[i,j]）。对于任意的x,y,z，数据保证 a[x,x]&#x3D;0，a[x,y]&#x3D;a[y,x] 并且 a[x,y]+a[y,z]&gt;&#x3D;a[x,z]。 输出格式输出一个整数，表示最短Hamilton路径的长度。 思路： 状态表示：f(i, j)表示为从0走到 j的所有路径是 i的加权和集合的Min 比如i &#x3D; 110001 表示为从0到 j，走了点1、5、6，没走2、3、4 状态计算： 通过看走到 j之前的倒数第二个点来做状态转移 如果倒数第二个点是k，则 f(i, j) &#x3D; f(i-{j}, k) + a[k, j] 所以也就是f(i, j) &#x3D; min( f(i-{j}, k) + a[k, j] )，k是所有从0到 j所经过的倒数第二个点 12345678910111213141516171819202122232425262728293031#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 20, M = 1 &lt;&lt; N;int n;int w[N][N];int f[M][N];int main()&#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; n; j ++ ) cin &gt;&gt; w[i][j]; memset(f, 0x3f, sizeof f); f[1][0] = 0; for (int i = 0; i &lt; 1 &lt;&lt; n; i ++ ) for (int j = 0; j &lt; n; j ++ ) if (i &gt;&gt; j &amp; 1) for (int k = 0; k &lt; n; k ++ ) if (i &gt;&gt; k &amp; 1) f[i][j] = min(f[i][j], f[i - (1 &lt;&lt; j)][k] + w[k][j]); cout &lt;&lt; f[(1 &lt;&lt; n) - 1][n - 1]; return 0;&#125; 7 树形DP 一般来说树形dp在设状态转移方程时都可以用f[i][]表示i这颗子树怎么怎么样的最优解，实现时一般都是用子树更新父亲（即从下向上更新） 7.1 例题1：没有上司的舞会 📌(树形DP最经典问题)Ural大学有N名职员，编号为1~N。他们的关系就像一棵以校长为根的树，父节点就是子节点的直接上司。每个职员有一个快乐指数，用整数 Hi 给出，其中 1≤i≤N。现在要召开一场周年庆宴会，不过，没有职员愿意和直接上司一起参会。在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所有参会职员的快乐指数总和最大，求这个最大值。 输入格式第一行一个整数N。接下来N行，第 i 行表示 i 号职员的快乐指数Hi。接下来N-1行，每行输入一对整数L, K,表示K是L的直接上司。 输出格式输出最大的快乐指数。 思路： 状态表示： 每个节点都有两种状态： f(u, 0)：以u为根节点，但是不选择u的所有方案的集合中的最大快乐指数 f(u, 1)：以u为根节点，同时选择u的所有方案的集合中的最大快乐指数 状态计算： 对于f(u, 0)：由于u未被选择，所以u的子节点可有可无，即对于每个u的子节点Si，f(Si, 0)和f(Si, 1)都可以选择，取其中有最大快乐指数的方案。 对于f(u, 1)：由于u已选，u的子节点不能再选，所以对于每个u的子节点Si，只能有 f(Si, 0)。 f(u, 0) &#x3D; $\\sum_i{max(f(Si,0),f(S_i,1))}$ f(u, 1) &#x3D; $\\sum_i{f(S_i,0)}+A[u]$ 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 6010;int n;int h[N], e[N], ne[N], idx;//邻接表int happy[N];int f[N][2];bool has_fa[N];//判断各个节点是否有父节点，没有父节点的节点就是根节点void add(int a, int b)//邻接表中插入一条边，模板&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;&#125;void dfs(int u)&#123; f[u][1] = happy[u]; for (int i = h[u]; ~i; i = ne[i])//~i即为判断 i!=-1，按位取反，模板 &#123; int j = e[i]; dfs(j); f[u][1] += f[j][0]; f[u][0] += max(f[j][0], f[j][1]); &#125;&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;happy[i]); memset(h, -1, sizeof h); for (int i = 0; i &lt; n - 1; i ++ ) &#123; int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); add(b, a); has_fa[a] = true; &#125; int root = 1; while (has_fa[root]) root ++ ;//找到根节点 dfs(root); printf(&quot;%d\\n&quot;, max(f[root][0], f[root][1])); return 0;&#125; 8 记忆化搜索 记忆化搜索 &#x3D; 搜索的形式 + 动态规划的思想搜索：动态规划数组记录上一层计算结果，当要使用时直接从数组中获取避免过多的重复计算，往往具有较低的空间复杂度 8.1 例题1：滑雪 📌给定一个R行C列的矩阵，表示一个矩形网格滑雪场。矩阵中第 i 行第 j 列的点表示滑雪场的第 i 行第 j 列区域的高度。一个人从滑雪场中的某个区域内出发，每次可以向上下左右任意一个方向滑动一个单位距离。当然，一个人能够滑动到某相邻区域的前提是该区域的高度低于自己目前所在区域的高度。下面给出一个矩阵作为例子：&amp;#x20;1 2 3 4 516 17 18 19 615 24 25 20 714 23 22 21 813 12 11 10 9在给定矩阵中，一条可行的滑行轨迹为24-17-2-1。在给定矩阵中，最长的滑行轨迹为25-24-23-…-3-2-1，沿途共经过25个区域。现在给定你一个二维矩阵表示滑雪场各区域的高度，请你找出在该滑雪场中能够完成的最长滑雪轨迹，并输出其长度(可经过最大区域数)。 思路：递归 状态表示： f(i, j)：以第i行第j列为起点的所有轨迹的集合中的最大长度 状态计算： f(i, j)即为这四种状态在不出界且严格低于(i, j)位置的高度时，取max的结果 由于状态转移方程中，中心区域的状态依托于外圈的状态，直至边缘，所以可用递归的形式来写。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 310;int n, m;int g[N][N];//矩阵int f[N][N];//状态int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;//上下左右int dp(int x, int y)&#123; int &amp;v = f[x][y]; //在返回值的同时，更新f数组 if (v != -1) return v; //如果算过了，直接返回值 v = 1; //初始化，最差情况是只走了自己本身这一步 for (int i = 0; i &lt; 4; i ++ ) &#123; int a = x + dx[i], b = y + dy[i]; if (a &gt;= 1 &amp;&amp; a &lt;= n &amp;&amp; b &gt;= 1 &amp;&amp; b &lt;= m &amp;&amp; g[x][y] &gt; g[a][b]) v = max(v, dp(a, b) + 1); &#125; return v;&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); //n行m列 for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) scanf(&quot;%d&quot;, &amp;g[i][j]); //获取矩阵 memset(f, -1, sizeof f); int res = 0; for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) res = max(res, dp(i, j)); printf(&quot;%d\\n&quot;, res); return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"矩阵论","slug":"矩阵论","date":"2021-05-25T13:30:00.000Z","updated":"2022-07-10T13:46:36.606Z","comments":true,"path":"2021/05/25/矩阵论/","link":"","permalink":"http://example.com/2021/05/25/%E7%9F%A9%E9%98%B5%E8%AE%BA/","excerpt":"","text":"矩阵论原文出处 1 线性空间与线性变换 （1）线性空间的定义： 以$\\alpha, \\beta, \\gamma,…$为元素的非空集合$V$，数域$F$，定义两种运算： 加法：$\\forall \\alpha , \\beta \\in V, ; \\alpha + \\beta \\in V$； 数乘：$\\forall k \\in F, \\alpha \\in V, k \\alpha \\in V$。 **满足8条：加法交换律、加法结合律、数乘结合律、两个分配律，0元存在，1元存在，负元存在。称 **$V$为数域$F$上的线性空间。 （2）证明一组向量是线性空间的基，两步走： 证明这组向量线性无关； 证明线性空间任意向量可由这组向量表示。 （3）如果${E_{ij}, i&#x3D;1,2,…,m;j&#x3D;1,2,…,n}$是矩阵空间$R^{m \\times n}$的一组基，则$\\dim R^{m \\times n} &#x3D; m \\times n$。 📌注：这里有前提条件，实际上$\\dim R^{m \\times n}$并不是总等于$m \\times n$ （4）$\\alpha_1, \\alpha_2, …, \\alpha_n$是线性空间$V_n(F)$的一组基，对于$\\forall \\beta \\in V$, $$\\beta &#x3D; (\\alpha_1 ; \\alpha_2 ; … ; \\alpha_n)\\begin{bmatrix}x_1\\ x_2\\ …\\ x_n\\end{bmatrix}&#x3D; (\\alpha_1 ; \\alpha_2 ; … ; \\alpha_n)X$$ 其中$X$称为向量$\\beta$在基$(\\alpha_1 ; \\alpha_2 ; … ; \\alpha_n)$下对应的坐标。 $V_n(F)$中向量组${\\beta_1 ; \\beta_2 ; … ; \\beta_m}$线性相关的充要条件是坐标向量组${X_1,X_2,…,X_m}$是线性相关组。 （5）设$(\\alpha_1 ; \\alpha_2 ; … ; \\alpha_n)$和$(\\beta_1 ; \\beta_2 ; … ; \\beta_n)$是$n$维线性空间$V_n(F)$中的两组基，则有$C\\in F^{m \\times n}$ $$(\\beta_1 ; \\beta_2 ; … ; \\beta_n) &#x3D; (\\alpha_1 ; \\alpha_2 ; … ; \\alpha_n)C$$ 其中$C$称为从基$(\\alpha_1 ; \\alpha_2 ; … ; \\alpha_n)$到$(\\beta_1 ; \\beta_2 ; … ; \\beta_n)$的过渡矩阵。 📌重要推论：如果向量$\\alpha \\in V_n(F)$，$\\alpha$在两组基下对应坐标分别是$X$和$Y$，则有： $\\alpha &#x3D; (\\alpha_1 ; \\alpha_2 ; … ; \\alpha_n)X\\\\alpha &#x3D; (\\beta_1 ; \\beta_2 ; … ; \\beta_n)Y$ 显然有：$\\color{red}{X &#x3D; CY}$。 （6）设$W$是线性空间$V_n(F)$的非空子集合，则$W$是$V_n(F)$的子空间的充要条件是： 若$\\alpha, \\beta \\in W$，则$\\alpha + \\beta \\in W$ 若$\\alpha \\in W, ; k \\in F$，则$k \\alpha \\in W$ 也就是说只需要验证对加法和数乘封闭即可。 （7）设$W_1, ; W_2$是线性空间$V$的子空间，则： $W_1$与$W_2$的交空间为：$W_1 \\cap W_2 &#x3D; { \\alpha | \\alpha \\in W_1 ; and ; \\alpha \\in W_2 }$ $W_1$与$W_2$的和空间为：$W_1 + W_2 &#x3D; { \\alpha | \\alpha &#x3D; \\alpha_1 + \\alpha_2, ; \\alpha_1 \\in W_1, ; \\alpha_2 \\in W_2 }$ 📌***两个重要的维数公式 $\\dim (W_1 \\cap W_2) \\leqslant \\dim W_i \\leqslant \\dim(W_1 + W_2) \\leqslant \\dim V$ ***$\\dim W_1 + \\dim W_2 &#x3D; \\dim (W_1 + W_2) + \\dim(W_1 \\cap W_2)$ 📌直和子空间：如果$W &#x3D; W_1 + W_2$，并且$W_1 \\cap W_2 &#x3D; {0}$，那么称$W$是$W_1$与$W_2$的直和子空间，表示为$W &#x3D; W_1 \\oplus W_2$。 📌直和补子空间：对$n$维空间$V$的任何子空间$W$，设$\\alpha_1, …,\\alpha_r$为$W$的基，$r &lt; n$，把它们扩充为$V$的基${\\alpha_1, …,\\alpha_r; \\beta_{r+1}, …, \\beta_n}, \\quad U &#x3D; L{\\beta_{r+1}, …, \\beta_n }$有$V &#x3D; W \\oplus U$成立，则称$U$是$W$的直和补子空间。 （8）若$(\\alpha_1 ; \\alpha_2 ; … ; \\alpha_n)$是线性空间$V_n(F)$的一组基，则$V_n(F) &#x3D; L {\\alpha_1, \\alpha_2, .., \\alpha_n}$ 对一个矩阵$A \\in F^{m \\times n}$，可以得到两个与$A$相关的子空间： $N(A) &#x3D; {X |AX&#x3D;0 } \\subseteq F^n\\R(A) &#x3D; L{A_1, A_2, …,A_n } \\subseteq F^m$ 其中$N(A)$称为矩阵$A$的零空间，$R(A)$称为矩阵$A$的列空间 （9）内积： 欧氏空间的内积：$(\\alpha, \\beta) &#x3D; \\alpha^T \\beta ; \\quad (A, B) &#x3D; tr(AB^T)$ 酉空间的内积：$(\\alpha, \\beta) &#x3D; \\beta^H \\alpha ; \\quad (A, B) &#x3D; tr(B^HA)$ 📌柯西不等式：$|(\\alpha, \\beta)|^2 \\leqslant (\\alpha, \\alpha)(\\beta, \\beta)$ 正交补子空间****：设​$U$为内积空间$V_n(F)$的一个子空间，定义$V_n(F)$上的一个子集$U^{\\perp} &#x3D; {\\alpha ;| ;\\alpha \\in V_n(F), ; \\forall \\beta \\in U, ; (\\alpha, \\beta)&#x3D;0 }$称为$U$的正交补子空间，有$V_n(F) &#x3D; U \\oplus U^{\\perp}$。 （10）设$T$是线性空间$V_n(F)$上的线性变换，则满足$T(k_1 \\alpha_1 + k_2 \\alpha_2) &#x3D; k_1 T(\\alpha_1) + k_2 T(\\alpha_2)$，则有： 像空间****： ​$R(T) &#x3D; {\\beta | ; \\exists \\alpha \\in V_n(F), s.t. ; \\beta &#x3D; T(\\alpha)}$是$V_n(F)$上的子空间，称为$T$的像空间；$\\dim R(T)$称为$T$的秩。 零空间****： ​$N(T) &#x3D; {\\alpha |; T(\\alpha) &#x3D; 0}$是$V_n(F)$上的子空间，称为$T$的零空间；$\\dim N(T)$称为$T$的零度。 （11）设$T$为$V_n(F)$上的线性变换，${\\alpha_1, \\alpha_2, …, \\alpha_n}$是$V_n(F)$的基，若存在$n$阶方阵$A$，有： $$T(\\alpha_1 ; \\alpha_2 ; … ; \\alpha_n) &#x3D; (\\alpha_1 ; \\alpha_2 ; … ; \\alpha_n)A$$ 称$A$为$T$在基${\\alpha_1, \\alpha_2, …, \\alpha_n}$下的矩阵。 设$\\alpha$与$T(\\alpha)$在基${\\alpha_1, \\alpha_2, … , \\alpha_n}$下的坐标分别是$X$与$Y$，则有：${\\color {red}{ Y &#x3D; AX}}$。 设${\\alpha_1, \\alpha_2, … , \\alpha_n}$和${\\beta_1, \\beta_2, … , \\beta_n}$是$V_n(F)$的两组基，且有$(\\beta_1 ; \\beta_2 ; … ; \\beta_n) &#x3D; (\\alpha_1 ; \\alpha_2 ; … ; \\alpha_n)C$；$T$在两组基下的变换矩阵分别是$A$与$B$，则${\\color{red} {B&#x3D;C^{-1}AC}}$。 📌如何对矩阵做线性变换？ $E_{11}&#x3D;\\begin{bmatrix} 1 &amp; 0 \\ 0 &amp; 0 \\end{bmatrix}\\ E_{12}&#x3D;\\begin{bmatrix} 0 &amp; 1 \\ 0 &amp; 0 \\end{bmatrix}\\ E_{21}&#x3D;\\begin{bmatrix} 0 &amp; 0 \\ 1 &amp; 0 \\end{bmatrix}\\ E_{22}&#x3D;\\begin{bmatrix} 0 &amp; 0 \\ 0 &amp; 1 \\end{bmatrix}$是$R^{2\\times2}$的基，那么线性变换对应的矩阵为$4\\times4$，每一列对应着对${E_{11},E_{12},E_{21},E_{22}}$相应基进行的变换。 📌如$T(E_{11})&#x3D;-bE_{12}+cE_{21}\\ T(E_{12})&#x3D;-cE_{11}+(a-d)E_{12}+cE_{22}\\ T(E_{21})&#x3D;bE_{11}+(d-a)E_{21}-bE_{22}\\ T(E_{22})&#x3D;bE_{12}-cE_{21}$ 📌则T在基$E_{11},E_{12},E_{21},E_{22}$下的矩阵为 $\\begin{bmatrix} 0 &amp; -c &amp; b &amp; 0 \\ -b &amp; a-d &amp; 0 &amp; b\\c &amp; 0 &amp; d-a &amp; -c\\0 &amp; c &amp; -b &amp; 0 \\end{bmatrix}$ （12）设$T$是线性空间$V_n(F)$上的线性变换，$W$是$V_n(F)$的子空间，如果$\\forall \\alpha \\in W, ; T(\\alpha) \\in W$，即值域$T(W) \\subseteq W$，则称$W$是$T$的不变子空间。 📌重要例题 设$T$是欧式空间$R^3$上的线性变换，对$R^3$中单位矢量$u$，$\\forall x \\in R^3$，$T(x) &#x3D; x - (1-k)(x,u)u$，问：T的不变子空间的直和分解以及相应的矩阵分解。 📌答：对向量$u$有$T(u) &#x3D; u - (1-k)(u,u)u&#x3D; u - (1-k)u &#x3D; ku$ 所以以$u$为基向量的空间是不变子空间，表示为$L{u}$； 同理，对于$u$的正交补子空间$u^{\\perp}$，对于任意向量$X \\in u^{\\perp}$，有 $T(X) &#x3D; X - (1-k)(X,u)u &#x3D; X-0&#x3D;X$ 于是另一个不变子空间为$u^{\\perp}$；即$R^3 &#x3D; L{u} \\oplus u^{\\perp}$。 显然有$L{u}$是一维空间，特征值$k$对应的特征向量是$u_1 &#x3D; u$；那么$u^{\\perp}$就是二维空间，特征值$1$对应两个线性无关的特征向量，可以找到两个单位正交特征向量$u_2, u_3$，所以相应的矩阵分解为$\\begin{bmatrix}k &amp; &amp; \\ &amp; 1 &amp; \\ &amp; &amp; 1\\end{bmatrix}$，对应的特征向量组 ${u_1,u_2,u_3}$为标准正交基。 （13）正交变换（酉变换）：线性变换$T$不改变向量内积，即$(T(\\alpha), T(\\beta)) &#x3D; (\\alpha, \\beta)$。 正交变换$T$关于任一标准正交基的矩阵$C$满足$C^TC &#x3D; CC^T&#x3D;I$；酉变换关于任一标准正交基的矩阵$U$满足$U^HU&#x3D;UU^H&#x3D;I$。 正交矩阵的行列式为$\\pm 1$；酉矩阵的行列式的模长为$1$。 （14）常见的正交变换 $R^2$上绕原点逆时针旋转$\\theta$角的线性变换$T_{\\theta}$称为_正交变换_，在标准正交基下对应的变换矩阵$\\begin{bmatrix} \\cos \\theta &amp; - \\sin \\theta \\ \\sin \\theta &amp; \\cos \\theta \\end{bmatrix}$是正交矩阵。 空间$R^3$上绕过原点的直线$l$旋转$\\theta$角的变化$T_{L_{\\theta}}$为_正交变换_，在标准正交基下对应的变换矩阵$\\begin{bmatrix}1 &amp; &amp; \\ &amp; \\cos \\theta &amp; -\\sin \\theta \\ &amp; \\sin \\theta &amp; \\cos \\theta \\end{bmatrix}$是正交矩阵。 2 Jordan标准型 （1）若有$T(\\xi) &#x3D; \\lambda \\xi$，称$\\lambda$为$T$的特征值，$\\xi$为$T$的特征向量。如果$A$是线性变换$T$对应的矩阵，那么，$\\lambda$和$\\xi$也是$A$的特征值和特征向量。 （2）设$\\lambda_1, \\lambda_2, …, \\lambda_s$是$V_n(F)$上线性变换$T$的$s$个互异特征值，$V_{\\lambda_i}$是$\\lambda_i$的特征子空间，其中$i&#x3D;1,2,…,s$，则： $V_{\\lambda_i}$是$T$的不变子空间； $\\lambda_i \\neq \\lambda_j$时，$V_{\\lambda_i} \\cap V_{\\lambda_j} &#x3D; {0}$； 若$\\lambda_i$是$k_i$重（代数重数）的，$\\dim V_{\\lambda_i}$是_几何重数_，则有$\\dim V_{\\lambda_i} \\leqslant k_i$。 （3）线性变换$T$有对角矩阵表示的充分必要条件是 $T$有$n$个线性无关的特征向量。 幂等矩阵**：**$A^2 &#x3D; A$，$A$相似于对角矩阵$\\begin{bmatrix} I_r&amp; \\ &amp; 0\\end{bmatrix}$**，其中**$r$为矩阵$A$的秩。 乘方矩阵**：**$A^2 &#x3D; I$，$A$相似于对角阵$\\begin{bmatrix}I_s &amp; \\ &amp; I_t\\end{bmatrix}$**，其中**$s+t&#x3D;n$。 （4）关于秩的不等式： $rank(A \\pm B) \\leqslant rank(A) + rank(B)$ $rank(A) + rank(B) -n \\leqslant rank(A_{m \\times n}B_{n \\times m}) \\leqslant \\min(r(A), r(B))$ $if ;A_{m \\times n}B_{n \\times m}&#x3D;0, \\quad rank(A) + rank(B) \\leqslant n$ （5）形如$J(\\lambda) &#x3D; \\begin{bmatrix}\\lambda &amp; 1 &amp; &amp; \\ &amp; \\lambda &amp; 1 &amp; \\ &amp; &amp; … &amp; 1\\ &amp; &amp; &amp; \\lambda\\end{bmatrix}$，称为Jordan块。Jordan块呈上三角，主对角线是它的全部特征值，特点是主对角线上元素相等，紧邻上方元素$a_{i,i+1} &#x3D; 1$，其余元素为0。 （6）每个$n$阶方阵$A$都相似于一个Jordan矩阵，即存在可逆矩阵$P$，有： $P^{-1}AP &#x3D; J_A &#x3D; \\begin{bmatrix}J_1(\\lambda_1) &amp; &amp; &amp; \\ &amp; J_2(\\lambda_2) &amp; &amp; \\ &amp; &amp; … &amp; \\ &amp; &amp; &amp; J_s(\\lambda_s)\\end{bmatrix}$ 其中$J_A$称为Jordan标准形。 （7）Jordan标准形的求法： 求矩阵$A$的特征多项式$|\\lambda I-A| &#x3D; (\\lambda - \\lambda_1)^{k_1}(\\lambda-\\lambda_2)^{k_2}…(\\lambda - \\lambda_s)^{k_s}$，其中$k_i$是特征值$\\lambda_i$的代数重数，决定了对角线上特征值$\\lambda_i$的个数； 对$\\lambda_i$，由$(A-\\lambda_i I)X&#x3D;0$，求$A$的线性无关的特征向量$\\alpha_1,\\alpha_2, …,\\alpha_{t_i}$，其中$t_i$是特征值$\\lambda_i$的几何重数，决定了Jordan块的个数； 如果$k_i &#x3D; t_i$，即代数重数等于几何重数，说明$\\lambda_i$对应的Jordan块是对角阵； 如果$t_i &lt; k_i$，就选择合适的特征向量$\\alpha_j$，利用${\\color{red} {|A-\\lambda_i I| &#x3D; \\alpha_j}}$求Jordan链，确定每一个小Jordan块的阶数。 将所有特征值$\\lambda_i$对应的Jordan块组合起来，形成Jordan矩阵$J_A$。 （8）矩阵多项式可以表示为$g(A) &#x3D; a_m A^m + a_{m-1}A^{m-1}+…+a_1A +a_0 I$ ，由于有$A &#x3D; P J_AP^{-1}$，所以有： $g(A) &#x3D; P \\begin{bmatrix}g(J_1(\\lambda_1)) &amp; &amp; &amp; \\ &amp; g(J_2(\\lambda_2)) &amp; &amp; \\ &amp; &amp; … &amp; \\ &amp; &amp; &amp; g(J_s(\\lambda_s)) \\end{bmatrix} P^{-1}$ 而对于$g(J(\\lambda))$则有： $g(J(\\lambda)) &#x3D; \\begin{bmatrix}g(\\lambda) &amp; g’(\\lambda) &amp; … &amp; \\frac{g^{(r-1)}(\\lambda)}{(r-1)!} \\ &amp; g(\\lambda) &amp; … &amp; .\\ &amp; &amp; … &amp; .\\ &amp; &amp; &amp; g(\\lambda)\\end{bmatrix}$ 对于常用的幂指数形式有 $J^k(\\lambda) &#x3D; \\begin{bmatrix}\\lambda^k &amp; \\frac{(\\lambda^k)’}{1!} &amp; \\frac{(\\lambda^k)’’}{2!} &amp;… \\ &amp; \\lambda^k&amp; … &amp; .\\ &amp; &amp; … &amp; .\\ &amp; &amp; &amp; \\lambda^k\\end{bmatrix}$ （9）使$g(A)&#x3D;0$的多项式$g(\\lambda)$称为$A$的化零多项式，特征多项式必是矩阵$A$的化零多项式。 📌注：化零多项式的根一定包含了所有的特征值，但不能说化零多项式的根一定是特征值。 （10）对于最小多项式 $m_T(\\lambda)$最高项系数为1； $m_T(\\lambda)$是$T$的一个化零多项式； $m_T(\\lambda)$是化零多项式中次数最低的那一个。 最小多项式$m_T(\\lambda)$的根一定包含了所有的特征值$\\lambda_i$，子式$(\\lambda-\\lambda_i)^{r_i}$的幂$r_i$等于Jordan标准形中关于特征值$\\lambda_i$的Jordan块中的最高阶数。 📌比如矩阵$A$有一个代数重数为3的特征值2，该特征值对应两个Jordan块，分别是 $\\begin{bmatrix}2 &amp; 1 \\ &amp; 2 \\end{bmatrix}$以及$[2]$， 说明其中其最高阶数为2，那么在最小多项式中对应的子式为$(\\lambda -2)^2$。 📌线性变换可以对角化的充要条件是其最小多项式是一次因子的乘积 （11）线性变换与Jordan标准型的结合 线性变换在原基的变换矩阵不是对角矩阵，如何求得新基，使得在新基下的变换矩阵是对角矩阵 线性变换在原基的变换矩阵不是Jordan标准型，如何求得新基，使得在新基下的变换矩阵是Jordan标准型 对原基下的变换矩阵求相似对角化，得到的特征向量组成的矩阵P右乘原基，即是可使变换矩阵成为对角阵的新基 对原基下的变换矩阵求相似的Jordan标准型$P\\Lambda P^{-1}$，用$P$右乘原基，即是可使变换矩阵成为Jordan标准型的新基 📌左式在书上定义2.1处有证明，即$T(\\xi)&#x3D;\\lambda\\xi$&amp;#x20;$\\xi&#x3D;(\\alpha_1,\\alpha_2…\\alpha_n)\\bold X$$T(\\xi)&#x3D;(\\alpha1,\\alpha_2…\\alpha_n) A\\bold{X}\\rightarrow A\\bold X&#x3D;\\lambda\\bold X$&amp;#x20;这说明$\\lambda$是矩阵A的特征值，$\\bold X$是矩阵A关于$\\lambda$的特征向量 3 矩阵分解 （1）等价标准形 对于$A \\in C^{m \\times n}$，存在可逆矩阵$P \\in C^{m \\times m}, Q \\in C^{n \\times n}$，使得 $$A &#x3D; P \\begin{bmatrix}I_r &amp; 0 \\ 0 &amp; 0\\end{bmatrix}Q$$ 其中$r$是矩阵$A$的秩。 （2）相似标准形 存在可逆矩阵$P \\in C^{ n \\times n}$，有 $$A &#x3D; P \\begin{bmatrix}\\lambda_1 &amp; &amp; &amp; \\ &amp; \\lambda_2 &amp; &amp; \\ &amp; &amp; … &amp; \\ &amp; &amp; &amp; \\lambda_n\\end{bmatrix} P^{-1}$$ （3）LU分解 定义：$L$是下三角矩阵，$U$是上三角矩阵，$A&#x3D;LU$。 📌存在条件：A的秩为r，前r阶顺序主子式不为0，则存在LU分解 求法： 对于$(A ;|; I_n)$，只用第$i$行乘数$k$加到第$j$行（$i &lt; j$）型初等变换将$A$化为上三角形$U$，可以得到${\\color{red} (U ; |; P)}$； 可知$PA&#x3D;U$，于是有$L&#x3D;P^{-1}$，则$A&#x3D;LU$。 （4）LDV分解 定义：$L, V$分别是对角线元素为1的下三角矩阵和上三角矩阵，$D$为对角矩阵，$A&#x3D;LDV$。 求法： 方法一： 由LU分解得到$A &#x3D; LU$； 通过每行除以对应的对角线上元素的值，将$U$的对角线元素化为1，得到$U&#x3D;D_1V$； 通过每列除以对应的对角线上元素的值，将$L$的对角线元素化为1，得到$L&#x3D;L_{real}D_2$ 有$A&#x3D;L_{real}D_2D_1V&#x3D;LDV$。 方法二： 取矩阵$A$对角线第一个元素，得到矩阵$A_1&#x3D;[a_{11}]$，则有$A_1 &#x3D; L_1D_1V_1 &#x3D; [1][a_{11}][1]$； 取包含对角线前两个元素的二阶矩阵$A_2 &#x3D; \\begin{bmatrix}A_1 &amp; \\alpha\\ \\beta &amp; a_{22}\\end{bmatrix}$，则有矩阵$A_2 &#x3D; L_2 D_2 V_2$，其中$L_2 &#x3D; \\begin{bmatrix}L_1 &amp; 0\\ x &amp; 1\\end{bmatrix}$，$D_2 &#x3D; \\begin{bmatrix}D_1 &amp; 0\\ 0 &amp; d_2\\end{bmatrix}$，$V_2 &#x3D; \\begin{bmatrix}V_1 &amp; y\\ 0 &amp; 1\\end{bmatrix}$，求得未知量$x, d_2, y$； 以此类推，最终得到$A &#x3D; L_n D_n V_n$。 📌方法二即： $A_n &#x3D; \\begin{bmatrix}A_{n-1} &amp; \\tau\\ u^T &amp; a_{nn}\\end{bmatrix}&#x3D;\\begin{bmatrix}L_{n-1} &amp; 0\\ l^T &amp; 1\\end{bmatrix}\\begin{bmatrix}D_{n-1} &amp; 0\\ 0 &amp; d_n\\end{bmatrix}\\begin{bmatrix}V_{n-1} &amp; v\\ 0 &amp; 1\\end{bmatrix}$迭代：&amp;#x20;$A_{n-1}&#x3D;L_{n-1}D_{n-1}V_{n-1}\\\\tau_n&#x3D;L_{n-1}D_{n-1}v_n\\u_n^T&#x3D;l_n^TD_{n-1}V_{n-1}\\a_{nn}&#x3D;l_n^TD_nv_n+d_n$ 📌有LU分解不一定有LDV分解，LU的对角线可以是0，而LDV对角线只能是1 （5）满秩分解 定义：对于$rank(A)&#x3D;r$的矩阵$A$，若存在秩为$r$的矩阵$B \\in F^{m \\times r}, ; C \\in F^{r \\times n}$，有$A&#x3D;BC$，称为矩阵$A$的满秩分解。 📌任何非零矩阵，都存在满秩分解 求法：方法较多，一般只用最简单的第3种。 用行初等变换把$A$化为Hermite标准形； 依Hermite标准形中向量$e_i$所在的列的位置第$j_i$列，相应地取出$A$的第$j_i$列$a_{ji}$，得到 $A$的列向量极大无关组${a_{j_1}, a_{j_2}, …, a_{j_r}}$，$B &#x3D;(a_{j_1}, a_{j_2}, …, a_{j_r})$; $A$的Hermite矩阵中的非零行构成矩阵$C$，得到满秩分解$A&#x3D;BC$。 📌求矩阵$A&#x3D;\\begin{bmatrix}1 &amp; 1 &amp; 2\\ 0 &amp; 2 &amp; 2\\ 1 &amp; 0 &amp; 1\\end{bmatrix}$的满秩分解。 答： 用行初等变换化$A$为Hermite标准形：$A &#x3D; \\begin{bmatrix}1 &amp; 1 &amp; 2\\ 0 &amp; 2 &amp; 2\\ 1 &amp; 0 &amp; 1\\end{bmatrix} \\rightarrow \\begin{bmatrix}1 &amp; 1 &amp; 2\\ 0 &amp; 2 &amp; 2\\ 0 &amp; -1 &amp; -1\\end{bmatrix} \\rightarrow \\begin{bmatrix}1 &amp; 0 &amp; 1\\ 0 &amp; 1 &amp; 1\\ 0 &amp;0 &amp;0 \\end{bmatrix}$可知$rank(A)&#x3D;2$，$A$的前两列线性无关，取出构成$B$；取出$A$的Hermite标准形的前两行作为$C$，有$B &#x3D; \\begin{bmatrix} 1&amp;1 \\ 0&amp;2 \\ 1&amp;0 \\end{bmatrix}, C &#x3D; \\begin{bmatrix}1 &amp; 0 &amp; 1\\ 0 &amp; 1 &amp; 1\\end{bmatrix}, A&#x3D;BC$ （6）谱分解 定义：矩阵$A$互异的特征值${\\lambda_1, \\lambda_2, …, \\lambda_s}$称为矩阵$A$的谱。可相似对角化是可以谱分解的充要条件。 求法： 通过求特征值和特征向量得到 $A &#x3D; P\\begin{bmatrix}\\lambda_1 &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; \\ &amp; … &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; \\ &amp; &amp; \\lambda_1 &amp; &amp; &amp; &amp; &amp; &amp; &amp; \\ &amp; &amp; &amp; \\lambda_2&amp; &amp; &amp; &amp; &amp; &amp; \\ &amp; &amp; &amp; &amp; … &amp; &amp; &amp; &amp; &amp; \\ &amp; &amp; &amp; &amp; &amp; \\lambda_2 &amp; &amp; &amp; &amp; \\ &amp; &amp; &amp; &amp; &amp; &amp; … &amp; &amp; &amp; \\ &amp; &amp; &amp; &amp; &amp; &amp; &amp; \\lambda_s &amp; &amp; \\ &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; … &amp; \\ &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; \\lambda_s\\end{bmatrix} P^{-1}$； 对角阵$\\Lambda &#x3D; \\lambda_1 \\begin{bmatrix}I_{r_1} &amp; &amp; &amp; \\ &amp; 0 &amp; &amp; \\ &amp; &amp; … &amp; \\ &amp; &amp; &amp; 0\\end{bmatrix} + \\lambda_2\\begin{bmatrix}0 &amp; &amp; &amp; \\ &amp; I_{r_2} &amp; &amp; \\ &amp; &amp; 0 &amp; \\ &amp; &amp; &amp; 0\\end{bmatrix} + … + \\lambda_s\\begin{bmatrix}0 &amp; &amp; &amp; \\ &amp; 0 &amp; &amp; \\ &amp; &amp; 0 &amp; \\ &amp; &amp; &amp; I_{r_s}\\end{bmatrix}$，令$Q_i &#x3D; \\begin{bmatrix}0 &amp; &amp; &amp; \\ &amp;… &amp; &amp; \\ &amp; &amp; I_{r_i} &amp; \\ &amp; &amp; &amp; …\\end{bmatrix}$； 得到$A &#x3D; \\sum_{i&#x3D;1}^s \\lambda_i P_i$，其中$P_i &#x3D; P Q_i P^{-1}$。 （7）Schur分解 UR分解：对可逆矩阵$A$，存在酉矩阵$U$和主对角线上元素都为正的上三角矩阵$R$，使$A&#x3D;UR$。 Schur分解：设$A\\in C^{n\\times n}$，则存在酉矩阵$U$和上三角矩阵$T$，使得 $U^HAU&#x3D;T&#x3D;\\begin{bmatrix}\\lambda_1&amp;t_{12} &amp;… &amp;t_{1n} \\ &amp;\\lambda_2 &amp;… &amp;t_{2n} \\ &amp; &amp; … &amp; \\ &amp; &amp; &amp; \\lambda_n\\end{bmatrix}$ 其中$\\lambda_i$是矩阵$A$的特征值，$i&#x3D;1,2,…,n$ UR分解**求法： 取矩阵$A &#x3D; (A_1, A_2, …, A_n)$的列向量，进行施密特正交化，得到$u_1,u_2, …,u_n$，有$U&#x3D;(u_1,u_2,…,u_n)$； 再由$R &#x3D; U^H A$得到$R$，于是$A&#x3D;UR$。 📌施密特正交化方法： 设$\\alpha_1,\\alpha_2,…,a_r(r\\le n)$是线性无关的向量组，则通过以下方法 $\\beta_1&#x3D;\\alpha_1\\\\beta_2&#x3D;\\alpha_2-\\frac{(\\alpha_2,\\beta_1)}{(\\beta_1,\\beta_1)}\\beta_1\\……\\\\beta_k&#x3D;\\alpha_k-\\sum_{i&#x3D;1}^{k-1}\\frac{(\\alpha_k,\\beta_i)}{(\\beta_i,\\beta_i)}\\beta_i\\k&#x3D;3,4,…,r$&amp;#x20;得到的向量组$\\beta_1,\\beta_2,…,\\beta_r$是正交向量组 Schur分解求法： $A$相似于Jordan标准型$A&#x3D;PJP^{-1}$； 通过$P$的UR分解有$P&#x3D;UR$，则$A&#x3D;PJP^{-1}&#x3D;URJR^{-1}U^H$； 令$T&#x3D;RJR^{-1}$，则$T$是一个上三角形矩阵，即有$U^HAU&#x3D;T$。 （8）几种特殊矩阵： 正规矩阵：$A^HA &#x3D; AA^H$ （正规矩阵酉相似于对角阵） 酉矩阵：$A^HA &#x3D; AA^H&#x3D;I$ Hermite矩阵：$A^H &#x3D; A$ 📌对于正规矩阵，$A$和$A^H$的特征向量相等，更一般地，只要$AB&#x3D;BA$且$A$和$B$都可相似对角化，那么A和B特征向量就相同。&amp;#x20;证明： $A&#x3D;P\\Lambda_1 P^{-1}&#x3D;P\\begin{bmatrix}\\lambda_1 &amp; \\ &amp; \\lambda_2\\ &amp; &amp; …\\ &amp; &amp; &amp; \\lambda_n\\end{bmatrix}P^{-1}$则$P^{-1}APP^{-1}BP&#x3D;P^{-1}ABP&#x3D;P^{-1}BAP&#x3D;P^{-1}BPP^{-1}AP$&amp;#x20;即$\\begin{bmatrix}\\lambda_1&amp;&amp;&amp;\\&amp;\\lambda_2&amp;&amp;\\&amp;&amp;…&amp;\\&amp;&amp;&amp;\\lambda_n\\end{bmatrix}P^{-1}BP&#x3D;P^{-1}BP\\begin{bmatrix}\\lambda_1&amp;&amp;&amp;\\&amp;\\lambda_2&amp;&amp;\\&amp;&amp;…&amp;\\&amp;&amp;&amp;\\lambda_n\\end{bmatrix}$&amp;#x20;所以$P^{-1}BP&#x3D;\\begin{bmatrix}\\lambda_1^{-1}&amp;&amp;&amp;\\&amp;\\lambda_2^{-1}&amp;&amp;\\&amp;&amp;…&amp;\\&amp;&amp;&amp;\\lambda_n^{-1}\\end{bmatrix}P^{-1}BP\\begin{bmatrix}\\lambda_1&amp;&amp;&amp;\\&amp;\\lambda_2&amp;&amp;\\&amp;&amp;…&amp;\\&amp;&amp;&amp;\\lambda_n\\end{bmatrix}$也就是说$P^{-1}BP$的每个元素$a_{ij}&#x3D;a_{ij}\\frac{\\lambda_j}{\\lambda_i}$，只有对角线元素是可以满足此条件的，所以$P^{-1}BP$是对角矩阵$\\begin{bmatrix}k_1&amp;&amp;&amp;\\&amp;k_2&amp;&amp;\\&amp;&amp;…&amp;\\&amp;&amp;&amp;k_n\\end{bmatrix}$ ，$k_1,k_2,…k_n$也就是B的特征向量。对于$P&#x3D;[\\alpha_1,\\alpha_2,…\\alpha_n]$的列向量$\\alpha_i$，有$A\\alpha_i&#x3D;\\lambda_i\\alpha_i,B\\alpha_i&#x3D;k_i\\alpha_i$，所以$\\alpha_i$同时是A和B的特征向量。即A和B特征向量相同 （9）奇异值分解（SVD分解） 奇异值：对$rank(A)&#x3D;r$的矩阵A，矩阵$A^HA$的非零特征值有$\\lambda_1 \\geqslant \\lambda_2 \\geqslant … \\geqslant \\lambda_r &gt;0$，则称正数$\\sigma_i &#x3D; \\sqrt{\\lambda_i}$为矩阵A的奇异值。 定义：对$rank(A)&#x3D;r$的矩阵$A \\in C^{m \\times n}$，奇异值有$\\sigma_1 \\geqslant \\sigma_2 \\geqslant … \\geqslant \\sigma_r &gt; 0$，则存在酉矩阵$U \\in C^{m \\times m}, ; V \\in C^{n \\times n}$，分块矩阵$\\Sigma &#x3D; \\begin{bmatrix}\\Delta &amp; 0\\ 0 &amp; 0\\end{bmatrix}$，有$A &#x3D; U \\Sigma V^H$，其中$\\Delta &#x3D; \\begin{bmatrix}\\sigma_1 &amp; &amp; &amp; \\ &amp; \\sigma_2 &amp; &amp; \\ &amp; &amp; … &amp; \\ &amp; &amp; &amp; \\sigma_r\\end{bmatrix}$。 求解：第一步和第三步要求非零特征值，而第二步无此要求 由特征多项式$|\\lambda I - A^HA| &#x3D; 0$求得特征值$\\lambda_1 \\geqslant \\lambda_2 \\geqslant .. \\geqslant \\lambda_n$，（务必按照从大到小排列）（奇异值矩阵中某奇异值个数等于特征值重数），以及每个特征值对应的特征向量$\\alpha_1, \\alpha_2, …, \\alpha_n$； 对特征向量进行施密特正交化和单位化（一般只需要单位化），得到单位正交向量组$v_1, v_2, ..,v_n$，则$V&#x3D;(v_1, v_2, …,v_n)$； 对于非零特征值$\\lambda_1, …, \\lambda_r$对应奇异值$\\sigma_1, … , \\sigma_r$，于是有${\\color{red} {u_i &#x3D; \\frac{1}{\\sigma_i}Av_i}}$，这样得到了$r$个列向量，剩余的设为$\\beta$，通过正交的特性$u_i^T \\beta &#x3D; 0$即可求得；（U的列向量也需要标准化） 于是得到$A&#x3D;U \\Sigma V^H$ 📌奇异值性质：&amp;#x20;(1) 求逆与共轭转置的可交换性： $(AA^{-1})^H&#x3D;(A^{-1})^HA^H&#x3D;I因此(A^{-1})^H&#x3D;(A^H)^{-1}$&amp;#x20;(2) $rank(A)&#x3D;rank(A^HA)&#x3D;rank(AA^H)$&amp;#x20;(3) $AA^H$与$A^HA$的非零特征值相等&amp;#x20;(4) $AA^H$与$A^HA$都是半正定矩阵，$A\\in C^{m\\times n}$，当$rank(A)&#x3D;m或n$时，二者分别正定&amp;#x20;(5) $A$与$A^{-1}$的特征值互为倒数&amp;#x20;$Ax&#x3D;\\lambda x\\A^{-1}Ax&#x3D;\\lambda A^{-1}x\\\\frac 1\\lambda x&#x3D;A^{-1}x$ （10）极分解（不考） 定义：对于$rank(A)&#x3D;r$的矩阵$A \\in C^{n \\times n}$，可以被分解为$A&#x3D;PQ$，其中$P$为半正定矩阵，$Q$为酉矩阵。 求法： 对$A$进行奇异值分解，得到$A&#x3D;U \\Sigma V^H$; 可以得到$A &#x3D; (U \\Sigma U^H)(UV^H)$，于是$P&#x3D;U \\Sigma U^H, ; Q&#x3D;UV^H$，$A&#x3D;PQ$。 4 矩阵广义逆 （1）设$A \\in C^{m \\times n}, B \\in C^{n \\times m}$，若有$BA&#x3D;I_n$，则称$B$是$A$的一个左逆。 📌等价条件：- $A$的零空间$N(A)&#x3D;{0}$- $m \\geqslant n, ; rank(A)&#x3D; n$，即$A$是列满秩的- $A^H A$可逆 （2）设$A \\in C^{m \\times n}, B \\in C^{n \\times m}$，若有$AC &#x3D; I_m$，则称$C$是$A$的一个右逆。 📌等价条件：- $A$的列空间$R(A)&#x3D;C^m$- $m \\leqslant n, ; rank(A)&#x3D;m$，即$A$是行满秩的- $AA^H$可逆 （3）对于$A \\in C^{m \\times n}, ; G \\in C^{n \\times m}$，有$AGA&#x3D;A$，称$G$是$A$的一个减号广义逆。 求法： 对$rank(A)&#x3D;r$的矩阵$A$，有矩阵$\\begin{bmatrix}A &amp; I_m\\ I_n &amp; 0 \\end{bmatrix}$进行初等变换，对$A$行变换时$I_m$保持同步，对$A$列变换时，$I_n$保持同步，将$A$化为最简形，得到$\\begin{bmatrix} I_r&amp; 0 &amp; P \\ 0 &amp; 0 &amp; \\ \\ Q &amp; &amp; 0 &amp; \\end{bmatrix}$； 有$G &#x3D; Q\\begin{bmatrix}I_r &amp; U\\ V &amp; W\\end{bmatrix}P$，其中$U,V,W$是满足固定阶次的任意矩阵。 （4）加号广义逆（M-P逆） 定义：对于矩阵$A \\in C^{m \\times n}, ; G \\in C^{n \\times m}$，满足4条- $AGA&#x3D;A$- $GAG&#x3D;G$- $(AG)^H &#x3D; AG$- $(GA)^H&#x3D;GA$&amp;#x20;称$G$为$A$的M-P逆。 求法： 方法一： 对矩阵$A$进行满秩分解，得到$A&#x3D;BC$; 则$\\color{red}{A^+ &#x3D; C^H(CC^H)^{-1}(B^HB)^{-1}B^H}$，也就是等于C的右逆 x B的左逆。 方法二： 对矩阵$A$进行奇异值分解，得到$A &#x3D; U \\begin{bmatrix}\\Delta &amp;0 \\ 0 &amp; 0\\end{bmatrix}V^H$； 则$\\color{red}{A^+ &#x3D; V \\begin{bmatrix}\\Delta^{-1} &amp; 0\\ 0 &amp; 0\\end{bmatrix}U^H}$。 📌性质- $rank(A) &#x3D; rank(A^+)$- $rank(A^+A) &#x3D; rank(AA^+)&#x3D;rank(A)$ （5）投影变换 定义：$C^n &#x3D; L \\oplus M, \\quad x&#x3D;y+z, \\quad y \\in L, z \\in M$，投影变换$\\sigma$就是把$C^n$映射成子空间$L$，称$\\sigma$是从$C^n$沿子空间$M$到子空间$L$的投影变换，在一组基下对应的矩阵称为投影矩阵，子空间$L$称为投影子空间。显然有，子空间$L$就是$\\sigma$的像空间$R(\\sigma)$，$M$就是$\\sigma$的核空间$N(\\sigma)$，于是$C^n &#x3D; R(\\sigma) \\oplus N(\\sigma)$。 📌$\\sigma$是投影变换的充要条件是$\\sigma$关于某组基下的矩阵$A$是幂等矩阵，即$A^2&#x3D;A$。 求法： 找出像空间$L$的一组基$y_1,y_2,…,y_r$，得到矩阵$B &#x3D; (y_1 ; y_2 ; … ; y_r)$；找出$M$的一组基$z_{r+1}, …., z_n$，得到矩阵$C&#x3D;(z_{r+1} ; … ; z_n)$； 于是有投影矩阵$\\color{red}{A &#x3D; (B | 0)(B|C)^{-1}}$。 （6）正交投影变换 定义：若$C^n &#x3D; R(\\sigma) \\oplus N(\\sigma)$，$R(\\sigma)$的正交补空间是$R(\\sigma)^{\\perp} &#x3D; N(\\sigma)$，称$\\sigma$是正交投影变换，其在标准正交基下对应的矩阵称为正交投影矩阵。 正交投影变换：$\\color{red}P(X)&#x3D;X-(X,u)u$，$u$便是零空间的基。 📌$\\sigma$是正交投影变换的充要条件是$A$是幂等Hermite矩阵，即$A^2&#x3D;A, ;A^H&#x3D;A$。 求法： $A &#x3D; (B | 0)(B|C)^{-1} &#x3D; (B|0)((B|C)^H(B|C))^{-1}(B|C)^H &#x3D; {\\color{red} {B(B^HB)^{-1}B^H}}$ （7）最佳最小二乘解 $A \\in C^{m \\times n}, ; b \\in C^m$，则${\\color{red} {x_0&#x3D;A^+b}}$是线性方程组$Ax&#x3D;b$的最佳最小二乘解。 $A \\in C^{m \\times n}, ; B \\in C^{m \\times k}$，则${\\color{red}{X_0 &#x3D; A^+B}}$是$AX&#x3D;B$的最佳最小二乘解。 5 矩阵分析 （1）向量范数满足正定性、齐次性和三角不等式，定义了范数的内积空间称为赋范空间。 （2）重要的向量范数： 对于复向量$x &#x3D; (x_1 ;; x_2 ;; … ;; x_n)$，有： 2-范数****： ​${\\color{red}{|x|| &#x3D; \\sqrt{|x_1|^2 + |x_2|^2 + … + |x_n|^2}}}$ 1-范数****： ​${\\color{red}{||x||_1 &#x3D; |x_1| + |x_2| + … + |x_n|}}$ ∞范数****： ​${\\color{red}{||x||_{\\infty} &#x3D; \\underset{i}{\\max} |x_i|}}$ 📌有限维线性空间的任意两种向量范数都是等价的。 （3）矩阵范数满足正定性、齐次性、三角不等式以及相容性。 （4）重要的矩阵范数和诱导范数 F范数：${\\color{red}{||A||_F &#x3D; [tr(A^HA)]^{\\frac{1}{2}}}}$ 列和范数： ${\\color{red}{||A||1 &#x3D; \\underset{j}{\\max}(\\sum{i&#x3D;1}^n |a_{ij}|)}}$，即每一列各元素模相加其中的最大值 谱范数：${\\color{red}{||A||_2 &#x3D; \\sqrt{\\lambda_1}}}$，其中$\\lambda_1$是$A^HA$的最大特征值 行和范数：${\\color{red}{||A||{\\infty} &#x3D; \\underset{i}{\\max}(\\sum{j&#x3D;1}^n |a_{ij}|)}}$，即每一行各元素模相加其中的最大值 （5）向量收敛和矩阵收敛必须其中的每一个元素都收敛。 📌向量按分量收敛的充要条件是它按任意一个向量范数收敛。 📌当$k \\rightarrow \\infty$时，$||A^{(k)}-A|| \\rightarrow 0$，称矩阵序列按矩阵范数收敛于$A$ （6）谱半径 定义：$\\lambda_1, \\lambda_2, …, \\lambda_n$是矩阵$A \\in C^{n \\times n}$的全部特征值，称${\\color{red}{\\rho(A)&#x3D;\\underset{i}{\\max}|\\lambda_i|}}$为$A$的谱半径。 📌$A^k \\rightarrow 0(k \\rightarrow \\infty)$的充要条件是$\\rho(A) &lt; 1$ 📌$A$的谱半径是$A$的任意一种矩阵范数的下确界。 （7）矩阵幂级数 若复变量$z$的幂级数$\\sum_{k&#x3D;0}^{\\infty}a_kz^k$的收敛半径为$R$，而方阵$A \\in C^{n \\times n}$的谱半径为$\\rho(A)$，则 当${\\color{red} {\\rho(A) &lt; R}}$时，矩阵幂级数$\\sum_{k&#x3D;0}^{\\infty}a_kA^k$收敛； 当${\\color{red} {\\rho(A) &gt; R}}$时，矩阵幂级数$\\sum_{k&#x3D;0}^{\\infty}a_k A^k$发散 📌当求解$A$的特征值比较困难时，由于$A$的每个范数都是谱半径$\\rho(A)$的上界，只需要找到一种特殊的矩阵范数$||A||$，使得$||A|| &lt; R$，就能说明矩阵幂级数收敛。（优先考虑行和、列和范数） （8）常用的幂级数 收敛域是整个复平面的幂级数 $e^A &#x3D; \\sum_{k&#x3D;0}^{\\infty} \\frac{1}{k!}A^k$ $\\cos A &#x3D; \\sum_{k&#x3D;0}^{\\infty}\\frac{(-1)^k}{(2k)!}A^{2k}$ $\\sin A &#x3D; \\sum_{k&#x3D;0}^{\\infty}\\frac{(-1)^k}{(2k+1)!}A^{2k+1}$ 收敛域为复平面$|z| &lt; 1$的幂级数 $(I-A)^{-1} &#x3D; \\sum_{k&#x3D;0}^{\\infty}A^k, \\quad \\rho(A) &lt; 1$ $\\ln(I+A) &#x3D; \\sum_{k&#x3D;1}^{\\infty}\\frac{(-1)^{k-1}}{k}A^k, \\quad \\rho(A) &lt; 1$ （9）矩阵函数的两种求法 方法一：Jordan标准形法 求矩阵$A$的Jordan标准形$J_A$，得到${\\color{red} {A &#x3D; PJ_AP^{-1}}}$ 设解析函数为$f(z)$，则对每一个Jordan块有$f(J_i)&#x3D; \\begin{bmatrix}f(\\lambda_i) &amp; \\frac{f’(\\lambda_i)}{1!} &amp; \\frac{f’’(\\lambda_i)}{2!} &amp; … \\ &amp; f(\\lambda_i) &amp; \\frac{f’(\\lambda_i)}{1!} &amp; …\\ &amp; &amp; … &amp; \\ &amp; &amp; &amp; f(\\lambda_i)\\end{bmatrix}$，得到$f(J_A)$ 最后得到$f(A) &#x3D; Pf(J_A)P^{-1}$ 📌这种方法的难点在于需要求Jordan链，过程中可以会遇到麻烦。如果不同特征值个数较多，建议使用第一种；而如果特征值比较单一，并且 代数重数 - 几何重数 &gt; 2，建议使用第二种 方法二：最小多项式法 先计算$A$的Jordan标准形，由此得到最小多项式$m_A(\\lambda)&#x3D;(\\lambda -\\lambda_1)^{n_1}(\\lambda-\\lambda_2)^{n_2}…(\\lambda-\\lambda_s)^{n_s}$，其中幂次和有$\\sum_{i&#x3D;1}^s n_i &#x3D;m$； 得到$g(\\lambda)&#x3D;c_0+c_1\\lambda+…+c_{m-1}\\lambda^{m-1}$，并令$g^{(j)}(\\lambda_i)&#x3D;f^{(j)}(\\lambda_i)$，解得系数$c_0,c_1,…,c_{m-1}$； 最后得到$f(A) &#x3D; c_0I + c_1A+…+c_{m-1}A^{m-1}$ 📌当不同特征值的个数比较多或者最小多项式幂次较高时，计算起来比较复杂，建议使用第一种。 （10）两个知识点： 重要的导数：$\\color{red}{\\frac{d A^{-1}(t)}{dt} &#x3D; - A^{-1}(t) \\big( \\frac{d}{dt}A(t)\\big)A^{-1}(t)}$ 矩阵指数函数的行列式：$|e^A| &#x3D; e^{trA}$ 📌上式证明：矩阵函数的特征值是让原矩阵的特征值做函数参数的结果，即 $A$的特征值是$\\lambda$，则$f(A)$的特征值是$f(\\lambda)$ 由于A相似于Jordan标准型，所以$|e^{A}|&#x3D;|P||e^{J_A}||P^{-1}|$，由于行列式等于特征值之积， 所以$|e^A|&#x3D;|e^{J_A}|&#x3D;e^{\\lambda_1}e^{\\lambda_2}…&#x3D;e^{\\lambda_1+\\lambda_2+…}&#x3D;e^{trA}$ （11）矩阵函数应用 一阶常系数齐次微分方程组： $\\begin{cases}\\dot{x}(t) &#x3D; Ax(t)\\x(t_0) &#x3D; C_{n \\times 1}\\end{cases}$ 解为：${\\color{red}{x(t) &#x3D; e^{A(t-t_0)}x(t_0)}}$ 一阶线性常系数非齐次线性方程组：$\\begin{cases}\\dot{x}(t) &#x3D; Ax(t) + f(t)\\x(t_0) &#x3D; C\\end{cases}$ 解为：${\\color{red} {x(t) &#x3D; e^{A(t-t_0)}x(t_0) + \\int_{t_0}^t e^{A(t-\\tau)}f(\\tau)d \\tau}}$ 6 Kronecker积 （1）对于矩阵$A&#x3D;(a_{ij}) \\in C^{m \\times n}, ;B&#x3D;(b_{ij}) \\in C^{s \\times t}$，则K积为： $$A \\otimes B &#x3D; \\begin{bmatrix}a_{11}B &amp; a_{12}B &amp; … &amp; a_{1n}B\\ a_{21}B &amp; a_{22}B &amp; … &amp; a_{2n}B\\ … &amp; … &amp; &amp; …\\ a_{n1}B &amp; a_{n2}B &amp; … &amp; a_{nn}B\\end{bmatrix}$$ 📌K积不具有交换律，即$A \\otimes B \\neq B \\otimes A$ （2）重要性质 $I \\otimes I &#x3D; I$ $(A \\otimes B)(C \\otimes D) &#x3D; (AC) \\otimes (BD)$ $(A \\otimes B)^k &#x3D; A^k \\otimes B^k$ $(A \\otimes B) &#x3D; (I_m \\otimes B)(A \\otimes I_n)$ $(A \\otimes B)^{-1} &#x3D; A^{-1} \\otimes B^{-1}$ $|A \\otimes B| &#x3D; |B \\otimes A| &#x3D; |A|^n|B|^m$（这里的表示的阶数，表示的阶数） $rank(A \\otimes B) &#x3D; rank(A)rank(B)$ 酉矩阵的K积也是酉矩阵 Hermite矩阵的K积也是Hermite矩阵 （3）K和：设$A \\in F^{m \\times m}, ;B \\in F^{n \\times n}$，$A \\oplus B &#x3D; A \\otimes I_n + I_m \\otimes B$ （4）若$A$的特征值是$\\lambda_i$，相应的特征向量是$x_i$；$B$的特征值是$\\mu_i$，相应的特征向量为$y_i$；则： $**A \\otimes B$的特征值是$\\color{red}{\\lambda_i \\mu_i}$，对应的特征向量是$\\color{red}{x_i \\otimes y_i}$** $**A \\oplus B$的特征值是$\\color{red}{\\lambda_i + \\mu_i}$，对应的特征向量是$\\color{red}{x_i \\otimes y_i}$** 📌K积下的奇异值也和特征值有一样的结论 （5）设$f(z)$是解析函数，$A \\in F^{n \\times n}$，$f(A)$存在，则 $f(I_m \\otimes A) &#x3D; I_m \\otimes f(A)$ $f(A \\otimes I_m) &#x3D; f(A) \\otimes I_m$ （6）设矩阵$A \\in F^{m \\times n}, \\quad A&#x3D;(A_1, A_2,…,A_n)$，则$Vec(A) &#x3D; \\begin{bmatrix}A_1\\ A_2\\ …\\ A_n\\end{bmatrix} \\in F^{nm}$ 📌${\\color{red}{Vec(ABC) &#x3D; (C^T \\otimes A)Vec(B)}}$ $Vec(AX) &#x3D; (I_s \\otimes A)Vec(X)$ $Vec(XC) &#x3D; (C^T \\otimes I_k) Vec(X)$ （7）求解矩阵方程$AX+XB&#x3D;D$，将两边同时取向量化算子，得到${\\color{red}{(I_m \\otimes A + B^T \\otimes I_n)Vec(X) &#x3D; Vec(D)}}$，最后通过常规的求非齐次线性方程组的方法求解。 （8）求微分方程：$\\begin{cases}\\dot{X}(t) &#x3D; AX(t) + X(t)B\\X(0) &#x3D; C\\end{cases}$ 用向量化算子作用在方程两边，得到$Vec(\\dot{X}(t)) &#x3D; (I_n \\otimes A + B^T \\otimes I_m)Vec(X(t))$和$Vec(X(0)) &#x3D; Vec(C)$ 令$Y(t) &#x3D; Vec(X(t)), \\quad C_1 &#x3D; Vec(C), \\quad G &#x3D; I_n \\otimes A + B^T \\otimes I_m$，通过求解普通微分方程的方法得到$Y(t) &#x3D; e^{Gt}C_1$； 将$Y(t), ; G, ; C_1$带入化简求得$X(t)$。","categories":[{"name":"数学","slug":"数学","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数学方法","slug":"数学方法","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6%E6%96%B9%E6%B3%95/"}]},{"title":"Docker使用方法详解","slug":"Docker/Docker","date":"2020-04-05T09:55:32.000Z","updated":"2022-07-10T13:22:58.194Z","comments":true,"path":"2020/04/05/Docker/Docker/","link":"","permalink":"http://example.com/2020/04/05/Docker/Docker/","excerpt":"","text":"Docker官方手册 电子书：docker从入门到实践 1 docker简介1.1 docker与虚拟机1.2 镜像2 docker基本命令2.1 docker基本命令概览 2.2 docker run详解 📌若之前未下载对应镜像，会从docker hub拉取；若下载过，直接用镜像创建 若直接输入docker run ubuntu，会发现创建了容器之后便退出了，并没有运行 这是因为docker是用来运行进程或任务的，进程一旦完成，容器便会退出。而ubuntu只是一个其它服务依托的基础镜像，本身并没有进程，所以创建新容器后就会退出。 1234567#----------------- 解决这种问题的几种方式 ---------------------# 方式一：启动容器时指定运行命令docker run ubuntu sleep 5 # 此命令会启动容器时执行sleep 5，睡眠5秒后应用停止，容器退出# 方式二：交互模式，连接到终端docker run -it kodekloud/simple-prompt-docker 若容器化应用既包括标准输入又有标准输出，那run容器时默认只会输出，并不会监听标准输入 -i ：交互模式，可以监听标准输入 -t：即使是交互模式，由于终端不一致，有标准输入的app仍不会完整实现，所以用-t选项连接终端 docker run还有attach和detach的选项 12345# -d选项，使容器在后台运行docker run -d kodekloud/simple-webapp# 如果想重新连接到正在后台运行的容器，可以使用attach命令docker attach 容器ID/容器名 此外还可以用tag指定run的版本，如docker run redis:4.0（默认tag是latest） 端口映射：-p选项 docker容器的IP地址以及端口均属于内部，可以从容器内部访问localhost，但是外部默认无法访问 此时需要将容器的端口映射到主机的端口，之后便可以通过主机IP访问容器 12# simple-webapp程序监听容器的5000端口docker run -p 80:5000 kodekloud/simple-webapp #容器的5000端口被映射到主机的80端口 通过把不同容器映射到主机的不同端口上，可以同时实现多个实例 目录映射 容器有自己的隔离的文件系统，任何对文件的修改都发生在容器内部，如果用rm命令删除容器，数据也会消失。如果想删除容器但是保留数据，可以将容器内的卷挂载到主机中。 1234# -v选项负责目录映射docker run -v /opt/datadir:/var/lib/mysql mysql# 将主机的/opt/datadir映射到mysql容器内的/var/lib/mysql目录# mysql容器删除后/opt/datadir中的内容仍在 设置并查看环境变量 可以在run的时候指定容器的环境变量，从而使调用该环境变量的程序得到自定义数值 123456# 使用-e选项，将simple-webapp-color容器中的APP_COLOR环境变量赋值为bluedocker run -e APP_COLOR=blue simple-webapp-color# 使用inspect可以查看环境变量的值docker inspect simple-webapp-color# 输出中的Config中会有环境变量列表 3 docker构建镜像基本步骤 创建Dockerfile（dockerfle中的每一行都是命令+参数） 1234567891011FROM UbuntuRUN apt-get updateRUN apt-get install pythonRUN pip install flaskRUN pip install flask-mysqlCOPY . /opt/source-codeENTRYPOINT FLASK_APP=/opt/source-code/app.py flask run Layer1. Base Ubuntu Layer Layer2. Changes in apt packages Layer3. Changes in pip packages Layer4. Source Code Layer5. Update Entrypoint with &quot;flask command&quot; 📌关于docker分层结构：- 每一层只存储与前一层之间的变化，所以往往层数很高时，该层大小也很小- docker history+镜像名：可查看每一层执行的命令和大小- docker build会在构建期间缓存已经成功的层，这样如果构建失败或者需要修改镜像时，可以从中间的某一层开始重新构建，节省时间 # dockerfile基本指令 FROM : 指定基础镜像，在其上构建当前镜像 RUN : 在基础镜像容器中运行命令 COPY : 从本地指定目录复制内容到容器的指定目录 CMD : 指定在容器初始阶段运行的默认程序（有参数） 如Ubuntu镜像的dockerfile中有CMD &#123;&quot;bash&quot;&#125; 如果在docker run后追加命令，该命令会覆盖默认CMD 有两种书写格式： CMD command param1 | CMD [&quot;command&quot;,&quot;param1&quot;] CMD sleep 5 CMD [&quot;sleep&quot;,&quot;5&quot;] ENTRYPOINT : 指定在容器初始阶段运行的默认程序（可以无参数） docker run后追加参数，相当于执行ENTRYPOINT中的命令+参数 ENTRYPOINT+CMD组合 : 默认执行ENTRYPOINT命令+CMD参数，此时二者必须是JSON格式 ENTRYPOINT [&quot;sleep&quot;] CMD [&quot;5&quot;] ADD : 相当于COPY，有自动解压缩功能，但会令镜像构建缓存失效，使镜像构建缓慢 ENV : 设置环境变量，格式有两种 ENV &lt;key&gt; &lt;value&gt; ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt; ARG : 设置构建镜像时的环境变量，容器运行时环境变量不复存在，即相当于dockerfile的宏 有作用域，若在FROM指令之前指定，那么只能用于该FROM指令中，后续指令无法再用 参数值在docker build中可用--build-arg &lt;参数名&gt;=&lt;值&gt;来覆盖 WORKDIR : 相当于dockerfile中的cd 📌注：若要在容器运行时改变入口点，如从sleep改成bash，可以docker run - - entrypoint bash ubuntu-sleeper 10 更多dockerfile指令可查看https://vuepress.mirror.docker-practice.com/image/dockerfile/ 使用docker build构建镜像 123456# 使用URL github.com/creack/docker-firefox 的 Dockerfile 创建镜像docker build github.com/creack/docker-firefox# 通过-f选项指定Dockerfile的位置docker build -f /path/to/Dockerfile# 使用当前目录的 Dockerfile 创建镜像（注意最后那个点），标签为 runoob/ubuntu:v1docker build -t runoob/ubuntu:v1 . 使用docker push将镜像推到docker hub 4 docker registry docker registry是镜像存储的地方，中央仓库 如nginx镜像名全称为nginx&#x2F;nginx，前者是用户名，若不提供则默认用户名与镜像名相同 默认的docker registry是dockerhub，其它的还有谷歌gcr(提供k8s镜像)等等，AWS等公司也提供私有registry方便于不想共享镜像的时候 dockerhub提供的私有仓库：docker login private-registry.io 使用私有仓库需要保证在登录状态 本地Registry创建与使用Registry本身就是一个应用程序，且已经ss被做成了镜像，其容器开放端口5000，利用该容器可以在局域网内与团队共享所创建的镜像 12345678910# 运行registry容器，也可以加上-v选项将镜像存于本地docker run -d -p 5000:5000 --name registry registry:2# 使用tag将镜像标记为可被本地Registry接受的镜像名docker image tag my-image localhost:5000/my-image# 向本地registry推送镜像docker push localhost:5000/my-image# 从本地registry拉取镜像docker pull localhost:5000/my-image# 从局域网内其它主机的registry拉取镜像docker pull 192.168.56.100:5000/my-image 📌注：可以通过curl localhost:5000&#x2F;v2&#x2F;_catalog命令查看镜像是否上传成功 上述方法适用于docker 1.3.x之前的版本，交互全部使用http服务。然而该版本之后，docker搭建私有镜像默认使用https，若从registry里pull镜像会报错。 解决办法一：配置SSL证书 官方文档（难，因为很难建立证书） 创建certs文件夹 1mkdir -p certs 从CA拷贝.crt和.key文件到certs文件夹（例中采用名字domain.crt和domain.key） 假设域名为https:&#x2F;&#x2F;myregistry.domain.com&#x2F; &amp;#x20;2. 启动registry容器 123456789docker run -d \\ --restart=always \\ --name registry \\ -v &quot;$(pwd)&quot;/certs:/certs \\ -e REGISTRY_HTTP_ADDR=0.0.0.0:443 \\ -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/domain.crt \\ -e REGISTRY_HTTP_TLS_KEY=/certs/domain.key \\ -p 443:443 \\ registry:2 此命令将容器中的certs文件夹挂载到宿主机的certs文件夹，通过环境变量告知容器该到哪里找domain.crt和domain.key。registry将在443端口（默认HTTPS端口）运行。 新registry通过myregistry.domain.com访问 1234docker pull ubuntu:16.04docker tag ubuntu:16.04 myregistry.domain.com/my-ubuntudocker push myregistry.domain.com/my-ubuntudocker pull myregistry.domain.com/my-ubuntu 使用中间证书(intermediate certificate) 证书发放者往往会提供的是中间证书，需要利用该证书创建domain.crt 1cat domain.crt intermediate-certificates.pem &gt; certs/domain.crt 解决方法2：需要pull的机器添加信任registry列表 打开&#x2F;etc&#x2F;docker&#x2F;daemon.json 添加私有registry 1&quot;insecure-registries&quot;:[&quot;myregistry.example.com:5000&quot;] 或 1234&quot;insecure-registries&quot;: [ &quot;registry:5000&quot;, &quot;registry2:5000&quot;] 5 docker存储docker容器被创建后，就会创建以下目录 docker文件系统 /var/lib/docker -- aufs -- containers -- image -- volumes 一般容器内的数据在容器删除后便被删除，要想避免这种情况可以采用外部存储挂载到容器内的方法 主要有两种挂载方式，卷挂载(volume)和绑定挂载(binding) 5.1 卷挂载卷挂载是在docker主机内创建一个独立于容器的卷，卷内的内容与宿主机无关 创建卷 123456789101112131415$ docker volume create my-vol # 创建卷$ docker volume ls # 列出所有卷DRIVER VOLUME NAMElocal my-vol$ docker volume inspect my-vol # 查看卷的信息[ &#123; &quot;Driver&quot;: &quot;local&quot;, &quot;Labels&quot;: &#123;&#125;, &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;, &quot;Name&quot;: &quot;my-vol&quot;, &quot;Options&quot;: &#123;&#125;, &quot;Scope&quot;: &quot;local&quot; &#125;] 挂载卷 12旧写法：-v my-vol:/usr/share/nginx/html #后者是容器内目录新写法：--mount source=my-vol,target=/usr/share/nginx/html 删除卷 12docker volume rm my-voldocker volume prune #删除无主卷 5.2 绑定挂载绑定挂载是将宿主机的目录指定为容器内的目录，即该目录的修改是对宿主机目录的直接修改 旧写法：-v选项 新写法：- - mount选项 6 docker网络 docker自动创建Bridge、 none、 host三种网络可通过network选项修改当前模式：docker run Ubuntu - -network&#x3D;host none模式：完全没有网络，容器彼此隔绝，容器与主机隔绝 host模式：容器使用主机的网络，容器的端口就是主机的端口，注意此时，不同容器再不能在内部使用相同的端口运行程序 Bridge模式详解7 docker composeCompose-file官方文档 8 docker swarm官方文档 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131version: &#x27;3.7&#x27;services: minio1: image: minio/minio:RELEASE.2020-11-19T23-48-16Z hostname: minio1 volumes: - minio1-data:/export ports: - &quot;9001:9000&quot; networks: - minio_distributed deploy: restart_policy: delay: 10s max_attempts: 10 window: 60s placement: constraints: - node.labels.minio1==true command: server http://minio&#123;1...4&#125;/export secrets: - secret_key - access_key healthcheck: test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:9000/minio/health/live&quot;] interval: 30s timeout: 20s retries: 3 minio2: image: minio/minio:RELEASE.2020-11-19T23-48-16Z hostname: minio2 volumes: - minio2-data:/export ports: - &quot;9002:9000&quot; networks: - minio_distributed deploy: restart_policy: delay: 10s max_attempts: 10 window: 60s placement: constraints: - node.labels.minio2==true command: server http://minio&#123;1...4&#125;/export secrets: - secret_key - access_key healthcheck: test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:9000/minio/health/live&quot;] interval: 30s timeout: 20s retries: 3 minio3: image: minio/minio:RELEASE.2020-11-19T23-48-16Z hostname: minio3 volumes: - minio3-data:/export ports: - &quot;9003:9000&quot; networks: - minio_distributed deploy: restart_policy: delay: 10s max_attempts: 10 window: 60s placement: constraints: - node.labels.minio3==true command: server http://minio&#123;1...4&#125;/export secrets: - secret_key - access_key healthcheck: test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:9000/minio/health/live&quot;] interval: 30s timeout: 20s retries: 3 minio4: image: minio/minio:RELEASE.2020-11-19T23-48-16Z hostname: minio4 volumes: - minio4-data:/export ports: - &quot;9004:9000&quot; networks: - minio_distributed deploy: restart_policy: delay: 10s max_attempts: 10 window: 60s placement: constraints: - node.labels.minio4==true command: server http://minio&#123;1...4&#125;/export secrets: - secret_key - access_key healthcheck: test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:9000/minio/health/live&quot;] interval: 30s timeout: 20s retries: 3volumes: minio1-data: minio2-data: minio3-data: minio4-data:networks: minio_distributed: driver: overlaysecrets: secret_key: external: true name: minio_secret_key access_key: external: true name: minio_access_key","categories":[{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"JavaScript","slug":"JavaScript","date":"2020-02-24T08:54:31.000Z","updated":"2022-07-10T13:37:30.591Z","comments":true,"path":"2020/02/24/JavaScript/","link":"","permalink":"http://example.com/2020/02/24/JavaScript/","excerpt":"","text":"JavaScript1 在HTML中使用JS 方式1 123&lt;script&gt; console.log(&#x27;Hello World!&#x27;);&lt;/script&gt; 方式2 1&lt;script&gt;src = &quot;main.js&quot;&lt;/script&gt; 12//main.jsconsole.log(&#x27;Hello World!&#x27;) 2 变量三种方式声明 var：全局作用域，最不常用 let：可重新赋值的局部变量 const：不可重新赋值的局部变量；必须初始化，否则报错；最常用 3 数据类型12345678910//string number boolean null undefinedconst name = &#x27;John&#x27;; //stringconst age = 30; //numberconst rating = 4.5; //numberconst isCool = true; //booleanconst x = null; //nullconst y = undefined; //undefinedlet z; //undefined//查看变量的数据类型：typeofconsole.log(typeof x);//此时会输出object而不是null，这是JS的一个bug JS的数字不区分整形和浮点数 4 字符串 字符串中加入变量 123456const name = &#x27;John&#x27;;const age = 30;//方式1：拼接console.log(&#x27;My name is &#x27;+name+&#x27; and I am &#x27;+age);//方式2：模板字符串，需反引号console.log(`My name is $&#123;name&#125; and I am $&#123;age&#125;`); 部分字符串属性与方法 123456789const s = &#x27;Hello World!&#x27;;console.log(s.length);//长度属性console.log(s.toUpperCase());//转大写方法console.log(s.toLowerCase());//转小写方法console.log(s.substring(0,5));//截取子串，从0开始，在5之前结束，输出&#x27;Hello&#x27;console.log(s.substring(0,5).toUpperCase());//HELLO//分割字符串到数组中const v = &#x27;technology, computer, it, code&#x27;console.log(v.split(&#x27;, &#x27;))//输出[technology,computer,it,code]; 5 数组1234567891011121314151617//JS数组不需要指定长度和类型/*-------创建数组-------*///创建方式1const numbers = new Array(1,2,3,4,5);//创建方式2const fruits = [&#x27;Apple&#x27;, &#x27;Orange&#x27;, 10, true];//JS中数组可以存放不同类型值//在数组末尾添加值fruits[4]=&#x27;Mangos&#x27;;fruits.push(&#x27;Grapes&#x27;);//在数组开头添加值fruits.unshift(&#x27;Strawberries&#x27;);//数组末尾删除值fruits.pop();//判断是否是数组console.log(Array.isArray(fruits));//寻找索引console.log(fruits.indexOf(&#x27;Orange&#x27;)); 6 对象JS中的对象就是键值对 12345678910111213141516const person = &#123; firstName:&#x27;John&#x27;, lastName:&#x27;Doe&#x27;, age:30, hobbies:[&#x27;music&#x27;,&#x27;movie&#x27;,&#x27;sport&#x27;], address:&#123;//对象里可以嵌套对象 street:&#x27;50 main st&#x27;, city:&#x27;Boston&#x27;, state:&#x27;MA&#x27; &#125;&#125;//找到&#x27;movie&#x27;person.hobbies[1]//找到Bostonperson.address.city 定义后仍可添加属性 1person.email = &#x27;john@gmail.com&#x27; 解构 1234567const &#123;firstName, lastName&#125; = person;//firstName变量被创建，并赋值为person.firstName，即Bob//lastName变量被创建，并赋值为person.lastName，即Doe//对象里的嵌套对象的属性也可以被结构const &#123;firstName, lastName, address:&#123;city&#125;&#125; = person;//city变量被创建，并赋值为person.address.city，即Boston 对象数组 JSON 1234567891011121314151617const todos = [ &#123; id: 1, text: &#x27;Take out trash&#x27;, isCompleted:true &#125;, &#123; id: 2, text: &#x27;Meeting with boss&#x27;, isCompleted:true &#125;, &#123; id: 3, text: &#x27;Dentist appt&#x27;, isCompleted:false &#125;]; 123456789101112131415161718[ &#123;//所有属性要加上双引号 &quot;id&quot;: 1, //字符串不能再用单引号 &quot;text&quot;: &quot;Take out trash&quot;, isCompleted:true &#125;, &#123; &quot;id&quot;: 2, &quot;text&quot;: &quot;Meeting with boss&quot;, &quot;isCompleted&quot;:true &#125;, &#123; &quot;id&quot;: 3, &quot;text&quot;: &quot;Dentist appt&quot;, &quot;isCompleted&quot;:false &#125;] 12//对象数组转JSONconst todoJSON = JSON.stringify(todos); 7 循环12345678910111213141516171819202122232425262728293031//forfor(let i = 0; i &lt; 10; i++)&#123; console.log(i);&#125;//whilelet i = 0;while(i &lt; 10)&#123; console.log(i); i++;&#125;//for...offor(let todo of todos)&#123; console.log(todo.text);&#125;//forEach：foreach是方法，输入参数为函数，该函数为每一个数组元素执行任务，无返回值todos.forEach(function(todo)&#123;//todo可被看作每个数组元素的代称 console.log(todo.text);&#125;); //map：与forEach一致，但是有返回值，最后会创建新数组，不影响旧数组const todoText = todos.map(function(todo)&#123; return todo.text;&#125;); //filter：也会返回新数组，但是只摘取原数组中满足条件的元素const todoCompleted = todos.filter(function(todo)&#123; return todo.isCompleted === true;&#125;); 8 条件1234567if(a &gt; 5)&#123; console.log(&#x27;a is bigger than 5&#x27;);&#125;else if(a &lt; 5)&#123; console.log(&#x27;a is less than 5&#x27;);&#125;else&#123; console.log(&#x27;a is equal to 5&#x27;);&#125; 1234567891011switch(color)&#123;case &#x27;blue&#x27;: console.log(&#x27;color is blue&#x27;); break;case &#x27;red&#x27;: console.log(&#x27;color is red&#x27;); break;default: console.log(&#x27;color is others&#x27;); break;&#125; JS中&#x3D;&#x3D;&#x3D;要求数据类型一致且数值相等；而&#x3D;&#x3D;不要求数据一致，’10’&#x3D;&#x3D;10，自动类型转换 9 函数 典型函数 1234//格式：function 函数名(参数名,...)&#123;&#125;function addNums(num1 = 1, num2 = 1)&#123;//这里只是设置默认值，可不写= return num1+num2;&#125; 箭头函数，好处体现在只有一行的函数可以写得简短些 123const addNums(num1 = 1, num2 = 1) =&gt; &#123; return num1+num2;&#125; 10 面向对象12345678910111213/*-------假设已经定义person对象为例-------*///构造函数function Person(firstName,lastName,dob)&#123; this.firstName = firstName; this.lastName = lastName; this.dob = new Date(dob); //创建方法 this.getBirthday = function()&#123; return this.dob.getFullYear(); &#125;&#125;//初始化const person1 = new Person(&#x27;John&#x27;,&#x27;Doe&#x27;,&#x27;4-3-1980&#x27;); 原型 原型是所有对象都会继承的对象，可以通过在原型添加属性、方法，实现在对象中添加属性与方法 12345678910111213function Person(firstName,lastName,dob)&#123; this.firstName = firstName; this.lastName = lastName; this.dob = new Date(dob);&#125;//创建方法Person.prototype.getBirthday = function()&#123; return this.dob.getFullYear();&#125;//初始化const person1 = new Person(&#x27;John&#x27;,&#x27;Doe&#x27;,&#x27;4-3-1980&#x27;);//调用方法不需要写原型person1.getBirthday(); 类：ES6引入先特性，与上述对象行为一致，只是写法更清晰 123456789101112class Person &#123; //构造函数 constructor(firstName, lastName, dob)&#123; this.firstName = firstName; this.lastName = lastName; this.dob = new Date(dob); &#125; //方法 getBirthday()&#123; return this.dob.getFullYear(); &#125;&#125; 11 DOMDOM(Document Object Model)，是借助window对象的document属性，获取HTML的ID、类、标签、文本等等元素，并且可以对HTML\\CSS进行修改，从而获取有用数据或者改变网页状态。 window对象就是浏览器的窗口，网页应用皆继承window对象 1 12 同步与异步","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"Go语言基础","slug":"Golang/Golang","date":"2019-12-21T05:22:57.000Z","updated":"2022-07-10T13:23:24.404Z","comments":true,"path":"2019/12/21/Golang/Golang/","link":"","permalink":"http://example.com/2019/12/21/Golang/Golang/","excerpt":"","text":"Golang基础语法1. Workspace go(workspace) -bin 存放二进制 -src 存放源文件 github.com username go_project_1 file_1 …… go_project_2 file_1 …… -pkg 存放安装的包 建立go语言的workspace前提是将GOPATH设置成了环境变量，可用go env查看GOPATH go语言的工程结构比较严格，参见上面的文件树 可通过godoc.org查看可安装包，利用go get安装 2. Hello World !12345package mainimport &quot;fmt&quot;func main()&#123; fmt.Println(&quot;Hello World!&quot;)&#125; 文件结构：包声明 → 导入包 → 函数 包声明：指明文件属于哪个包，package main执行入口，每个应用程序都有package main 导入包需双引号，单引号会报错 无需分号 3. 变量与数据类型123456789101112131415161718192021222324252627282930package mainimport &quot;fmt&quot;func main()&#123; //MAIN TYPES //string //bool //int(对应CPU平台字长) int8 int16 int32 int64 //uint(对应CPU平台字长) uint8 uint16 uint32 uint64 uintptr //byte - alias for uint8 //rune - alias for int32 //float32 float64 //complex64 complex128 /*---------定义变量 第一种方法：var关键字---------*/ /*格式：var + 变量名 + 数据类型 = 赋值*/ var name_1 string = &quot;oliver&quot;//这里的string可省略，编译器可推断出它是string类型 var age = 32//编译器推断出是int类型 name_1 = &quot;Peter&quot;//使用var关键字定义后可修改变量值 /*使用const关键字*/ const isCool = true//省略bool //isCool = false 不注释会报错 /*---------定义变量 第二种方法：冒号---------*/ /*格式：变量名 := 赋值*/ name_2 := &quot;Pai&quot; /*多变量定义的简便写法*/ name_3,email := &quot;oliverPai&quot;,&quot;oliver@gmail.com&quot; fmt.Println(name_1,name_2,name_3,age,isCool,email)&#125; go语言中，变量声明不使用会报错 获取类型方法：fmt.Printf(“%T”,variables) 第一种方法可以在函数外声明变量，第二种方法只能用于函数内，且无法指定类型 go语言中没有专门的字符类型，字符串由一个个字节构成 注意，go语言不支持隐式做int和bool类型间的转换，需要自己写btoi或itob函数 go、string与float64之间的转换 12345678910111213141516171819202122232425//-------------------------- int转string ------------------------------i := int64(123)s := strconv.Itoa(i)s := strconv.FormatInt(i, 10)//-------------------------- string转int ------------------------------i, err := strconv.Atoi(s)i, err := strconv.ParseInt(s, 10, 64)//转int64//第二个参数为基数，第三个参数位大小表示期望转换的结果类型，其值可以为0, 8, 16, 32和64//float转stringv := 3.1415926535s1 := strconv.FormatFloat(v, &#x27;E&#x27;, -1, 32)//&#x27;e&#x27;&amp;&#x27;E&#x27;: 表示10进制指数//&#x27;b&#x27;: 表示2进制指数//&#x27;f&#x27;: 无指数，正常形式//&#x27;g&#x27;&amp;&#x27;G&#x27;: 大数用&#x27;e&#x27;表示，否则用&#x27;f&#x27;//&#x27;x&#x27;&amp;&#x27;X&#x27;: 16进制表示的二进制指数//-1是精度float32s2 := strconv.FormatFloat(v, &#x27;E&#x27;, -1, 64)//float64//string转floats := &quot;3.1415926535&quot;v1, err := strconv.ParseFloat(v, 32)v2, err := strconv.ParseFloat(v, 64) 4. 包package 导入多个包：包之间无需逗号，空格间隔即可。不同包需写在不同行，需要圆括号 1234import ( &quot;fmt&quot; &quot;math&quot;) 新建自己的包 新建文件夹，新建函数的文件 在文件顶部声明包名（不需要与文件夹同名） 在文件内写函数 123456789//创建strutil文件夹，新建reverse.go文件package strutilfunc reverse(s string) string &#123; runes := []rune(s) for i,j := 0,len(runes)-1 ; i&lt;j ; i,j = i+1, j-1&#123; runes[i],runes[j] = runes[j],runes[i] &#125; return string(runes)&#125; 新建后，导入包路径需从src开始，如reverse.go存在&#x2F;src&#x2F;github.com&#x2F;oliverPai&#x2F;strutil&#x2F;reverse.go，则导入包时为import “github.com&#x2F;oliverPai&#x2F;strutil“ 导入go get获取的包，与导入自己的包一样操作，如aws包 import “github.com&#x2F;aws“ 5 数组array&amp;slice1234567891011/*------Array 定长数组------*//*先声明后赋值*/var fruitArr [2] stringfruitArr[0] = &quot;Apple&quot;fruitArr[1] = &quot;Orange&quot;/*声明并赋值*/fruitArr_1 := [2]string&#123;&quot;Apple&quot;,&quot;Orange&quot;&#125;/*------Slice 不定长数组------*/fruitSlice := []string&#123;&quot;Apple&quot;,&quot;Orange&quot;,&quot;Grape&quot;&#125; 统计数组元素个数可用len函数 数组支持切片操作，如fmt.Println(fruitSlice[1:2])输出Orange，从索引1开始，在索引2之前结束 make函数构造slice slice本质上是引用类型，可用make构造 1234567891011//格式：make([]T, size, cap)//T:切片的元素类型//size:切片中元素的数量//cap:切片的容量func main() &#123; a := make([]int, 2, 10) fmt.Println(a) //[0 0] fmt.Println(len(a)) //2 fmt.Println(cap(a)) //10&#125;//如果是make([]int,2),则len为2 slice元素的增删 append函数可以用来在slice末尾追加元素 12345678func main()&#123; var s []int s = append(s, 1) // [1] s = append(s, 2, 3, 4) // [1 2 3 4] s2 := []int&#123;5, 6, 7&#125; //对一个slice添加另一个slice的元素时，需要加上... s = append(s, s2...) // [1 2 3 4 5 6 7]&#125; go语言中没有专门的删减slice元素的函数，但是可以通过赋值完成这一目标 12//对a中删掉索引为index的元素a = append(a[:index], a[index+1:]...) slice的拷贝 slice的拷贝分为两种情况，一种是两个slice共享一片内存区域，二者完全相同，修改一个会更改另一个的值；另一种情况是二者只是数值相同而已，修改一个不会对另一个造成影响 12345678//第一种情况，直接赋值拷贝，二者共享内存func main() &#123; s1 := make([]int, 3) //[0 0 0] s2 := s1 //将s1直接赋值给s2，s1和s2共用一个底层数组 s2[0] = 100 fmt.Println(s1) //[100 0 0] fmt.Println(s2) //[100 0 0]&#125; 123456789101112//第二种情况，使用copy函数，不共享内存func main() &#123; // copy()复制切片 a := []int&#123;1, 2, 3, 4, 5&#125; c := make([]int, 5, 5) copy(c, a) //使用copy()函数将切片a中的元素复制到切片c fmt.Println(a) //[1 2 3 4 5] fmt.Println(c) //[1 2 3 4 5] c[0] = 1000 fmt.Println(a) //[1 2 3 4 5] fmt.Println(c) //[1000 2 3 4 5]&#125; 判断slice为空应该通过len(slice)&#x3D;&#x3D;0判断，而不是slice&#x3D;&#x3D;nil 6 函数+异常123456789101112131415161718192021222324252627282930/*格式：func 函数名(参数1 参数1类型, 参数2 参数2类型,...)(返回值1类型, 返回值2类型 ,...)&#123;&#125;*/func greeting(name string) string &#123; return &quot;Hello&quot;+name&#125;/*某些参数若同类型，可写在一起，只保留一个数据类型*/func plus(a, b int) int &#123; return a + b&#125;/*可给返回值命名，也可不命名*/func SumAndProduct(A, B int) (int, int) &#123; return A+B, A*B&#125;func change(a, b int) (x, y int) &#123;//命名可使代码阅读和书写更清晰 x = a + 100//101 y = b + 100//102 return//101 102 //return x, y //同上 //return y, x //102 101&#125;/*匿名函数*/f := func(a,b int) int&#123; return a+b&#125;//直接执行匿名函数——加括号func()&#123; fmt.Println(&quot;Anonymous&quot;)&#125;() 匿名函数可以用来做异常处理，通过defer+recover 12345678910111213141516171819package mainfunc a()&#123; fmt.Println(&quot;function a\\n&quot;)&#125;//仅用panic做异常处理func b()&#123; panic(&quot;panic in b&quot;)&#125;func c()&#123; fmt.Println(&quot;function c\\n&quot;)&#125;func main()&#123; a() b() c()&#125;//输出 function a// panic: panic in b//由于在b函数终止，因此未全部执行完 1234567891011121314151617181920//使用匿名函数+defer+recover的异常处理//defer+recover可暂时跳过出错地方func b()&#123; defer func()&#123; err := recover() if err != nil&#123;//检测到错误 fmt.Println(&quot;function b error&quot;) &#125; &#125;() panic(&quot;panic in b&quot;)&#125;//输出 function a// function b error// function c//defer会在函数要退出前执行，所以在执行到//panic时，由于出错即将退出，触发匿名函数//执行匿名函数后，不再执行panic、//defer必须写在可能引发panic的语句之前,//否则未注册defer，无法执行匿名函数//如果多个defer函数，它们会逆序执行 📌除了匿名函数+defer+recover做异常处理，还可以使用go内置的error类型 1234//error类型定义type error interface&#123; Error() string&#125; 123456//使用errors.New可返回一个错误信息func sqrt(f float64) (float64,error)&#123; if f &lt; 0&#123; return 0, errors.New(&quot;math: square root of negative number&quot;) &#125;&#125; 7 条件 if语句 12345678//go里面的if不需要圆括号if color == &quot;red&quot;&#123; fmt.Println(&quot;color is red&quot;)&#125; else if color == &quot;blue&quot;&#123; fmt.Println(&quot;color is blue&quot;)&#125; else &#123; fmt.Println(&quot;color is not red or blue&quot;)&#125; switch语句 123456789//go语言在每个case会自动加上一个break，即go里switch不需要break，同时无法控制执行case的数量switch color&#123;case &quot;red&quot;: fmt.Println(&quot;color is red&quot;)case &quot;blue&quot;: fmt.Println(&quot;color is blue&quot;)default: fmt.Println(&quot;color is not red or blue&quot;)&#125; 8 循环1234567891011121314//写法1i := 1for i &lt;= 10 &#123; fmt.Println(i) i++&#125;//写法2for i := 1; i &lt;= 10; i++&#123; fmt.Println(i)&#125;//无限循环for &#123; //content&#125; for是go语言提供的唯一循环方式 go语言也可以在循环中用continue和break 9 Mapgo语言的Map是键-值对，类似于python的字典 1234567891011121314151617/*-------先声明后赋值-------*//*格式：make(map[键数据类型][值数据类型])*/emails := make(map[string]string)//赋值emails[&quot;Bob&quot;] = &quot;bob@gmail.com&quot;emails[&quot;Sharon&quot;] = &quot;sharon@gmail.com&quot;emails[&quot;Mike&quot;] = &quot;mike@gmail.com&quot;//从map中删除delete(emails,&quot;Bob&quot;)//格式：delete(map名，键名)//索引fmt.Println(emails[&quot;Sharon&quot;])/*-------声明的同时赋值-------*//*格式：:=map[键数据类型]值数据类型&#123;键1:值1,键2:值2,...&#125;*/emails := map[string]string&#123;&quot;Bob&quot;:&quot;bob@gmail.com&quot;,&quot;Sharon&quot;:&quot;sharon@gmail.com&quot;&#125;//依然可以添加东西emails[&quot;Mike&quot;] = &quot;mike@gmail.com&quot; 10 范围rangerange用于遍历数组、map、channel等，能够使for循环成为foreach 123456789101112131415161718192021/*-------遍历数组-------*/ids := []int&#123;33,76,25,89,14,71&#125;//range需要传入两个变量，第一项是index，第二项是index对应的元素for i,id := range ids &#123; fmt.Printf(&quot;%d - ID: %d&quot;, i, id)&#125;//当不想要index时，可用_代替for _,id := range ids &#123; fmt.Printf(&quot;ID: %d&quot;, id)&#125;/*-------遍历Map-------*/emails := map[string]string&#123;&quot;Bob&quot;:&quot;bob@gmail.com&quot;,&quot;Sharon&quot;:&quot;sharon@gmail.com&quot;&#125;//range需要传入两个变量，第一项是键，第二项是值for k,v := range emails&#123; fmt.Printf(&quot;%s: %s&quot;,k,v)&#125;//当只想要键不想要值时，可以省略第二项for k := range emails&#123; fmt.Println(&quot;Name: &quot; + k)&#125; range对数组的操作同样可以应用到字符串上，第一项index，第二项字符 11 指针12345678910func main()&#123; a := 5 b := &amp;a//b是指向a的指针 fmt.Printf(&quot;%T&quot;,b)//输出*int //取值 fmt.Println(*b)//输出5 //改值 *b = 10 fmt.Println(a)//输出10&#125; go语言中指针的好处在于，对于操作某连续地址的一大片数据，使用指针可以提高执行效率 可以利用指针对特殊地址修改数值 12 闭包closure闭包是函数作为返回值时，匿名函数内部访问外层变量的行为 核心在于，被访问的外层变量相当于被访问了引用，其修改后的值被一直保留 12345678910111213141516171819202122/*------例1------*/package mainimport &quot;fmt&quot;//..(..1...).(....2.......)func adder() func(int) int &#123; sum := 0//被访问的外层变量 return func(x int) int &#123; sum += x return sum &#125;&#125;func main()&#123; //将函数赋给变量时，需和1处一致 sum := adder() for i:=0; i&lt; 10; i++&#123; //调用函数变量时，需和2处一致 fmt.Println(sum(i)) &#125;&#125;//输出结果：//0 1 3 6 10 15 21 28 36 45 12345678910111213141516171819202122/*------例2------*/package mainfunc calc(base int)(func(int)int, func(int)int)&#123; add := func(int)int&#123; base += i return base &#125; sub := func(int)int&#123; base -= i return base &#125;&#125;func main()&#123; x,y := calc(100) ret1 := x(200) //base已被改成300 fmt.Println(ret1)//输出100+200=300 //由于base得以保留，此处base是300 ret2 := y(200) fmt.Println(ret2)//输出300-200=100&#125; 闭包的用处 📌A代码： func (o *Once) Do2(f func()) {}B代码： func Do1（参数）需求： B要调用A写的o对象里的方法Do2，并把自己的Do1当作参数传到Do2 中，但是B写的Do1有传参，而A写的Do2中传入的方法参数是不能带参数的解决办法：闭包编写一个func Do3（参数）（func (o *Once) Do2(f func())），也就是新的Do3函数中的参数是Do1中要传入的参数，返回值是Do2，那么在Do2中就能调用Do3中传入的参数，也就是Do1中期望的参数，Do3返回的是一个函数，那这个函数调用了这个函数之外的一个变量，所以形成了一个闭包。 13 结构体go里没有类，结构体可以有属性和方法，结构体就是类 123456789101112131415161718192021package mainimport &quot;fmt&quot;//定义一个结构体type Person struct&#123; firstName string lastName string city string gender string age int&#125;func main()&#123; //初始化结构体 person1:=Person&#123;firstName:&quot;Samantha&quot;, lastName:&quot;Smith&quot;, city:&quot;Boston&quot;, gender:&quot;f&quot;, age:25&#125; fmt.Println(person1)&#125; 12345678910111213//左边代码的简便写法//同类型可以写一起type Person struct&#123; firstName,lastName,city,gender string age int&#125;func main()&#123; //不需要指定属性名 person1 := Person&#123;&quot;Samantha&quot;,&quot;Smith&quot;, &quot;Boston&quot;,&quot;f&quot;,25&#125; fmt.Println(person1)&#125; 12345//获取属性fmt.Println(person1.firstName)//改变属性\\person1.age++fmt.Println(person1.age) 123456789101112/*-------value receiver方法：不改变任何数值-------*///格式：func (identifier 结构体名) 函数名 返回值类型&#123;&#125;func (p Person) greet() string&#123; return &quot;Hello, my name is &quot;+p.firstName+&quot; &quot;+p.lastName+&quot; and I am &quot;+strconv.Itoa(p.age) //这里的strconv.Itoa用来int转字符串，否则会报错，需事先导入strconv包&#125;/*-------pointer receiver方法：改变数值-------*///格式：func (identifier *结构体名) 函数名 返回值类型&#123;&#125;func (p *Person) hasBirthday() &#123; p.age++&#125; identifier相当于this指针，go语言没有- &gt; 结构体的方法不能写在结构体内，要写在外面 匿名字段——实现结构体的“继承” 12345678910111213141516171819//Address 地址结构体type Address struct &#123; Province string City string&#125;//User 用户结构体type User struct &#123; Name string Gender string Address //匿名字段&#125;//当需要访问User中的Address中的Province时可有两种方式var user1 User//方式1：匿名字段默认按类型名索引user1.Address.Province = Hubei//方式2：继承，直接索引，go的struct查找属性顺序：自身属性-&gt;匿名字段属性user1.Province = Hubei 一个结构体包含多个匿名字段时，若这些匿名字段包含同名属性，会导致访问报错 方法也可以被继承，包含匿名字段结构体时，可选类型为指针 123456789101112131415161718192021222324252627/Animal 动物type Animal struct &#123; name string&#125;func (a *Animal) move() &#123; fmt.Printf(&quot;%s会动！\\n&quot;, a.name)&#125;//Dog 狗type Dog struct &#123; Feet int8 *Animal //通过嵌套匿名结构体实现继承&#125;func (d *Dog) wang() &#123; fmt.Printf(&quot;%s会汪汪汪~\\n&quot;, d.name)&#125;func main() &#123; d1 := &amp;Dog&#123; Feet: 4, Animal: &amp;Animal&#123; //注意嵌套的是结构体指针 name: &quot;乐乐&quot;, &#125;, &#125; d1.wang() //乐乐会汪汪汪~ d1.move() //乐乐会动！&#125; 结构体内的标识符（变量名、函数名）首字母大写，则对外可见（别的包可以拿到），否则只能在当前包使用 对结构体中的slice赋值 1234567891011type Person struct &#123; name string age int8 act []string&#125;func main() &#123; p1 := Person&#123;name: &quot;小王子&quot;, age: 18&#125; data := []string&#123;&quot;吃饭&quot;, &quot;睡觉&quot;&#125; p1.SetAct(data)&#125; 12345//方式1：指针赋值//main中data和p.act共同变化func(p *Person)SetAct(dreams[]string)&#123; p.act = dreams&#125; 123456//方式2：拷贝赋值//改变data不会改变p.actfunc(p *Person)SetAct(dreams[]string)&#123; p.dreams = make([]string,len(dreams)) copy(p.act, dreams)&#125; 14 接口interfaceinterface是多种结构体共性方法的集合 interface定义命名一个类型，使得不管最初是什么类型的struct，只要实现了interface中的方法，都可以被算作被interface命名的类型 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//格式/* type 接口名 interface&#123; 方法名1(参数列表1)返回值列表1 ...... &#125;*/package mainimport ( &quot;fmt&quot; &quot;math&quot;)// 定义interfacetype Shape interface &#123; area() float64&#125;//实现Circle结构体的area方法type Circle struct &#123; x, y, radius float64&#125;func (c Circle) area() float64 &#123; return math.Pi * c.radius * c.radius&#125;//实现Rectangle结构体的area方法type Rectangle struct &#123; width, height float64&#125;func (r Rectangle) area() float64 &#123; return r.width * r.height&#125;//因为实现了area方法，Rectangle和Circle都是Shape类型func getArea(s Shape) float64 &#123; return s.area()&#125;func main() &#123; circle := Circle&#123;x: 0, y: 0, radius: 5&#125; rectangle := Rectangle&#123;width: 10, height: 5&#125; fmt.Printf(&quot;Circle Area: %f\\n&quot;, getArea(circle)) fmt.Printf(&quot;Rectangle Area: %f\\n&quot;, getArea(rectangle))&#125; interface是一种类型，一种抽象的类型 利用slice和interface可以实现函数参数可变，格式：变量名…类型 12345678910111213141516171819202122//同类型可变参数func functest1(values ...int)(sum int)&#123; sum = 0 for _,i:=range values&#123; fmt.Println(i) sum += i &#125; return&#125;//参数传入方式func main()&#123; //参数可以为空 fmt.Println(functest1()) //参数可以是1个 fmt.Println(functest1(1)) //参数可以是多个 fmt.Println(functest1(1,3,4)) //参数可以是slice，必须有... var tmp []int = []int&#123;2,4,5&#125; fmt.Println(functest1(tmp...)) //**可变参函数和以slice为参数的函数不一样**&#125; 12345678910111213141516171819202122//不同类型可变参数//类型必须是空的interfacefunc functest2(values ... interface&#123;&#125;)&#123; for _,i := range values&#123; fmt.Printf(&quot;function test2:Type %T, i %v\\n&quot;,i,i) &#125; return&#125;//参数传入方式func main()&#123; //**方式1：传入interface的slice** var d[] interface&#123;&#125; d = append(d,1) d = append(d,&quot;hello&quot;) d = append(d,3.14) functest2(d...)//一定要有... //**方式2：直接传不同类型参数** functest2(&quot;hello&quot;,10)&#125; go认为，任何类型都实现了空接口，所以空接口可接受任何类型值，也可用于函数参数，接收任何类型。同时可用于map的value，扩展map功能 1234var m = make(map[string]interface&#123;&#125;)m[&#x27;name&#x27;] = &#x27;oliver&#x27;m[&#x27;age&#x27;] = agem[&#x27;hobby&#x27;] = []string&#123;&quot;篮球&quot;,&quot;羽毛球&quot;&#125; 数值接收与指针接收实现接口的区别 值接收实现的接口，即可用实现接口的结构体，也可以用该结构体的指针调用接口方法 指针接收实现的接口，只能用结构体的指针调用接口方法 123456//实现Mover接口type Mover interface &#123; move()&#125;//结构体dog，将会使用dog实现值接收接口，也将使用&amp;dog实现指针接收接口type dog struct &#123;&#125; 123456789101112131415//值实现的接口func (d dog) move() &#123; fmt.Println(&quot;狗会动&quot;)&#125;func main() &#123; var x Mover var val_rec = dog&#123;&#125; // dog类型 x = val_rec // x可以接收dog类型 var poi_rec = &amp;dog&#123;&#125;// *dog类型 x = poi_rec // x可以接收*dog类型 x.move()&#125; 123456789101112//指针实现的接口func (d *dog) move() &#123; fmt.Println(&quot;狗会动&quot;)&#125;func main() &#123; var x Mover var poi_rec = &amp;dog&#123;&#125; // *dog类型 x = poi_rec // x只能接收*dog类型 x.move()&#125; 接口类型变量 接口类型变量可以接收任何实现了该接口的类型 123456789//如果有一个Sayer接口，其内部有say方法//cat结构体和dog结构体都实现了say方法var x Sayera := cat&#123;&#125; b := dog&#123;&#125;x = a // 可以把cat实例直接赋值给xx.say() x = b // 可以把dog实例直接赋值给xx.say() 接口嵌套 123456789101112131415// Sayer 接口type Sayer interface &#123; say()&#125;// Mover 接口type Mover interface &#123; move()&#125;// 接口嵌套，生成新的animal接口type animal interface &#123; Sayer Mover&#125; 让一个结构体同时实现say()方法和move()方法，即为实现animal接口 接口类型断言 接口类型断言用于空接口存储变量时，推断出变量的类型，格式x.(T)：x是空接口变量，T是推断类型 1234567891011//x.(T)返回两个变量，第一个是x转换为T类型后的值，第二个是bool值，反映是否推断正确func main() &#123; var x interface&#123;&#125; x = &quot;Hello World&quot; v, ok := x.(string) if ok &#123; fmt.Println(v) &#125; else &#123; fmt.Println(&quot;类型断言失败&quot;) &#125;&#125; 15 反射 📌补充知识：结构体标签(tag)，只用于反射机制，格式为 key1:&quot;value1&quot; key2:&quot;value2&quot; 静态编译语言在编译时，会将变量转换成内存地址，关于变量的信息将消失不见，也无从获取； 但是go语言引入了反射机制，可以将变量的信息(变量名、变量类型等)整合到可执行文件中，从而能够实现在程序运行时对变量信息的访问。采用reflect包的API进行反射操作！ reflect.TypeOf()：获取变量类型 返回的变量是reflect.Type实例，该实例含有两个重要方法Name和Kind，前者返回类型名(包括自定义类型名)，后者是更加底层的类型，比如Name会返回结构体名，而Kind则是struct 12345678910111213141516171819202122232425type myInt int64//获取类型func reflectType(x interface&#123;&#125;) &#123; t := reflect.TypeOf(x) fmt.Printf(&quot;type:%v kind:%v\\n&quot;, t.Name(), t.Kind())&#125;func main() &#123; var a *float32 // 指针 var b myInt // 自定义类型 var c rune // 类型别名 reflectType(a) // type: kind:ptr reflectType(b) // type:myInt kind:int64 reflectType(c) // type:int32 kind:int32 type person struct &#123; name string age int &#125; var d = person&#123; name: &quot;Oliver&quot;, age: 18, &#125; reflectType(d) // type:person kind:struct&#125; 数组、切片、Map、指针等类型的变量，Name都是返回空 reflect.ValueOf()：获取值信息，即可读值，又可改值 12345678910111213141516171819202122232425//读值func reflectValue(x interface&#123;&#125;) &#123; v := reflect.ValueOf(x) k := v.Kind() switch k &#123; case reflect.Int64: // v.Int()从反射中获取整型的原始值，然后通过int64()强制类型转换 fmt.Printf(&quot;type is int64, value is %d\\n&quot;, int64(v.Int())) case reflect.Float32: // v.Float()从反射中获取浮点型的原始值，然后通过float32()强制类型转换 fmt.Printf(&quot;type is float32, value is %f\\n&quot;, float32(v.Float())) case reflect.Float64: // v.Float()从反射中获取浮点型的原始值，然后通过float64()强制类型转换 fmt.Printf(&quot;type is float64, value is %f\\n&quot;, float64(v.Float())) &#125;&#125;func main() &#123; var a float32 = 3.14 var b int64 = 100 reflectValue(a) // type is float32, value is 3.140000 reflectValue(b) // type is int64, value is 100 // 将int类型的原始值转换为reflect.Value类型 c := reflect.ValueOf(10) fmt.Printf(&quot;type c :%T\\n&quot;, c) // type c :reflect.Value&#125; reflect.Value可用转换类型方法： 方法 说明 Int() int64 将值以 int 类型返回，所有有符号整型均可以此方式返回 Uint() uint64 将值以 uint 类型返回，所有无符号整型均可以此方式返回 Float() float64 将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回 Bool() bool 将值以 bool 类型返回 Bytes() []byts 将值以字节数组 []bytes 类型返回 String() string 将值以字符串类型返回 Interface() interface{} 将值以 interface{} 类型返回，可以通过类型断言转换为指定类型 修改值的时候需要注意！ 必须用Elem才能修改地址对应的值，不用Elem最后只能修改拷贝值，会引起panic！ 1234567891011121314151617181920//改值func reflectSetValue1(x interface&#123;&#125;) &#123; v := reflect.ValueOf(x) if v.Kind() == reflect.Int64 &#123; v.SetInt(200) //修改的是副本，reflect包会引发panic &#125;&#125;func reflectSetValue2(x interface&#123;&#125;) &#123; v := reflect.ValueOf(x) // 反射中使用 Elem()方法获取指针对应的值 if v.Elem().Kind() == reflect.Int64 &#123; v.Elem().SetInt(200) &#125;&#125;func main() &#123; var a int64 = 100 // reflectSetValue1(a) //panic: reflect: reflect.Value.SetInt using unaddressable value reflectSetValue2(&amp;a) fmt.Println(a)&#125; 结构体反射 结构体反射可以用来在运行时获取结构体的属性和方法 reflect.Type可用结构体反射方法： 方法 说明 NumField() int 返回结构体成员字段数量。 FieldByName(name string) (StructField, bool) 根据给定字符串返回字符串对应的结构体字段的信息。 FieldByIndex(index []int) StructField 多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息。 FieldByNameFunc(match func(string) bool) (StructField,bool) 根据传入的匹配函数匹配需要的字段。 NumMethod() int 返回该类型的方法集中方法的数目 Method(int) Method 返回该类型方法集中的第i个方法 123456789101112//利用Field方法获取的是一个StructField实例，该结构体结构为type StructField struct &#123; // Name是字段的名字。PkgPath是非导出字段的包路径，对导出字段该字段为&quot;&quot;。 // 参见http://golang.org/ref/spec#Uniqueness_of_identifiers Name string PkgPath string Type Type // 字段的类型 Tag StructTag // 字段的标签 Offset uintptr // 字段在结构体中的字节偏移量 Index []int // 用于Type.FieldByIndex时的索引切片 Anonymous bool // 是否匿名字段&#125; 12345678910111213141516171819202122232425//获取方法type student struct &#123; Name string `json:&quot;name&quot;` Score int `json:&quot;score&quot;`&#125;func main() &#123; stu1 := student&#123; Name: &quot;小王子&quot;, Score: 90, &#125; t := reflect.TypeOf(stu1) fmt.Println(t.Name(), t.Kind()) // student struct // 通过for循环遍历结构体的所有字段信息 for i := 0; i &lt; t.NumField(); i++ &#123; field := t.Field(i) fmt.Printf(&quot;name:%s index:%d type:%v json tag:%v\\n&quot;, field.Name, field.Index, field.Type, field.Tag.Get(&quot;json&quot;)) &#125; // 通过字段名获取指定结构体字段信息 if scoreField, ok := t.FieldByName(&quot;Score&quot;); ok &#123; fmt.Printf(&quot;name:%s index:%d type:%v json tag:%v\\n&quot;, scoreField.Name, scoreField.Index, scoreField.Type, scoreField.Tag.Get(&quot;json&quot;)) &#125;&#125; 12345678910111213141516171819202122232425262728//获取方法// 给student添加两个方法 Study和Sleep(注意首字母大写)func (s student) Study() string &#123; msg := &quot;好好学习，天天向上。&quot; fmt.Println(msg) return msg&#125;func (s student) Sleep() string &#123; msg := &quot;好好睡觉，快快长大。&quot; fmt.Println(msg) return msg&#125;func printMethod(x interface&#123;&#125;) &#123; t := reflect.TypeOf(x) v := reflect.ValueOf(x) fmt.Println(t.NumMethod()) for i := 0; i &lt; v.NumMethod(); i++ &#123; methodType := v.Method(i).Type() fmt.Printf(&quot;method name:%s\\n&quot;, t.Method(i).Name) fmt.Printf(&quot;method:%s\\n&quot;, methodType) // 通过反射调用方法传递的参数必须是 []reflect.Value 类型 var args = []reflect.Value&#123;&#125; v.Method(i).Call(args) &#125;&#125; 注意上面右边的代码虽然获取了方法的信息，但也有陌生的调用方法的操作method.Call() 123456789101112131415//利用反射调用函数或方法func fn(p1, p2 int) int &#123; return p1 + p2&#125;func main() &#123; valueFunc := reflect.ValueOf(fn)//reflect.Value实例是函数，输入值和返回值都是[]reflect.Value类型 paramList := []reflect.Value&#123; reflect.ValueOf(22),//设置第一个参数 reflect.ValueOf(20),//设置第二个参数 &#125; // 反射调用函数 resultList := valueFunc.Call(paramList) // 获取第一个返回值, 取整数值 fmt.Println(resultList[0].Int()) // 42&#125; 📌反射的优劣优点：搭配接口实现泛型，代码更灵活缺点：性能低下，使用反射的代码通常比正常代码慢一两个数量级&amp;#x20; 代码脆弱，引起panic是真正运行时，代码写完很长时间后 16 并发 goroutine协程 go调用协程只需要在被调用的函数前加上go即可 123456789101112131415161718package mainimport&#123; &quot;fmt&quot; &quot;sync&quot;&#125;var wg sync.WaitGroup //信号量，计数器func hello(i int) &#123; fmt.Println(&quot;Hello Goroutine!&quot;, i) wg.Done() //每当一个协程执行完，需要计数器减一&#125;func main() &#123; wg.Add(10000) //因为有10000个协程，所以要给计数器加10000 for i := 0; i &lt; 10000; i++ &#123; go hello(i) //执行10000个协程 &#125; wg.Wait() // 等待所有登记的goroutine都结束&#125; goroutine调用匿名函数，需要注意闭包情形 1234567891011/*错误写法*/func main() &#123; wg.Add(10000) for i := 0; i &lt; 10000; i++ &#123; go func ()&#123;//匿名函数 fmt.Println(&quot;Hello Goroutine!&quot;,i) wg.Done() &#125;()//此时形成了闭包 &#125; wg.Wait() &#125; 1234567891011/*正确写法*/func main() &#123; wg.Add(10000) for i := 0; i &lt; 10000; i++ &#123; go func (i int)&#123;//匿名函数 fmt.Println(&quot;Hello Goroutine!&quot;,i) wg.Done() &#125;(i)//将参数直接传入线程，避免闭包 &#125; wg.Wait() &#125; 上面左边的写法构成了闭包，也就是i自增时，参数并未传入对应协程，而对应协程将要执行时 才从外部获取i的值，而此时i可能已经自增很多。所以左边的代码最后会输出大量的10000 此外，可以通过GOMAXPROCS参数设置要将协程分配给多少个OS线程，默认使用全部物理线程 1234567891011121314151617181920212223package mainimport&#123; &quot;fmt&quot; &quot;sync&quot; &quot;runtime&quot;&#125;func a() &#123; for i := 1; i &lt; 10; i++ &#123; fmt.Println(&quot;A:&quot;, i) &#125;&#125;func b() &#123; for i := 1; i &lt; 10; i++ &#123; fmt.Println(&quot;B:&quot;, i) &#125;&#125;func main() &#123; runtime.GOMAXPROCS(1)//只有一个物理核心，并行也串行 go a() go b() time.Sleep(time.Second)//等待所有线程结束&#125; channel channel就是消息队列(先入先出)，用于协程之间的通信，格式为：var 变量 chan 数据类型 或：make(chan 元素类型, [缓冲大小]) 1234567//新建channelvar ch1 chan int // 声明一个传递整型的通道var ch2 chan bool // 声明一个传递布尔型的通道var ch3 chan []int // 声明一个传递int切片的通道ch4 := make(chan int)ch5 := make(chan bool)ch6 := make(chan []int) 对于channel，有发送、接收、关闭三种操作，前两者使用&lt; - 符号传递数据 1234567//发送ch &lt;- 10 // 把10发送到ch中//接收x := &lt;- ch // 从ch中接收值并赋值给变量x&lt;-ch // 从ch中接收值，忽略结果//关闭close(ch) 需要注意的是，当channel关闭后，不可再向channel关闭值，可以接收，如果全部接收完，再接收就是该类型的零值。channel不能重复关闭。 1234567//无缓冲channelch := make(chan int)//无缓冲channel如果没有接收操作时就执行发送，最后程序会进入死锁，所以对于无缓冲必须要有接收//有缓冲channelch := make(chan int)//指定缓冲区大小为1//发送后无接收会阻塞下一次发送，直至接收完 无缓冲可以实现goroutine同步 channel被关闭后，若一直接收最后会无限接收零值，所以需要机制判断channel为空 1234567891011121314151617/*******机制1：利用接收操作时返回的布尔值*******/func main() &#123; ch1 := make(chan int) // 开启goroutine将0~100的数发送到ch1中 go func() &#123; for i := 0; i &lt; 100; i++ &#123; ch1 &lt;- i &#125; close(ch1) &#125;() for &#123; i, ok := &lt;-ch1 // 通道关闭后再取值时，ok=false if !ok &#123; break &#125; &#125;&#125; 12345678910111213141516/*******机制2：使用for range*******/// channel 练习func main() &#123; ch1 := make(chan int) // 开启goroutine将0~100的数发送到ch1中 go func() &#123; for i := 0; i &lt; 100; i++ &#123; ch1 &lt;- i &#125; close(ch1) &#125;() // 在主goroutine中从ch1中接收值打印 for i := range ch1 &#123; // 通道关闭后会退出for range循环 fmt.Println(i) &#125;&#125; 单向通道 单向通道就是只能发送或接收，只有单项操作的通道，比如 12chan&lt;- int //只写通道，只能向该通道输入int值&lt;-chan int //只读通道，只能从该通道读取int值 123456789101112131415161718192021222324252627//例程func counter(out chan&lt;- int) &#123; for i := 0; i &lt; 100; i++ &#123; out &lt;- i &#125; close(out)&#125;func squarer(out chan&lt;- int, in &lt;-chan int) &#123; for i := range in &#123; out &lt;- i * i &#125; close(out)&#125;func printer(in &lt;-chan int) &#123; for i := range in &#123; fmt.Println(i) &#125;&#125;func main() &#123; ch1 := make(chan int) ch2 := make(chan int) go counter(ch1) go squarer(ch2, ch1) printer(ch2)&#125; Select语句 select类似于switch，有很多case和一个default，用来在一个语句块对多个channel进行收发操作，每个case对应一个收和发 12345678910func main() &#123; ch := make(chan int, 1) for i := 0; i &lt; 10; i++ &#123; select &#123; case x := &lt;-ch: fmt.Println(x) case ch &lt;- i: &#125; &#125;&#125; 每次可处理一个case，若有多个case可执行操作，会随机选取一个执行 没有case的select会一直等待，阻塞程序 同步 当多个goroutine同时操作一个资源(临界区)时，就有竞态问题，此时需要利用锁实现同步 互斥锁sync.Mutex：当一个协程将资源锁住，进行操作时，其它协程必须等待解锁才能访问资源 12345678910111213141516171819var x int64var wg sync.WaitGroupvar lock sync.Mutexfunc add() &#123; for i := 0; i &lt; 5000; i++ &#123; lock.Lock() // 加锁 x = x + 1 lock.Unlock() // 解锁 &#125; wg.Done()&#125;func main() &#123; wg.Add(2) go add() go add() wg.Wait() fmt.Println(x)&#125; 读写互斥锁sync.RWMutex：资源被一个goroutine上了写锁后，其它协同都必须等待解锁才能进行读写操作；而被上了读锁时，其它要进行读操作的协同可以读，写操作的协程需要等待 123456789101112131415161718192021222324252627282930313233343536var ( x int64 wg sync.WaitGroup lock sync.Mutex rwlock sync.RWMutex)func write() &#123; rwlock.Lock() // 加写锁 x = x + 1 time.Sleep(10 * time.Millisecond) // 假设读操作耗时10毫秒 rwlock.Unlock() // 解写锁 wg.Done()&#125;func read() &#123; rwlock.RLock() // 加读锁 time.Sleep(time.Millisecond) // 假设读操作耗时1毫秒 rwlock.RUnlock() // 解读锁 wg.Done()&#125;func main() &#123; start := time.Now() for i := 0; i &lt; 10; i++ &#123; wg.Add(1) go write() &#125; for i := 0; i &lt; 1000; i++ &#123; wg.Add(1) go read() &#125; wg.Wait() end := time.Now() fmt.Println(end.Sub(start))&#125; 利用读写互斥锁执行上面代码要比用互斥锁快十倍 并发中的单例：sync.Once 针对高并发情形下只执行一次的操作，可以使用sync.Once避免一系列问题，比如下面例子 123456789101112131415161718var icons map[string]image.Imagefunc loadIcons() &#123; icons = map[string]image.Image&#123; &quot;left&quot;: loadIcon(&quot;left.png&quot;), &quot;up&quot;: loadIcon(&quot;up.png&quot;), &quot;right&quot;: loadIcon(&quot;right.png&quot;), &quot;down&quot;: loadIcon(&quot;down.png&quot;), &#125;&#125;// Icon被多个goroutine调用不是并发安全的func Icon(name string) image.Image &#123; if icons == nil &#123; loadIcons() &#125; return icons[name]&#125; 1234567func loadIcons() &#123; icons = make(map[string]image.Image) icons[&quot;left&quot;] = loadIcon(&quot;left.png&quot;) icons[&quot;up&quot;] = loadIcon(&quot;up.png&quot;) icons[&quot;right&quot;] = loadIcon(&quot;right.png&quot;) icons[&quot;down&quot;] = loadIcon(&quot;down.png&quot;)&#125; 这种情况下，可能会出现一个协程调用Icon时，写icons这个map只写到一半，还没写到right，就有另一个协程调用Icon了。 此时icons不是nil，但是要调用icons[“right”]，导致错误。 使用sync.Once的Do方法执行if里的操作可以解决这一问题 123456789101112131415161718/****************正确写法*****************/var icons map[string]image.Imagevar loadIconsOnce sync.Oncefunc loadIcons() &#123; icons = map[string]image.Image&#123; &quot;left&quot;: loadIcon(&quot;left.png&quot;), &quot;up&quot;: loadIcon(&quot;up.png&quot;), &quot;right&quot;: loadIcon(&quot;right.png&quot;), &quot;down&quot;: loadIcon(&quot;down.png&quot;), &#125;&#125;// Icon 是并发安全的func Icon(name string) image.Image &#123; loadIconsOnce.Do(loadIcons) return icons[name]&#125; sync.Once相当于有一个互斥锁和布尔值，前者上锁保护临界资源和布尔值，后者标记是否执行过 面向并发的map：sync.Map 多个协程同时写map是不被允许也是不安全的，若想不加锁的前提下使用map，可以用sync.Map 12345678910111213141516var m = sync.Map&#123;&#125;//sync.Map的读操作是Load方法，写操作是Store方法func main() &#123; wg := sync.WaitGroup&#123;&#125; for i := 0; i &lt; 20; i++ &#123; wg.Add(1) go func(n int) &#123; key := strconv.Itoa(n) m.Store(key, n) value, _ := m.Load(key)//第二个返回值是布尔类型，判断是否被找到 fmt.Printf(&quot;k=:%v,v:=%v\\n&quot;, key, value) wg.Done() &#125;(i) &#125; wg.Wait()&#125; 值得一提的是，sync.Map的键值都是空接口类型，也就是说可以在同一个sync.Map存储任意类型的键-值对，而不是像传统map要把类型写死 原子操作 原子操作操作数据时是不可被分割的，所以不会被其它协程抢占，并发安全，而且性能比互斥锁优异 123456789101112131415161718192021222324252627282930313233343536373839404142434445package mainimport ( &quot;fmt&quot; &quot;sync&quot; &quot;sync/atomic&quot; &quot;time&quot;)type Counter interface &#123; Inc() Load() int64&#125;// 原子操作版type AtomicCounter struct &#123; counter int64&#125;func (a *AtomicCounter) Inc() &#123; atomic.AddInt64(&amp;a.counter, 1)//原子方法&#125;func (a *AtomicCounter) Load() int64 &#123; return atomic.LoadInt64(&amp;a.counter)//原子方法&#125;func test(c Counter) &#123; var wg sync.WaitGroup start := time.Now() for i := 0; i &lt; 1000; i++ &#123; wg.Add(1) go func() &#123; c.Inc() wg.Done() &#125;() &#125; wg.Wait() end := time.Now() fmt.Println(c.Load(), end.Sub(start))&#125;func main() &#123; c3 := AtomicCounter&#123;&#125; // 并发安全且比互斥锁效率更高 test(&amp;c3)&#125; 17 IO编程17.1 文件IO文件读和写分别至少有三种方式，并且读文件和写文件时文件的打开方式也是不同的 12345678910111213141516//读---打开文件:os.Open(文件名)package mainimport ( &quot;fmt&quot; &quot;os&quot;)func main() &#123; // 只读方式打开当前目录下的main.go文件 file, err := os.Open(&quot;./main.go&quot;) if err != nil &#123; fmt.Println(&quot;open file failed!, err:&quot;, err) return &#125; // 关闭文件 defer file.Close()//用defer保证最后一定会关闭文件&#125; 12345678910111213141516171819//写---打开文件：os.OpenFile(文件名,模式,权限设置)//模式：os.O_WRONLY(只写)、os.O_CREATE(创建文件)、//os.O_RDONLY(只读)、os.O_RDWR(读写)、os.O_TRUNC(清空)、os.O_APPEND(追加)//权限：r（读）04，w（写）02，x（执行）01// owner group other//0 - rwx - rwx - rwxpackage mainimport ( &quot;fmt&quot; &quot;os&quot;)func main() &#123; file, err := os.OpenFile(&quot;xx.txt&quot;, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666) if err != nil &#123; fmt.Println(&quot;open file failed, err:&quot;, err) return &#125; defer file.Close()&#125; 读文件的三种方式 方式一：file.Read()，优势：原生读文件方式，可以精准把控读到的字节数 123456789101112131415161718192021222324//Read()函数会接收一个字节数组做参数//返回字节数和error类型func main() &#123; // 只读方式打开当前目录下的main.go文件 file, err := os.Open(&quot;./main.go&quot;) if err != nil &#123; fmt.Println(&quot;Failed!, err:&quot;, err) return &#125; defer file.Close() // 使用Read方法读取数据 var tmp = make([]byte, 128) n, err := file.Read(tmp) if err == io.EOF &#123;//读取少于128字节，读完了 fmt.Println(&quot;文件读完了&quot;) return &#125; if err != nil &#123; fmt.Println(&quot;Failed, err:&quot;, err) return &#125; fmt.Printf(&quot;读取了%d字节数据\\n&quot;, n) fmt.Println(string(tmp[:n]))&#125; 1234567891011121314151617181920212223242526//循环读取func main() &#123; // 只读方式打开当前目录下的main.go文件 file, err := os.Open(&quot;./main.go&quot;) if err != nil &#123; fmt.Println(&quot;open failed!, err:&quot;, err) return &#125; defer file.Close() // 循环读取文件 var content []byte var tmp = make([]byte, 128) for &#123; n, err := file.Read(tmp) if err == io.EOF &#123; fmt.Println(&quot;文件读完了&quot;) break &#125; if err != nil &#123; fmt.Println(&quot;read failed, err:&quot;, err) return &#125; content = append(content, tmp[:n]...) &#125; fmt.Println(string(content))&#125; 方式二：bufio读取文件，优势：提供大量函数，读文件更加灵活，而且会先从磁盘读到缓存，然后使用时可直接从缓存取数据，减少了磁盘IO带来的瓶颈效应，速度快 1234567891011121314151617181920212223242526272829303132package mainimport ( &quot;bufio&quot; &quot;fmt&quot; &quot;io&quot; &quot;os&quot;)// bufio按行读取示例func main() &#123; file, err := os.Open(&quot;./xx.txt&quot;) if err != nil &#123; fmt.Println(&quot;open file failed, err:&quot;, err) return &#125; defer file.Close() reader := bufio.NewReader(file)//需要new一个reader对象 for &#123; line, err := reader.ReadString(&#x27;\\n&#x27;) //注意是字符 if err == io.EOF &#123; if len(line) != 0 &#123; fmt.Println(line) &#125; fmt.Println(&quot;文件读完了&quot;) break &#125; if err != nil &#123; fmt.Println(&quot;read file failed, err:&quot;, err) return &#125; fmt.Print(line) &#125;&#125; 方式三：io&#x2F;ioutil包的ReadFile方法，优势：可以一次读取完整文件内容，不需要Open、Close 12345678910111213141516package mainimport ( &quot;fmt&quot; &quot;io/ioutil&quot;)// ioutil.ReadFile读取整个文件func main() &#123; content, err := ioutil.ReadFile(&quot;./main.go&quot;)//返回的是字节数组 if err != nil &#123; fmt.Println(&quot;read file failed, err:&quot;, err) return &#125; fmt.Println(string(content))&#125; 写文件的三种方式 方式一：os包的write和writeString函数，前者写字节数组，后者写字符串 1234567891011func main() &#123; file, err := os.OpenFile(&quot;xx.txt&quot;, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666) if err != nil &#123; fmt.Println(&quot;open file failed, err:&quot;, err) return &#125; defer file.Close() str := &quot;hello 沙河&quot; file.Write([]byte(str)) //写入字节切片数据 file.WriteString(&quot;hello 小王子&quot;) //直接写入字符串数据&#125; 方式二：bufio的writer对象，需要注意的是，这种方式先写到缓存里，再刷新到磁盘中，所以写完后，需要执行Flush函数 12345678910111213func main() &#123; file, err := os.OpenFile(&quot;xx.txt&quot;, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666) if err != nil &#123; fmt.Println(&quot;open file failed, err:&quot;, err) return &#125; defer file.Close() writer := bufio.NewWriter(file) for i := 0; i &lt; 10; i++ &#123; writer.WriteString(&quot;hello沙河\\n&quot;) //将数据先写入缓存 &#125; writer.Flush() //将缓存中的内容写入文件&#125; 方式三：io&#x2F;ioutil包的WriteFile方法，其最后一个参数与OpenFile的最后一个参数一致 123456789//不需要OpenFile、Closefunc main() &#123; str := &quot;hello 沙河&quot; err := ioutil.WriteFile(&quot;./xx.txt&quot;, []byte(str), 0666) if err != nil &#123; fmt.Println(&quot;write file failed, err:&quot;, err) return &#125;&#125; 17.2 log包输出日志go语言中的log包与python中的logging非常相似，都有logger，可以指定输出到控制台或文件，有fomatter，不同信息有不同等级。 https://golang.org/pkg/log/ https://www.bilibili.com/video/BV1QJ411X7CN?from=search&amp;seid&#x3D;2882714410354221537 17.3 fmt包18 正则表达式Go语言的正则表达式用到了”regexp”包，正则格式和python中的无异。 有两种方式进行正则表达式匹配，一种是正则字符串直接拿来匹配，另一种是将正则表达式字符串通过函数优化成go语言的regexp对象，再利用该对象的方法。后者是线程安全的！ 1234567//第一种方式：正则字符串直接匹配matched, err := regexp.MatchString(`a.b`, &quot;aaxbb&quot;)//注意需要用反引号fmt.Println(matched) // truefmt.Println(err) // nil (regexp is valid)matched, _ := regexp.MatchString(`^a.b$`, &quot;aaxbb&quot;)fmt.Println(matched) // false 12345//第二种方式：正则字符串先编译成regexp对象//两种编译方式re1, err := regexp.Compile(`regexp`) // error if regexp invalidre2 := regexp.MustCompile(`regexp`) // panic if regexp invalid//后者可直接配合defer recover Find：find有两种，一种用字符串，一种用字节数组，没有String字样的find方法都是字节数组 12345678910111213141516171819//找到第一个匹配的子串//方法的参数是待匹配的字符串re := regexp.MustCompile(`foo.?`)fmt.Printf(&quot;%q\\n&quot;, re.FindString(&quot;seafood fool&quot;)) // &quot;food&quot;fmt.Printf(&quot;%q\\n&quot;, re.FindString(&quot;meat&quot;)) // &quot;&quot;//找到第一个匹配的子串的位置re := regexp.MustCompile(`ab?`)fmt.Println(re.FindStringIndex(&quot;tablett&quot;)) // [1 3]fmt.Println(re.FindStringIndex(&quot;foo&quot;) == nil) // true//找到所有匹配的子串re := regexp.MustCompile(`a.`)fmt.Printf(&quot;%q\\n&quot;, re.FindAllString(&quot;paranormal&quot;, -1)) // [&quot;ar&quot; &quot;an&quot; &quot;al&quot;]fmt.Printf(&quot;%q\\n&quot;, re.FindAllString(&quot;paranormal&quot;, 2)) // [&quot;ar&quot; &quot;an&quot;]fmt.Printf(&quot;%q\\n&quot;, re.FindAllString(&quot;graal&quot;, -1)) // [&quot;aa&quot;]fmt.Printf(&quot;%q\\n&quot;, re.FindAllString(&quot;none&quot;, -1)) // [] (nil slice)//FindAllString方法最后一个参指定返回多少子串//小于0：返回所有；等于0：不返回；大于0：返回这个数量的子串 Replace： 12re := regexp.MustCompile(`ab*`)fmt.Printf(&quot;%q\\n&quot;, re.ReplaceAllString(&quot;-a-abb-&quot;, &quot;T&quot;)) // &quot;-T-T-&quot; Split： 12345678910111213a := regexp.MustCompile(`a`)fmt.Printf(&quot;%q\\n&quot;, a.Split(&quot;banana&quot;, -1)) // [&quot;b&quot; &quot;n&quot; &quot;n&quot; &quot;&quot;]fmt.Printf(&quot;%q\\n&quot;, a.Split(&quot;banana&quot;, 0)) // [] (nil slice)fmt.Printf(&quot;%q\\n&quot;, a.Split(&quot;banana&quot;, 1)) // [&quot;banana&quot;]fmt.Printf(&quot;%q\\n&quot;, a.Split(&quot;banana&quot;, 2)) // [&quot;b&quot; &quot;nana&quot;]zp := regexp.MustCompile(`z+`)fmt.Printf(&quot;%q\\n&quot;, zp.Split(&quot;pizza&quot;, -1)) // [&quot;pi&quot; &quot;a&quot;]fmt.Printf(&quot;%q\\n&quot;, zp.Split(&quot;pizza&quot;, 0)) // [] (nil slice)fmt.Printf(&quot;%q\\n&quot;, zp.Split(&quot;pizza&quot;, 1)) // [&quot;pizza&quot;]fmt.Printf(&quot;%q\\n&quot;, zp.Split(&quot;pizza&quot;, 2)) // [&quot;pi&quot; &quot;a&quot;]//Split方法最后一个参数指定返回多少子串//小于0：返回所有；等于0：不返回；大于0：返回这个数量的子串 19 go语言常用标准库19.1 time19.2 flag19.3 strconvGo语言底层原理《Go语言底层原理剖析》 Golang修养之路：https://www.kancloud.cn/aceld/golang GMP模型逃逸现象make和new 的区别 变量声明： var关键字，不指定变量默认值时，变量的默认值会是零值 12var i int //int类型的零值是0var s string //string类型的零值是&quot;&quot; 引用类型的零值是nil new内存分配 使用new时必须先分配内存 12345func main() &#123; var i *int *i=10 fmt.Println(*i)&#125; 1234567func main() &#123; var i *int i=new(int) *i=10 fmt.Println(*i)&#125; new()只接收一个参数，就是类型。返回的是类型指针，并且分配内存后会默认给指针指向的地址赋零值。 make内存分配 make只用于三种类型：chan，map，slice的内存创建。而且返回的不是指针，而就是这三种类型（不是指针，因为它们自身就是引用类型）。 1func make(t Type, size ...IntegerType) Type 123ch := make(chan int)ch := make(chan bool)ch := make(chan []int) 12/*格式：make(map[键数据类型][值数据类型])*/emails := make(map[string]string) 1234//T:切片的元素类型//size:切片中元素的数量//cap:切片的容量a := make([]int, 2, 10) make与new的异同： 相同：均为堆空间分配 不同： make：只用于slice、map和chan的初始化，无可替代； new：用于类型内存分配（初始化值为0），不常用 📌new不常用：现实代码通常采用短语句声明以及结构体的字面量达到分配内存目的，如：i :&#x3D; 0u :&#x3D; user{} 内存分配 垃圾回收 📌为什么需要垃圾回收？1. 减少错误和复杂性手动分配、释放内存等可能会带来内存泄露、野指针等问题。虽然垃圾回收不保证完全不产生内存泄露，但其提供了重要的保障，即不再被引用的对象最终将被收集。同时，可以避免悬空指针、多次释放等手动管理内存时会出现的问题。垃圾回收功能屏蔽了内存管理的复杂性，开发者可更好地关注核心业务逻辑。2. 解耦现代软件工程崇尚模块化，而模块间只提供少量接口以交互。当多个模块同时维护一个内存时，释放内存将变得非常小心。手动分配面临这样的问题：缺乏信息，难以在本地模块内做出全局的决定。垃圾回收机制将此工作托管给了具有全局视野的运行时代码，从而使业务模块间真正解耦，从而有利于开发、调试，并开发出更大规模的、高并发的项目。 📌什么场景需要垃圾回收？垃圾回收带来了额外的成本，需要保存内存的状态信息并扫描内存，很多时候还需要中断整个程序来处理垃圾回收。因此，垃圾回收对于要求极致的速度和内存要求极小的场景并不适用（嵌入式、系统级程序）；却是开发大规模、分布式、微服务集群的极佳选择。 Go垃圾回收中的三色标记：Go执行垃圾回收具体流程：deferdefer的执行顺序 栈：先进后出 函数的返回值初始化 只要函数返回值有名字（例子中为t），这个t会在函数起始处被初始化为对应类型的零值并且作用域为整个函数。 return和defer谁先谁后 &amp; 有名函数返回值遇见defer情况 12345678910111213package mainimport &quot;fmt&quot;func returnButDefer() (t int) &#123; //t初始化0， 并且作用域为该函数全域 defer func() &#123; t = t * 10 &#125;() return 1&#125;func main() &#123; fmt.Println(returnButDefer())&#125; 12$ go run test.go10 本应返回1，但是return后进入了defer，所以t=t*10被执行，因此最后返回给main的结果为10。 defer遇见panic defer中包含panic12345678910111213141516171819package mainimport &quot;fmt&quot;func main() &#123; defer func() &#123; if err := recover(); err != nil&#123; fmt.Println(err) &#125;else &#123; fmt.Println(&quot;fatal&quot;) &#125; &#125;() defer func() &#123; panic(&quot;defer panic&quot;) &#125;() panic(&quot;panic&quot;)&#125; 12输出结果：defer panic 触发panic(&quot;panic&quot;)后defer顺序出栈执行，第一个被执行的defer中的panic(&quot;defer panic&quot;)异常，会覆盖掉main中的panic(&quot;panic&quot;)，最后这个异常被第二个执行的defer捕获到。 defer下的函数参数包含子函数123456789101112package mainimport &quot;fmt&quot;func function(index int, value int) int &#123; fmt.Println(index) return index&#125;func main() &#123; defer function(1, function(3, 0)) defer function(2, function(4, 0))&#125; 12345输出结果：3421 这里有四个函数，用第一个参数的值给它们标号为1\\2\\3\\4。需要研究它们的先后执行顺序： 有两个defer，所以defer会压栈两次，先进栈1，后进栈2。压1时，由于需要连同函数地址、函数形参一同进栈，因此为了得到第二个参数的结果，需要先执行function3。同理在压2时，就需要先执行function4。 因此执行顺序为：3→4→2→1。 相关工具gRPC gRPC允许","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://example.com/tags/golang/"}]}],"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"数学","slug":"数学","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6/"},{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"数学方法","slug":"数学方法","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6%E6%96%B9%E6%B3%95/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"},{"name":"golang","slug":"golang","permalink":"http://example.com/tags/golang/"}]}