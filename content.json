{"meta":{"title":"OliverPai","subtitle":"落叶本就是假的","description":"求索与记录","author":"OliverPai","url":"http://example.com","root":"/"},"pages":[{"title":"分类","date":"2022-07-10T06:59:32.000Z","updated":"2022-07-10T07:01:11.993Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-07-10T06:59:23.000Z","updated":"2022-07-10T07:01:31.691Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"WebRTC替代方案：Salsify","slug":"WebRTC替代方案：Salsify","date":"2022-07-12T13:53:06.000Z","updated":"2022-07-12T16:24:30.497Z","comments":true,"path":"2022/07/12/WebRTC替代方案：Salsify/","link":"","permalink":"http://example.com/2022/07/12/WebRTC%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88%EF%BC%9ASalsify/","excerpt":"","text":"论文：《Salsify: Low-Latency Network Video Through Tighter Integration Between a Video Codec and a Transport Protocol》 会议：NSDI‘2018 作者：Sadjad Fouladi, John Emmons, Emre Orbay, Catherine Wu^, Riad S. Wahby, Keith Winstein 机构：Stanford University, ^Saratoga High School 代码：Salsify — A New Architecture for Real-time Internet Video 资助机构：DARPA、Google、Huawei、VMware、Dropbox、Facebook 背景 实时视频已成为受众广泛的网络应用，被视频会议、云游戏、机器人/交通设施即时交互等技术采纳，要求视频得以压缩且以低延时在网络中发送。时至今日此类系统通常包含两部分：传输控制和视频编码。 传输控制：将压缩的视频发到接收方，处理ACK和拥塞信号，估计网络链路的平均速率。 视频编码：选取编码参数（帧率、清晰度）生成压缩后的视频流，并且让视频流平均速率逼近估计的网络容量。 然而，大多数现有方案将视频编码和传输控制想分离，也就是说二者的速率控制方法独立运行。先由传输控制提供对当前网络数据率的估计，再交付给编码器试图产生匹配速率的视频流。这样的工程实践将二者视为黑盒，却带来了严重的性能损失（因为码率估计和控制为平均值，无法应对瞬时的网络状况变化）。Salsify旨在让二者更加紧密贴合，将二者放入同一个算法中，实现编码过程中的逐帧速率控制，以避免缓存溢出、排队时延，且使视频传输能够匹配动态的网络容量。 Salsify的组件没有全新设计的，均为采用已有方案。Salsify基于VP8（VP9和H.265等是众多视频会议软件采用的常用方案）编码，其速率控制策略基于Sprout。 文章经过实验认为，对视频编码器的改进已经走到了回报下降的阶段，即在现有最前沿方案基础上继续改进视频编码器收获的回报将不值得付出的劳动，但是优化整个视频系统的结构，依然可以带来显著的收益。 文章列举了实时视频目前可优化的几个方面： 网络自适应：Skype、FaceTime、Hangouts、WebRTC等均具备网络自适应能力，可以探索、估计当前网络情况并进行数据率调整。Salsify希望能够获得比上述方案更强的自适应能力。 信源-信道协作的视频编码：现有理论研究曾尝试过进行信源、信道的联合编码以在网络链路高负荷复用(heavy-multiplexed)时，得以在丢包和时延方面幸存。现有典型方案网络由信道影响信源，即根据信道条件控制信源。而Salsify希望从另一个角度优化此问题，直接在信源处引入传输控制，以预先规避信道拥塞、丢包（overflowing router buffers）的情况。 跨层策略：SoftCast、Apex等均在物理层有所操作。当无线链路有更多噪声、串扰时，通过在物理层发送规则的模拟信号，可以缓解视频传输质量下降的状况。Salsify未操作物理层，而是选择和Skype、FaceTime等方案一样传输UDP包。 低时延传输协议：传输协议的设计也是传输控制和带宽估计的基石，如Sprout协议。Salsify基于Sprout-EWMA协议，但是进行了增强，使其能够排除因节拍导致的延时，从而更加准确的计算出网络延时。 分层视频编码（SVC）：分层编码产生多路视频流，根据质量需求（或网络状况）进行码流的选择，以在网络经常变化的场景中应用。本文实验部分的基线包含了采用VP9_SVC的WebRTC作为基线，发现其相比于传统WebRTC并未带来显著的效果提升。 实时视频系统的测量：此类工作主要用于对视频系统传输质量进行评估，如测量接收方和发送方的视频流差异、延时等等。Salsify在实验部分对此方面进行了补充。 QoE驱动传输：多种反映用户体验的metric被集成到一个QoE中，通过该值刻画在实际状况下时延、画面质量的重要程度。Salsify在此方面无涉及。 丢包恢复：RTP和WebRTC会重发丢失的包。然而WebRTC相关机制的弊端在于，每当重传，需要重新对丢失的帧进行编码，此过程耗时耗能。而进行前向纠错编码（forward-error-correction）可能难以应对杂乱无序的丢包情况。Salsify旨在重发丢包时，可以避免对视频帧的重新编码。 优化设计及部署 Salsify主要优化的点，在于将视频编码和传输控制捆绑在了一起。这主要是应对传统方案（如WebRTC）的不足。以WebRTC为例，编码器获取原始画面后会进行压缩，使得能够压缩到指定的平均数据率。而WebRTC的拥塞控制会以大约1秒的周期更新帧率和目标比特率。这种平均的方式无法应对突发异常的风险：如果编码器编出的帧超出了当前网络容量，WebRTC也将发送它，那么就很可能导致丢发或缓存膨胀，情况发生后WebRTC又会要求编码过程暂停，直到拥塞清除。 Salsify的解决方案： 破除“平均”的劣势：每一帧在进行压缩之前，传输控制可以提前通知编码器目标比特数（该数据量确保可被接收，且不会造成丢包，或者额外的排队）。 实现数据量的可控：state-passing style的视频编码。编码器按状态编码，由于控制参数生成准确的预期比特量的压缩帧是很难的，因此系统中每次会尝试两套参数，每套参数编码出不同画质。而发送前先检查两套参数下的数据量，哪个与目标数据量最匹配，从而发送相应的帧。同时，状态被保存起来，以应对需要重发的情况。并且该状态作为下一帧编码两版本的基础。 文中对该机制进行两种实现：Salsify-1c（两套参数在单核串行编码）和Salsify-2c（两套参数在双核并行编码） 视频编码 Salsify的视频编码器基于谷歌VP8来实现，在原有基础上进行了修改——以显式的state-passing style暴露了编解码过程的内部状态（internal state）。 state包含了参考图像、用于熵编码的概率表。如一个1280x720分辨率的图像大概有4MiB左右的中间状态。 编码器：利用状态中和参考图像的相似度，来编码。 解码器：类似于状态机，接收到压缩帧后从源状态转移到目标状态。 VP8以函数式的方式将编解码过程中的中间状态从内部维护到外部： 12decode(state, frame) -&gt; (state&#x27;, image)encode(state, image, quality) -&gt; frame 为了能够让编码的帧大小可以匹配提前估计的网络状态，运行两个编码器，以两种压缩等级进行压缩，再在传输控制时进行选择。 如果两种压缩等级都超过了估计的网络容量，那么就进入第三种选择：不传。 （文章中说传统方案中，只能暂时中断帧进入编码器，而不能直接跳过它） 传输控制 每一帧被切成了一或多个最大传输单元（MTU）大小的包。 传输协议：每一帧数据包的头部，需要包含帧号（frame serial number）、帧中数据包的索引（fragment index）、源状态的哈希值、目标状态的哈希值。接收端识别到两个哈希值后，会知道此帧处于哪种何种状态（源状态），需要将其转化为何种状态（目标状态），再产生显示的画面。 接收端还会将目标状态存储起来，用于丢包恢复时重发。 对于每个包的回应，接收端会发送一个ACK消息，包含着帧号、包索引、当前的解码状态哈希。 时延估计： WebRTC、Sprout-EWMA等方案中计算包的移动平均inter-arrival时间，来探测出网络状态。然而，直接用【接收此包时间-接收上一包时间】来计算inter-arrival并不准确，因为发送端处理不同帧时是按节拍处理的。当遇到情况：此帧第一包接收时延 - 上一帧最后一包接收时延，会出现一个额外的由节拍器导致的时延，文中称为grace period。 如图展示了grace period发生的状况 这样的状况对于网络状态的估计是消极的，因为会让应用错误认为此时的网络变差。为此，需要改进inter-arrival计算公式。文中的平滑inter-arrival公式如下： τi←(Ti−Ti−1−grace-periodi)+(1−α)τi−1\\tau_i\\leftarrow(T_i-T_{i-1}-\\text{grace-period}_i)+(1-\\alpha)\\tau_{i-1} τi​←(Ti​−Ti−1​−grace-periodi​)+(1−α)τi−1​ 其中Ti是第i个包接收到的时间，a取0.1。 发送策略： 发送端计算Ni：当前in-flight的包数量 NiN_iNi​=最后一个发送的包序列号-最后一个被ACK的包序列号 前文的是由接收端收到第i包时报道的inter-arrival。定义d是端到端时延的系统上限（人为设定，比如想保持交互性就需要设置为100ms），那么此时in-flight状态的包数就不应该超过。 所以，当前状态，可以发送的目标数据量为：(d/τi−Ni)(d/\\tau_i-N_i)(d/τi​−Ni​)个MTU大小的帧切的fragment。对应算法1的step 6。 当需要发送时，会选择不超过此大小的最大帧。如果所有的编码版本都超过了此大小，发送端会取消本次帧的发送（跳过帧）。一旦超过了4帧被跳过，发送端会进行低画质传输。此步骤如算法2所示： 测试平台 为了能将发送方和接收方的视频帧匹配上，在传输之前会对视频进行预处理，在画面左上和右下加上二维码（占地3.6%），每个二维码编码了一个64位的随机数，且每次的随机数在整个视频传输过程中是唯一的。 为了能够评估传输质量，选取了两个metric：图像相似度（SSIM）和时延（对应每一帧从发送到接收到的时间，二维码帧匹配用于测量时延）。二者集成在系统中，其中SSIM的测量使用了Xiph Daala工具包。Network Emulator模块为了模拟出不同的网络条件，采用了Cellsim。 与Salsify进行对比的基线为： 场景为三人视频会议，持续10分钟，60fps，1280x720分辨率。模拟网络条件时，读取的trace足够覆盖整个视频会议的长度。 评估结果 前6个实验中的参数设定：buffer大小为可容纳256个包，rtt设定为40ms。 实验1：变化蜂窝 trace：AT&amp;T LTE、T-Mobile UMTS(“3G”)、Verizon LTE。网络容量随时间变化，从大于20Mbps到少于100kbps不等。AT&amp;T LTE中，发送端Salsify-2c保留了6个状态，接收端保留3个状态。 实验2：间歇性链路 测试Salsify的丢包还原(loss resilience)能力而设定的两阶段间歇性链路。开始时网络容量设定为12Mbps无丢包，之后failure事件发生，所有包均被丢弃，持续5秒，之后restore事件发生恢复网络，持续10分钟。 实验3：仿真WiFi 设定瞬时数据率服从泊松过程，均值为570kbps。 实验4：组件影响分析 文中没有指出采用了何种conventional。 实验5：网络容量滑坡 网络容量逐渐减小到0，再逐渐回升。 实验6：丢包实验 离线事件持续1秒，其中的包全部丢出。由于WebRTC的恢复阶段，对丢的帧进行重新编码，所以出现了时延上的尖刺。而Salsify由于没有这样的包袱，在网络恢复时可以立即编码新帧，所以会平滑很多。 实验7：队列敏感性 DropTail queue：当一个数据报到达队列时，数据报被放到队列中等待被传送，但由于长度有限，因此如果数据流太大，队列将没有空间去暂存这些新到的数据报，于是会把队列最尾端的数据报丢弃，这样的管理机制就叫做DropTail。 此实验旨在判断算法的队列敏感性。因此在CellSim模拟网络条件时，引入了DropTail机制，丢弃阈值设定为64、256和1024个包。实验表明，Salsify对于队列长度的变化并不是很敏感，因此算法设计时的目标 就是不增加额外的排队状况，而且要求低时延，就不会要求开辟较大buffer。","categories":[{"name":"WebRTC","slug":"WebRTC","permalink":"http://example.com/categories/WebRTC/"}],"tags":[{"name":"WebRTC","slug":"WebRTC","permalink":"http://example.com/tags/WebRTC/"}]},{"title":"WebRTC-GCC替代方案：Concerto","slug":"WebRTC-GCC替代方案：Concerto","date":"2022-07-11T14:54:55.000Z","updated":"2022-07-12T16:48:03.255Z","comments":true,"path":"2022/07/11/WebRTC-GCC替代方案：Concerto/","link":"","permalink":"http://example.com/2022/07/11/WebRTC-GCC%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88%EF%BC%9AConcerto/","excerpt":"","text":"论文：《Learning to Coordinate Video Codec with Transport Protocol for Mobile Video Telephony》 会议：Mobicom’ 2019 作者：Anfu Zhou, Huanhuan Zhang, Guangyuan Su, Leilei Wu, Ruoxuan Ma, Zhen Meng, Xinyu Zhang, Xiufeng Xie, Huadong Ma, Xiaojiang Chen^ 机构：Beijing Univ. of Posts and Telecom, ^Alibaba Inc. 应用：淘宝Live（内嵌在淘宝app中，论文中说还在优化，作者主页上说已规模应用） 代码：未开源 背景 作者团队联合淘宝一起记录直播数据，建立了庞大的数据集，并通过对数据的分析，发现目前基于WebRTC建立直播系统所面临的严峻问题。同时，也通过进一步的探究，发现了导致问题出现的根本原因。 数据集构造 现有工作基本均通过实验室内的testbed、仿真器或者对直播类应用进行嗅探/抓包，以获取WebRTC终端通信时受不同因素（带宽、时延、丢包）等影响的拥塞状况。规模较小，无法充分体现不同时间、空间下实际系统拥塞情况的多样性。针对此问题，淘宝Live为作者团队提供了其app在全球范围下的直播数据集。 淘宝Live是淘宝App内置的模块，其结构如图。当一个caller开启一个会话时，其视频推流到MCU（多媒体控制单元）中，之后MCU将视频分发至两路，一路直接发到与caller直接互动的callee处（此时MCU相当于中继），而另一路则将多个帧打包成一个chunk（大约包含5秒的内容），再讲chunk发送到CDN处。而CDN再进行重分发，分发至其他用户（其他用户对实时性要求可能略低）。收集数据集时主要收集MCU充当中继的那一路实时session数据。 收集过程关注的是caller-to-MCU这一路，因为通常情况下此路上行带宽（通常受第一跳链路带宽制约）会低于MCU-to-callee这一路的下行带宽，从而成为瓶颈链路。此会话中，caller的客户端负责记录编码器比特率、GCC带宽估计值，以每3秒间隙log一次均值。会话结束时会将log结果发送给MCU，同时MCU也会记录吞吐量、丢包率和时延等数据，以每1秒间隙记录一次。 最终的数据集多样性体现在下面两图中，从全球用户获取长达1348548小时的会话数据，且无线通信模式多样。 现有问题 根据ITU G.114标准，视频通话中合理的QoE水平体现在：端到端丢包率小于1%，且RTT小于300ms。基于此，可以有PSR（poor session ratio）指标来量化： PSR=#sessions with RTT &gt; 300ms or packet loss &gt; 1%#all sessionsPSR=\\frac{\\#sessions\\ with\\ RTT\\ &gt;\\ 300ms\\ or\\ packet\\ loss\\ &gt;\\ 1\\%}{\\#all\\ sessions} PSR=#all sessions#sessions with RTT &gt; 300ms or packet loss &gt; 1%​ 空间分布特点： 将拥有大于2000个session的地区视作主要地区，统计此类地区session的PSR。这样的session中80.6%是国内通话（这个国内不局限在中国），其余为国际通话。 发现所有地区的PSR，都至少是12%，而且超过一般的地区的PSR都达到了20%。也就是说，每5个会话中的一个就在经历较差用户体验的视频通话。 时间分布特点： 所有的trace都切割成若干个持续1小时的time window。下图是24小时下time window在不同时段的数量。可以发现两点： 即使不是视频通话高峰期（凌晨1点到早8点），也会出现低PSR的情况，只是占比相对少一些。非高峰期低PSR的session占比17.5%，高峰期占比28.5%以上。 即使流量负载下降（即session数减少），PSR也没有显著降低。这表明WebRTC的码率适应策略并没有充分利用整体变好的网络环境，而是受限于短暂的拥塞状况。 无线接入类型特点： 淘宝LIve的用户主要通过三种方式接入互联网：WiFi（大多数采用WiFi，占全部session的73%）、4G、3G。其中WiFI的PSR（18%）远好于后两者。 有研究表明，可能是3G/4G蜂窝网络中普遍存在的bufferbloat现象导致了这一问题，bufferbloadt可以减少丢包并能缓解带宽变化带来的影响，却带来了更大时延。 bufferbloat：缓存膨胀到过大的状态。 总结上述对数据集的分析，可以发现，无论何种时间段、无论何种地域、无论何种网络接入方式，低QoE在由WebRTC构建的视频通话系统中，都是普遍存在的，而且占比不少。因此，改善低性能的问题迫在眉睫，需要从数据中寻找到造成此类现象的答案。 原因分析 作者发现的，造成WebRTC普遍低QoE现象的原因在于淘宝Live中传输控制和编码器的协作程度还不够。证据在于，如果单独使用GCC传输不需编码的文件，可以发现GCC在码率估计方面的能力是很强的，其有能力可以保证较低时延和较低丢包率（近似为0的丢包率），但一般涉及了编码，性能就会严重恶化。问题不在于编码器，而在于GCC和编码器的步调不一致，是结构的问题。 单独GCC vs 视频通话 为了能够提高实验速度，作者团队实现了一个网络模拟器，相比于现实网络可以加速400倍的运行。可以直接读取数据集中的trace，并得到和实际情况相当的网络动态变化。 从数据集中随机选取了1000个会话，共763小时。将这些会话的throughput充当模拟器里的变化带宽，从而记录单独GCC传文件和视频通话这两种情况下，吞吐量、丢包率、时延等信息。结果如下： 可以发现，视频通话的吞吐量明显低于纯GCC，然而其丢包率和时延又显著高于纯GCC。这是一种反常现象，按理说相同的网络环境下，更低的吞吐量更不容易导致拥塞（更少的网络负载），因此也应该丢包和时延更低。那么这样的反常现象又该如何解释？进一步分析可以发现，这个现象是又两个因素导致的：（下图随机取一个session演示） 快速下降：以M1，M2这两个点为例，在这两个位置RTT和丢包均出现峰值，那么本来追踪带宽还不错的两个方案，均选择了下调吞吐率。但是此时，相比于纯GCC，视频通话下降的幅度更大。（GCC分别下降44.9%和25.8%，而视频通话下降了83.6%和58.5%）这表明视频通话遭遇了更严重的网络拥塞，正如上面中、右两张图。 缓慢恢复：拥塞结束后，视频通话将耗费更多的时间来恢复其比特率，如上面M3标记所示。 两因素的进一步佐证 所以，是先有了同一时刻出现的更严重的丢包和时延，视频通话选择了更大的比特率降幅，同时低比特率持续的时间也更久（即使拥塞早已过去），从而导致了比纯GCC明显低的比特率。当再出现严重丢包和时延时，又会重复这一过程，也就在统计意义上，发生了上面的反常现象。 那么为什么会出现这两个因素呢？文章给出了答案： 视频编码器不能生成完美匹配GCC估计值的比特率： 长期的平均比特率也许能够匹配目标，但是瞬时的变化（比如比特率突然飙到了平均值的两倍）会带来拥塞。 编码器滞后于GCC： 编码器需要至少1秒来近似出目标码率，但是此时的网络条件可能已经变了。 间歇性的视频流量模式影响了GCC带宽估计： 视频并不会像文件一样连续发送。一般是一帧编码后才会突发一系列的包，而其余时间链路处于空闲状态。但GCC每接收到ACK才开始估计带宽。也就是说，ACK到达得越不频繁，带宽估计的更新也会越慢，那么码率调整也将慢下来。（视频通话更新码率的次数比纯GCC足足少了50%） 事实上，通过对反常现象的分析，进一步验证了之前推断的正确性：传输与编码的配合能力弱，导致了普遍存在的WebRTC低QoE问题。（前两个原因导致了更为严重的拥塞，后一个原因导致了更慢的恢复） 因此，解决此类低QoE问题的关键，在于如何让传输控制和编码器之间的合作更为紧密一些。作者不认为Salsify中那种逐帧计算的方式是正确的，因为太过频繁的变化帧率分辨率，会导致人主观上的不适，一定程度上违反了优化QoE的目标。（而且Salsify的编码过程state-passing style，无法在硬编中进行） 算法设计 文章作者希望提出一个算法，在不严重改变WebRTC结构的前提下，能够替代GCC。也就是如下图，其以传输层信息（丢包率、包时延间隔）和编码器信息（发送端编码器比特率、接收端吞吐率）作为输入，输出一个目标码率，用于下一个时隙的pace和编码（设定时隙长度为1s，因为太短编码器用不了，太长的话对网络拥塞的反应能力会降低）。 输出的目标码率B应当是一个由两部分协同确定的数值，兼顾到传输控制和视频编码在当前网络下的特征，成为匹配这些特征的最优决策。比如当网络动态变化过于剧烈，Concerto应该偏向保守的B，而当发现拥塞已过时，应该能够快速提升码率。 Concento算法并没有采用学界目前RTC算法占主导地位的强化学习，而是使用了模仿学习方式。 文章中认为强化学习的劣势： 强化学习已在点播的应用中收获了良好效果，然而视频通话与点播有本质不同。在点播过程中可以容许buffer在几秒的时间上扩容，以补偿短期内的网络动态变化，而这也能体现强化学习“优化长期目标”的思想。但是视频通话的时延限制要低得多，而且其QoE主要体现在了对瞬时网络状态变化的应对，体现在瞬时动作上。 其次，强化学习并没有一个明确的指导原则，需要模型自己摸索，得到的决策不一定最优。但是对于视频通话是可以有专家系统决策的，因此可以通过模仿的方式，确保做出的就是接近最优决策的策略。 整个算法是在一个网络模拟器中训练的，从数据集中提取trace，trace里的throughput作为设定的带宽。trace中的80%用于训练，20%用于测试。 模仿学习(Imitation Learning) IL的agent与环境交互，在每个离散时隙感知到状态，根据此状态确定了动作，并获得奖励值。状态空间为S，动作空间A，IL的目标在于做出最优的状态-动作映射策略，来优化某些特定指标。 为了得到最优决策，设定一个专家（可能是人，可能是机器）。在第 i 轮训练中，现有策略会生成所有状态-动作对组成的集合。专家会从中进行指导，提供在此状态上的更优动作，形成新的集合。接着新集合被灌入神经网络中，迫使模型学习到更优决策，进而开启新的一轮训练。 经过n轮训练，得到的策略将会收敛于最优策略 Concerto 输入输出： 第t时隙的输入状态为st=( lt→, dt→, ut→, vt→ )s_t=(\\ \\overset{\\rightarrow}{l_t},\\ \\overset{\\rightarrow}{d_t},\\ \\overset{\\rightarrow}{u_t},\\ \\overset{\\rightarrow}{v_t}\\ )st​=( lt​→​, dt​→​, ut​→​, vt​→​ )，其中lt→\\overset{\\rightarrow}{l_t}lt​→​表示过去k个时隙的丢包率统计值序列，后面三项分别是包间时延序列、编码器的发送码率序列和接收端吞吐量序列。 通过训练的策略π∗\\pi^*π∗，状态映射到动作at=πt(st)a_t=\\pi_t(s_t)at​=πt​(st​)：目标码率，是编码器的目标比特率，也是传输层的发送码率。 动作发生后，新的状态出现st+1s_{t+1}st+1​，以此类推。 网络结构： 状态中的每个元素向量，并不是一维的，是二维的。因丢包序列为例，每个1s时间内，会获得多个RTCP包（默认15个），而每个RTCP包对应多个RTP包（默认4个），每个RTP包带来了一个丢包率数值。因此丢包率元素是一个15x4的二维矩阵。 训练方式： 自行设计的损失函数： cross-entropy：H(p,q)=∑x−p(x)log⁡q(x)H(p, q) = \\sum_x -p(x)\\log q(x)H(p,q)=∑x​−p(x)logq(x) 不能仅仅使用cross-entropy来反映当前决策和最优决策之间的差距，还应该引入视频通话的特点。比如要惩罚underuse和overshoot这两种情况，但是对overshoot的惩罚要更严厉一些，因为其带来的伤害更大。因此在制定损失函数时，需要一个权重来刻画这种差异性的惩罚。 w(s)={∥πθ(s)−π∗(s)∥2 if πθ(s)≤π∗(s)∥πθ(s)−π∗(s)∥2+C else w(s)= \\begin{cases}\\left\\|\\pi_{\\theta}(s)-\\pi^{*}(s)\\right\\|^{2} &amp; \\text { if } \\pi_{\\theta}(s) \\leq \\pi^{*}(s) \\\\ \\left\\|\\pi_{\\theta}(s)-\\pi^{*}(s)\\right\\|^{2}+C &amp; \\text { else }\\end{cases} w(s)={∥πθ​(s)−π∗(s)∥2∥πθ​(s)−π∗(s)∥2+C​ if πθ​(s)≤π∗(s) else ​ ℓ(πθ(s),π∗(s))=w(s)×H(p,q)\\ell\\left(\\pi_{\\theta}(s), \\pi^{*}(s)\\right)=w(s) \\times H(p, q) ℓ(πθ​(s),π∗(s))=w(s)×H(p,q) 平滑的比特率转换： 类似于滤波器的策略。首先计算历史比特率的加权平均：ϕ(t, k)=∑i=1k2−k×πθ(st−i)\\phi(t,\\ k)=\\sum_{i=1}^k 2^{-k}\\times\\pi_{\\theta}(s_{t-i})ϕ(t, k)=∑i=1k​2−k×πθ​(st−i​)，那么训练时为了能够更加平滑，需要新比特率不要偏离ϕ(t,k)\\phi(t,k)ϕ(t,k)太多，所以在训练时除了要最小化损失函数，还需要照顾到一个反映平滑度的regularizer。 πθ∗=arg⁡min⁡θEst∽dπi−1[ℓ(πθ(st),π∗(st))+λ∣∣πθ(st)−ϕ(t,k)∣∣]\\pi_{\\theta^{*}}=\\underset{\\theta}{\\arg \\min } {E}_{s_{t} \\backsim d_{\\pi_{i-1}}}\\left[\\ell\\left(\\pi_{\\theta}\\left(s_{t}\\right), \\pi^{*}\\left(s_{t}\\right)\\right)+\\lambda||\\pi_{\\theta}\\left(s_{t}\\right)-\\phi(t, k)||\\right] πθ∗​=θargmin​Est​∽dπi−1​​​[ℓ(πθ​(st​),π∗(st​))+λ∣∣πθ​(st​)−ϕ(t,k)∣∣] 专家标签： 这里的ground-truth就是设定的带宽，将其作为专家标签。训练好后，实际部署就不再需要这样的标签了。 参数： L=4, β=0.5, λ=0.5, k=3L=4,\\ \\beta=0.5,\\ \\lambda=0.5,\\ k=3L=4, β=0.5, λ=0.5, k=3。其中L是监督学习的loop数，β\\betaβ是每个loop中专家策略的占比 训练过程，使用的硬件为Tesla K80，每个epoch持续15分钟，大约20个epoch可收敛。learning rate以exponential decay方式，初始值0.001，斜率0.6。优化器为Adam且batch size为32. 实验验证 基线方案：WebRTC、Salsify、RL-V（Pensieve） 实验环境： 仿真： 仿真器由三部分组成。frame handler会从真正的视频中提取帧，交由ffmpeg编码，以模拟出间歇性流量；控制单元部署算法；传输单元会将每一帧包装为RTP包，经由仿真的网络链路（服从trace的链路变化）。 实验室testbed： 三台运行ubuntu1604的电脑，其中的router使用tc来控制网络条件，来服从数据集的trace的变化。 实际部署： 直接将concerto集成进淘宝app中（仅限ios），编译后的模型17.2MB，运行时开销可忽略不计（iphone7中仅需几毫秒做出比特率决策，足够1s的更新周期使用）。 QoE metric：QoE=a×Delay+b×PQ+cQoE=a\\times Delay+b\\times PQ+cQoE=a×Delay+b×PQ+c 其中Delay是是平均时延、PQ是picture quality，abc是用于量化的系数。QoEpQoE_pQoEp​表示侧重画质（比如直播带货），QoEdQoE_dQoEd​表示侧重视频的时延（比如交互式通话）。 性能对比 Concerto在所有网络接入方式下的QoE都远高于其他基线方法。 WebRTC相比于WebRTC，会有更大的吞吐量增益（因此会有比较好的画质提升）。 为了观察为什么会有这样的吞吐量增益，以一个200s的会话为例。可以发现，Concerto对带宽的追踪能力最强，然而WebRTC却在遭受large reduction和slow recovery这两个因素的制约。这也是Concerto相比于WebRTC有所提升的原因。 Concerto各模块作用 兼顾编码器、损失函数： Concerto相比于WebRTC的主要改进在于在做码率决策时，不仅考虑网络状态，同时还兼顾了编码器特性。为了验证这样做可以带来正向增益，将模仿学习输入参数中的去掉，此时的状态称为2-state，再训练推理以观察效果。事实上可以看到，相比于4-state，QoE会有18%的下降。 除此之外，自行设计的损失函数或许也是提升性能的因素。尝试四种损失函数进行训练：l1（传统cross-entropy）、l2（平方差，C=0）、l3（严厉惩罚overshoot，C=100）、l4（合理惩罚overshoot，C=8）。 可以观察到还是l4有最好的效果，说明自行设计的损失函数以及合理的权衡可以带来很大的增益。 神经网络参数： 实际部署 团队将concerto部署在淘宝app的淘宝Live中，征募了6名志愿者在大量的地区（家、办公室、教学楼、超市、逛街、开车）游走，大部分室内接入的是WiFi，而室外接入的是4G。全部实验总共300个会话，共计69个小时。每位志愿者拿两部手机，分别运行WebRTC的淘宝和集成了concerto的淘宝，以保证在相同的网络环境下测试两种方案。 WebRTC和Concerto的对比如表所示： 1）Concerto会有略低一点的吞吐率，但是却能显著降低卡顿时间； 2）对于WebRTC而言，4G情况下，移动速度越快，QoE越差； 3）WebRTC在WiFi场景下是可以取得比较好表现的。","categories":[{"name":"WebRTC","slug":"WebRTC","permalink":"http://example.com/categories/WebRTC/"}],"tags":[{"name":"WebRTC","slug":"WebRTC","permalink":"http://example.com/tags/WebRTC/"}]},{"title":"Linux下tc模拟弱网","slug":"Linux下tc模拟弱网","date":"2022-07-09T15:49:51.000Z","updated":"2022-07-12T16:15:41.440Z","comments":true,"path":"2022/07/09/Linux下tc模拟弱网/","link":"","permalink":"http://example.com/2022/07/09/Linux%E4%B8%8Btc%E6%A8%A1%E6%8B%9F%E5%BC%B1%E7%BD%91/","excerpt":"","text":"man文档：man tc 《Linux高级路由和流量控制手册》 tc简介 tc全称traffic controller，是Linux系统自带的流量控制器，可以通过软件形式控制传输过程中的变量——可用带宽、延时、丢包。同时，可以输入事先制定的变量时间序列，输入到由tc组成的Linux脚本中，使得后面较长时间的网络状态遵循设定值，从而模拟带宽骤变、时延抖动等情况。 由于是Linux自带工具，因此无需安装，其文档可在终端输入man tc获得。 后文中将提到，弱网条件下进行带宽限制和变化采用wondershaper完成，而延迟、抖动、丢包等情况的模拟借助netem实现，二者均依赖于tc。本文将首先简要介绍tc的工作原理，并解释tc命令中的常见选项，最后给出如何利用tc在Linux系统下模拟多种弱网状态。 tc原理及常用命令 默认配置时，Linux内核是如何安排流量传输的 每次在执行ip命令的时候，都会看到qdisc这个词 12345root@ubuntu:~$ ip l1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:002: enp0s5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000 link/ether 00:1c:42:f2:0d:5c brd ff:ff:ff:ff:ff:ff 可以看到，罗列ip时，lo的qdisc是noqueue，而enp0s5的qdisc是fq_codel。我们可以将Linux内核进行网络数据传输的过程，视为队列进出。当有数据想要传输时，先放入一个队列中，当满足某些要求后，通过某种规则以一定的顺序出队列，经由网络设备发送出去。而这里的要求与规则就是由qdisc制定的。qdisc全称queueing discipline，即排队规则，用于管理队列中数据的组织方式。 ubuntu20.04默认使用的是fq_codel这一规则，而过去的Linux内核默认使用的qdisc是pfifo_fast，这里将从pfifo_fast开始介绍qdisc的工作方式。如名字所示，其是一个先入先出队列，因此所有包都是按进入队列的先后顺序来发送的。 pfifo_fast有三个&quot;band&quot;（可以理解为实际的队列），编号分别为0、1、2，三个队列均为FIFO，但存在优先级的差异：如果band0有数据，就不会处理band1，如果band1有数据，就不会处理band2。当产生一个数据包时（不管是TCP还是UDP的），内核都会检查该包的TOS字段（ip协议头部），根据该字段的值选择将包放在哪一个band中。 通过sudo tc qdisc add dev enp0s5 root pfifo_fast将默认qdisc从fq_codel改为pfifo_fast后，可以看到： 12root@ubuntu:~$ tc qdisc show dev enp0s5qdisc pfifo_fast 8001: root refcnt 2 bands 3 priomap 1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1 有三个band，对应刚才所述的内容。pfifo_fast的配置是写死的，用户无法更改，但这份写死的配置中让我们看到了priomap这一参数，其意义为：将TOS字段映射为数据包优先级的规则。（这里的优先级指的是不同band的优先级，同一个band内数据包之间，只有先后顺序，没有优先级之分），tos由四个比特位组成： 1234567Binary Decimcal Meaning-----------------------------------------1000 8 Minimize delay (md)0100 4 Maximize throughput (mt)0010 2 Maximize reliability (mr)0001 1 Minimize monetary cost (mmc)0000 0 Normal Service priomap的规则如下（可以用tcpdump -vv查看）： 123456789101112131415161718TOS Bits Means Linux Priority Band------------------------------------------------------------0x0 0 Normal Service 0 Best Effort 10x2 1 Minimize Monetary Cost 1 Filler 20x4 2 Maximize Reliability 0 Best Effort 10x6 3 mmc+mr 0 Best Effort 10x8 4 Maximize Throughput 2 Bulk 20xa 5 mmc+mt 2 Bulk 20xc 6 mr+mt 2 Bulk 20xe 7 mmc+mr+mt 2 Bulk 20x10 8 Minimize Delay 6 Interactive 00x12 9 mmc+md 6 Interactive 00x14 10 mr+md 6 Interactive 00x16 11 mmc+mr+md 6 Interactive 00x18 12 mt+md 4 Int. Bulk 10x1a 13 mmc+mt+md 4 Int. Bulk 10x1c 14 mr+mt+md 4 Int. Bulk 10x1e 15 mmc+mr+mt+md 4 Int. Bulk 1 往往很多应用也会通过TOS字段，定义自己属于何种优先级（比如交互式流量应当具备高优先级，而大文件传输可以处于较低优先级） 123456789101112131415161718TELNET 1000 (minimize delay)FTP Control 1000 (minimize delay) Data 0100 (maximize throughput)TFTP 1000 (minimize delay)SMTP Command phase 1000 (minimize delay) DATA phase 0100 (maximize throughput)DNS UDP Query 1000 (minimize delay) TCP Query 0000 Zone Transfer 0100 (maximize throughput)NNTP 0001 (minimize monetary cost)ICMP Errors 0000 Requests 0000 (mostly) Responses &lt;same as request&gt; (mostly) 除此之外，既然涉及队列，队列的长度就不可能是无限大的，应当存在一个最大值。而pfifo_fast这个qdisc的发送队列长度由txqueuelen表示。tc命令是无法更改这个属性的（因为pfifo_fast对于tc而言，配置是写死的），但是ifconfig却可以： 1ifconfig enp0s5 txqueuelen 10 经过这些操作后，如果想把默认qdisc改回之前的fq_codel，可以通过下面的命令： 1sudo tc qdisc replace dev enp0s5 root fq_codel 那么抛开qdisc的具体类型，Linux是流量是如何进入和发出的呢。 下面的图诠释了流量在Linux中从进到出所经历的大致流程，其从外部网络进入主机，然后进入ingress qdisc。这里会有policing过程，根据结果判断是否要丢弃这个包，以达到约束下行速率的目的。若判断允许通过，当其目的端为主机的应用程序时，会进入内核ip协议栈，最后交给用户态程序。如果还要将结果发送出去，就需要经过egress。这个时候需要判定使用那个qdisc进行流量发送。此时可能会有很多qdisc，根据各种限定选择好合适的qdisc后，该qdisc就会接收包（enqueueing入队过程），此时包位于qdisc中，等待内核召唤，然后从队列中拿出，交付给网络接口来发送出去（dequeueing出队过程）。 123456789101112131415161718192021 Userspace programs ^ | +---------------+-----------------------------------------+ | Y | | -------&gt; IP Stack | | | | | | | Y | | | Y | | ^ | | | | / ----------&gt; Forwarding -&gt; | | ^ / | | | |/ Y | | | | | | ^ Y /-qdisc1-\\ | | | Egress /--qdisc2--\\ |---&gt;-&gt;Ingress Classifier ---qdisc3---- | -&gt; | Qdisc \\__qdisc4__/ | | \\-qdiscN_/ | | | +----------------------------------------------------------+ 术语 介绍了pfifo_fast后就可以对qdisc以及Linux内核如何进行数据包的发送有一个大致印象。pfifo_fast只是众多qdisc的冰山一角，下面为了更为详细地介绍tc如何利用qdisc进行流量控制，先简单说明一个术语。 排队规则：Queueing Discipline：qdisc 管理设备队列的算法，可以是管理入向(incoming/ingress)的，也可以是管理出向队列(outgoing/egress)的。 根排队规则：root qdisc 直接attach到网络设备（比如网卡）的那个qdisc。与该网络设备挂钩的全部类或qdisc共同构成了一棵树，而root qdisc就是这棵树的根节点。 无类别排队规则：classless qdisc 对所有包一视同仁，同等对待。tc内置了以下的classless qdisc（概念不重要，可以直接移步）： choke： CHOKe (CHOose and Keep for responsive flows, CHOose and Kill for unresponsive flows) is a classless qdisc designed to both identify and penalize flows that monopolize the queue. CHOKe is a variation of RED, and the configuration is similar to RED. codel： CoDel (pronounced “coddle”) is an adaptive “no-knobs” active queue management algorithm (AQM) scheme that was developed to address the shortcomings of RED and its variants. bfifo、qfifo： Simplest usable qdisc, pure First In, First Out behaviour. Limited in packets or in bytes. fq： Fair Queue Scheduler realises TCP pacing and scales to millions of concurrent flows per qdisc. fq_codel： Fair Queuing Controlled Delay is queuing discipline that combines Fair Queuing with the CoDel AQM scheme. FQ_Codel uses a stochastic model to classify incoming packets into different flows and is used to provide a fair share of the bandwidth to all the flows using the queue. Each such flow is managed by the CoDel queuing discipline. Reordering within a flow is avoided since Codel internally uses a FIFO queue. gred： Generalized Random Early Detection combines multiple RED queues in order to achieve multiple drop priorities. This is required to realize Assured Forwarding (RFC 2597). hhf Heavy-Hitter Filter differentiates between small flows and the opposite, heavy-hitters. The goal is to catch the heavy-hitters and move them to a separate queue with less priority so that bulk traffic does not affect the latency of critical traffic. ingress： This is a special qdisc as it applies to incoming traffic on an interface, allowing for it to be filtered and policed. mqprio： The Multiqueue Priority Qdisc is a simple queuing discipline that allows mapping traffic flows to hardware queue ranges using priorities and a configurable priority to traffic class mapping. A traffic class in this context is a set of contiguous qdisc classes which map 1:1 to a set of hardware exposed queues. multiq： Multiqueue is a qdisc optimized for devices with multiple Tx queues. It has been added for hardware that wishes to avoid head-of-line blocking. It will cycle though the bands and verify that the hardware queue associated with the band is not stopped prior to dequeuing a packet. netem： Network Emulator is an enhancement of the Linux traffic control facilities that allow to add delay, packet loss, duplication and more other characteristics to packets outgoing from a selected network interface. pfifo_fast： Standard qdisc for ‘Advanced Router’ enabled kernels. Consists of a three-band queue which honors Type of Service flags, as well as the priority that may be assigned to a packet. pie： Proportional Integral controller-Enhanced (PIE) is a control theoretic active queue management scheme. It is based on the proportional integral controller but aims to control delay. red： Random Early Detection simulates physical congestion by randomly dropping packets when nearing configured bandwidth allocation. Well suited to very large bandwidth applications. sfb： Stochastic Fair Blue is a classless qdisc to manage congestion based on packet loss and link utilization history while trying to prevent non-responsive flows (i.e. flows that do not react to congestion marking or dropped packets) from impacting performance of responsive flows. Unlike RED, where the marking probability has to be configured, BLUE tries to determine the ideal marking probability automatically. sfq： Stochastic Fairness Queueing reorders queued traffic so each ‘session’ gets to send a packet in turn. tbf： The Token Bucket Filter is suited for slowing traffic down to a precisely configured rate. Scales well to large bandwidths. 有类别排队规则：classful qdisc 一个classful qdisc中包含多个类别（classes），每个类别可以进一步包含其他qdisc，包含的可以是classful qdisc，也可以是classless qdisc。tc内置了如下的classful qdisc（概念不重要，可直接移步）： ATM： Map flows to virtual circuits of an underlying asynchronous transfer mode device. CBQ： Class Based Queueing implements a rich linksharing hierarchy of classes. It contains shaping elements as well as prioritizing capabilities. Shaping is performed using link idle time calculations based on average packet size and underlying link bandwidth. The latter may be ill- defined for some interfaces. DRR： The Deficit Round Robin Scheduler is a more flexible replacement for Stochastic Fairness Queuing. Unlike SFQ, there are no built-in queues – you need to add classes and then set up filters to classify packets accordingly. This can be useful e.g. for using RED qdiscs with different settings for particular traffic. There is no default class – if a packet cannot be classified, it is dropped. DSMARK： Classify packets based on TOS field, change TOS field of packets based on classification. HFSC： Hierarchical Fair Service Curve guarantees precise bandwidth and delay allocation for leaf classes and allocates excess bandwidth fairly. Unlike HTB, it makes use of packet dropping to achieve low delays which interactive sessions benefit from. HTB： The Hierarchy Token Bucket implements a rich linksharing hierarchy of classes with an emphasis on conforming to existing practices. HTB facilitates guaranteeing bandwidth to classes, while also allowing specification of upper limits to inter-class sharing. It contains shaping elements, based on TBF and can prioritize classes. PRIO： The PRIO qdisc is a non-shaping container for a configurable number of classes which are dequeued in order. This allows for easy prioritization of traffic, where lower classes are only able to send if higher ones have no packets available. To facilitate configuration, Type Of Service bits are honored by default. QFQ： Quick Fair Queueing is an O(1) scheduler that provides near-optimal guarantees, and is the first to achieve that goal with a constant cost also with respect to the number of groups and the packet length. The QFQ algorithm has no loops, and uses very simple instructions and data structures that lend themselves very well to a hardware implementation. 类别：class 一个class的parent可以是一个qdisc，也可以是另一个class。leaf class是没有child class的，这种class只attach一个qdisc，来负责被判定到该class的数据发送。 分类器：Classifier 用于在classful qdisc中判断每个包应当放在哪一个class中。 过滤器：Filter 分类的过程通过过滤器完成。过滤器中包含着很多判断条件，匹配到条件之后算filter匹配成功了。注意Filter仅限classful qdisc使用，在classless qdisc场景是不会使用到filter的。 Linux支持的Filter包括： basic bpf cgroup flow fw route rsvp tcindex u32 matchall 随到随发qdisc：Work-Conserving qdisc 只要有包可发送就会立即发送，而不会延迟包的发送。 非随到随发qdisc：non-Work-Conserving qdisc 可能会延迟一段时间再将一个包发送出去的qdisc，即使有能力立即发，也要延迟。 Shaping &amp; Policing shaping是针对egress进行整形的，在包发送之前进行延迟处理以达到预设的最大发送速率；policing是针对ingress的，没有入向队列这一说，控制下行速率只能对包进行丢弃，不能延迟。 classless qdisc 所谓无类别排队规则，就是不管入队是什么包哪种包，都将其放入一个队列中，之后按照排队规则将包从队列取出发送，这里将主要介绍TBF和SFQ。 有类别排队规则相反，入队之前会先将包判定属于某种类别，之后将包放入相应类别的队列中，按照该类别的排队规则进行取出发送。 pfifo_fast严格意义上不属于classless qdisc，因为其分了三个band，相当于包也有了优先级。但对于用户来说，它就是classless的，因为用户是无法修改其配置的，用户眼里是看不出优先级的。 TBF（Token Bucket Filter） TBF 是一个简单 qdisc，对于没有超过预设速率的流量直接透传，但也能容忍超过预设速率的短时抖动（short bursts in excess of this rate）。 TBF非常简洁，对网络和处理器都很友好（network-and processor friendly）。 如果只是想实现接口限速，那TBF是第一选择。 令牌桶（token bucket），顾名思义，首先维护了一个bucket用于存储令牌（token），而这个桶就是一个buffer。其大小决定了能容纳的token数量。在TBF算法中，存在token flow和data flow两种流。data flow的元素就是数据包，而token flow的元素就是token。token会以特定的速率填充进bucket中。当一个包到来时，会从bucket中拿出一个token，数据包发送出去后，就会从bucket中删除该token。两个flow的速率彼此独立，可能存在三种情况： 数据速率==token速率：每个包都能找到一个对应的token，然后直接从队列出去，没有延时（delay）。 数据速率 &lt; token速率：正常到来的数据都能及时发送出去，然后删除一个token。由于token速率大于数据速率，会产生bucket积压，极端情况会将bucket占满。如果数据速率突然高于token速率，就可以消耗这些积压的 token 。因此积压的 token 有一个额外好处：能够容忍短时数据速率抖动（burst）。 数据速率 &gt; token速率：token很快就会用完，然后 TBF 会关闭（throttle ）一会。这种情况称为overlimit（超过限制）。如果包还是源源不断地到来，就会产生丢包。 第三种情况是接口限速的关键所在，它使我们能够对数据可用的带宽进行整形(shape the bandwidth)。 积压的 token 使得超过限速的短时抖动数据仍然能发送，不会丢包，但持续的 overload 会导致数据不断被 delay，然后被丢弃。 实际情况中，token是基于字节数，而不是包数。 TBF中可以设置的参数： limit or latency： limit：因等待可用 token 而被放入队列的字节数。 latency：每个包在 TBF 中停留的最长时间。随后会基于 latency、bucket size、rate 和 peakrate（如果设置了）来计算 limit。 burst/buffer/maxburst： bucket 的大小，单位是字节。这是累积可用的 token 所支持的最大字节数（ maximum amount of bytes that tokens can be available for instantaneously）。总体来说，越大的整流速率（shaping rates）需要越大的缓冲区。要在 Intel 网卡 上实现 10Mbps 整流，你至少需要 10KB 缓冲区。 如果缓冲区太小，可能会丢包，因为 token 到来太快导致无法放入 bucket 中。 mpu： “零长度”的包占用的并不是零带宽（A zero-sized packet does not use zero bandwidth）。例如对于以太网，任何一个包的字节数不会少于 64。 Minimum Packet Unit（最小包单元）决定了一个包所使用的最小 token 量（the minimal token usage for a packet）。 rate：速率控制 peakrate： 默认情况下，包到了之后只要有 token 就会被立即发送。peakrate 可指定 bucket 发送数据的最快速度。通常来说：放行一个包 -&gt; 等待恰当的时长 -&gt; 放行下一个包。通过计算等待时长，最终实现了peakrate效果。 但实际中，由于 Unix 默认的 10ms 定时器精读限制，如果平均每个包 10Kbits ， 我们只能做到 1Mbps peakrate！（10Kb/10ms = 1000Kbps = 1Mbps）。 mtu/minburst： 1Mbit/s 的 peakrate 通常并不是很有用，因为实际中的带宽要远大于此。实现更高 peakrate 的一种方式是：每个 timer tick 发送多个包，在效果上就好像我们创建了第二个 bucket！ 计算最大可能的 peakrate 时，用 MTU 乘以 100（更准确地说，乘以 HZ 数，例如 Intel 上是 100，Alpha 上是 1024）。 一个简单但非常有用的配置： 1tc qdisc add dev ppp0 root tbf rate 220kbit latency 50ms burst 1540 如果链路中有一个queue很大的网络设备，那么大文件传输时会严重影响实时交互。因为上传的数据会被缓存到该设备的queue里，而且缓存的数据量很大（以提高吞吐）。如果入队的数据包能少一些，可以保证交互式数据的实时性。因此，上面的配置将发送速率降低到了网络设备不会对数据进行排队缓存的水平，从而降低了延时。 SFQ（Stochastic Fairness Queueing） 随机公平排队（SFQ）是公平排队算法族的一个简单实现。相比其他算法，SFQ 精准性要差一些，但它所需的计算量也更少，而结果几乎是完全公平的（almost perfectly fair）。 SFQ 中的核心是 conversion（会话）或 flow（流），大部分情况下都对应一个 TCP session 或 UDP stream。每个 conversion 对应一个 FIFO queue，然后将流量分到不同 queue。发送数据时，按照 round robin 方式，每个 session 轮流发送。 这种机制会产生非常公平的结果，不会因为单个 conversion 太大而把其他 conversion 的带宽都挤占掉。SFQ 被称为“随机的”（stochastic）是因为它其实并没有为每个 session 分配一个 queue，而是用算法将流量哈希到了一组有限的 queue。 这种方式也会导致问题：多个session可能被哈希到同一个queue中，那么queue中的各session吞吐量就会变少，达不到预期的整流带宽。于是为了避免这个问题严重影响性能，SFQ 会不断变换它使用的哈希算法，最终任何两个会话冲突的持续时间都不会很长，只会有几秒钟。 SFQ 只有在实际出向带宽已经非常饱和的情况下才有效，这一点非常重要！所以一般会将SFQ与其他qdisc相结合来实现一般情况下的公平排队。更明确的说，没有其他方式配合，单纯地使用SFQ配置没有意义。 SFQ中可以设置的参数： perturb：每隔多少秒就重新配置哈希算法。如果这个参数不设，哈希算法就永远不会重新配置。 建议显式设置这个参数，不要为空。10s 可能是个不错的选择。 quantum：在轮到下一个 queue 发送之前，当前 queue 允许出队（dequeue）的最大字节数。默认是一个 MTU。不建议设置为小于 MTU 的值。 limit：SFQ 能缓存的最大包数（超过这个阈值将导致丢包）。 对SFQ来ls一下，还可以看见一个自动分配的句柄编号（handle number，下面的800c）和一个flows属性： 123$ tc -s -d qdisc lsqdisc sfq 800c: dev ppp0 quantum 1514b limit 128p flows 128/1024 perturb 10sec Sent 4812 bytes 62 pkts (dropped 0, overlimits 0) flows 128/1024表示这个SFQ中有1024个哈希槽（hash buckets），其中128个当前有数据待发送。 classful qdisc 有类别排队规则不再对所有包一视同仁。classful qdisc下面可以再分若干类别，每个类别有自己的qdisc。 当流量进入一个 classful qdisc 时，该 qdisc 需要将其发送到内部的某个 class —— 即 需要对这个包进行“分类”。而要这个判断过程，实际上是查询所谓的“过滤器”（ ‘filters’）。过滤器是在 qdisc 中被调用的，而不是其他地方，理解一点非常重要！ 过滤器返回一个判决结果给 qdisc，qdisc 据此将包 enqueue 到合适的 class。 每个 subclass 可能会进一步执行其他 filters，以判断是否需要进一步处理。如果没有其他过滤器，这个 class 将把包 enqueue 到它自带的 qdisc。 前面提到root qdisc是直接attach到网络设备（比如网卡）的那个qdisc。如果root qdisc被设置为一个classful qdisc，那么其下层可以配置众多qdisc或class。下面的qdisc和class也可以继续向下配置更多的qdisc和class。配置时，可以通过**句柄（handle）**指定具体设置树状qdisc中的哪一个节点。 handle： 每个handle由两部分组成：: 按照惯例，root qdisc的handle为1:，这是1:0的简写 每个qdisc的minor number永远是0（class可以不必是0，更为灵活一些） class可以有qdisc做children，qdisc也可以有class做children。 比如下面的分层例子： 1234567891011121314 1: root qdisc | 1:1 child class / | \\ / | \\ / | \\ / | \\ 1:10 1:11 1:12 child classes | | | | 11: | leaf class | | 10: 12: qdisc / \\ / \\10:1 10:2 12:1 12:2 leaf classes 一个包可能会经历这样的过程：1: -&gt; 1:1 -&gt; 1:12 -&gt; 12: -&gt; 12:2。如果设置了filter，其能够直接在root处决定叶子节点的包，也可能会经历：1: -&gt; 12:2。 需要注意的是，包只会通过root qdisc入队或出队，也就是说当一个包被判定到一个叶子节点qdisc，并入队后，若要将其发送出去，会dequeue到它的父节点的qdisc，之后一层一层，直到传入root qdisc，此时再进行root qdisc的dequeue，从而通过网络设备发射出去。嵌套类（nested classed）只会和它们的parent qdiscs通信，而永远不会直接和接口交互。 由于这样的机制，所以子qdisc的流量整形受限于父qdisc的流量整形（比如子qdisc限速100M，而父qdisc限速10M，那么最终流量会被整形为10M），但是HTB是例外。 PRIO PRIO qdisc会根据filter的设置对流量分类： 可以将 PRIO qdisc 理解为 pfifo_fast qdisc 的升级版，它也有多个 band，但每个 band 都是一个独立的 class，而不是简单的 FIFO。当一个包 enqueue 到 PRIO qdisc 之后，它会根据设置的 filters 选择一个 class ，并将包送到这个 class。默认情况下会创建三个 class。每个 class 默认情况下都包含一个纯 FIFO qdisc，没有其他内部结构，但你可以用其他类型的 qdisc 替换掉 FIFO。 当从 PRIO qdisc 取出（dequeue）一个包时，会先尝试 :1。只有 lower bands/classes 没有数据包可取时，才会尝试 higher classes。相比于pfifo_fast，PRIO可以自定义优先级规则（通过设置filter），而非仅仅根据TOS分类。 由于PRIO自身并不携带流量整形功能，因此若想进行流量整形，可以借助PRIO先分类再整形，构成嵌套qdisc： 在外层嵌套一个专门负责流量整形的classful qdisc。即PRIO qdisc是work-conserving（随到随发型）的。 PRIO的主要参数： bands： 需要创建的band数量。如果改变这个配置，还需要同时修改priomap参数。 priomap： 如果没有提供tc filter来指导分类，那么就会使用和pfifo_fast类似的方式进行优先级排序。 band 0 对应的minor number是1，band 1 对应的minor number是2，以此类推。 示例配置： 123456$ tc qdisc add dev eth0 root handle 1: prio # This *instantly* creates classes 1:1, 1:2, 1:3$ tc qdisc add dev eth0 parent 1:1 handle 10: sfq$ tc qdisc add dev eth0 parent 1:2 handle 20: tbf rate 20kbit buffer 1600 limit 3000$ tc qdisc add dev eth0 parent 1:3 handle 30: sfq 上述脚本会创建如下结构的树状qdisc。PRIO按自动配置，采用TOS字段区分优先级。 123456789 1: root qdisc / | \\ / | \\ / | \\ 1:1 1:2 1:3 classes | | | 10: 20: 30: qdiscs qdiscs sfq tbf sfqband 0 1 2 tc-filter 每次要判断将包送到哪个 class 进行处理时，都会调用所谓的“classifier chain”（分类器链）。这个 chain 由 attach 到 classful qdisc 的所有 filter 构成。 123456789 root 1: | _1:1_ / | \\ / | \\ / | \\ 10: 11: 12: / \\ / \\10:1 10:2 12:1 12:2 当 enqueue 一个包时，在每一个分叉的地方都需要查询相关的过滤规则。 一种典型的配置是： 在 1:1 配置一个 filter，将包送到 12:。 在 12: 配置一个 filter，将包送到12:2。 需要注意的是，包是无法向上过滤的（filter a packet ‘upwards’，上层可以选择下层，下层不能选择上层）。 另外，使用 HTB 时，所有的 filters 必须 attach 到 root！ 包只能向下 enqueue！当 dequeue 时，它们会重新上来，到达要发送它的网络接口。 包并不是一路向下，最后从叶子节点到达网卡的！ tc支持了很多filter，u32（universal 32bit classifier）是最常用的一种。其可以匹配ip头部的任何部分。 12tc filter [add dev eth0] [parent handle] [protocol ip] [ something ] \\ u32 match ip [OPTION_LIST] [0xffff] flowid [child handle] something的内容因具体classful qdisc而异，比如PRIO，就可以设置为prio 1，表示匹配的包会被置为最高优先级，送入band 0。 OPTION_LIST中的内容是关键，其可以匹配ip地址（v4和v6均可）、端口、协议（tcp还是udp）。 ip（是ipv4，若使用ipv6需要改成ip6选项）： src 1.2.3.4/32，表示匹配源ip为1.2.3.4发来的包，子网掩码/32。相应的也可以有：dst 4.3.2.1/32，表示匹配要发送到目标ip 4.3.2.1的包，子网掩码/32。 port：与ip类似，分为源端口和目标端口：sport 80或dport 80。 protocol：指定要匹配的协议，协议号写在/etc/protocols中。比如要指定udp协议protocol 17，要指定tcp协议protocol 6，要指定ICMP协议protocol 1。 TOS：指定要匹配的包的TOS字段，比如tos 0x10 0xff，就是tos字段为0x10和0xff的包都要匹配到。 fwmark：可以用ipchains/iptables等工具对包打标，filter匹配时只匹配这些标记即可。比如将包标记为6： 1iptables -A PREROUTING -t mangle -i eth0 -j MARK --set-mark 6 现在匹配标记为6的包： 1tc filter add dev eth1 protocol ip parent 1:0 prio 1 handle 6 fw flowid 1:1 如果OPTION_LIST什么都不设，那么就说明，如果一个包不满足其他filter的条件，就会满足此filter。 0xffff：表示ip头部的32位都匹配，一般就是0xffff。 flowid指定了class，即匹配的包送到parent qdisc包含的哪个类中。 举个例子，上面指定的PRIO并没有添加filter，而是采用了默认的类似于pfifo_fast的方式。这里加上一些自定义匹配条件： 123$ tc filter add dev eth0 parent 10:0 protocol ip prio 1 u32 match ip dst 4.3.2.1/32 0xffff flowid 10:1$ tc filter add dev eth0 parent 10:0 protocol ip prio 1 u32 match ip src 1.2.3.4/32 0xffff flowid 10:1$ tc filter add dev eth0 protocol ip parent 10: prio 2 0xffff flowid 10:2 HTB（层级令牌桶） HTB是非常常用的一种classful qdisc，可以做到比较精准的网络限速，具有比CBQ更易扩展的特性。其原理不是本文重点，因此不做介绍，详细原理可以在HTB官网中看到。 需要注意，如果htb构成了嵌套，即父qdisc和子qdisc都是htb，那么子qdisc的最低保障速率（rate）不受父qdisc最高速率（ceil）的约束，即突破了前述层层dequeue下的子qdisc行为受限。 使用tc的脚本 wondershaper wondershaper是由tc写成的Linux脚本，用于限制上行或下行带宽，基于HTB。使用方法为： 12wondershaper -s ens33 -u 150 -d 100 #将ens33网卡的上行带宽设置为150kbps,下行100kbpswondershaper -c ens33 #取消对ens33网卡的限制 comcast comcast是更好用的工具，除了限制带宽之外还能设定延时、丢包率、协议、ip、端口号 123456$ comcast --device=eth0 --latency=250 \\ --target-bw=1000 --default-bw=1000000 \\ --packet-loss=10% \\ --target-addr=8.8.8.8,10.0.0.0/24 \\ --target-proto=tcp,udp,icmp \\ --target-port=80,22,1000:2000 comcast本质上是对NetEm（一种classless qdisc）的封装。 NetEm：较简单的弱网模拟方式 NetEm(netem)是Linux2.6及以上内核版本提供的一个网络模拟功能模块。该功能模块可以用来在性能良好的局域网中，模拟出复杂的互联网传输功能，诸如低带宽、传输延迟、延迟抖动、丢包等情况。而tc可以用来控制netem的工作方式，二者配合以进行弱网模拟。 netem本质上属于一种classless qdisc，与tbf一个级别。虽然下面的例子中netem功能都被添加到了root qdisc，但是这并不是必须的。netem功能也可以被加入到其他自定义qdisc中，如自定义的parent qdisc等。 介绍Netem原理的论文，本质上是通过两个队列（一个private holding queue，一个FIFO嵌套队列），入队过程中会先给包打上时间戳，放入private holding queue，定时器再将包从该队列取出放入嵌套FIFO，最终发送时从嵌套FIFO取包。 延迟，丢包，重复，损坏，乱序等模拟的情况，均可用ping工具验证。 传输延迟： 1tc qdisc add dev ens33 root netem delay 100ms 此命令将ens33网卡的传输设置为延迟100ms发送。更真实的情况下，延迟值不会如此准确，而是有一定的波动。可以用下面的情况来模拟出带有波动延迟： 1tc qdisc add dev ens33 root netem delay 100ms 10ms 此外，还可以通过设置几率来加强波动的随机性： 1tc qdisc add dev ens33 root netem delay 100ms 10ms 30% 此命令将ens33网卡的传输设置为100ms延迟发送，同时会有30%的包在100ms基础上在延迟±10ms。 网络丢包： 1tc qdisc add dev ens33 root netem loss 1% 该命令将ens33网卡设置为随机丢掉1%的数据包 同时也可以设置丢包的成功率： 1tc qdisc add dev ens33 root netem loss 1% 30% 此命令设置ens33网卡以30%的成功率随机丢掉1%的包。 包重复： 1tc qdisc add dev ens33 root netem duplicate 1% 此命令将ens33网卡的传输设置为随机产生1%的重复数据包。 包损坏： 1tc qdisc add dev ens33 root netem corrupt 0.2% 命令将ens33网卡的传输设置为随机产生0.2%的损坏数据包 包乱序： 1tc qdisc add dev ens33 root netem delay 10ms reorder 25% 50% 命令将ens33网卡设置为：有25%的数据包（50%相关）会被立即发送，其他的延迟10ms。 相关数值控制了伪随机数之间的关联。NetEm算法中的伪随机数生成器，会基于前一次的伪随机数，和此时生成的另一个伪随机数ri，决定当前要产生的伪随机数x_i。 也可以设置乱序的间隔： 1tc qdisc add dev ens33 root netem reorder 25% gap 5 delay 100ms 命令使得ens33网卡每传5个包时，前4个包被延时100ms发送，而第5个包以25%的概率被立即发送。 限制带宽： netem可以利用rate进行网速限速，但是需要注意limit需要足够大。 1234567DELAY_MS=40RATE_MBIT=10BUF_PKTS=33BDP_BYTES=$(echo &quot;($DELAY_MS/1000.0)*($RATE_MBIT*1000000.0/8.0)&quot; | bc -q -l)BDP_PKTS=$(echo &quot;$BDP_BYTES/1500&quot; | bc -q)LIMIT_PKTS=$(echo &quot;$BDP_PKTS+$BUF_PKTS&quot; | bc -q)tc qdisc replace dev eth0 root netem delay $&#123;DELAY_MS&#125;ms rate $&#123;RATE_MBIT&#125;Mbit limit $&#123;LIMIT_PKTS&#125; （只能限制上行带宽哈） 网损时限定条件： netem同时对tcp和udp进行网损。而若在视频会议场景，仅想测试弱网场景下的udp传输，而不想影响到tcp相关的信令连接，那么需要更细致地设定规则，因为netem默认会同时损伤tcp和udp。 可以结合PRIO这个classful qdisc配合netem，进行针对性调整。（17对应的就是udp protocol） 12345678tc qdisc add dev &lt;name&gt; root handle 1: priotc filter add dev &lt;name&gt; protocol ip parent 1: prio 10 u32 match ip protocol 17 0xff flowid 1:1tc filter add dev &lt;name&gt; protocol ip parent 1: prio 10 u32 match ip protocol 17 0xff flowid 1:2tc filter add dev &lt;name&gt; protocol ip parent 1: prio 10 u32 match ip protocol 17 0xff flowid 1:3tc qdisc add dev &lt;name&gt; parent 1:1 netem &lt;impairments&gt;tc qdisc add dev &lt;name&gt; parent 1:2 netem &lt;impairments&gt;tc qdisc add dev &lt;name&gt; parent 1:3 netem &lt;impairments&gt; 此外，还可以分链路以限速： 1234tc qdisc add dev eth0 root handle 1: priotc qdisc add dev eth0 parent 1:3 handle 30: tbf rate 20kbit buffer 1600 limit 3000tc qdisc add dev eth0 parent 30:1 handle 31: netem delay 200ms 10ms distribution normaltc filter add dev eth0 protocol ip parent 1:0 prio 3 u32 match ip dst 65.172.181.4/32 flowid 1:3 ipert验证： iperf工具可以分别针对tcp和udp进行可达速率测试。通过下面的命令设置对udp限速后， 12345678910sudo tc qdisc replace dev enp0s5 root handle 1: prio# 将udp传输限制为10Mbpssudo tc qdisc add dev enp0s5 parent 1:1 handle 10: \\ netem delay 40ms rate 10Mbit limit 2000sudo tc filter add dev enp0s5 protocol ip parent 1:0 prio 1 \\ u32 match ip protocol 17 0xff flowid 1:1# 将tcp传输开放不限制sudo tc qdisc add dev enp0s5 parent 1:2 handle 20: fq_codelsudo tc filter add dev enp0s5 protocol ip parent 1:1 prio 2 \\ u32 match ip protocol 6 0xff flowid 1: 使用iperf测量的结果：(限速uplink的主机是client，接收数据包的主机是server) 1iperf3 -c 192.168.0.108 -u -b 20M #-u选项表明发的是udp包 1iperf3 -c 192.168.0.108 #默认发的是tcp包 netem读取trace TCN是Linux内核中对netem的进一步扩展，它能够从一个trace中读取时延、丢包、包重复、包损坏等随时间变化的数值，且trace长度不限。TCN可模拟出真实网络下的重要特性（e.g., long-range dependence, self-similarity of cross-traffic）。 其他配置 如果用Wifi进行两设备间通信，同时在发送设备处使用tc模拟网损，可能会带来问题，因为无线网络本身抖动和延迟就比较大，而且因时而变。下图是通过中科大测速网站测试的结果： 也就是说，可能网络条件自身的延迟抖动比我们自行设定的还要大，那么模拟出的网损就失去了意义。因此，如果可以的话，两台设备间最好还是通过网线或者数据线进入同一局域网，确保足够稳定的网络条件，再进行网损。","categories":[{"name":"WebRTC","slug":"WebRTC","permalink":"http://example.com/categories/WebRTC/"}],"tags":[{"name":"WebRTC","slug":"WebRTC","permalink":"http://example.com/tags/WebRTC/"}]},{"title":"WebRTC拥塞控制策略改进调研","slug":"WebRTC拥塞控制策略改进调研","date":"2022-07-08T16:00:49.000Z","updated":"2022-07-12T16:16:30.783Z","comments":true,"path":"2022/07/09/WebRTC拥塞控制策略改进调研/","link":"","permalink":"http://example.com/2022/07/09/WebRTC%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AD%96%E7%95%A5%E6%94%B9%E8%BF%9B%E8%B0%83%E7%A0%94/","excerpt":"","text":"背景 随着新政策的引导及资本市场的追捧，直播行业首先在娱乐、游戏直播等行业经历了一次大规模增长，2020年后，疫情爆发进一步促进了直播行业高速发展，正在全面赋能电商、旅游、文化传播等众多领域。基于WebRTC的超低延时技术应运而生。WebRTC已被纳入万维网联盟的W3C推荐标准，且被腾讯云、阿里云等公司广泛应用于会议、云游戏等场景。然而，虽然WebRTC对直播服务质量提供了一定程度的优化，根据众多企业（如阿里、声网等）的测试，其在弱网环境中的效果仍然存在带宽利用率低、延时较高、恢复能力较弱等不足等问题（弱网阶段主要体现在用户接入最后一公里网络质量）。此类问题导致弱网中WebRTC性能不佳的情况普遍存在，字节跳动火山引擎数据显示，接近40%的直播产品用户处于弱网状态。同时根据淘宝Live的统计数据，国内至少有12%的用户承受着WebRTC中的低QoE（Quality of Experience）问题，且大部分地区有20%的用户QoE较低。 通过在WebRTC中引入弱网抗性优化策略，在弱网环境下改善传输性能的问题已迫在眉睫。本文档旨在调研业界改良WebRTC传输的解决方案，从中获取启发。 WebRTC现有策略 RTCP协议与NACK： RTCP报文头部 RTP协议和RTCP协议通常搭配使用，RTP包负责数据传输，而RTCP包可以承载传输过程中的信息，比如包的端到端延迟等，可认为RTP侧重数据，RTCP侧重控制。当PT设置为205时，表示当前的RTCP报文属于RTPFB（RTP Feedback），即RTP反馈报文，用于反馈过去一段时间RTP包的传输情况。 当RTCP报文类型为RTPFB，且此时FMT字段设置为1，表示NACK报文。此报文由数据接收端回传给数据发送端，通知发送端过去时间内有哪些包丢失。NACK报文包含两个字段：PID和BLP。PID标识从哪个包（填充该包的序列号）开始丢包，而BLP标识从PID开始，接下来16个RTP包的丢失情况。 RTX： 发送端收到NACK报文后，着手开展所丢包的重传工作。重传流为RTX流（区别于原始码流，重传的包有不同的头部：PT、SSRC、序列号等） 媒体协商阶段已开始将原始码流与RTX流绑定 GCC（Transport-cc）码率估计： GCC算法有两种，一种是早期版本WebRTC采用的Goog-REMB，另一种是现在版本中使用的Transport-cc。前者在接收端采集数据，利用卡尔曼滤波估算出带宽后反馈给发送端，发送端再根据估算结果做出下一阶段的码率决策。后者则直接在发送端进行码率估计，接收端仅反馈通信信息（如延迟、丢包）即可。Goog-REMB已基本不被使用。 WebRTC网络传输与QoS 现在的WebRTC还添加了Probe探测估计的带宽与实际带宽是否相匹配。 Pacer： 码率估计后，会驱动编码器和pacer控制传输速率。更具体地，音视频编码器控制输出码流的大小，pacer控制码流发送的速率。一帧视频可能很大，远大于以太网的1500byte，需要分别封装在几个RTP报文中，若这些视频帧RTP报文一起发送到网络上，必然会导致网络瞬间拥塞，产生丢包抖动等异常。再者，包之间的大小可能有显著差异，比如I、P、B帧间的长度相差非常大，直接发送网络波动幅度很大。因此在通过编码器控制流速后，仍需要pacer进行平滑发包，从而能够让数据包有条不紊地在网络中传输且不造成波动和拥塞。 组好的包会进入pace queue中，此队列并不是FIFO，在入队时会将各个数据包排出优先级（比如I帧的包肯定要优先于B、P帧的包），高优先级在发送时会先出队列。发送线程每隔5ms（timer）从pace queue中取出数据包以发送。发送的数据量由Budget计算：待发送字节数=（当前时间-上次send时间）*目标码率+8。为确保在定时时间内可以把数据包都发出去，可以修改参数（max_pacing_delay，发送时延上限）以调整目标码率。当队列中数据发完，下一时刻未到，会发padding包。 FEC： FEC是发送端在发送报文的时候，将媒体包按照一定规则产生冗余包，随同媒体数据一同发送，当接收端丢包后可以根据冗余包和媒体包恢复出丢失的媒体数据。 FEC流也不同于原始码流。相比于RTX流，其延迟更小。但是冗余包导致带宽占用大。 方便与RTX区分，可理解为RTX是后向纠错（FEC是前向纠错）。 WebRTC内置三种类型的FEC方案：RED、UlpFEC（默认）、FLEXFEC。 JitterBuffer： 网络抖动会造成包到达乱序，比如104号包到了，但是103号包没到，那么就无法组帧。为了避免乱序造成的丢包，需要引入buffer专门对抗jitter。当103号包到达时，根据对序列号的计算，将其插入到buffer的合适位置，即可交给组帧模块进一步处理。然而buffer大小不应该是一成不变的，当抖动小的时候就该小（降低延时），当抖动大的时候就需要大（提高包乱序容错能力）。 WebRTC利用卡尔曼滤波来适应抖动，调整JitterBuffer大小。（算法与Goog-REMB比较像） SVC / Simulcast Simulcast直译过来是多播的意思，其实就是一个客户端发送多条不同码率大小的流，为了达到这样的效果，客户端会对同一帧画面进行不同分辨率的编码来达到降低码率的目的。Simulcast虽然理论上可以解决下行带宽不足时降码率的需求，但仍然存在致命缺陷： 1.上行带宽的增加，我们在上行时会多发送多条流，导致大量的带宽浪费。而为了应对几个下行网络较差的用户而牺牲上行用户的带宽资源，这样的做法有待商榷； 2.下行可供的流选择性很少，及时使用3条流同时传输的方式，在移动网络这样复杂多变的网络条件下，上下调整的幅度将会是巨大的，会造成不好的用户体验，相比SVC适用性较差。 SVC技术是H.264标准的一个扩展，最初由JVT在2004年开始制定。H.264 SVC是H.264标准的扩展部分，SVC扩展部分引入了一种传统H.264 AVC不存在的概念——编码流中的层。基本层编码最低层的时域、空域和质量流；增强层以基本层作为起始点，对附加信息进行，从而在解码过程中重构更高层的质量、分辨率和时域层。通过解码基本层和相邻增强层，解码器能生成特定层的视频流。 对上述内容进行总结的话，可归纳出如下思维导图： 现有问题 1 一蹶不振：对丢包敏感 当多于10%的丢包率时，WebRTC会一蹶不振 GCC中，如果丢包率小于2%，允许速率上升，如果丢包率介于2%~10%，速率控制不变。 实验现象中，当丢包率大于等于10%时，数据率收敛到50Kbps，相当于只在传输音频数据（音频因其速率要求低，故在WebRTC中不会被限制）。 即使在事先建立好数据通路再提高丢包率，来到20%后依然会有数据率急剧下降的情况出现。 2 对抖动敏感 &amp; 反应迟钝 且由于TCC依托于接收端反馈的信息，当处于高延时环境下，TCC无法及时更新，从而导致传输性能差。高延时场景尤其体现在4G/3G蜂窝网络条件下，蜂窝网络中会有bufferbloat问题，即缓存膨胀到过大的状态。bufferbloadt可以减少丢包并能缓解带宽变化带来的影响，却带来了更大时延。 3 带宽利用率低：快下降与慢恢复 快速下降：以M1，M2这两个点为例，在这两个位置RTT和丢包均出现峰值，那么本来追踪带宽还不错的两个方案，均选择了下调吞吐率。但是此时，相比于纯GCC，视频通话下降的幅度更大。（GCC分别下降44.9%和25.8%，而视频通话下降了83.6%和58.5%）这表明视频通话遭遇了更严重的网络拥塞，正如上面中、右两张图。 缓慢恢复：拥塞结束后，视频通话将耗费更多的时间来恢复其比特率，如上面M3标记所示。 优化方案 工业界优化 声网 音视频学习 – 弱网对抗技术相关实践 https://km.sankuai.com/page/495742814 声网通过测试发现，主流拥塞控制算法（Cubic、BBR、PCC Vivace、Copa、Verus、Sprout、Vegas等）各有优劣，适用的网络或者业务场景各不相同，但是哪个都不适合应用于实时音视频场景。即使在几个算法之间调参，也无法取得比较好的效果。 针对此，声网自研了新的拥塞控制算法，算法具备“在线学习”、“loss differentiator(损失函数微分器，也就是机器学习优化器)”、“异常时序检测”等能力，可以提升带宽追踪速度，并能有效应对持续丢包。 （算法是learning-based，但可能不是基于深度学习） 融云 RTC系统音视频传输弱网对抗技术 融云分析了现阶段WebRTC码率估计、ARQ、FEC、JitterBuffer抗抖动的方式，分析了在应对丢包方面的要点，以及当前WebRTC抗抖动能力的不足，最终给出了自己的优化方案。 ARQ： 重传流程有以下细节需要考虑： 首次请求延时：应结合其他策略考虑发现丢包时是否立即请求，比如结合 FEC 策略考虑。 重复请求间隔考虑：同一个数据包重复请求间隔要大于当前 RTT。 请求次数限制：结合当前 RTT 与容忍的最大延时来计算。 发送端重传带宽限制：重传带宽作为总传输带宽的一部分，不能超出总体带宽限制。 重传包回传机制：建议采用单独的 RTP 码流发送，利于丢包率统计与重传带宽计算。 ARQ与FEC的配合： 相较于 FEC，ARQ 的缺点是会引入延时，优点是有较高的带宽利用率。抗丢包技术的优化目标概括来讲就是在满足延时要求的前提下，尽量以最小的额外带宽与计算成本，获得足够的保护力度。因此，在考虑ARQ和FEC的配合策略时应考虑以下原则： 在延时限制容许的前提下尽可能使用 ARQ，可根据当前 RTT 和最大延时限制计算最大重传次数； 如果最大重传次数可以将丢包率降低到一定程度以下（&lt;%1)，则不必开启 FEC 保护； 如果需开启 FEC，FEC 的保护程度要依据应用 ARQ 修复之后剩余的丢包概率来计算，进行兜底保护。 下图是在一定场景下的 FEC 与 ARQ 配合示意图，RTT 在 20ms 内，如果传输延时要求在 100ms 以内，在丢包 30% 的弱网链路上，则 ARQ 可以将丢包率降低到 1% 以下，由 ARQ 负责丢包修复。而随着 RTT 的上涨，FEC 的保护占比增加，最终由 FEC 单独负责丢包修复。 抖动问题： WebRTC的JitterBuffer机制中，针对视频分别采用了基于卡尔曼滤波的抖动延时估计算法。然而，WebRTC 主要为一对一实时沟通的应用场景设计，在如视频会议等一对多、多对多场景下，音视频流更多的是通过流媒体中转服务转发。通过实测，该算法对多节点转发场景下的全链路抖动延时估计效果有待改进。 融云的弱网对抗技术优化方案： 拥塞控制：基于 Google GCC 算法进行改进。除了统计单向延时变化进行拥塞趋势判断之外，同时对丢包模式进行进一步分析，提升带宽预测的准确率。 抗丢包：基于 FlexFEC 框架，采用高修复能力的 FEC 编码，并进行综合调优来提升抗丢包能力 优化ARQ与FEC机制的配合 抗抖动：采用场景适应性更强的抖动延时估计方法，力求提升流畅度的同时减少延时。 迈聆会议 WebRTC拥塞控制算法对比-GCC vs BBR vs PCC 基于谷歌的gcc算法自研了Omcc算法(optimization of Mindlinker in network congestion controller)，在现有表现上已经可以在大部分网络场景下准确预估带宽。 Omcc算法已经可以做到抗50%丢包, 抗800ms抖动, 抗2s延时, 在300k-10mbps带宽范围下也可以准确预估带宽值, 在保障低延时的情况下, 能够尽可能提高带宽利用率。 （但是并没有说明是如何实现的） 迈聆会议给出了GCC、BBR、PCC这三种已经在WebRTC新版本中集成的拥塞控制算法的测试和优缺点说明，阐述了自研拥塞控制算法的需求。 123456○ 带宽限制: 500kbps 1mbps 2mbps○ 丢包限制: 10% 20%○ 延时限制: 100ms 200ms○ 抖动限制: 100ms 200ms○ 混合网损模拟A: 1mbps+10%+100ms延时○ 混合网损模拟B: 10%+100ms延时+100ms抖动 腾讯 腾讯发布超低延时直播白皮书，其中腾讯认为原生WebRTC的音视频编码格式受限，音频不支持AAC，视频不支持H.265和B帧，不支持私有数据的透传，不支持可选加密限制了其在大规模直播场景的应用。且重传较为激进（为保证低延迟），这带来了大量的带宽浪费。因此腾讯基于WebRTC在适配低延迟直播方面进行了大量的优化升级。 1、编码改造： 支持AAC：附加Audio FEC，使音频能抗50%以上的丢包 H.265：更高压缩率 B帧：增强画质的同时大幅减少码率，通过客户端SDK配合CDN实现。 Simulcast/ABR（自适应码率优化弱网卡顿） 2、传输改造： 柔性分级传输：直播场景下主播和观众是1对多模型，个别观众的网络问题无法调整主播推流码率，因此采用柔性分级丢帧的传输策略来渐进式减低码率。 net_score=1 / exp(k1 * rtt / rtt_max + k2 * loss_rate + k3 * retrans_rate) * 100 自适应码率：扩展RTCP作为切流信令，服务端通过渐进式的超发来探测网络的承载能力作为切流决策依据 P2P分发网络：将看同一视频流的用户群就近组织成网络，相互分享传输 自适应pacing降低卡顿、优先响应I帧以优化重传 避免NACK积压：新的GOP到来时，将往期GOP的NACK丢弃。 即构科技 如何实现70%丢包下音视频的高可用：信令篇、数据篇 与融云相似，即构也在融合ARQ和FEC方面发力。ARQ和FEC各有优劣，适用于不同的场景。 混合ARQ与FEC的智能策略应当充分考虑网络情况，根据RTT和丢包率来智能地决定使用FEC还是ARQ，以及二者都使用时各自的比例。 此外，当GCC估计出带宽后，仍需要进行合理的带宽分配。发送端需要把带宽分配给原始数据包、FEC校验包、ARQ重传包，而分配的依据则是网络情况（包括RTT和丢包率等因素）。 冗余数据包的带宽分配得越多，纠错能力就越强，然而原始数据包就相应分配得越少，实时视频的质量就会降低； 冗余数据包的带宽分配得越少，纠错能力越弱，但原始数据包的带宽分配也更多，质量得到了保障。 合理的带宽分配就是在视频质量和纠错能力之间寻找平衡点： 百度智能云 百度智能云抗弱网技术 百度智能云总结了Transport-cc的设计不足，并在抗弱网方面给出了自己的实践解决方案。其优化策略与上述公司存在很多重合之处。 Transport-cc的设计不足： 强依赖反馈，由接收影响发送，因此在高延迟时算法几近失效； 丢包、延时拥塞都基于统计实现，反应灵敏度低； 算法未能覆盖高抖动场景。 百度智能云的优化实践： 视频的带宽分为三部分：视频原始码率、前向纠错的FEC码率、重传NACK的RTX码率。可以根据实际的丢包、延时情况改变NACK+FEC的带宽分配比例，从而提升抗丢包率。 规避重传时的NACK风暴：同一个RTP包，在两次重传间会隔1倍的RTT，通过这种方式保护因多次发送导致的带宽占用。 增强丢包抗性： 将丢包的情况分类为：拥塞丢包、非拥塞丢包和偶发丢包。 非拥塞丢包场景下，个体的避让对整体信号质量的影响有限，为了保证视频的流畅，我们不能降低带宽，需要发送更多的数据包，将带宽分配给纠错部分。目前，还很难解决拥塞丢包问题。偶发丢包问题可能是非持续的网络信号抖动，无需通过降低带宽来优化。 增强乱序抖动抗性： 带宽估计对乱序抖动的适应性较差。为此，我们需要避免将乱序误判为丢包。在存在一定丢包的情况下，也应该考虑对乱序和延时的估计，提升对弱网的适应性。 提升拥塞灵敏度： 在带宽估计过程中，默认的实现以事后统计数据为基础。为了提升探测拥塞的灵敏度，可以通过在发送端增加 TCP 拥塞窗口，动态地分配窗口，可以很灵敏地感知到发送方下行带宽出现的拥塞。 工业界优化结果 1、声网：在带宽限制128k1Mbps区间内，丢包率050%范围内以及延时15ms时，相比于WebRTC码率明显提升且卡顿率显著降低。 2、融云：在 60%、70% 的高丢包场景下，融云可以做到在Android 和 iOS 移动端测试，流畅度方面 MOS 值仍达到 4 分。 3、腾讯：优化的超低延迟直播技术已支持腾讯高质量完成多项大型赛事、活动。 4、迈聆会议：Omcc算法可以做到抗50%丢包、抗800ms抖动、抗2s延时，在300k~10Mbps带宽范围下准确预估带宽值，收获更高带宽利用率。 5、即构科技：实现在70%高丢包环境下，音视频流畅互动。 6、百度智能云：未说明可以做到何种程度的抗性优化。 学术界优化 学术界在优化视频传输方面，有非常多设计ABR算法和基于深度学习进行带宽预测的工作，但相关算法目前落地，乃至应用于MRTC改进并不现实。偏工程且受广泛关注的工作有以下两项。两项工作的主要发力点在于改进WebRTC结构的不足，相比于工业界优化方案更为激进。 Salsify(NSDI’ 18) 可参考本人之前的笔记： Concerto(Mobicom’19 淘宝Live) 可参考本人之前的笔记： 总结 通过对业界和学界进行调研，发现对WebRTC传输性能进行改进可以从NACK、FEC、拥塞控制、结构调整、编码优化、抖动适应能力等多方面入手。此处对后续可能进行的改进方案进行列举： 1、BBR计算结果对比GCC中的Probe效果，观察能否通过融合BBR的方式针对WebRTC现存的“慢恢复”问题进行提速，以规避突发风险或提高服务质量。 2、引入对丢包模式的分析，从而对抗丢包网络状况，避免带宽利用率持续偏低。 3、同时考虑ARQ和FEC策略， 4、对实际音视频码流、RTX码流、FEC码流进行合理带宽分配。 5、改进NACK处理策略，优化ARQ阶段的大量重复NACK。 6、参考Salsify中的编码器state-passing，优化重传时的编码时延。 7、优化多节点情况下JitterBuffer的抖动估计算法。 8、支持B帧。 9、引入B帧后进行平滑发包（参考腾讯）。 10、自适应QoS分级，进行SVC或ABR。 11、在ACK高时延时，采用时序预测方法（包括带宽预测和时延预测）及时更新目标码率，避免GCC慢速更新。 12、在PCC/GCC基础上自研拥塞控制算法（或结合Salsify等工作的策略替换GCC）。 13、参考Concerto，对码率估计进行经验调参（结合编码器特点）。 14、编码器提速。 15、在实际4G、5G网络中进一步测试并分析问题（改善将更偏底层，比如优化4/5G通信的Resource Block），目前已知4G网络下的RTC极易遭遇bufferbloat问题，后续优化时可参考bufferbloat状况改善方案。 16、pacer引入对inter arrival的修正，参考Salsify改进（动态pacer发送）","categories":[{"name":"WebRTC","slug":"WebRTC","permalink":"http://example.com/categories/WebRTC/"}],"tags":[{"name":"WebRTC","slug":"WebRTC","permalink":"http://example.com/tags/WebRTC/"}]},{"title":"C++基础知识","slug":"C++基础知识/C++基础知识","date":"2022-07-01T04:33:00.000Z","updated":"2022-07-10T11:29:19.416Z","comments":true,"path":"2022/07/01/C++基础知识/C++基础知识/","link":"","permalink":"http://example.com/2022/07/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"C++基础知识 参考资料： - 《C语言导学》（第一版） - 《C primer》（第五版） - 《C新经典：对象模型》（第一版） - 《C并发编程实战》（第二版） 时间线： 2021/10/9：开始整理笔记，以《C语言导学》为线索梳理 2022/05/24：初步整理完成，汇总《C语言导学》，部分《C++ Primer》和少量《Effective Modern C++》 2022/06/20：开始在笔记中加入并发（《C并发编程实战》第二版）知识 2022/07/07：学习极客时间“现代C实战30讲”，添加type_traits相关内容 面向过程 1 基础知识 程序编译： ISO的C++标准定义了两种实体： 1.核心语言特性 比如内置类型（int, float）以及循环（for, while）； 2.标准库组件 比如容器（vector, map）以及I/O操作（&lt;&lt;, getline）。 预处理期编程： 预处理编程的操作目标是“源码”，各种指令控制预处理器，实际上就是让预处理器改造源码，改造成其他形式。预处理指令以“#”开头，单独的“#”也是一个预处理指令，即空指令，相当于空行。 12345# // 预处理空行#if __linux__ // 预处理检查宏是否存在# define HAS_LINUX 1 // 宏定义，有缩进#endif // 预处理条件语句结束# // 预处理空行 预处理器改造后的代码可以让gcc用-E选项来展开。 包含文件（#include）： #include不仅可以包含头文件，理论上，只要想，源码、普通文本、图片、音频、视频都可以引进来（虽然可能出现无法处理的错误）。比如#include &quot;a.out&quot;。引用头文件时常用的技巧是“Include Guard”： 1234#ifndef _XXX_H_INCLUDE_#define _XXX_H_INCLUDE_... //头文件内容#endif _XXX_H_INCLUDE_ 还有一种常用用法，使用“ *.inc”文件存放一些代码片段。比如有一个很大的用于数值计算的数组，直接放在源码文件里很占地方，不方便对源码的逻辑部分进行梳理查看。那么，便可以把此数组放在calc_values.inc中，通过#include加载它，从而替换原来的大批数字： 12345678910111213//calc_values.inc文件static uint32_t calc_table[] = &#123; // 非常大的一个数组，有几十行 0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, ... &#125;;//源码文件static uint32_t calc_table[] = &#123;# include &quot;calc_values.inc&quot; // 非常大的一个数组，细节被隐藏&#125;; 宏定义（#define/#undef）： 宏的展开、替换发生在预处理阶段，对于一些调用频繁的小代码片段，用宏来封装的效果比inline关键字要好，因为其是源码级别的无条件内联，比如Nginx中的代码 1234#define ngx_tolower(c) ((c &gt;= &#x27;A&#x27; &amp;&amp; c &lt;= &#x27;Z&#x27;) ? (c | 0x20) : c)#define ngx_toupper(c) ((c &gt;= &#x27;a&#x27; &amp;&amp; c &lt;= &#x27;z&#x27;) ? (c &amp; ~0x20) : c)#define ngx_memzero(buf, n) (void) memset(buf, 0, n) 宏没有作用域概念，永远生效，因此对于一些用于简化代码、起临时作用的宏，用完后尽快#undef取消定义，避免冲突： 123456789#define CUBE(a) (a) * (a) * (a) // 定义一个简单的求立方的宏cout &lt;&lt; CUBE(10) &lt;&lt; endl; // 使用宏简化代码cout &lt;&lt; CUBE(15) &lt;&lt; endl; // 使用宏简化代码#undef CUBE // 使用完毕后立即取消定义#ifdef AUTH_PWD // 检查是否已经有宏定义# undef AUTH_PWD // 取消宏定义#endif // 宏定义检查结束#define AUTH_PWD &quot;xxx&quot; // 重新宏定义 宏也被常用来做文本替换，比如： 12345678#define BEGIN_NAMESPACE(x) namespace x &#123;#define END_NAMESPACE(x) &#125;BEGIN_NAMESPACE(my_own)... // functions and classesEND_NAMESPACE(my_own) 此处只是简单的文本替换，但是全大写的形式非常醒目，可以更容易识别出命名空间开始和结束的位置。 条件编译（#if/#else/#endif）： 在预处理阶段实现分支处理，通过判断宏的数值来产生不同的源码，从而改变源文件的形态。#if后的判断依据，也就是定义好的各种宏。 C++版本号宏：__cplusplus，利用该宏来判断当前的环境，从而使用相应的处理方式。 123456789101112131415#ifdef __cplusplus // 定义了这个宏就是在用C++编译 extern &quot;C&quot; &#123; // 函数按照C的方式去处理#endif void a_c_function(int a);#ifdef __cplusplus // 检查是否是C++编译 &#125; // extern &quot;C&quot; 结束#endif#if __cplusplus &gt;= 201402 // 检查C++标准的版本号 cout &lt;&lt; &quot;c++14 or later&quot; &lt;&lt; endl; // 201402就是C++14#elif __cplusplus &gt;= 201103 // 检查C++标准的版本号 cout &lt;&lt; &quot;c++11 or before&quot; &lt;&lt; endl; // 201103是C++11#else // __cplusplus &lt; 201103 // 199711是C++98# error &quot;c++ is too old&quot; // 太低则预处理报错#endif // __cplusplus &gt;= 201402 // 预处理语句结束 C++语言特性宏：可以在预处理阶段判断系统是否支持某些语法特性，若支持就用特性，不支持就用老写法 C标准提供的宏：C有很多预定义的宏，如源文件信息的“FILE”“LINE”“DATE”，以及一些测试语言特性是否被支持的宏，如“__cpp_decltype”“__cpp_decltype_auto”“__cpp_lib_make_unique”等。 编译器提供的宏：C++标准里很多宏未定义，但编译器提供，可用g++ -E -dM - &lt; /dev/null查看。 123456789101112131415#if defined(__cpp_decltype_auto) //检查是否支持decltype(auto) cout &lt;&lt; &quot;decltype(auto) enable&quot; &lt;&lt; endl;#else cout &lt;&lt; &quot;decltype(auto) disable&quot; &lt;&lt; endl;#endif //__cpp_decltype_auto#if __GNUC__ &lt;= 4 cout &lt;&lt; &quot;gcc is too old&quot; &lt;&lt; endl;#else // __GNUC__ &gt; 4 cout &lt;&lt; &quot;gcc is good enough&quot; &lt;&lt; endl;#endif // __GNUC__ &lt;= 4#if defined(__SSE4_2__) &amp;&amp; defined(__x86_64) cout &lt;&lt; &quot;we can do more optimization&quot; &lt;&lt; endl;#endif // defined(__SSE4_2__) &amp;&amp; defined(__x86_64) 自定义的宏：可以用自定义的宏来实现条件编译，比如Nginx使用Shell脚本检测外部环境，生成一个包含若干宏的源码配置文件，再条件编译包含不同的头文件，实现操作系统定制化。 123456789101112#if (NGX_FREEBSD)# include #elif (NGX_LINUX)# include #elif (NGX_SOLARIS)# include #elif (NGX_DARWIN)# include #endif 代码禁用启用： 使用#if 1或#if 0来显式启用或者禁用大段代码，要比/*...*/的注释方式安全且清晰： 1234567#if 0 // 0即禁用下面的代码，1则是启用 ... // 任意的代码#endif // 预处理结束#if 1 // 1启用代码，用来强调下面代码的必要性 ... // 任意的代码#endif // 预处理结束 属性：编译期指令 前面的#include、#define都是预处理指令，用于控制预处理器。类似的，还有“编译指令”来控制编译器。 C++11之前标准里没有编译指令，但编译器提供了，比如GCC里的__attribute__，VC里的__declspec C++11开始，官方将编译指令正式命名为“属性”，用两对方括号的形式[[...]]表示，相当于给变量、函数、类等贴上一个编译阶段的标签，让编译器识别。 虽然官方将属性的语法加进来了，但是标准里定义的属性还是十分有限的，最有用的当属C++14的deprecated： 12345[[deprecated(&quot;deadline:2020-12-31&quot;)]]int old_func();//使用此函数的程序编译时会报出一条警告：//warning: ‘int old_func()’ is deprecated: deadline:2020-12-31 [-Wdeprecated-declarations] 属性支持非标准扩展，也就是允许使用编译器提供的非官方属性，比如GCC的属性在gnu::中： gnu::deprecated：与C14的deprecated相同，但是可以用在C11里。 gnu::unused：抑制对变量、类、函数的未使用警告，与&quot;(void) var&quot;效果一样。 12[[gnu::unused]] //声明下面的变量暂不使用，不是错误，不需要warningint nouse; gnu::constructor：函数会在main()函数之前执行，效果类似对全局对象的构造函数 gnu::destructor：函数会在main()函数结束之后执行，效果类似对全局对象的析构函数 gnu::always_inline：要求编译器强制内联函数，作用比inline关键字强 12345[[gnu::always_inline]] inlineint get_num()&#123; return 42;&#125; gnu::hot：标记热点函数，要求编译器对其进行更积极的优化 📌constructor和destructor必须使用C语言的语法，比如只能用printf()而不能用cout。 下面两种写法是等价的： 12345678910111213141516171819__attribute__((constructor)) void load_file()&#123; printf(&quot;Constructor is called.\\n&quot;); g_count = (int *)malloc(sizeof(int)); if (g_count == NULL) &#123; fprintf(stderr, &quot;Failed to malloc memory.\\n&quot;); &#125;&#125;__attribute__((destructor)) void unload_file()&#123; printf(&quot;destructor is called.\\n&quot;); if (g_count) free(g_count);&#125;int main()&#123; return 0;&#125; 123456789101112131415161718192021[[gnu::constructor]] void load_file()&#123; printf(&quot;Constructor is called.\\n&quot;); g_count = (int *)malloc(sizeof(int)); if (g_count == NULL) &#123; fprintf(stderr, &quot;Failed to malloc memory.\\n&quot;); &#125;&#125;[[gnu::destructor]] void unload_file()&#123; printf(&quot;destructor is called.\\n&quot;); if (g_count) free(g_count);&#125;int main()&#123; return 0;&#125; 函数： 123//返回值类型 函数名字（函数参数）double sqrt (double);double sqrt (double d); 1.对于类成员函数来说，类名字也是函数名字的一部分char&amp; String::operator[](int index); 2.编译器会检查实参的类型，并且会在必要的时候执行隐式实参类型转换 sqrt(2); 3.函数重载可能会因为二义性报错： 12345void print(int, double);void print(double, int);void user()&#123; print(0,0); //此时会报错，因为两个print都可以用&#125; 📌C和C编译文件的区别： C语言不支持重载，而C支持。如一个函数声明为void function(float x,float y)，在C语言中，编译器进行编译之后，在库中的名字为_function；在C中，编译器进行编译后，在库中的名字为_function_float_float。 编译器在链接的阶段，都是找到相应的函数名，进行链接。 在C语言中，两个函数的名字一样，就会在链接时报错； 在C中 ，两个函数名字不相同，就不会报错。 变量类型与算术： 基本类型：bool，int，double，char，unsigned，等 算术运算符 比较运算符 逻辑运算符 1234567x+y //二元加法+x //一元正（结果没区别）x-y //二元减法-y //一元负（结果取负）x*y //乘法x/y //除法x%y //取模 123456x==yx!=yx&lt;yx&gt;yx&lt;=yx&gt;=y 123456x&amp;y //按位与x|y //按位或x^y //按位异或~x //按位求补x&amp;&amp;y //逻辑与x||y //逻辑或 初始化的两种方式：=赋值运算符 和 {}初始值列表，二者区别在于前者允许隐式类型转换，而后者不允许 12double x = 2.4complex &lt;double&gt; test = &#123;2.4,2&#125;;//正确，会转换 12double x &#123;2.4&#125;;//正确complex &lt;double&gt; test &#123;2.4, 2&#125;//错误，2是int 由于不允许隐式类型转换，所以一般建议初始值列表的方式初始化变量，可以避免一些导致部分信息丢失的类型转换 还可以使用auto关键字根据初始值自动推断类型 1234auto b = true;auto ch = &#x27;x&#x27;;auto i = 123;auto d = 1.2; 常量： const：保证变量不变 const int dmv = 17; constexpr：编译时求值 constexpr double max1=square(dmv); 📌constexpr若要用在编译时求值场景，右式必须是常量表达式！ 12//常量表达式函数必须有constexpr声明constexpr double square(double x)&#123;return x*x;&#125; 由constexpr声明的函数可以接受非常量实参，但此时将不再是常量表达式；若接受的是常量实参，此时是常量表达式。 123int var = 17;constexpr result1 = square(var);//报错！因为square(var)非常量表达式，不可编译时求值 ↑错误 →正确 12345const int dmv = 17;constexpr result2 = square(dmv);//正确！square(dmv)是常量表达式，此时编译时求值const result3 = square(var);//正确！result3仍是常量，此为运行时求值 作用域与生命周期： 局部作用域： 类作用域： 命名空间作用域： 循环与条件： [ ] 普通for 123for(auto i = 0; i != 10; ++i)&#123; //......&#125; [ ] 普通while 123while(i++ != 10)&#123; //......&#125; for循环的执行顺序：先auto i=0，再判断i≠10，若满足，执行{ }中的内容，再进行i，然后判断i≠10，满足则执行{ }，再i，循环往复。 [ ] for…range（类似于Python里的for） 拷贝形式的for…range（x是v中元素的拷贝值） 12345int v[] &#123;1,2,3,4,5,6,7,8&#125;;for(auto x:v) print(&quot;%d&quot;, x);for(auto x:&#123;1,2,3,4,5&#125;) print(&quot;%d&quot;, x); 引用形式的for…range（x是v中元素的引用） 12for(auto&amp; x:v) ++x; [ ] switch 1234567891011switch(ch)&#123; case &#x27;u&#x27;: //...... break; case &#x27;d&#x27;: //...... break; default: //...... break;&#125; switch的限制： ch必须是一个整形或枚举类型，或者是一个class（class中有转换函数将其转换为整型或枚举类型） 内联函数： 内联函数以空间换时间，省去调用函数的额外开销。所以代码很长或有循环的时候不适合使用内联； inline对编译器而言只是一个建议，如果定义的函数体内有递归/循环等，编译器优化时自动忽视内联； inline必须与函数定义放在一起，仅将内联放在声明前是不起作用的； 定义在类内的成员函数默认为内联函数； 内联与宏函数的区别： 宏： 没有类型检测，不安全 不能进行调试 不可以访问类的成员变量 内联函数： 有类型检测，较安全 进行参数传递，可在运行时调试 可以访问类的成员变量 指针与引用： 空指针尽量用nullptr，使用NULL可能会导致与整数0的混淆。 12char* p = &amp;v[3]; //p指向v数组中的第四个元素的地址char x = *p; //v是p指向地址的变量的值 📌前置&amp;表示一个变量的地址； 后置&amp;表示声明一个引用 将引用传入作为函数实参 一般来说，函数实参的传递是一个拷贝的过程，将变量的值拷贝到函数的栈中，不会带来对原变量的影响。 而若将引用作为参数传递void sort(vector&lt;double&gt;&amp; vec);，sort函数将直接操纵vec向量，没有拷贝的过程。这样可以加快速度，节省空间，但带来了操作原变量，误改动值的风险。 若想加快传入大数组参数的速度，又不改变值，可以加入const限定！ 1double sum(const vector&lt;double&gt;&amp; vec); 二级指针与指针的引用 二级指针 指针的指针，作用是改变指针本身的内容。 指针的引用 指针的引用，可以写为int *&amp;i;形式，本质是((int*)&amp;) i;，表示i是一个int型指针的引用，也可以像二级指针一样修改指针本身的内容。 需要说明的是，没有指向引用的指针，因为引用不是变量，因此不存在指针。 2 用户自定义类型 这是C++提供的一种抽象机制，用户可以此机制定义自己想要实现某些功能的新类型 结构体： 12345678struct Vector&#123; int sz; //元素的数量 double * elem;//指向元素的指针&#125;;void Vector_init(Vector&amp; v, int s)&#123; v.elem = new double[s]; v.sz = s;&#125; 访问结构体的元素有两种方式，点运算符和→运算符（指针） 1234567Vector v &#123;0, nullptr&#125;;Vector_init(v, 3);v.elem[0] = 1,v.elem[1] = 2,v.elem[2] = 3;Vector&amp; rv = v;Vector* pv = &amp;v; cout &lt;&lt; v.sz &lt;&lt; rv.sz &lt;&lt; pv-&gt;sz &lt;&lt; endl; 结构体的多种初始化方法： 📌结构体初始化： - {}初始化： Node b = &#123;2, nullptr&#125;或 Node b &#123;2, nullptr&#125;; - 构造函数初始化： `struct Node{ int var; Node* `\\*\\*`next; Node(int value, Node next_ty)&#123; this→var = value; this→next = next_ty; &#125; //或者： Node(int value, Node* next_ty):var(value), next(next_ty)&#123;&#125;; };``Node c(3, nullptr) 或 Node* d = new Node(4,nullptr)` 类： 类有一系列成员，可能是数据、函数或类型。public成员定义了该类的接口，private成员则只能从接口访问 123456789class Vector&#123;public: Vector(int s): elem&#123;new double[s]&#125;, sz&#123;&#125; &#123;&#125; //构造函数的初始值列表 double&amp; operator[](int i)&#123; return elem[i]; &#125; int size() &#123; return sz; &#125;private: double* elem; // 指向元素的指针 int sz; //元素的数量&#125; 需要注意的一点是，虽然Vector类中elem的元素个数可能会变，但是Vector声明的对象大小是不变的。这一点也适用于所有类声明的对象。 📌struct和class并没有太大区别，struct中也可以定义一些成员函数。唯一的区别体现在struct中的所有成员都是public的。 枚举： 普通枚举：enum 普通枚举的枚举值都是整形，默认情况下枚举值对应的整数从0开始，依次加1 12enum Color &#123;red, green, blue&#125;;int col = green; //col的值变为1 强类型枚举：（scoped enumeration，C++11引入的特性） 强类型中，每个enum class是不同的类型，其枚举值位于指定的作用域中，不得混用，可避免对常量的意外误用 1234567enum class Color &#123;red, blue, green&#125;;enum class Traffic_light &#123;green, yellow, red&#125;;Color x = red; //报错，哪个red？Color y = Traffic_light::red; //报错，这个Red不是一个Color对象Color z = Color::red; //正确 int col = Color::red; //报错，Color::Red不是一个int 强类型枚举并不和普通枚举一样，枚举值并不是int。但其作为一种用户自定义类型，也可进行运算符重载 1234567Traffic_light&amp; operator++(Traffic_light&amp; t)&#123;//前置++运算符 switch(t)&#123; case Traffic_light::green: return t = Traffic_light::yellow; case Traffic_light::green: return t = Traffic_light::yellow; case Traffic_light::green: return t = Traffic_light::yellow; &#125;&#125; 联合： union的所有成员被分配在同一片内存区域中，其实际占用的空间就是它最大的成员所占的空间。同一时刻，union中只能保存一个成员的值。 12345678910111213enum Type &#123;str, num&#125;;struct Entry&#123; char* name; Type t; char* s; //如果t==str,则使用s int i; //如果t==num,则使用i&#125;;void f(Entry* p)&#123; if(p-&gt;t==str) cout &lt;&lt; p-&gt;s; //......&#125; 如左边程序所示，s和i永远不会同时用到，但又同时定义了二者，所以无形中浪费了内存空间，使用联合可解决该问题。 命名联合和匿名联合均可！ 1234567891011121314151617//命名联合体enum Type &#123;str,num&#125;;union Value&#123; char* s; int i;&#125;;struct Entry&#123; char* name; Type t; Value v;&#125;;void f(Entry* p)&#123; if(p-&gt;t==str) cout&lt;&lt;p-&gt;v.s; //......&#125; 1234567891011121314151617//匿名联合体enum Type &#123;str,num&#125;;struct Entry&#123; char* name; Type t; union &#123; char* s; int i; &#125;;&#125;;void f(Entry* p)&#123; if(p-&gt;t==str) cout&lt;&lt;p-&gt;s;//匿名的优势在于，可以直接用 //......&#125; 注意：初始化此结构体不能再Entry test&#123;&quot;abc&quot;, num, 123&#125;，{}会按{char , Type, char}初始化，发挥不了union优势 要逐个赋初值，以匿名联合体为例，要Entry test;test.name=&quot;abc&quot;; test.t=str;test.s=&quot;abc&quot;;//test.t=num;test.i=123; auto/decltype auto自动类型推到，在代码里的作用像一个占位符，写上它，让编译器自动填上变量的类型。其属于编译阶段的特殊指令，因此在泛型编程和模板元编程里有比较多的使用。 decltype比较像函数，来计算类型，跟auto很像。（也是编译阶段的类型推导） auto注意事项： auto的自动推导能力只能用在“初始化”场合 12345auto x = 0L; // 自动推导为longauto y = &amp;x; // 自动推导为long*auto z &#123;&amp;x&#125;; // 自动推导为long* auto err; // 错误，没有赋值表达式，不知道是什么类型 类成员变量初始化时，不允许使用auto推导类型 1234class X final&#123; auto a = 10; // 错误，类里不能使用auto推导类型&#125;; auto总是推导出“值类型”，绝不会是“引用”；但是auto可以附加上const、 *、&amp;等，得到新的类型 123456auto x = 10L; // auto推导为long，x是longauto&amp; x1 = x; // auto推导为long，x1是long&amp;auto* x2 = &amp;x; // auto推导为long，x2是long*const auto&amp; x3 = x; // auto推导为long，x3是const long&amp;auto x4 = &amp;x3; // auto推导为const long*，x4是const long* decltype注意事项：decltype没有auto这么多局限，前述auto的三个事项在decltype这里均不需要注意。 类型推导时不需要初始化（后面无需有表达式），可以直接声明变量； decltype不仅能够推导出值类型，还能推导出引用类型，即“原始类型” 12345678int x = 0; // 整型变量decltype(x) x1; // 推导为int，x1是intdecltype(x)&amp; x2 = x; // 推导为int，x2是int&amp;，引用必须赋值decltype(x)* x3; // 推导为int，x3是int*decltype(&amp;x) x4; // 推导为int*，x4是int*decltype(&amp;x)* x5; // 推导为int*，x5是int**decltype(x2) x6 = x2; // 推导为int&amp;，x6是int&amp;，引用必须赋值 C++14引入了decltype(auto)，既能够精确推导类型，又可以像auto一样方便（decltype里不再每次都输入特定的表达式了） 12345int x = 0; // 整型变量decltype(auto) x1 = (x); // 推导为int&amp;，因为(expr)是引用类型decltype(auto) x2 = &amp;x; // 推导为int*decltype(auto) x3 = x1; // 推导为int&amp; auto和decltype的使用： auto使用场景：变量声明、range-based for：for(auto&amp; i : vec)、函数返回值auto test()&#123;&#125;（C++14） decltype的使用场景： 当类型非常奇怪时，给奇怪类型一个别名 12345// UNIX信号函数的原型，看着就让人晕，你能手写出函数指针吗？void (*signal(int signo, void (*func)(int)))(int)// 使用decltype可以轻松得到函数指针类型using sig_func_ptr_t = decltype(&amp;signal) ; 类内成员，auto被禁，decltype可以替换 123456789101112class DemoClass final&#123;public: using set_type = std::set; // 集合类型别名private: set_type m_set; // 使用别名定义成员变量 // 使用decltype计算表达式的类型，定义别名 using iter_type = decltype(m_set.begin()); iter_type m_pos; // 类型别名定义成员变量&#125;; 位域 C++中的类和结构体可以包含比内置整形类型占用更少存储空间的成员。这些成员可以指定位数大小，叫做“位域”。 位域可以看做内置整形类型的子集，位域成员可以指定其在结构体中占用的位数。 123456struct Date&#123; unsigned short nWeekDay : 3; //3 bits unsigned short nMonthDay : 6; //6 bits unsigned short nMonth : 5; //5 bits unsigned short nYear : 8; //8 bits&#125;; 声明为位域的数据从低位到高位进行排序 假定系统中unsigned short是16位的，nYear8位，会溢出unsigned short类型的单元边界，因此它会从新的unsigned short开始。同时，还可以有匿名位域（宽度为0），匿名位域会强制下一字段与下一个类型边界对齐 1234567struct Date&#123; unsigned short nWeekDay : 3; //3 bits unsigned short nMonthDay : 6; //6 bits unsigned : 0; //强制对齐到下一边界 unsigned short nMonth : 5; //5 bits unsigned short nYear : 8; //8 bits&#125;; 带有零长度位域的对象布局 📌位域字段的基础类型必须是整形类型（内置的那些） 3 模块化 命名空间： 一段完整的程序可能是由不同部分构成的，应对这种情况，为使结构清晰且编译加快，应该使用分离编译，即在头文件中声明，利用头文件提供接口，具体实现在不同源文件中。 但是若有多个开发者共同开发，把模块组装在一起构成程序并不一定是一件容易的事情，特别是当不同开发者命名了同一个函数名时。命名空间为解决此情况问题而生。 如要声明一个自己的complex类型，但又不想与std库中的complex类型冲突： 123456789101112131415namespace My_Code&#123; class complex&#123; //...... &#125;; complex sort(complex);&#125;My_Code::complex My_Code::sort(My_Code::complex)&#123; //......&#125;int main()&#123; My_Code::complex a &#123;1,2&#125;; My_Code::complex result = My_Code::sort(a);&#125; 当然，如果不想写的像上面那样繁琐，也可以直接用using关键字using namespace My_Code，使得一个指定命名空间的名字在当前在当前作用域中可见。 4 错误处理 异常&amp;不变式： 异常负责报告运行时程序发射时能够的错误。由throw语句指定。例如在自定义Vector时，需要确保索引Vector对象时，不会有越界的情况发生。因此，可以在operator[]()中抛出异常： 12345double&amp; Vector::operator[](int i)&#123; if(i&lt;0 || size()&lt;=i) throw out_of_range&#123;&quot;Vector::operator[]&quot;&#125;; return elem[i];&#125; throw将程序的控制权从调用了Vector::operator[]()的函数转移到了out_of_range异常的异常处理代码。比如下面当try中的索引越界，抛出out_of_range异常后，会进入catch块中的代码： 12345678910void f(Vector&amp; v)&#123; //... try &#123; //可能发生越界错误的代码被放在了try块中 v[v.size()] = 7; &#125; catch (out_of_range) &#123; //捕捉到越界异常 //处理越界错误 &#125; //...&#125; 除此之外，在调用构造函数构造Vector时，传入的参数也需要满足一些条件。将从调用构造函数，直到调用析构函数这一过程中，对象始终所满足的要求称为不变式(Invariant)。比如调用Vector构造函数指定包含多少个元素，却传进了一个负值，这时需要不变式来约束。这种情况下的不变式可以通过异常实现。 123456789101112131415161718Vector::Vector(int s)&#123; if (s &lt; 0) throw length_error&#123;&#125;; elem = new double[s]; sz = s;&#125;void test()&#123; try &#123; Vector v(-27); &#125; catch (std::length_error) &#123; //处理负值问题 &#125; catch (std::bad_alloc) &#123; //处理内存耗尽问题 &#125;&#125; 📌当希望一个函数永远不抛出异常，可以将其声明为noexcept。这样的话当函数抛出了异常，标准库函数terminate()会立即终止当前程序的执行，避免异常的传播和扩散。 noexcept 等效于 noexcept(true) C++11后，类的析构函数默认是noexcept，也就是析构函数不允许抛出异常。但如果人为将声明改为noexcept(false)，或者其基类的析构函数是noexcept(false)，那么此时的析构函数可以抛出异常。 此外，noexcept自身也可以是一个运算符，标志一个函数是否被声明成了noexcept，是否能抛出异常。 123456789101112131415void f() noexcept; //函数f()不抛出异常void (*fp) noexcept(false); //fp指向可能抛出异常的函数void g(void pfa() noexcept); //g接收不抛出异常的函数的指针noexcept(f); //返回值为true//两种noexcept可配合于函数模板//以声明函数对某些类型抛异常，但不对其他类型抛出template &lt;class T&gt;void fun() noexcpet(noexcept(T()))&#123;//...&#125; 静态断言： 上述两种方式均为运行时报错，而静态断言可以在编译时报错，从而让开发者改进代码以规避运行时的错误。static_assert(A,S)机制的作用是，当A不为true时，把S作为一条编译器错误信息输出。 📌需注意，A必须是常量表达式！ 12345constexpr double C = 299792.458;double speed = 100000;const double local_max = 160.0/(60*60);static_assert(speed&lt;C,&quot;can&#x27;t go that fast&quot;); // 报错，speed不是常量，非常量表达式static_assert(local_max&lt;C,&quot;can&#x27;t go that fast&quot;); // 正确，常量表达式 5 const const常量与宏的区别 const定义的常量在预处理阶段并不存在，而是直到运行阶段才出现。也就是说，const声明出来的是一种“只读变量”，可以用指针获取地址。既然可以获取指针，那么便可以利用指针再强制写入，从而“常量不常”。 123456//需要加上volatile修饰，运行时才能看到效果const volatile int MAX_LEN = 1024;auto ptr = (int*)(&amp;MAX_LEN);*ptr = 2048;cout &lt;&lt; MAX_LEN &lt;&lt; endl;//输出2048 修改时需要用volatile禁用优化。不加的话编译器看到const会采取优化手段，把所有const常量出现的地方替换成原值 const修饰成员函数 123const int&amp; fun(int&amp; a); //修饰返回值int&amp; fun(const int&amp; a); //修饰形参int&amp; fun(int&amp; a) const&#123;&#125; //const成员函数 const修饰返回值 const修饰返回值多是在返回类型为引用的情况下，避免返回值被修改的情况。 因为此时这个引用比不是临时对象的引用，必然是成员变量后函数参数。不用const修饰可能会成为左值被修改，如下： 1234567891011121314151617181920class A&#123;private: int data;public: A(int num):data(num)&#123;&#125; ~A()&#123;&#125;; int&amp; get_data() &#123; return data; &#125;&#125;;int main()&#123; A a(1); a.get_data()=3; cout&lt;&lt;a.get_data()&lt;&lt;endl; //data=3 return 0;&#125; 如果返回值加上了const，此时试图改变返回值的操作是不允许的，编译会报错。从而规避上述情况。 const修饰形参 传引用的方式可以节省内存，提高效率。但导致了函数具备修改该值的风险。如果在引用类型的形参前加const，就可以规避此风险。 const修饰成员函数 考虑这样一种场景：一个对象被声明成const，但是其某个成员函数非const，此时通过该对象调用该成员函数，编译器会报错 12const String str(&quot;hello world&quot;);str.print(); //类内的print没有被const修饰 这是因为调用成员函数时，会使用this指针。但是我们定义了一个const对象，但this指针不是const类型的，所以出现参数类型不匹配，编译无法通过的情况。 用const修饰成员函数，实质上是修饰this所指向的对象。 当类内没有函数重载，即只有一个版本的成员函数时，const对象只能调用const成员函数，non-const对象既可以调用const成员函数，也可以调用non-const成员函数。 而如果一个成员函数同时有const和non-const两个版本的话，const对象只能调用const成员函数，non-const对象只能调用non-const成员函数。 const修饰指针 const char* ptr：* ptr是const的，即不能通过*ptr修改值，但是ptr可以修改，值也可改 1234567char str[] = &quot;hello world&quot;;char ss[] = &quot;good game||&quot;;const char* ptr = str;ptr[0] = &#x27;s&#x27;; //报错！str[0] = &#x27;s&#x27;; //不报错，正常，输出会得到&quot;sello world&quot;ptr = ss; //不报错，输出*ptr会得到&quot;good game||&quot; char const* ptr：与const char*一致。 char* const ptr：ptr是const的，即不能修改ptr，但可以通过*ptr改值 123456char str[] = &quot;hello world&quot;;char ss[] = &quot;good game||&quot;;char* const ptr = str;ptr[0] = &#x27;s&#x27;; //正常ptr = ss; //报错 📌const在*前值不变，const在*后地址不变 值得注意的是，有一种说法为const在前的属于底层const，而const在后的属于顶层constconst int*，const int&amp;这种属于底层const，使得值不可改；int* const属于顶层const，值可改 6 匿名函数（lambda表达式） 具体形式：[capture](parameters)→return-type&#123;body&#125; 如最简单的形式： 1[](int x, int y)-&gt;int &#123;int z=x+y; return z;&#125; 若想捕获外部变量，可在[ ]内输入外部参数： 123456[] //未定义变量.试图在Lambda内使用任何外部变量都是错误的.[x, &amp;y] //x 按值捕获, y 按引用捕获.[&amp;] //用到的任何外部变量都隐式按引用捕获[=] //用到的任何外部变量都隐式按值捕获[&amp;, x] //x显式地按值捕获. 其它变量按引用捕获[=, &amp;z] //z按引用捕获. 其它变量按值捕获 1234567std::vector&lt;int&gt; some_list;int total = 0;for (int i=0;i&lt;5;++i) some_list.push_back(i);std::for_each(begin(some_list), end(some_list), [&amp;total](int x) &#123; total += x;&#125;); 📌[ ]中想捕获this时，this只能按值捕获[this]。 如果用户想把lambda表达式当作一个参数来传递，可以用auto关键字（转换成std::function对象）帮助存储： 12345678910111213141516171819#include&lt;functional&gt;#include&lt;vector&gt;#include&lt;iostream&gt;double eval(std::function&lt;double(double)&gt; f, double x = 2.0)&#123;return f(x);&#125;int main()&#123; std::function&lt;double(double)&gt; f0 = [](double x)&#123;return 1;&#125;; auto f1 = [](double x)&#123;return x;&#125;; decltype(f0) fa[3] = &#123;f0,f1,[](double x)&#123;return x*x;&#125;&#125;; std::vector&lt;decltype(f0)&gt; fv = &#123;f0,f1&#125;; fv.push_back ([](double x)&#123;return x*x;&#125;); for(int i=0;i&lt;fv.size();i++) std::cout &lt;&lt; fv[i](2.0) &lt;&lt; &quot;\\n&quot;; for(int i=0;i&lt;3;i++) std::cout &lt;&lt; fa[i](2.0) &lt;&lt; &quot;\\n&quot;; for(auto &amp;f : fv) std::cout &lt;&lt; f(2.0) &lt;&lt; &quot;\\n&quot;; for(auto &amp;f : fa) std::cout &lt;&lt; f(2.0) &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; eval(f0) &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; eval(f1) &lt;&lt; &quot;\\n&quot;; return 0;&#125; 📌- std::function&lt;double(double)&gt;里，括号外的double是返回类型，括号里的double是参数类型 - decltype()，C++11中的类型说明符，返回操作数的数据类型。 lambda表达式其实是一种闭包。 mutable 修饰类内成员 前面说到，被const修饰的常成员函数，不会修改对象的任何属性。但是没有提到一种情况，那就是该属性由mutable修饰。mutable的作用是：可以在常成员函数中被修改其值。 1234567class A&#123;public: void print(void) const&#123; cout &lt;&lt; m_data++ &lt;&lt; endl; &#125; mutable int m_data;&#125;; 修饰匿名函数 当[]中采用值捕获时，是不允许在匿名函数内部修改捕获的变量的值的。但是如果有mutable修饰匿名函数，则在捕获时会创建该变量在匿名函数中的同名拷贝，而且该拷贝会一直存在，直到匿名函数作用域完结。此时，匿名函数内部可以对该“变量”（实质上是拷贝）进行修改，同时不必担心原变量被修改。而且每次进入相同的匿名函数时，该拷贝都会维持上一次调用该函数时的值。 1234567891011121314151617int main()&#123; int t = 10; //按值捕获 auto f = [t]() mutable &#123; return ++t; &#125;; auto f2 = [t]() mutable &#123; return ++t; &#125;; cout &lt;&lt; f() &lt;&lt; endl; //11 cout &lt;&lt; f2() &lt;&lt; endl; //11 cout &lt;&lt; f() &lt;&lt; endl; //12 cout &lt;&lt; f2() &lt;&lt; endl; //12 cout &lt;&lt; t &lt;&lt;endl; //10&#125; 7 函数指针 函数指针指向的是函数而非对象，其指向的函数的类型，仅由其返回值类型和形参类型决定，与函数名无关。比如： 1bool lengthCompare(const string &amp;, const string &amp;); 定义了一个函数lengthCompare，其类型为bool(const string&amp;, const string&amp;)。可以声明一个指针pf： 1bool (*pf)(const string &amp;, const string &amp;); 📌*pf两端的括号必不可少。如果不写这对括号，表示一个函数，返回bool*类型的返回值 这是一个指向bool(const string&amp;, const string&amp;)类型函数的函数指针，因此可以有 123456pf = lengthCompare; //pf指向lengthCompare函数pf = &amp;lengthCompare; //等价的赋值语句：取地址符是可选的bool b1 = pf(&quot;hello&quot;, &quot;goodbye&quot;); //调用lengthCompare函数bool b2 = (*pf)(&quot;hello&quot;, &quot;goodbye&quot;); //一个等价的调用bool b3 = lengthCompare(&quot;hello&quot;, &quot;goodbye&quot;); //另一个等价的调用 重载函数的指针 如果指针指向一个函数，这个函数的函数名被很多函数共享，即出现重载，那么编译器需要通过指针类型决定选用哪个函数 123456void ff(int*);void ff(unsigned int);void (*pf1)(unsigned int) = ff; //pf1指向ff(unsigned)void (*pf2)(int) = ff; //错误，没有可以匹配的重载（参数角度）double (*pf3)(int*) = ff; //错误，没有可以匹配的重载（返回类型角度） 可以看出，相比于一般的重载（只看形参，不看返回值），函数指针在重载的选择上要苛刻一些，既考虑了形参，又要考虑返回值类型。 函数指针形参 C++“表面上”是可以把“函数类型”作为形参传入一个函数的，即： 123//第三个形参是函数类型void useBigger(const string &amp;s1, const string &amp;s2, bool pf(const string &amp;, const string &amp;)); 实际上，编译器偷偷地做了一个隐式转换，将所谓的函数类型给解释成了函数指针问题，即转换成了 12void useBigger(const string &amp;s1, const string &amp;s2, bool (*pf)(const string &amp;, const string &amp;)); 此时可以直接把函数名作为实参传入，它会被自动转换成指针： 1useBigger(s1, s2, lengthCompare); 利用类型别名和decltype简化函数指针： 1234567/* ---- 函数类型别名 ---- */typedef bool Func(const string&amp;, const string&amp;); //定义Func为bool(const string&amp;, const string&amp;)类型typedef decltype(lengthCompare) Func2; //定义Func2为与lengthCompare类型一致的函数类型/* ---- 函数指针别名 ---- */typedef bool(*FuncP) (const string&amp;, const string&amp;); //定义FuncP为函数指针typedef decltype(lengthCompare) *FuncP2; //decltype返回的是类型，所以要加上*才能使FuncP2指针 那么在使用的时候，就可以使用下面这几种等价写法 1234void useBigger(const string&amp;, const string&amp;, Func);void useBigger(const string&amp;, const string&amp;, Func2);void useBigger(const string&amp;, const string&amp;, FuncP);void useBigger(const string&amp;, const string&amp;, FuncP2); 第1、2条语句中，编译器自动将Func、Func2类型转换成函数指针 返回指向函数的指针 函数不能作为另一个函数的返回值，但是函数可以返回函数指针，以达到类似效果。然而，返回值不再像形参一样，编译器不再对返回值进行自动的隐式转换，因此返回值需要显式声明为函数指针类型。而简化这种显式声明的方式仍然是别名： 123456using F = int(int*, int); //F是函数类型，不是指针using PF = int(*)(int*, int); //PF是指针类型PF f1(int); //正确：PF是指向函数的指针，f1返回指向函数的指针F f1(int); //错误：F是函数类型，f1不能返回一个函数F *f1(int); //正确：显式地指定返回类型是指向F类型函数的指针 此外，还有一种奇技淫巧，可以用下面的形式声明f1： 12345int (*f1(int)) (int*, int);/*需要按照由内向外的顺序解读此代码：f1有形参列表，所以它是函数，f1前面有*，所以f1返回一个指针；进一步观察发现，指针的类型本身也包含形参列表，因此指针指向函数，该函数的返回值类型是int*/ Modern C++中，也可以用尾置返回类型的方式，声明一个返回函数指针的函数 1auto f1(int) -&gt; int(*)(int*, int); 8 常用关键字 四种cast（转换） const_cast 用于将const变量转化为非const。 static_cast 用于各种隐式转换，比如非const转const，void*转指针等，static_cast能用于多态向上转化，如果向下转，不管是否非法，都会直接转而无视潜在的问题，因此不安全。 dynamic_cast 用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果转化的是指针，且是非法的，返回NULL；如果转化的是引用，且是非法的，则抛出异常（相比于static_cast更安全）。 12345678910111213141516171819202122232425// 我是父类class Tfather&#123;public: virtual void f() &#123; cout &lt;&lt; &quot;father&#x27;s f()&quot; &lt;&lt; endl; &#125;&#125;;// 我是子类class Tson : public Tfather&#123;public: void f() &#123; cout &lt;&lt; &quot;son&#x27;s f()&quot; &lt;&lt; endl; &#125; int data; // 我是子类独有成员&#125;;Tfather father;Tson son;son.data = 123;Tfather* pf;Tson* ps;/* 上行转换：没有问题，多态有效 */ps = &amp;son;pf = dynamic_cast&lt;Tfather *&gt;(ps); reinterpret_cast 几乎什么都可以转，比如将int转为指针，可能会出问题，尽量少用。 📌为什么不使用C的强制转换？ C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。 隐式转换的四种方式： 1. 算术表达式 int m=10; double n=m; //n=10.0，隐式把m转为double类型 2. 赋值 int* p = NULL; //NULL(0)隐式转换为int*类型的空指针值 3. 函数入参 float add(float f); add(2); //2隐式转换为float类型 4. 函数返回值 double minus(int a, int b) { return a-b; } //返回值隐式转换为double类型 static作用 static作用在全局变量 加了static之后，变量只在当前文件有效 static作用在类成员变量 static成员变量可以实现多个对象之间的数据共享，静态数据成员只存储一处，供所有对象共用 static作用在全局函数 在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static 如果想要其他文件可以引用本地函数，则要在函数定义时使用关键字extern，表示该函数是外部函数，可供其他文件调用 static作用在类成员函数 由于static修饰的类成员属于类，不属于对象，因此static类成员函数是没有this指针的，正因为没有this指针，所以static类成员函数不能访问非static的类成员，只能访问 static修饰的类成员 📌phread_create参数必须是static的，因为非static会自动加一个this指针，导致传入参数和函数不匹配 📌C是否允许同时用const和static修饰一个成员函数呢？ 答案是不可以，C编译器在实现const的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数const this *。但当一个成员为static的时候，该函数是没有this指针的。也就是说此时const的用法和static是冲突的。 同理，virtual和static也不能一起用，virtual也有一个隐含参数this指针。 9 再看函数重载 函数重载取决于参数的类型、个数，而跟返回类型无关。编译器通过在编译时对函数重新命名以解决同名冲突。 对于普通函数： 123456void print(int i)&#123; cout &lt;&lt; &quot;Print an integer: &quot; &lt;&lt; i &lt;&lt;endl;&#125;void print(String s)&#123; cout &lt;&lt; &quot;Print a string: &quot; &lt;&lt; s &lt;&lt; endl;&#125; 执行objdump -d a.out &gt;log.txt反汇编，可以将编译结果打印到log.txt中进行分析。分析可知： void print(int i)→**_Z5printi** void print(String s)→**_Z5printSs** 其中Z5表示返回值类型，i表示int类型,Ss表示String类型（g++编译结果，vs的方案可能会有出入） 对于类内的函数重载： 123456789class test&#123;public: void print(int i)&#123; cout &lt;&lt; &quot;int&quot; &lt;&lt; endl; &#125; void print(char c)&#123; cout &lt;&lt; &quot;char&quot; &lt;&lt; endl; &#125;&#125;; 反汇编后，可知两个函数被映射为： void print(int i)→**_ZN4test5printEi** void print(char c)→**_ZN4test5printEc** N4test表示作用域。 由以上可知，g++对函数重载的映射机制为：作用域 + 返回类型 + 函数名 + 参数列表 虽然返回值类型也参与了函数重载的映射机制，但是编译器处理函数重载时并不考虑返回值类型，这样可使函数调用时独立于上下文，而且减少很多麻烦，如： 12345678910float sqrt(float);double sqrt(double);void f(double da, float fla)&#123; float fl = sqrt(da); // 调用sqrt(double) double d = sqrt(da); // 调用sqrt(double) fl = sqrt(fla); //调用sqrt(float) d = sqrt(fla); //调用sqrt(float)&#125; 函数重载时的匹配优先级 C++ Primer 6.6节 C++编译器力图找最佳匹配。为了确定最佳匹配，编译器将实参类型向形参类型的转换划分为几个等级，具体排序如下： 精确匹配，包括以下情况 实参类型和形参类型相同 实参从数组类型或函数类型转换为对应的指针类型 数组类型转指针：在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针 12int ia[0];int* ip = ia; 函数类型转指针：当把一个函数名传入函数时，编译器会隐式将其转换为函数指针类型 12345bool lengthCompare(const string&amp;, const string&amp;);void useBigger(const string&amp; s1, const string&amp; s2, bool (*pf)(const string&amp;, const string&amp;));useBigger(s1, s2, lengthCompare); 向实参添加顶层const或从实参删除顶层const 可以理解为，顶层const不影响参数，因此下面的两个函数，是相同的参数类型 123456void foo(int* const a)&#123; cout &lt;&lt; &quot;1&quot; &lt;&lt; endl;&#125;void foo(int* b)&#123; cout &lt;&lt; &quot;2&quot; &lt;&lt; endl;&#125; 当程序中有两个这样的函数，编译时会报错，因为发生了歧义，编译器不知道应该选择哪个函数。 通过const转换实现的匹配 特指底层const转换，一般是非const转换成const形参 通过类型提升实现的匹配 对于bool, char, signed char, unsigned char, short, unsigned short等类型，只要所有可能的值都能存在int里，它们就会被提升为int；否则，提升为unsigned int。 较大的char类型（wchar_t, char16_t, char32_t）提升成int, unsigned int, long, unsigned long, long long, unsigned long long中最小的一种类型，前提是转换后的类型能容纳原类型所有可能的值。 通过算术类型转换和指针转换实现的匹配 算术类型转换就是不同数值类型间的相互转换，如int,short,double之类，但不再局限于类型提升，double也可隐式转为int，也能匹配到。 指针转换： 常量整数值0或者字面值nullptr能转换成任意指针类型 指向任意非常量的指针能转换成void* 指向任意对象的指针能转换成const void* 继承关系：编译器会隐式地执行派生类到基类的转换 123456//Bulk_quote继承自QuoteQuote item;Bulk_quote bulk;Quote *p = &amp;item;p = &amp;bulk;Quote &amp;r = bulk; 算术类型/指针类型自动转换成bool类型 存在一种从算术类型或指针类型向布尔类型自动转换的机制。如果指针或算术类型的值为0，转换结果为false；否则转换结果是true。 123char* cp = get_string();if(cp) /*...*/ //如果指针cp不是0，条件为真while(*cp) /*...*/ //如果*cp不是空字符，条件为真 通过类类型转换实现的匹配：见“类”章。 类类型转换的一个例子就是，char*转换成string类型 考虑这样一个场景 123Employee* findEmployee(const std::string&amp; surname, const std::string&amp; givenName, bool retired=false);Employee* findEmployee(const std::string&amp; fullName, bool retired = false)Employee* e = findEmployee(&quot;Chen&quot;, &quot;Shuo&quot;); 一般可能认为，执行第3行时，会调用第1行对应的函数。实则不然，实际情况下会调用第2行对应的函数。这就涉及上面所说的优先级问题。&quot;chen&quot;这种字符串字面量，作为参数时，是const char*类型，两种重载都没有考虑const char*，因此需要进行隐式转换。从const char*转换为string，是一个类类型转换，而从const char*转换为bool，是一个指针类型转换，后者优先级高于前者，因此会调用第2行对应的函数重载。 引入模板的重载 12345678910template&lt;typename T&gt;void foo(T a)&#123; cout &lt;&lt; 3 &lt;&lt; endl;&#125;void foo(int a)&#123; cout &lt;&lt; 1 &lt;&lt; endl;&#125;int main()&#123; foo(1.0);&#125; 最后会输出3，也就是使用了有模板的foo函数重载。因为编译器力图精确匹配，而T可以被推断为double/float类型，比int更精确，所以会使用有模板的foo函数重载。 面向对象 10 类 C++中的类可大致分为三种：具体类、抽象类和类层次漫游中的类。大部分类可归为这三种之一，或某种的简单变形，或某几种的组合。 具体类： 具体类可以有与内置类型相似的行为，同时为了提高灵活性，还可以把成员变量的主体部分放在自由存储中（动态内存、堆）。一个经典的用户自定义类型是complex： 1234567891011121314151617181920212223242526272829303132class complex&#123; double re,im;public: complex(double r, double i): re&#123;r&#125;, im&#123;i&#125;&#123;&#125; complex(double r): re&#123;r&#125;, im&#123;0&#125;&#123;&#125; complex(): re&#123;0&#125;, im&#123;0&#125;&#123;&#125; double real() const &#123;return re;&#125; void real(double d) &#123;re = d;&#125; double imag() const &#123;return im;&#125; //const 常量函数，函数不会改变所调用的对象 void imag(double d) &#123;im = d;&#125; complex&amp; operator+=(complex z)&#123;re+=z.re, im+=z.im; return *this;&#125; complex&amp; operator-=(complex z)&#123;re-=z.re, im-=z.im; return *this;&#125; complex&amp; operator*=(complex);//在类外的某处进行定义 complex&amp; operator/=(complex);//在类外的某处进行定义&#125;;//很多函数并不需要访问complex的成员变量，因此其定义可以与类的定义分离开来complex operator+(complex a, complex b)&#123; return a += b; &#125;complex operator-(complex a, complex b)&#123; return a -= b; &#125;complex operator-(complex a)&#123; return &#123;-a.real(), -a.imag()&#125;; &#125;complex operator*(complex a, complex b)&#123; return a *= b; &#125;complex operator/(complex a, complex b)&#123; return a /= b; &#125;bool operator==()&#123; return a.real() == b.real() &amp;&amp; a.imag() == b.imag();&#125;bool operator!=()&#123; return !(a==b);&#125; complex必须足够高效，否则专门定义一个类没有意义，因此简单的操作必须设置成内联的。 📌定义在类里面的函数默认是内联的，也可以在声明前加上inline关键字显式指定。 当给自定义类型使用运算符重载时，应该尊重其常规使用习惯： 比如不能定义一元运算符/，因为其语法在语言中已固定； 也不能改变内置类型的运算符的含义，如不能重新定义+执行int的减法 数据句柄模型(handle-to-data model)： 构造函数负责为元素分配空间并正确初始化成员，析构函数负责释放空间。 这也是资源获取即初始化(Resource Acquisition Is Initialization, RAII) 技术，可以防止在普通代码中利用“裸new”和“裸delete”分配内存，而是将分配操作隐藏在行为良好的抽象的实现内部，规避资源泄露的潜在风险。 123456789101112131415class Vector&#123;private: double* elem; //elem指向含有sz个double型元素的数组 int sz;public: Vector(int s): elem&#123;new double[s]&#125;,sz&#123;s&#125; &#123; // 构造函数，获取资源 for (int i=0;i!=s;++i) elem[i] = 0; &#125; ~Vector()&#123;delete[] elem;&#125; // 析构函数，释放资源 double&amp; operator[](int i); int size() const;&#125; 上面的构造函数，先建立了一定数目的存储，然后给存储中的各个元素赋值，用户使用时再向其中填值。这不是很好的初始化方法。更简洁的途径是; 利用元素列表进行初始化： 先重载一个构造函数Vector(std::initializer_list&lt;double&gt;) 12345Vector::Vector(std::initializer_list&lt;double&gt; lst): elem&#123;new double[lst.size()]&#125;, sz&#123;static_cast&lt;int&gt;(lst.size())&#125;&#123; copy(lst.begin(), lst.end(), elem);&#125; std::initializer_list是一种标准库类型，使用{1,2,3,4}列表时，编译器会创建一个该类型的对象。 static_cast负责强制类型转换，旨在避免特别严重的错误。 因此此时可以采用初始值列表来做初始化：Vector v1 = &#123;1,2,3,4,5&#125;; push_back()：在序列的末尾添加一个元素，容器长度加1. 抽象类： 抽象类的作用更类似于提供一个接口，将使用者与类的实现细节完全隔离开来。如设计一个比Vector更抽象的Container类： 123456class Container&#123;public: virtual double&amp; operator[](int) = 0;//纯虚函数 virtual int size() const = 0; //常量成员函数 virtual ~Container()[] //析构函数&#125; 123456void use(Container&amp; c)&#123; const int sz = c.size(); for(int i=0;i!=sz;++i) cout&lt;&lt;c[i]&lt;&lt;&#x27;\\n&#x27;;&#125; virtual关键字声明虚函数（可能在派生类中被重新定义），=0表示虚函数是纯虚函数，即Container的派生类必须定义这个函数。抽象类中不需要自行定义构造函数，因为不需要初始化数据，而且析构函数也是虚函数。 📌抽象类应放弃包含局部成员。 多态模型：use()完全忽视Container的实现细节，而使用Container接口。这种为其他类型提供接口的类，一般称为多态模型(polymorphic type)。use函数可以使用所有派生自Container的有这样接口的派生类。 派生类： 1234567891011class Vector_container: public Container&#123; //:public表示继承关系 Vector v;public: Vector_container(int s): v(s) &#123;&#125; ~Vector_container() &#123;&#125; double&amp; operator[](int i) &#123; return v[i]; &#125; int size() const &#123; return v.size(); &#125;&#125;;Vector_container vc &#123;10,9,8&#125;;use(vc); //使用多态模型，可以直接使用所有派生类 需要注意：使用多态模型会带来灵活性，但是必须通过引用或指针操作对象！ 这里的~Vector_container()隐式调用了~Vector() 虚函数的编译器实现： 当使用Vector_container作为Container对象时，use将必须使用Vector_container的operator[]()，而其他派生类则会使用那些派生类实现的operator[]()。因此Container的对象必须包含一些信息，使得运行时能够选择正确的虚函数实现。 做法如上图，编译器将虚函数名字转换成虚函数表(virtual function table, vtbl)，每个含有虚函数的类都有自己的vtbl用于辨识虚函数，从而确保对象被正确使用。调用Container对象时只需要知道vtbl指针位置和各虚函数索引即可。 📌这种方式，会使虚函数的调用多一些开销，如每个类都需要一个vtbl，并且保留其指针。但是函数调用的效率还是非常接近“普通函数调用”的（相差不超过25%）。 派生类的构造函数： 考虑这样的基类和派生类： 12345678910111213141516171819class Quote&#123;public: Quote() = default; Quote(const std::string &amp;book, double sales_price): bookNo(book), price(sales_price) &#123; &#125;private: std::string bookNo;protected: double price = 0.0;&#125;;class Bulk_quote : public Quote&#123;public: Bulk_quote() = default; Bulk_quote(const std::string &amp;book, double p, std::size_t qty, double disc);private: std::size_t min_qty = 0; double discount = 0.0;&#125;; 派生类对象中含有从基类继承的成员，但是派生类并不能直接初始化这些成员。派生类必须使用基类的构造函数来初始化它的基类部分： 12Bulk_quote::Bulk_quote(const std::string&amp; book, double p, std::size_t qty, double disc) : Quote(book, p), min_qty(qty), discount(disc) &#123;&#125; 这是由C++实例化对象时的内存分配导致的，一个派生类对象包含多个组成部分：一个含有派生类自己定义成员（对应minqty和discount）的子对象，以及一个基类对应的子对象（子对象中包含）。如果有多个基类，那么这样的子对象也有多个。因此在利用构造函数实例化派生类的对象时，也必须调用基类的构造函数，实例化子对象。 类层次漫游： 类层次就是结构就是，一个子类继承一个基类，另一个子类继承相同的基类，一个子子类继承子类等等 12345678910class Shape&#123;public: virtual Point center() const = 0; virtual void move(Point to) = 0; virtual void draw() const = 0; virtual void rotate(int angle) = 0; virtual ~shape() &#123;&#125;&#125;; 123456789101112class Circle: public Shape&#123;public: Circle(Point p, int rr); Point center() const &#123;return x;&#125; void move(Point to) &#123; x=to; &#125; void draw() const; void rotate(int) &#123;&#125;private: Point x; int r;&#125;; 123456789101112131415161718192021222324252627282930class Smiley: public Circle &#123;public: Smiley(Point p, int r) : Circle&#123;p,r&#125;, mouth&#123;nullptr&#125; &#123;&#125; ~Smiley()&#123; delete mouth; for (auto p:eyes) delete p; &#125; void move(Point to); void draw() const; void rotate(int); void add_eye(Shape* s)&#123;eyes.push_back(s);&#125; void set_mouth(Shape* s); //......private: vector&lt;Shape*&gt; eyes; Shape* mouth;&#125;;void Smiley::draw()&#123; Circle::draw(); for(auto p:eyes) p-&gt;draw(); mouth-&gt;draw();&#125; Smiley继承了Circle，Circle继承了Shape 对于抽象类来说，其派生类的对象通常是通过抽象基类的接口操纵的，所以基类中必须有一个虚析构函数。 rotate_all可以调用任何Shape的派生类，如Smiley，这体现了接口继承的益处，即：派生类可以用在任何需要基类对象的地方。 Smiley可以使用Circle的构造函数和Circle::draw()，这体现了实现继承的益处，即：基类可以提供简化派生类实现的函数或数据。 1234void rotate_all(vector&lt;Shape*&gt;&amp; v, int angle)&#123; for (auto p:v) p-&gt;rotate(angle);&#125; - 当某个函数需要使用特定派生类的成员函数时，可以使用dynamic_cast运算符询问类型： 12345678Shape* ps(read_shape(cin)); //根据cin指定的类型生成特定派生类的Shapeif(Smiley* p = dynamic_cast&lt;Smiley*&gt;(ps)) &#123; //或者引用: if(Smiley&amp; p = dynamic_cast&lt;Smiley&amp;&gt;(*ps)) //...指针p所指的对象类型是Smiley&#125;else&#123; //...指针p所指的对象类型不是Smiley，执行其他操作...&#125; 当不能直接使用候选的派生类时，可以用引用替代，用于dynamic_cast 若dynamic_cast的参数(ps)与期望类型(Smiley)不符时，则会返回nullptr。 📌private、public、protected： - 访问范围的差异： private：只能由该类中的函数、其友元函数访问，不能被任何其他访问，该类的对象也不能访问； protected：可以被该类中的函数、子类的函数、以及其友元函数访问，但不能被该类的对象访问； public：可以被该类中的函数、子类的函数、其友元函数访问，也可以由该类的对象访问。 - 继承后的方法属性变化： 使用private继承，父类的所有方法在子类中变为private； 使用protected继承，父类的protected和public方法在子类中变为protected，private方法不变； 使用public继承，父类中的方法属性不发生改变。 123456789101112//关于子类访问父类的private成员：//×！编译器报错class Animal&#123;private: int x;public: virtual void set_x()&#123;x = 10;&#125;&#125;class Dog&#123; void set_x() override&#123;x = 10;&#125;&#125;; 123456789101112//关于子类访问父类的protected成员：//√！编译器不报错class Animal&#123;protected: int x;public: virtual void set_x()&#123;x = 10;&#125;&#125;class Dog&#123; void set_x() override&#123;x = 10;&#125;&#125;; 📌explicit关键字： 声明为explicit的构造函数不能在隐式转换中使用。 当类构造函数只有一个参数或除了第一个参数外其余参数都有默认值时，则此类有隐含的类型转换操作符（隐式转换），但有时隐式转换并不是我们想要的，可在构造函数前加上关键字explicit，来指定显式调用。 class Demo{ public: explicit Demo(double a); }; 由于构造函数使用了explicit关键字，因此调用它时无法进行隐式转换，即Demo test; test=12.2; 是无效的！ 然而，此时可以进行显式转换 Demo test; test = Demo(12.2); 或者 test = (Demo)12.2; override、final、default、delete override 有virtual就允许多态，即允许继承基类的子类重新virtual的方法。然而存在两种情况： 子类并不想重写基类的函数，只是碰巧写的新函数与基类中的某一个方法重名了； 子类想重写基类的函数，但是把函数名写错了，此时编译器将该函数判定为新函数，不会报错，但运行时可能会出很多问题。 针对以上场景，C++11引入了override关键字，以起到标记作用。override表示，此成员函数就是要重写基类的同名函数，而且函数签名一致。 1234567891011class A&#123;protected: virtual void func(int k, int d)&#123; &#125;&#125;;class B : A&#123;protected: void func(int k, int d)&#123; &#125;&#125;; 而以下两种情况会导致编译器报错：原函数不存在，以及重新函数的函数签名不一致。 123456//原函数不存在（函数名写错了） //函数签名不一致（返回值写错了） class B : A&#123; class B : A&#123;protected: protected: void funa(int k, int d)&#123; int func(int k, int d)&#123; &#125; &#125;&#125;; &#125;; final 有一种情况，类A继承了一个基类，但是类A不希望被其他类所继承。或者说类A重写了基类的虚函数，但当类A被继承时，不再希望这个虚函数被重写。 值得一提的是，没有final时虚函数会传递，只要基类有virtual，即使类A重写时对这个函数不加virtual，类B继承类A时也能重写该函数，该函数仍然是一个虚函数。 final修饰类：不能再被继承 123456class Base final&#123;&#125;;//此时不能再继承Base类，下述代码会编译期报错class Derive : Base&#123;&#125;; final修饰虚函数，虚函数不能再被重写（注：final只能修饰虚函数，不能修饰其他成员函数） 12345678910class Base&#123; virtual void func() final&#123; &#125;&#125;;class Derive : Base&#123; //此时不能再重写func方法，下述代码会编译期报错 void func()&#123; &#125;&#125;; =default 当手动写了一个有参数的构造/析构函数时，编译器会把默认的构造/析构函数优化掉，即不生成那些默认无参数的构造/析构函数。如果想要保留这些默认函数，使得编译器能够生成默认函数从而保留无参数时的行为，可以用=default 报错场景： 123456789class A&#123;public: A(int i)&#123;&#125;;&#125;;int main()&#123; A a; //可以编译通过，但是会运行时报错，因为已经没有无参数的构造函数了，A a这句又没传参数 return 0;&#125; 不报错场景： 12345678910class A&#123;public: A() = default; A(int i)&#123;&#125;;&#125;;int main()&#123; A a; //运行时不会出错，因为默认无参数的构造函数得到了保留 return 0;&#125; =delete =delete与=default的作用相反，它会禁用掉类中的某个成员函数。比如不想要默认的构造函数、析构函数、拷贝构造函数或operator=，可以用=delete禁用掉。 12345678class test&#123; private: test() = default; ~test() = default; public: test(const test&amp; a) = delete; test&amp; operator=(const test&amp; a) = delete;&#125;; 菱形继承与虚继承 菱形继承的情况如图所示，B和C都继承了A，也就都继承了cnt属性。而D同时继承了B和C，此时D的对象内部将会有两份cnt，存在二义性。此时若要让D的对象访问或修改cnt属性，会因二义性（编译器不知道应该使用哪个cnt）使得编译器报错。 D: - B: cnt - C: cnt 1234567891011121314151617181920212223242526class A&#123; //间接基类Aprotected: int cnt;&#125;;class B: public A&#123; //直接基类Bprotected: int cnt_b;&#125;;class C: public A&#123; //直接基类Cprotected: int cnt_c;&#125;;class D: public B, public C&#123; //派生类Dpublic: void set_a(int i)&#123; cnt = i; &#125; void set_b(int i)&#123; cnt_b = i; &#125; void set_c(int i)&#123; cnt_c = i; &#125; &#125;;int main()&#123; D d; d.set_a(3); //报错！&#125; 解决菱形继承的二义性问题，一种方式是直接使用::B或::C，强制编译器使用来自某个基类的属性。 12345678910111213141516171819202122class A&#123; //间接基类Apublic: int cnt;&#125;;class B: public A&#123; //直接基类Bpublic: int cnt_b;&#125;;class C: public A&#123; //直接基类Cpublic: int cnt_c;&#125;;class D: public B, public C&#123; //派生类D&#125;;int main()&#123; D d; d.B::cnt = 3; //强制指定使用哪个基类的cnt属性，规避二义性&#125; 当上面的方案不能根治菱形继承的问题，因为属性在类D中本就应该只有一个。更有效方案是利用虚继承。虚继承会使得派生类中只保留一份来自间接基类的属性，有效防止二义性问题。此时的间接基类A，被称为虚基类。 1234567891011121314151617181920212223242526class A&#123; //间接基类Aprotected: int cnt;&#125;;class B: virtual public A&#123; //虚继承，直接基类Bprotected: int cnt_b;&#125;;class C: virtual public A&#123; //虚继承，直接基类Cprotected: int cnt_c;&#125;;class D: public B, public C&#123; //派生类Dpublic: void set_a(int i)&#123; cnt = i; &#125; void set_b(int i)&#123; cnt_b = i; &#125; void set_c(int i)&#123; cnt_c = i; &#125; &#125;;int main()&#123; D d; d.set_a(3); //正确！&#125; 标准库中也有利用虚继承解决菱形继承问题的案例。如iostream类同时继承了istream类和ostream类，而istream和ostream都继承了base_ios类。此时istream和ostream必须虚继承base_ios，否则会导致iostream类中包含两份来自base_ios的属性，导致二义性。 RAII：资源获取即初始化 Resource Acquisition is Initialization RAII主要利用对象离开作用域会自动调用析构函数的特性，在设计一个类时，于构造函数申请资源，在析构函数释放资源，即可避免内存泄露问题，并将程序员从内存管理的泥潭中释放出来。 123456789101112class CTest&#123;public: CTest()&#123; m_pInt = new int; &#125; ~CTest()&#123; if( m_pInt != nullptr ) delete m_pInt; &#125;private: int* m_pInt;&#125;; 对象隐式销毁 考虑这样的函数，user()函数在退出前会delete掉所有的Shape，delete运算符依赖于Shape的析构函数，而该函数是虚函数，所以delete会调用最终的派生类的析构函数。 123456789void user()&#123; std::vector&lt;Shape*&gt; v; while(cin) v.push_back(read_shape(cin)); draw_all(v); rotate_all(v,45); for(auto p : v) //最后删除元素 delete p;&#125; 这是“显式”地销毁对象。然而若对所有函数都执行这样的显式操作的话，可能总有漏网之鱼。解决方案便是“隐式”对象销毁，让编译器自己来做delete操作。 对象若要隐式销毁，需要避免“裸指针”，而是尽量用智能指针unique_ptr，此时可以修改代码如下： 12345678enum class Kind &#123; Circle, triangle, smiley &#125;;unique_ptr&lt;Shape&gt; read_shape()&#123; //...从is中读取描述信息，找到对应形状种类 switch(k)&#123; case Kind::circle: return unique_ptr&lt;Shape&gt;&#123;new Circle&#123;p,r&#125;&#125;; //......&#125; 1234567void user()&#123; vector&lt;unique_ptr&lt;Shape&gt;&gt; v; while(cin) v.push_back(read_shape(cin)); draw_all(v); rotate_all(v,45);&#125; 对象由unique_ptr拥有，当对象离开作用域时，unique_ptr将释放掉所指的对象。 友元函数&amp;友元类 普通友元函数 突破类内成员访问权限的限制，使得外部的函数仍能访问到类内的私有成员。 12345678910111213class A&#123;public: A()&#123;&#125;; ~A()&#123;&#125;; friend void foo(); //声明foo函数是类A的好朋友private: int m_data;&#125;;void foo()&#123; A aObj; aObj.m_data = 1;&#125; 友元成员函数 令类B的成员函数有权限访问类A的私有成员。 1234567891011121314151617181920class B&#123;public: B()&#123;&#125;; ~B()&#123;&#125;; void foo();&#125;;class A&#123;public: A()&#123;&#125;; ~A()&#123;&#125;; friend void B::foo(); //声明类B的foo成员函数是类A的好朋友private: int m_data;&#125;;void B::foo()&#123; A aObj; aObj.m_data = 1;&#125; 友元类 若类B是类A的友元类，那么类B的所有成员函数均能访问到类A的私有成员。 1234567891011121314151617181920class B&#123;public: B()&#123;&#125;; ~B()&#123;&#125;; void foo();&#125;;class A&#123;public: A()&#123;&#125;; ~A()&#123;&#125;; friend B; //声明类B是类A的好朋友private: int m_data;&#125;;void B::foo()&#123; A aObj; aObj.m_data = 1;&#125; 运算符重载 可以重载的运算符： + - * / % ^ &amp; | ~ ! = &lt; &gt; += -= *= /= %= ^= &amp;= |= &lt;&lt; &gt;&gt; &lt;&lt;= &gt;&gt;= == != &lt;= &gt;= &amp;&amp; || ++ – [] () -&gt; , new new[] delete delete[] 一元运算符重载：++、–、-（负号）、! 一元运算符往往不需要传形参，传形参说明是后缀++或后缀– 123456789101112131415161718192021222324252627282930class Complex &#123;private: double i; double j;public: Complex(int = 0, int = 0); void display(); Complex operator ++();//前缀自增 Complex operator ++(int);//后缀自增，参数需要加int&#125;;Complex::Complex(int a, int b) &#123; i = a; j = b;&#125;void Complex::display() &#123; cout &lt;&lt; i &lt;&lt; &#x27;+&#x27; &lt;&lt; j &lt;&lt; &#x27;i&#x27; &lt;&lt; endl;&#125;Complex Complex::operator ++() &#123; ++i; ++j; return *this;&#125;Complex Complex::operator ++(int) &#123; Complex temp =*this; ++*this; return temp;&#125; 二元运算符重载：+、-、 *、/ this是左值，形参是右值。 12345678910111213141516171819202122class test_minus&#123;private: int val1, val2;public: test_minus(int a, int b): val1(a), val2(b) &#123;&#125; test_minus operator-(const test_minus&amp; right)&#123; return test_minus(right.val1 - val1, right.val2 - val2); &#125; void Print()&#123; cout &lt;&lt; val1 &lt;&lt; &#x27; &#x27; &lt;&lt; val2 &lt;&lt; endl; &#125;&#125;;int main()&#123; test_minus a(1, 3); test_minus b(2, 0); test_minus c = a - b; c.Print(); //输出 1 -3 return 0;&#125; 还可以友元函数的方式重载： 123456789101112131415161718192021222324class test_minus&#123;private: int val1, val2;public: test_minus(int a, int b): val1(a), val2(b) &#123;&#125; friend test_minus operator- (const test_minus&amp;, const test_minus&amp;); //友元函数 void Print()&#123; cout &lt;&lt; val1 &lt;&lt; &#x27; &#x27; &lt;&lt; val2 &lt;&lt; endl; &#125;&#125;;test_minus operator-(const test_minus&amp; left, const test_minus&amp; right)&#123;//友元函数运算符重载 return test_minus(right.val1 - left.val1, right.val2 - left.val2);&#125;int main()&#123; test_minus a(1,3); test_minus b(2,0); test_minus c = a-b; c.Print(); return 0;&#125; 关系运算符重载：&lt;、&gt;、&lt;=、&gt;=、==、!= 和二元运算符一样，this是左值，形参是右值。可以在形参加上const以规避修改 1234567891011121314class Distance&#123;private: int feet; int inches;public: bool operator &lt;(const Distance&amp; d) &#123; if(feet &lt; d.feet) return true; if(feet == d.feet &amp;&amp; inches &lt; d.inches) return true; return false; &#125;&#125;; 流运算符重载：&lt;&lt;、&gt;&gt; 见“I/O流”章，需要注意区分一元运算符中的左移右移。 赋值运算符重载：= 123456789101112class Distance&#123; private: int feet; // 0 到无穷 int inches; // 0 到 12 public: void operator=(const Distance &amp;D ) &#123; feet = D.feet; inches = D.inches; &#125;&#125;; 函数调用运算符重载：() 12345678910111213141516171819202122232425262728class Distance&#123; private: int feet; // 0 到无穷 int inches; // 0 到 12 public: Distance(int f, int i)&#123; feet = f; inches = i; &#125; // 重载函数调用运算符 Distance operator()(int a, int b, int c) &#123; Distance D; // 进行随机计算 D.feet = a + c + 10; D.inches = b + c + 100 ; return D; &#125;&#125;;int main()&#123; Distance D1(11, 10), D2; D2 = D1(10, 10, 10); // invoke operator() return 0;&#125; 下标运算符重载：[] 123456789101112131415161718192021222324252627282930313233343536const int SIZE = 10;class safearay&#123; private: int arr[SIZE]; public: safearay() &#123; register int i; for(i = 0; i &lt; SIZE; i++) &#123; arr[i] = i; &#125; &#125; int&amp; operator[](int i) &#123; if( i &gt;= SIZE ) &#123; cout &lt;&lt; &quot;索引超过最大值&quot; &lt;&lt;endl; // 返回第一个元素 return arr[0]; &#125; return arr[i]; &#125;&#125;;int main()&#123; safearay A; cout &lt;&lt; &quot;A[2] 的值为 : &quot; &lt;&lt; A[2] &lt;&lt;endl; cout &lt;&lt; &quot;A[5] 的值为 : &quot; &lt;&lt; A[5]&lt;&lt;endl; cout &lt;&lt; &quot;A[12] 的值为 : &quot; &lt;&lt; A[12]&lt;&lt;endl; return 0;&#125; 📌C++的register关键字作用是，建议编译器使用CPU寄存器来存储变量，旨在提高访问变量的速度 类成员访问运算符重载：-&gt; 和 解引用运算符：* 成员访问-&gt;和解引用*的重载都只能由对象使用，而不能由指针使用，因此，出现pointer-&gt;mem;时，可能有两种情况： 指针，原原本本的成员访问和解引用功能：mem就是指针指向的对象，所属类型的成员 12pointer-&gt;mem;//等价于 (*pointer).mem; 对象，调用的重载的运算符：mem不一定是pointer所属类型的成员，可能是其它类型的 12pointer.operator()-&gt;mem;//等价于 (pointer.operator*()).mem; 重载时，一般要求解引用*重载，返回引用，要求成员访问-&gt;重载，返回指针。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class test_arrow_1&#123;public: int val1, val2; test_arrow_1(int a, int b) : val1(a), val2(b) &#123;&#125; void Print1()&#123; cout &lt;&lt; val1 &lt;&lt; &#x27; &#x27; &lt;&lt; val2 &lt;&lt; endl; &#125;&#125;;class test_arrow_2&#123;private: int val3, val4, val5;public: test_arrow_1* val6; test_arrow_2(int a, int b, int c, int d, int e) : val6(new test_arrow_1(a,b)), val3(c), val4(d), val5(e) &#123;&#125; void Print2()&#123; cout &lt;&lt; val6-&gt;val1 &lt;&lt; &#x27; &#x27; &lt;&lt; val6-&gt;val2 &lt;&lt; &#x27; &#x27; &lt;&lt; val3 &lt;&lt; &#x27; &#x27; &lt;&lt; val4 &lt;&lt; &#x27; &#x27; &lt;&lt; val5 &lt;&lt; endl; &#125; test_arrow_1&amp; operator*() const&#123; return (*val6); &#125; test_arrow_1* operator-&gt;() const&#123; return val6; &#125;&#125;;int main()&#123; test_arrow_2 t1(1,2,3,4,5); t1-&gt;val1 = 6; t1-&gt;Print1(); t1.Print2(); (*t1).val2 = 7; t1.Print2(); test_arrow_2* t2 = new test_arrow_2(6,7,8,9,10); t2-&gt;Print2(); (*t2).Print2(); return 0;&#125; 对象调用 1234567891011int main()&#123; test_arrow_2 t1(1,2,3,4,5); t1-&gt;val1 = 6; t1-&gt;Print1(); t1.Print2(); (*t1).val2 = 7; t1.Print2(); return 0;&#125; t1是重载了*和-&gt;的对象，而不是指针，因此，当t1调用*t1和t1-&gt;时，会使用重载的运算符函数。 因此t1-&gt;可以使用属于test_arrow_1类的属性和方法， (*t1)也可以使用属于改类的属性和方法。而“点运算符”仍然只能使用test_arrow_2类的。 指针调用 123test_arrow_2* t2 = &amp;t1;t2-&gt;Print2();(*t2).Print2(); t2是指针，因此调用*和-&gt;时，不能再调用重载的运算符函数，而是和平时的操作无异。因此t2-&gt;只能使用test_arrow_2的属性和方法，而且(*t2)也只能使用test_arrow_2的。 值得注意的是，解引用运算符 *，可以自定义任何逻辑，上面的代码中，也可以让解引用的重载返回一个int常数。 但是成员访问运算符无论怎么改，都必须保留成员访问的功能，虽然可能不再是当前类的成员了。 📌取地址符&amp;也可以重载，但一般不需要手动重载，类会默认生成&amp;和&amp; const 类类型转换（特殊运算符重载） 类型转换运算符，负责将一个类的类型转换成其他类型：operator type() const;，由于其通常不应该改变待转换对象的内容，因此，一般被定义为const成员。 12345678910class SmallInt&#123;public: SmallInt(int i = 0):val(i)&#123; if(i &lt; 0 || i &gt; 255) throw std::out_of_range(&quot;Bad SmallInt value&quot;); &#125; operator int() const &#123;&#125;; //类型转换运算符private: std::size_t val;&#125;; 这里SmallInt类中定义了向int类型的转换符，因此，可以显式/隐式的将SmallInt对象转换成int类型： 123SmallInt si;si = 4; // 首先将4隐式转换成SmallInt，然后调用SmallInt operator=si + 3; // 首先将si隐式转换成int，然后执行整数的加法 除此之外，如果转换后的类型又有其它内置转换方案，实际情况中，也可以出现转换传递的情况。比如 12SmallInt si = 3.14; // 调用SmallInt(int)构造函数si + 3.14; // SmallInt类型转换成int，int又继续隐式转换成double 📌一个类型转换函数必须是类的成员函数。 不能声明返回类型！（其名字就已说明返回） **形参列表必须为空！**通常应该为const！ 12345678class SmallInt;operator int(SmallInt&amp;); //错,不是成员函数class SmallInt&#123;public: int operator int() const; //错,有返回类型 operator int(int=0) const; //错,有形参 operator int*() const &#123;return 42;&#125;//错,42不是一个指针&#125;; 老版本C++，类型转换运算符的不足： 早期版本C++中，类中定义一个向bool转换的类型转换运算符，是比较普遍的。比如经常用的while(cin&gt;&gt;i)就是cin中内置了一个operator bool( )。然而，这样会有意想不到的效果，比如下面的语句： 12int i = 42;cin &lt;&lt; i; 流运算符&lt;&lt;是cout特有的，istream本身没有定义&lt;&lt;，所以这段代码本应报错。然而，istream内置了bool类型转换，由此将cin转换成了bool，接着bool会被提升为int，后面的&lt;&lt;成为了左移运算符。因此，这段代码不会报错，还会出现与预期大相径庭的结果。 C++11带来的解决方案：显式的类型转换运算符 为了防止上面现象的发生，C++引入了解决方案：explicit operator type()，即通过explicit关键字，要求显式转换 比如下面代码： 123456789101112class SmallInt&#123;public: SmallInt(int i = 0):val(i)&#123; if(i &lt; 0 || i &gt; 255) throw std::out_of_range(&quot;Bad SmallInt value&quot;); &#125; explicit operator int() const &#123; return val; &#125;&#125;;SmallInt si = 3; //正确：SmallInt的构造函数不是显式的si + 3; //错误：此处需要隐式的类型转换，但类的运算符不是显式的static_cast&lt;int&gt;(si)+3; //正确：显式地请求类型转换 这种规定还是有例外的，标准规定：如果表达式被用作了条件，则编译器会自动（即“隐式”）进行显式类型转换， 因此istream内部的bool()成为explicit的了，但是while(cin&gt;&gt;i)依然能用，因为是条件，会自动转成bool类型。 成为条件的几个位置： if, while, do…while, for 逻辑运算符!, ||, &amp;&amp; 条件运算符? : 类类型转换带来的二义性：（这里的类型转换不再局限于类型转换运算符，还包括构造函数） 有几种情况可能会带来二义性，出现二义性之后会编译报错，因为编译器不知道该使用哪种实现方式。 两个类提供了“互相指向”的类型转换： 123456789101112struct B;struct A &#123; A() = default; A(const B&amp;); //把一个B转换为A&#125;;struct B &#123; operator A() const; //把一个A转换为B&#125;;A f(const A&amp;); //定义一个接收A的函数B b;A a = f(b); //二义性错误：含义是 调用B中转换为A的类型转换运算符 f(b.operator A()) // 还是调用A中可以把B类型转换为A的构造函数 f(A(b)) 如果想执行上面的调用，必须显式地调用类型转换运算符或转换构造函数： 12A a1 = f(b.operator A()); //正确：使用B的类型转换运算符A a2 = f(A(b)); //正确：使用A的构造函数 类定义了多个转换规则： 最困扰的情况是类中定义了多个参数都是算术类型的构造函数，或者转换目标都是算术类型的类型转换运算符 1234567891011121314struct A&#123; A(int = 0); A(double = 0); operator int() const; operator double() const;&#125;;void f2(long double);A a;f2(a); //二义性错误，不知道是 f(a.operator int()) 还是 f(a.operator double())long lg;A a2(lg); //二义性错误，不知道是 A::A(int) 还是 A::A(double) f2的调用中，哪个类型转换都无法精确匹配long double，然而却都存在向long double的隐式转换（而且转换级别还一致）。因此出现了二义性。 📌C++ primer中建议， 最好不要创建两个转换源都是算术类型的类型转换！ 最好不要创建两个转换对象都是算术类型的类型转换！ 如果这种情况中，转换级别不一致，就不存在二义性问题。比如从short提升到int，级别高于long到double。 函数重载过程中，不同重载的形参，都定义了同一种类型转换运算符： 123456789struct C&#123; C(int);&#125;;struct D&#123; D(int);&#125;;void manip(const C&amp;);void manip(const D&amp;);manip(10); //二义性错误：含义是 manip(C(10)) 还是 manip(D(10)) 可以显式调用构造函数，以消除二义性： 1manip(C(10)); 但这种情况并没有结束，10可以精确匹配int，那么下面的代码是否就没有二义性了呢？ 123456789struct C&#123; C(int);&#125;;struct E&#123; E(double);&#125;;void manip(const C&amp;);void manip(const E&amp;);manip(10); //二义性错误：含义是 manip(C(10)) 还是 manip(E(double(10))) 还是会编译报错，还是会有二义性，这是因为在调用重载时，类类型转换都是最低级别的匹配度。即使int比double更能匹配10，但是现在不是int和double的比较，而是C(10)：int→C，和E(double(10))：int→E的比较，而二者是平级的。而且二者都是可行匹配。因此导致了二义性。 虽然，类型转换运算符可以在某些程度上简化操作，但还是要慎用，非常容易出现二义性问题！ new/delete的重载 new operator/delete operator就是new和delete操作符，而operator new/operator delete是函数。 placement new是operator new的全局重载。 new运算分两阶段：（1）调用::operator new配置内存；（2）调用对象构造函数构造对象内容。 delete运算分为两个阶段：（1）调用对象析构函数；（2）调用::operator delete释放内存。 operator new函数 默认的::operator new与malloc无明显区别。只分配所要求的空间，不调用相关对象的构造函数。当无法满足所要求分配的空间时，则： →如果有new_handler，则调用其，否则 →如果允许抛出异常（即nothrow参数未被设置），则执行bad_alloc异常，否则 →返回0 需要注意的是，::operator new是可以被重载的，也就是说可以自定义operator new的行为 operator new重载 重载时，返回类型必须声明为void* 重载时，第一个参数类型必须为表达要求分配空间的大小（字节），类型为size_t 重载时，可以带其它参数 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class X&#123;public: X() &#123; cout&lt;&lt;&quot;constructor of X&quot;&lt;&lt;endl; &#125; ~X() &#123; cout&lt;&lt;&quot;destructor of X&quot;&lt;&lt;endl;&#125; void* operator new(size_t size,string str) //重载::operator new &#123; cout&lt;&lt;&quot;operator new size &quot;&lt;&lt;size&lt;&lt;&quot; with string &quot;&lt;&lt;str&lt;&lt;endl; return ::operator new(size); &#125; void operator delete(void* pointee) //重载::operator delete &#123; cout&lt;&lt;&quot;operator delete&quot;&lt;&lt;endl; ::operator delete(pointee); &#125;private: int num;&#125;;int main()&#123; X *px = new(&quot;A new class&quot;) X; delete px; return 0;&#125; 缺省的operator new具有非常好的通用性，这也使得其在某些场合下牺牲了性能。针对性优化的operator new可以提升效率。 placement new函数 前面重载的operator new只能作为类内函数，无法全局使用。而placement new是一种全局的重载的operator new。 placement new的使用： operator new会分配内存，但是placement new不分配。相反地，placement new的参数就是一个预先分配好的内存，而placement new会在其上构造对象。（placement new不接收size_t类型参数，即不接收待分配内存大小参数），函数返回值是对象的地址。 12string* sp=static_cast&lt;string*&gt;(::operator new(sizeof(string)));mystr = new (sp) string(&quot;hello world&quot;); //使用placement new构造对象 placement new的使用步骤： 内存提前分配 调用placement new构造对象 使用对象mystr 析构对象mystr→~string(); 释放内存：内存sp可以被反复使用，反复通过placement new分配给新的对象，但若不想使用该内存，可以用delete [] buf;释放它。 为什么要有placement new： 确实有要在预分配内存上创建对象的需求。比如硬件中有一个内存映射的IO计时器设备，想建立一个clock对象在那个内存位置，但用。 增大时空效率。使用new操作符需要在堆中查找足够大的剩余空间，这个操作速度较慢，而且可能出现无法分配内存的异常（空间不够）。placement new可以解决，预先分配好的内存确保不会出现内存不足的异常，同时也省下了查找可用内存的时间。 📌申请内存和释放内存的操作符需要配套使用，比如new和delete一起用，new[]和delete[]一起用。 int* ptr = new int[10]; delete [] ptr; 拷贝和移动 拷贝构造：定义拷贝构造函数和拷贝赋值运算符 📌对于大容量的容器来说，拷贝过程可能耗费巨大。举例来说， 而事实上，我们并不真的想要一个副本，而是想将计算结果从函数中取出来，相比于拷贝，更希望的操作的移动。 1234567891011121314151617/******* 声明一个Vector类 *******/class Vector &#123;private: double* elem; int sz;public: Vector(int s); //构造函数：建议不变式，获取资源 ~Vector() &#123; delete[] elem; &#125; //析构函数：释放资源 Vector(const Vector&amp; a); //拷贝构造函数 Vector&amp; operator=(const Vector&amp; a); //拷贝赋值运算符 double&amp; operator[](int i); const double&amp; operator[](int i) const; int size() const;&#125;; 12345678/****拷贝构造函数****/Vector::Vector(const Vector&amp; a) :elem&#123;new double[a.sz]&#125;, //为元素分配空间 sz&#123;a.sz&#125;&#123; for(int i = 0; i != sz; ++i) //复制元素 elem[i] = a.elem[i];&#125; 这里是深拷贝。拷贝构造函数的输入参数是被拷贝的对象，也就是a = b中右面的b。 1234567891011/****拷贝赋值运算符****/Vector&amp; Vector::operator=(const Vector&amp; a)&#123; double* p = new double[a.sz]; for(int i = 0; i != a.sz; ++i) p[i]=a.elem[i]; delete[] elem; //删除旧元素 elem = p; sz = a.sz; return *this;&#125; 深拷贝与浅拷贝： 如果类中的属性均为基本类型变量，全部在栈上分配，不涉及深/浅拷贝问题。深拷贝与浅拷贝仅在，类中存在需要在堆上分配内存的属性时，才需要加以区分。考虑上面的Vector类： 12345678//拷贝构造函数：深拷贝Vector::Vector(const Vector&amp; a) :elem&#123;new double[a.sz]&#125;, //为元素分配空间 sz&#123;a.sz&#125;&#123; for(int i = 0; i != sz; ++i) //复制元素 elem[i] = a.elem[i];&#125; 12345//拷贝构造函数：浅拷贝Vector::Vector(const Vector&amp; a) :elem&#123;a.elem&#125;, //不分配空间，直接赋值 sz&#123;a.sz&#125;&#123; &#125; 也就是构造的Vector对象的elem指针，直接指向=右边的Vector对象的elem数组。 可以看出，深拷贝会重新开辟一片内存，并且对内存中的值逐个拷贝。而浅拷贝的话，不会开辟内存，对象的指针直接等于右值对象内的指针。换言之，深拷贝过程中，左值的堆内存和右值的堆内存是两片内存，而浅拷贝的话共同使用一片内存。 C++的默认拷贝构造函数=default采用的是浅拷贝方式。 但是，一般遇到有属性需要从堆内存分配时，应该自己手写深拷贝方式的拷贝构造函数。浅拷贝涉及这样多次析构的问题，考虑上面的Vector类，如果采用了浅拷贝的拷贝构造函数，禁用operator=，main函数进行最基本的赋值操作时： 12345int main()&#123; Vector lv(3); Vector rv = lv; return 0;&#125; 这时程序会在运行时崩溃，崩溃在析构函数上。在执行return 0之前，作用域内有两个Vector变量：lv和rv，二者的elem指向了同一片内存elem。然而，执行return 0，离开作用域时，会调用两个变量的析构函数。假设先调用了lv的析构函数，那么lv的elem会在析构时释放内存，此时的elem成为了野指针。而在调用rv的析构函数时，还会delete [] elem，此时要delete一个野指针，就会导致程序崩溃。 由此可见，对象中涉及堆时，应该尽量手写深拷贝形式的拷贝构造函数。 📌在C++标准中，NULL和nullptr都被认为是0，尤其nullptr指向的是0x0地址，可以重复delete。 因此，当一个对象被delete了，指针未归为nullptr，再调用该指针时会因野指针而使得程序崩溃。但如果delete后归为nullptr，再delete并不会出现问题。 右值引用： 通常写的引用int a=0; int &amp;b=a;，b是一个左值引用，它引用了一个左值a，但它不能引用右值，即int &amp;b=0;会报错。C++11之前，强行通过左值引用，引用一个右值的方式，只有一个，那就是常引用const int&amp;b=0;，但是如此并不能修改右值的值。 前面提到，浅拷贝比深拷贝效率更高（不用开辟新空间），但是存在重复析构的问题，那么是否可以通过下面的代码解决析构野指针的问题呢？ 1234demo(demo &amp;d):num(d.num)&#123; //拷贝构造函数，入参去掉const，让d可修改 d.num = nullptr; //修改原对象对应指针为空指针 cout&lt;&lt;&quot;copy construct!&quot;&lt;&lt;endl;&#125; 是不可以的，运行会报错。因为num=d.num表示d.num是右值，右值不可修改，但d.num=nullptr又让其成为可修改的左值，发生了冲突。 解决这个问题的方法，就是希望函数参数d是一个右值引用，右值引用的特定在于，既反映右值，又可以修改右值。 C定义了T&amp;&amp; param这样语法，表示param是一个右值引用，其可以引用一个右值，那么int &amp;&amp;b=0;就可行了，而且可以通过b来修改右值。与此同时，C11引入了std::move()函数，作用在于，不管输入的是左值还是右值，move出来的都是右值。 然而这样的语法，也不一定能保证引用到的必然是右值，以一个函数传参的例子进行说明： 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;void fun(int&amp; lvalue) // 接收左值&#123; std::cout &lt;&lt; &quot;lvalue = &quot; &lt;&lt; lvalue &lt;&lt; std::endl; &#125;void fun(int&amp;&amp; rvalue) // 接收右值&#123; std::cout &lt;&lt; &quot;rvalue = &quot; &lt;&lt; rvalue &lt;&lt; std::endl; &#125;template&lt;typename T&gt;void function(T&amp;&amp; param) // 不能确保是右值引用，但是是万能引用&#123; fun(param);&#125;int main()&#123; int x = 10; function(x); // 左值 function(std::move(x)); // 右值&#125; 首先看function函数，其明明标明入参应该是右值引用，为何还能通过function(x)传一个左值引用进去呢？ 这是引用折叠的原因导致的： 虽然是T&amp;&amp; param，但若传进去一个int&amp;，实际相当于传入的类型为int&amp; &amp;&amp;，等价于int&amp;，即左值引用。《Effective Modern C++》的作者将这种，由引用折叠导致的，既可以表示右值引用，又可以表示左值引用的语法称为万能引用。 引用折叠的规则： first second result &amp; &amp; 左值引用 &amp; &amp;&amp; 左值引用 &amp;&amp; &amp; 左值引用 &amp;&amp; &amp;&amp; 右值引用 即，只有两个引用均为右值引用时，才会折叠成右值引用。 万能引用的规律： 1234567891011121314Widget&amp;&amp; var1 = Widget(); // rvalue referenceauto&amp;&amp; var2 = var1; // universal referencetemplate&lt;typename T&gt;void f(std::vector&lt;T&gt;&amp;&amp; param); // rvalue referencetemplate&lt;typename T&gt;void f(T&amp;&amp; param); // universal referencetemplate&lt;typename T&gt;class vector &#123; void push_back(T&amp;&amp; x); // rvalue reference&#125; 如果T不是模板参数，而是具体的类型，如上面的第一个例子Widget，T&amp;&amp;一定是右值引用。 如果T是模板参数，T&amp;&amp;一般情况下是通用引用。除了下面两种例外情况： 如果T是模板参数，但param的类型不直接是T，比如std::vector&lt;T&gt;&amp;&amp;，那么std::vector&lt;T&gt;&amp;&amp;是右值引用。 如果T是模板参数，但不需要自动推导，比如已经在类实例化的时候手动指定过了，那么T&amp;&amp;是右值引用。 但是，如果执行上面的代码，会发现输出结果为： 12lvalue = 10lvalue = 10 也就是，左值和右值都被判定为左值。这是因为右值引用接收的值既可以是左值，也可以是右值，存在这样一个对应关系： 左值引用 右值引用 非引用 什么时候是左值 always 显式声明为变量时 显式声明为变量时 什么时候是右值 never 作为临时变量时 作为临时变量时 虽然move函数强行使得第二个function函数传入右值，但是，function函数内部调用fun函数时，涉及传参，又把param显式化了。这样就使得param变为一个左值。 那么如何保留右值的特点，使得调用fun函数也传入右值呢，C++11同时提供了完美转发std::forward特性。 std::forward的返回值既可能是左值，也可能是右值，当传入参数是右值引用时，返回右值，否则就返回左值。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;// 接收左值void fun(int&amp; lvalue)&#123; std::cout &lt;&lt; &quot;lvalue = &quot; &lt;&lt; lvalue &lt;&lt; std::endl; &#125;// 接收右值void fun(int&amp;&amp; rvalue)&#123; std::cout &lt;&lt; &quot;rvalue = &quot; &lt;&lt; rvalue &lt;&lt; std::endl; &#125;// 万能引用template&lt;typename T&gt;void function(T&amp;&amp; param)&#123; //fun(param); fun(std::forward&lt;T&gt;(param)); // 使用std::forward进行完美转发&#125;int main()&#123; int x = 10; function(x); // 左值 function(std::move(x)); // 右值&#125; 再执行通过完美转发改进的程序，可以得到这样的输出结果： 12lvalue = 10rvalue = 10 也就是，左值是左值的行为，右值是右值的行为，不再混乱，泾渭分明。 事实上，使用std::forward处理万能引用，也是官方推荐的开发方式！ 合理运用右值引用，达到提速效果的案例： 在做矩阵加法时，可以这样写，即入参是两个左值引用以避免拷贝 1234Matrix operator+(const Matrix&amp; lhs, const Matrix&amp; rhs) &#123; Matrix sum = ... // Sum all elements in lhs and rhs here. return sum;&#125; 但是这么做美中不足的地方在于，需要创建一个额外的Matrix对象。如果说，lhs和rhs有一个操作数可以是右值，也就是算完之后调用者不会再使用它，那便可以复用它的内存空间，不必创建新的Matrix对象，达到提高效率的目的。假设这个右值是lhs，那么便可以设置它为右值引用。 1234Matrix operator+(Matrix&amp;&amp; lhs, const Matrix&amp; rhs) &#123; lhs = ... // Sum all elements in lhs and rhs and assign to lhs. return std::move(lhs);&#125; 这里要用std::move返回值，避免让lhs成为显式变量，成为左值（成为左值的话，会返回对象的拷贝构造）。此时的返回值变成了右值引用，编译器自动为右值调用移动构造函数。 那么进行矩阵加法便可以： 12Matrix sum1 = m1 + m2; // 调用第一种实现Matrix sum3 = std::move(m1) + m2; // 调用第二种实现 一般不建议函数返回右值引用！ C++中的左右值： - lvalue：通常可以放在等号左边的表达式，左值 - rvalue：通常只能放在等号右边的表达式，右值 - glvalue：generalized lvalue，广义左值 - xvalue：expiring lvalue，将亡值，也就是std::move(ptr1)的值 - prvalue：pure rvalue，纯右值 对于包含右值的内存位置来说，其本质就是：它虽然没有名称，但是可以从程序的其他部分访问到它。 而右值引用便可以用来表示这个本应没有名称的临时对象。 C++11之后编译器开始支持RVO(Return Value Optimization)技术，RVO可以把函数返回时创建的临时对象优化掉，达到少调用拷贝构造函数的目标。如果函数返回一个仅在函数内的局部变量，而且变量类型支持移动构造函数，比如： std::vector&lt;int&gt; return_vector(void){ std::vector&lt;int&gt; tmp {1,2,3,4,5}; return tmp; } std::vector&lt;int&gt; rval_ref = return_vector(); 那么编译器发现tmp是局部变量，离开return_vector函数后就会死亡时，会把tmp当做将亡值（xvalue），编译器会为将亡值调用移动构造函数。 移动构造： 虽然深拷贝很稳定，使得出错的风险降低，但是带来了效率的牺牲。考虑下面的深拷贝构造函数代码： 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;class demo&#123;public: demo():num(new int(0))&#123; cout&lt;&lt;&quot;construct!&quot;&lt;&lt;endl; &#125; demo(const demo &amp;d):num(new int(*(d.num)))&#123; //拷贝构造函数 cout&lt;&lt;&quot;copy construct!&quot;&lt;&lt;endl; &#125; ~demo()&#123; delete num; cout&lt;&lt;&quot;class destruct!&quot;&lt;&lt;endl; &#125;private: int *num;&#125;;demo get_demo()&#123; return demo();&#125;int main()&#123; demo a = get_demo(); return 0;&#125; 使用g++ demo.cpp -o demo.exe -std=c++0x -fno-elide-constructors命令禁用优化，看最原始情况的输出，有： 首先在get_demo里调用了构造函数 离开get_demo时，return语句对函数内创建的对象进行拷贝，从而提供返回值 执行完return后，离开作用域，之前函数内创建的对象销毁，但是拷贝的作为返回值来到了main 返回值被=赋给了a，执行了拷贝构造（深拷贝，此时有两个demo对象） return 0之后，离开作用域，调用析构函数销毁对象，由于两个对象都要销毁，因此调用了两次析构函数 可以看出来，在第2步和第4步时执行了两次深拷贝，对于仅申请少量堆空间的临时对象来说，深拷贝的执行效率依旧可以接受，但如果临时对象中的指针成员申请了大量的堆空间，那么 2 次深拷贝操作势必会影响 a 对象初始化的执行效率。针对此，C++11引入了移动构造函数方案以避免深拷贝导致的效率问题。 移动构造函数与浅拷贝类似，但是区别在于：1. 参数要求是右值引用，而非左值引用；2. 函数内将原指针置为0 12345//添加移动构造函数demo(demo &amp;&amp;d):num(d.num)&#123; d.num = NULL; cout&lt;&lt;&quot;move construct!&quot;&lt;&lt;endl;&#125; 可以看出来，上面的main在执行过程中，return返回和=赋值，都是将右值赋给左值，因此对应上了移动构造函数中的右值引用。所以再执行代码时，将会通过两次移动替代两次拷贝： 实际开发中，通常在类中自定义移动构造函数的同时，会再为其自定义一个适当的拷贝构造函数，由此当用户利用右值初始化类对象时，会调用移动构造函数；使用左值（非右值）初始化类对象时，会调用拷贝构造函数。 但是，也可以完全用移动构造函数，也就是完全用右值引用，方法是采用std::move()函数，强行将左值转为右值。 📌C定义类class A，类内包含的默认8个成员函数： - 默认构造函数： A(); - 默认拷贝构造函数： A(const A&amp;); - 默认析构函数： ~A(); - 默认重载赋值运算符： A&amp; operator = (const A&amp;); - 默认重载取址运算符： A* operator &amp; (); - 默认const修饰的重载取址运算符： const A* operator &amp; () const; - （C11）默认移动构造函数： A(A&amp;&amp;); - （C++11）默认重载移动赋值运算符：A&amp; operator = (const A&amp;&amp;); unique_ptr就是通过移动构造函数实现的所有权转移。unique_ptr类中只有移动构造函数，禁用拷贝构造。 移动构造函数还有一个典型案例就是，vector容器中的emplace_back函数采用移动构造，push_back函数采用拷贝构造，前者比后者高效很多。 智能指针 智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，智能指针是一个类，当超出类的作用域时，会自动调用析构函数，析构函数会自动释放资源。因此智能指针在函数结束时自动释放内存空间，不需要手动释放（严格践行RAII）。而且智能指针重载了*和→操作符，使用起来和原始指针一样。不要试图delete智能指针。 auto_ptr（已被C++11弃用） 123auto_ptr&lt;string&gt; p1 (new string(&quot;I reigned lonely as a cloud&quot;));auto_ptr&lt;string&gt; p2;p2 = p1; //auto_ptr不会报错 auto_ptr采用所用权模式。上述代码执行时不会报错，但p2剥夺了p1的所有权，当程序访问p1时将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃风险。 unique_ptr unique_ptr实现独占式拥有，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露（如“new创建对象后因异常而忘记调用delete”）特别有用。 123unique_ptr&lt;string&gt; p3(new string (&quot;auto&quot;));unique_ptr&lt;string&gt; p4;p4 = p3; //报错！ 编译器认为p4=p3非法，因此避免了p3不再指向有效数据，成为野指针的问题。因此unique_ptr比auto_ptr更为安全。 智能指针没有定义加减运算，不能随意移动指针地址，从而避免指针越界等危险操作。 12ptr1++; //导致编译错误ptr2+=2; //导致编译错误 需要注意，使用智能指针也要避免未初始化的空指针问题。比如下面的代码会导致core dump： 12unique_ptr ptr3; //未初始化智能指针*ptr3 = 42; //错误！操作了空指针 为了避免这种低级错误，可以调用工厂函数make_unique()，强制要求创建指针的时候必须初始化： 12345678unique_ptr&lt;string&gt; ptr5;ptr5 = unique_ptr&lt;string&gt;(new string (&quot;You&quot;)); //不用工厂函数，而是构造函数，临时右值初始化auto ptr3 = make_unique(42); //工厂函数创建智能指针assert(ptr3 &amp;&amp; *ptr3 == 42);auto ptr4 = make_unique(&quot;god of war&quot;); //工厂函数创建智能指针assert(!ptr4-&gt;empty()); 📌make_unique()要求C14，但是如果使用C11，可以自己实现一个简化版的make_unqiue() template&lt;typename T, typename… Ts&gt; //可变参数模板 std::unique_ptr&lt;T&gt; make_unique(Ts&amp;&amp;… params) //返回智能指针，入口参数 { return std::unique_ptr&lt;T&gt;(new T(std::foward&lt;Ts&gt;(params)…)); //构造智能指针，完美转发 } （标准库的工厂函数内部是有优化的，会比手写类型构造的效率更高） 前面提到unique_ptr不允许直接进行“所有权”转移，这是因为其禁用了拷贝赋值，仅保留了移动构造和移动赋值。因此，若想要进行所有权转移，必须用std::move函数显式地声明： 12345auto ptr1 = make_unique(42); //工厂函数创建智能指针assert(ptr1 &amp;&amp; *ptr1 ==42);auto ptr2 = std::move(ptr1); //使用move()转移所有权assert(!ptr1 &amp;&amp; ptr2); get()和release()： bar是一个智能指针，p是一个普通指针，p=bar.get()，bar并未被释放，此时相当于指针p和智能指针bar共同管理一个对象。也就是说，*p=做的事情，会反映到bar指向的对象。 release()会释放当前指针对对象的所有权，其返回值用于新的指针（普通指针或智能指针）接管对象。 123456789101112131415 // foo bar p // --- --- ---std::unique_ptr&lt;int&gt; foo; // nullstd::unique_ptr&lt;int&gt; bar; // null nullint* p = nullptr; // null null nullfoo = std::unique_ptr&lt;int&gt;(new int(10)); // 10 null nullbar = std::move(foo); // null 10 nullp = bar.get(); // null 10 10*p = 20; // null 20 20p = nullptr; // null 20 nullfoo = std::unique_ptr&lt;int&gt;(new int(30)); // 30 20 nullp = foo.release(); // null 20 30*p = 40; // null 20 40 此外还有reset()方法，不仅会释放所有权，还会释放对象，即释放内存。 12345std::unique_ptr&lt;string&gt; p1(new std::string(&quot;1&quot;));std::unique_ptr&lt;string&gt; p2(p1.release()); //p1置空,p2接管std::unique_ptr&lt;string&gt; p3(new std::string(&quot;3&quot;));p2.reset(p3.release()); //p2会释放原来指向的对象，接管p3原来的对象 shared_ptr shared_ptr实现共享式拥有概念。多个智能指针指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时释放。采用计数机制表明资源被几个指针共享，可通过成员函数use_count()查看资源所得者个数。 构造方式： 可通过new来构造，也可通过传入auto_ptr，unique_ptr，weak_ptr来构造，还可通过std::make_shared函数构造，如： 12std::shared_ptr&lt;int&gt; sptr3(new int(10));std::shared_ptr&lt;int&gt; sptr4 = std::make_shared&lt;int&gt;(5); 由于所有权是可以被安全共享的，所以允许拷贝赋值： 12auto ptr1 = std::make_shared&lt;int&gt;(42);auto ptr2 = ptr1; 销毁方式： 对某个指针调用release()时，当前指针会释放资源所有权，计数减1。当计数等于0，资源被释放 关键成员函数： use_count：返回引用计数的个数 unique：返回是否是独占所有权（use_count为1） swap：交换两个shared_ptr对象 reset：放弃内部对象的所有权或拥有对象的变更，会引起原有对象的引用计数的减少 get：返回内部对象（指针），如shared_ptr&lt;int&gt;sp (new int(1))后，sp与sp.get()是等价的 weak_ptr weak_ptr指向由shared_ptr管理的对象，但不控制对象的生命周期。考虑这样一种情况，两个shared_ptr相互引用，如下： 123456789101112131415161718class A&#123;public: shared_ptr&lt;B&gt; pb_; ~A()&#123; cout&lt;&lt;&quot;A delete\\n&quot;; &#125;&#125;;class B&#123;public: shared_ptr&lt;A&gt; pa_; ~B()&#123; cout&lt;&lt;&quot;B delete\\n&quot;; &#125;&#125;;shared_ptr&lt;B&gt; pb (new B());shared_ptr&lt;A&gt; pa (new A());pb-&gt;pa_ = pa;pa-&gt;pb_ = pb;cout &lt;&lt; pb.use_count() &lt;&lt; endl;cout &lt;&lt; pa.use_count() &lt;&lt; endl; 此时两个指针互相引用，形成了死锁，计数不可能下降为0（两个的计数都为2），资源永远不会释放。而weak_ptr旨在解决这一问题，weak_ptr不会引起计数的增加或减少，但可指向shared_ptr管理的对象，因此在例子中，两shared_ptr中的一个降级为weak_ptr即可解决死锁问题。 12345class A&#123;public: weak_ptr&lt;B&gt; pb_; ~A()&#123; cout&lt;&lt;&quot;A delete\\n&quot;; &#125;&#125;; weak_ptr基本用法： 如果要使用weak_ptr指向的对象，首先要用expired成员函数检查对象是否存在且是否能引用，之后再用lock成员函数升格为shared_ptr，才能使用。 123456789101112int main()&#123; std::shared_ptr&lt;int&gt; sptr(new int(3)); //strong ref = 1 std::shared_ptr&lt;int&gt; sptr2 = sptr; //strong ref = 2 std::weak_ptr&lt;int&gt; wptr = sptr; //strong ref = 2, weak ref = 1 if(!wptr.expired())&#123; std::shared_ptr&lt;int&gt; sptr3 = wptr.lock();//strong ref = 3, weak ref = 1 &#125; return 0;&#125; 可以看到，使用weak_ptr是有强弱引用计数的 智能指针是否会有内存泄漏 当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，退出作用域时未能释放内存，从而导致内存泄露。 智能指针的内存泄露如何处理 为了解决循环引用导致的内存泄漏，引入了weak_ptr弱指针，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。 写时拷贝（COW, Copy On Write） 深拷贝和浅拷贝各有优劣，前者可以避免重复析构的问题，后者可以提高代码效率。写时拷贝即是融合了二者优点的改良方案，类似于shared_ptr。 其特点为：写之前→浅拷贝，多个对象可以指向一片内存；修改时→深拷贝，哪个对象要修改内存的值，就为其新开辟一块空间。当要释放掉某片内存时，只在最后一个对象销毁时释放该内存。 如何知道当前析构的是否是最后一个对象？ 利用计数器（引用计数），当新增了一个指向这片内存的对象时，该计数器加1，当销毁了一个指向这片内存的对象时，计数器减1。减到0时，说明在销毁最右一个对象，此时可以释放内存。 计数器位置的选取是此方案最重要的问题。 引用计数作为成员变量？ 难以做到多个对象之间的同步。 引用计数作为静态变量？ 所有对象共享该引用计数，如果都指向了相同内存，可以达到计数目的。然而，如果出现了写操作，会导致问题。举例说明，类中有一个string指针属性，实例化对象时需要开辟内存。当前三个对象都指向&quot;hello&quot;字符串时，计数器会加到3，但是如果第四个对象指向了&quot;world&quot;字符串，那么第四个对象会将计数器置1。那么前三个对象的计数器也会被修改为1，从而无法释放掉&quot;hello&quot;字符串。 引用计数放在堆内存中： 将引用计数变量放在堆内存中，是写时拷贝的惯用方案。当开辟内存时，多留4字节的裕量，将引用计数放在堆内存起始位置。之后再将类的属性（指针）指向堆内存起始位置+4。 以自定义一个CString类型为例： 查看引用计数函数： 引用计数在堆内存中，需要查看或修改时，返回该内存的引用。因为堆内存开辟时是char类型，指针需强制转为int* 不应暴露出可以外部修改引用计数的接口，所以引用计数和查看函数均应是私有的。 1234//mptr是类CString中，指向堆内存的指针成员int&amp; getRefCount(char* ptr)&#123; return *(int*)(ptr-4); //ptr指向的是字符串，想查看引用计数需地址回退四个字节&#125; 释放内存函数： 释放内存涉及的问题是判断是否销毁到了指向这片内存的最后一个对象。 12345void Release(char* ptr)&#123; if(--getRefCount(mptr) == 0)&#123; delete[] (mptr-4); //释放内存的时候还要释放保存引用计数的四个字节 &#125;&#125; 构造函数： 构造函数需从一个字符串常量构造，由于事先并无开辟的堆内存，所以需要开辟新内存，并将引用计数置1。 12345CString(char* ptr=NULL) : mptr(new char[strlen(ptr) + 1 + 4])&#123; //从字符串常量构造CString对象 mptr += 4; strcpy(mptr, ptr); getRefCount(mptr) = 1;&#125; 拷贝构造函数和重载赋值运算符： 拷贝构造函数用浅拷贝，同时给引用计数加1。 而赋值运算符需要注意的是，如果左值是原内存的最后一个对象，则需要销毁原内存（或者不是最后一个对象，要引用计数减1），再进行浅拷贝。 123CString(const CString&amp; rhs):mptr(rhs.mptr)&#123; ++getRefCount(mptr);&#125; 12345678CString&amp; operator=(const CString&amp; rhs)&#123; if(this != &amp;rhs)&#123; Release(mptr); mptr = rhs.mptr; ++getRefCount(mptr); &#125; return *this;&#125; 重载[]运算符函数： [ ]运算符涉及的问题是，CSting定义的对象str，往往是通过[ ]来修改值的，比如str[1]=‘a’。所以这里不应采用浅拷贝，而应是深拷贝。这也对应了写时拷贝的概念，即只有发生修改时，才用深拷贝。 但也不是所有情况下都必须用深拷贝，如果引用计数为1，说明只有一个对象独占资源，那么可以直接在原内存上进行修改，不需要深拷贝。如果引用计数大于1，说明多个对象共享堆内存，那么一个对象动了堆，其他对象也会跟着改变，但是其他对象本来的堆内存的值本就不应改变，这时需要采用深拷贝。 1234567891011 char&amp; operator[](int index)&#123; if(getRefCount(mptr) &gt; 1)&#123; //判断引用计数是否大于1 char* ptr = mptr; mptr = new char(strlen(mptr) + 1 + 4); //深拷贝 --getRefCount(ptr); mptr += 4; strcpy(mptr, ptr); getRefCount(mptr) = 1; &#125; return mptr[index];&#125; 这样写也存在问题，很多时候调用[ ]只希望访问值，而非修改，但访问时也采用了深拷贝，导致了效率的损失。这也是写时拷贝的缺点所在。 整体代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class CString&#123;public: CString(char* ptr=NULL) : mptr(new char[strlen(ptr) + 1 + 4])&#123; mptr += 4; strcpy(mptr, ptr); getRefCount(mptr) = 1; &#125; CString(const CString&amp; rhs):mptr(rhs.mptr)&#123; ++getRefCount(mptr); &#125; CString&amp; operator=(const CString&amp; rhs)&#123; if(this != &amp;rhs)&#123; Release(mptr); mptr = rhs.mptr; ++getRefCount(mptr); &#125; return *this; &#125; char&amp; operator[](int index)&#123; if(getRefCount(mptr) &gt; 1)&#123; char* ptr = mptr; mptr = new char(strlen(mptr) + 1 + 4); --getRefCount(ptr); mptr += 4; strcpy(mptr, ptr); getRefCount(mptr) = 1; &#125; return mptr[index]; &#125; ~CString()&#123; Release(mptr); //析构时调用释放内存函数 &#125; void Print()&#123; cout &lt;&lt; mptr &lt;&lt; endl; &#125;private: char* mptr; int&amp; getRefCount(char* ptr)&#123; return *(int*)(ptr-4); &#125; void Release(char* ptr)&#123; if(--getRefCount(mptr) == 0)&#123; delete[] (mptr-4); //释放内存的时候还要释放保存引用计数的四个字节 &#125; &#125;&#125;;int main()&#123; CString str1(&quot;hello&quot;);//构造 Cstring str2(str1);//拷贝构造 CString str3(&quot;world&quot;);//构造 str1 = str3; str1[0] = &#x27;a&#x27;; str1.Print(); str2.Print(); str3.Print(); return 0;&#125; 输出： aorld hellow world 11 模板 更高深的模板知识移步《泛型编程》笔记，泛型编程本身就是C++几大编程风格之一，可以说非常复杂 类模板 编译时的机制，并不会产生额外的运行时开销 123456789101112131415template&lt;typename T&gt;class Vector&#123;private: T* elem; int sz;public: explicit Vector(int s); ~Vector() &#123;delete[] elem;&#125; T&amp; operator[](int i); const T&amp; operator[](int i) const; int size() const &#123;return sz;&#125; T* begin(Vector&lt;T&gt;&amp; x); T* end(Vector&lt;T&gt;&amp; x)&#125;; 成员函数的定义方式与之类似 123456789101112131415161718192021222324template&lt;typename T&gt;Vector&lt;T&gt;::Vector(int s)&#123; if(s &lt; 0) throw Negative_size&#123;&#125;; elem = new T[s]; sz = s;&#125;template&lt;typename T&gt;const T&amp; Vector&lt;T&gt;::operator[](int i) const&#123; if(i&lt;0 || size()&lt;=i) throw out_of_range(&quot;Vector::operator[]&quot;); return elem[i];&#125;template&lt;typename T&gt;T* begin(Vector&lt;T&gt;&amp; x)&#123; return x.size() ? &amp;x[0] : nullptr;&#125;template&lt;typename T&gt;T* end(Vector&lt;T&gt;&amp; x)&#123; return begin(x) + x.size();&#125; 定义了begin 和end就可以使用for循环了 1234void f2(Vector&lt;string&gt;&amp; vs)&#123; for(auto&amp; s : vs) cout &lt;&lt; s &lt;&lt; &#x27;\\n&#x27;;&#125; 除了类型参数外，还接受普通的值参数 1234567template&lt;typename T, int N&gt;struct Buffer&#123; using value_type = T; constexpr int size() &#123;return N;&#125; T[N]; // ...&#125;; 函数模板 123456template&lt;typename Container, typename Value&gt;Value sum(const Container&amp; c, Value v)&#123; for(auto x : c) v += x; return v;&#125; 上面的函数相当于针对不同的类型实现了一个累加器 123456void user(Vector&lt;int&gt;&amp; vi, std::list)&#123; int x = sum(vi, 0); double d = sum(vi, 0.0); double dd = sum(ld, 0.0); auto z = sum(vc, complex&lt;double&gt;&#123;&#125;);&#125; 📌模板也可以跟函数参数一样，有默认值。 template &lt;typename ty=string&gt; int test(ty x) { //… } 如果没有显式说明ty的类型，也没有自动推断，那么编译时就会让ty成为默认类型string。 静态多态：CRTP Curiously Recurring Template Pattern 一般意义上的使用virtual实现的多态均为动态多态，在运行时实现多态。在C++中也可以使用静态多态，在编译时实现多态。动态多态由于存储虚表指针和虚表，以及有查询虚函数地址的一系列操作，会带来较大的开销。静态多态可以提升效率（降低开销），就像内联函数一样。 动态多态： 1234567891011121314151617181920212223242526272829class Animal&#123;public: virtual void Print() const&#123; cout &lt;&lt; &quot;unset&quot; &lt;&lt; endl; &#125;&#125;;class Dog : public Animal&#123;public: void Print() const override&#123; cout &lt;&lt; &quot;Dog&quot; &lt;&lt; endl; &#125;&#125;;class Cat : public Animal&#123;public: void Print() const override&#123; cout &lt;&lt; &quot;Cat&quot; &lt;&lt; endl; &#125;&#125;;void My_Print(const Animal&amp; animal)&#123; animal.Print();&#125;int main()&#123; Dog d; My_Print(d);&#125; 最简单的静态多态： 1234567891011121314151617181920212223242526272829303132333435enum Animal_Type&#123; unset, Dog, Cat,&#125;;class Animal&#123;public: Animal(Animal_Type animal_type) : animal_type(animal_type) &#123;&#125; void Print() const&#123; switch(animal_type)&#123; case unset: cout &lt;&lt; &quot;unset&quot; &lt;&lt; endl; break; case Dog: cout &lt;&lt; &quot;Dog&quot; &lt;&lt; endl; break; case Cat: cout &lt;&lt; &quot;Cat&quot; &lt;&lt; endl; break; default: break; &#125; &#125;private: Animal_Type animal_type;&#125;;void My_Print(const Animal&amp; animal)&#123; animal.Print();&#125;int main()&#123; Animal dog(Animal_Type::Dog); My_Print(dog);&#125; 然而这种最简单的静态多态方法导致的问题是明显的，Animal类非常难以维护，要加一个新类别或新动作，要直接修改Animal类和Animal_Type类的源码。于是可以采用模板来进行改进（需要说明的是，既不用virtual，也不用模板，达不到多态的目的）： 不用virtual和模板无法实现多态： 打印的结果是unset，因为调用My_Print时会把Dog类隐式转换为Animal类（因为My_Print函数接收的参数要求是Animal类） 1234567891011121314151617181920212223242526272829class Animal&#123;public: void Print() const&#123; cout &lt;&lt; &quot;unset&quot; &lt;&lt; endl; &#125;&#125;;class Dog : public Animal&#123;public: void Print() const&#123;//覆盖原Print cout &lt;&lt; &quot;Dog&quot; &lt;&lt; endl; &#125;&#125;;class Cat : public Animal&#123;public: void Print() const&#123;//覆盖原Print cout &lt;&lt; &quot;Cat&quot; &lt;&lt; endl; &#125;&#125;;void My_Print(const Animal&amp; animal)&#123; animal.Print();&#125;int main()&#123; Dog d; My_Print(d);&#125; 利用模板改进的静态多态： 打印Dog，My_Print是模板函数，自动推断类型 123456789101112131415161718192021222324252627282930class Animal&#123;public: void Print() const&#123; cout &lt;&lt; &quot;unset&quot; &lt;&lt; endl; &#125;&#125;;class Dog : public Animal&#123;public: void Print() const&#123; cout &lt;&lt; &quot;Dog&quot; &lt;&lt; endl; &#125;&#125;;class Cat : public Animal&#123;public: void Print() const&#123; cout &lt;&lt; &quot;Cat&quot; &lt;&lt; endl; &#125;&#125;;template&lt;typename A_T&gt;void My_Print(const A_T&amp; animal)&#123; animal.Print();&#125;int main()&#123; Dog d; My_Print(d);&#125; 可以在上面的静态多态实现方案的基础上，进一步改良。现在是有三个Print函数，可以进一步降到只有两个函数以降低开销。改良的方案是CRTP。 CRTP一般的套路如下，在基类上用模板，基类只保留接口，子类负责接口的具体实现。 12345678910111213template &lt;class Derived&gt; struct Base&#123; void Interface() &#123; // ... static_cast&lt;Derived*&gt;(this)-&gt;Implementation(); // ... &#125;&#125;;struct Derived : Base&lt;Derived&gt; &#123; void Implementation();&#125;; 针对上面的例子，则可以改写为CRTP实现的静态多态： 12345678910111213141516171819202122232425262728293031template&lt;typename Derived&gt;class Animal&#123;public: void Print() const&#123; static_cast&lt;Derived*&gt;(this) -&gt; Print(); &#125;&#125;;class Dog : public Animal&lt;Dog&gt;&#123;public: void Print() const&#123; cout &lt;&lt; &quot;Dog&quot; &lt;&lt; endl; &#125;&#125;;class Cat : public Animal&lt;Cat&gt;&#123;public: void Print() const&#123; cout &lt;&lt; &quot;Cat&quot; &lt;&lt; endl; &#125;&#125;;template&lt;typename A_T&gt;void My_Print(const A_T&amp; animal)&#123; animal.Print();&#125;int main()&#123; Dog d; My_Print(d);&#125; 在这个例子中，表面上Dog和Cat类都在继承Animal，但事实上它们继承的类是不同的，Dog继承的是Animal&lt;Dog&gt;类，Cat继承的是Animal&lt;Cat&gt;类。因此即使基类中有static变量，它们是不共享的。除此之外，由于继承的不是同一个基类，Dog和Cat的对象也无法放在同一个STL容器中，这也给CRTP的使用带来了局限。 函数对象（function object/functor） 函数对象，顾名思义，就是将函数视作一个类的对象。调用函数对象时与调用函数无异，而函数对象的一个好处就是比较灵活，可以作为其他函数的参数被调用。 模板的一个特殊用途就是泛化函数对象，例如： 1234567template&lt;typename T&gt;class Less_than&#123; const T val; //待比较的值public: Less_than(const T&amp; v) : val(v) &#123;&#125; bool operator()(const T&amp; x) const &#123; return x &lt; val; &#125; //调用运算符&#125;; 此时，可以像调用函数一样调用函数对象 1234Less_than&lt;int&gt; LT_i &#123;42&#125;;Less_than&lt;string&gt; LT_s &#123;&quot;Backus&quot;&#125;;bool b1 = LT_i(n); //如果n&lt;42则为真bool b2 = LT_s(s); //如果s&lt;&quot;Backus&quot;则为真 函数对象经常作为算法的参数出现，例如下面例子中pred就是函数对象作为的参数 12345678910111213//统计容器中有多少个小于某数的值template&lt;typename C, typename P&gt;int count(const C&amp; c, P pred)&#123; //C假定为容器类型，P为函数对象类型 int cnt = 0; for(const auto&amp; x : c) if(pred(x)) ++cnt; return cnt;&#125;void f(const Vector&lt;int&gt;&amp; vec, int x)&#123; cout &lt;&lt; count(vec, Less_than&lt;int&gt;&#123;x&#125;) &lt;&lt; endl;&#125; 除了用类和模板定义函数对象，还可以用匿名函数(lambda表达式)定义函数对象。 可变参数 省略符形参： 省略符形参应该仅仅用于C和C++通用的类型。特别应该注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。 1234567891011121314151617181920212223242526272829int sum(int count, ...)&#123; if (count &lt;= 0) &#123; return 0; &#125; //为了实现可变参数列表，首先需要声明一个va_list类型的指针 //va_list类型是在cstdarg头文件里面定义的，该指针用来依次指向各个参数 //va_start是一个宏，用来初始化arg_ptr，使其指向列表的第一个参数 //这个宏的第二个参数是sum函数参数列表省略号前得固定参数的名称，用来确定第一个参数的位置 va_list arg_ptr; va_start(arg_ptr, count); int CountSum = 0; //va_arg是一个宏，返回arg_ptr指向的参数位置，并使arg_ptr递增来指向下一个参数值 //va_arg宏的第二个参数是需要统计的第一个参数的类型， //如果类型不正确，程序也可能会执行，但得到的是无用的数据，arg_ptr将被错误地递增 for (int i = 0; i &lt; count; ++i) &#123; CountSum += va_arg(arg_ptr, int); &#125; //将va_list类型的指针复位成空值 //就是清空可变参数列表 va_end(arg_ptr); return CountSum;&#125;sum(5,1,2,3,4,5);//return 15 可变参数模板（实用）： 实现可变参数模板的关键是：当你传给它多个参数时，谨记把第一个参数和其他参数区分对待。此处，首先处理第一个参数head，然后使用剩余参数递归地调用f()。省略号…表示列表地“剩余部分”。最终，tail将为空。 123456789101112131415161718192021222324void f() &#123;&#125; //不执行任何操作template&lt;typename T&gt;void g(T x)&#123; cout &lt;&lt; x &lt;&lt; &quot; &quot;;&#125;template&lt;typename T, typename... Tail&gt;void f(T head, Tail... tail)&#123; //f()类似于printf()的简单变形 g(head); //对head做某些操作 f(tail...); //再次处理tail&#125;int main()&#123; cout &lt;&lt; &quot;first: &quot;; f(1,2.2,&quot;hello&quot;); cout &lt;&lt; &quot;\\n second: &quot;; f(0.2, &#x27;c&#x27;, &quot;yuck!&quot;, 0, 1, 2); cout &lt;&lt; &quot;\\n&quot;;&#125;//输出：//first: 1 2.2 hello//second: 0.2 c yuck! 0 1 2 可变参数initializer_list： 12345678//initializer_list相对vector更轻量化 而且元素是常量void error_msg(initializer_list&lt;string&gt; il) &#123; for (auto beg = il.begin(); beg != il.end(); ++beg) cout &lt;&lt; *beg &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125;error_msg(&#123;&quot;im&quot;,&quot;da&quot;,&quot;gong&quot;&#125;);//&quot;im da gong&quot; 这种方式局限性很大，列表里只能同类型，而且元素是常量。 这种方式的一个典型例子就是vector初始化赋值，可用下面代码模拟： 12345678910111213141516171819class MyNumber&#123;public: MyNumber(const std::initializer_list&lt;int&gt;&amp; v)&#123; for(auto itm : v) mVec.push_back(itm); &#125; void print()&#123; for(auto itm : mVec) std::cout &lt;&lt; itm &lt;&lt; &quot; &quot;; &#125;private: std::vector&lt;int&gt; mVec;&#125;;int main()&#123; MyNumber m = &#123;1,2,3,4&#125;; m.print(); return 0;&#125; 宏： 12345#define debug(...) print(cout,__VA_ARGS__)#define debug2(os, ...) print(os, __VA_ARGS__)//#define debug2(format, args...) print(format, ##args)//win32不支持debug2(cout,&quot;this &quot;, &quot; year&quot;);//&quot;this year&quot; __VA_ARGS__表示可变参数列表。 别名 泛型编程中的别名可以有很多用途， 写出通用代码： 比如，每个标准库容器都提供了value_type作为其值类型的名字（如vector&lt;int&gt;::value_type为int），因此可以利用这点写出代码，使代码能够在任何一个服从这种规范的容器上工作，如： 12345678template&lt;typename C&gt;using Element_type = typename C::value_type; //C的元素类型template&lt;typename Container&gt;void algo(Container&amp; c)&#123; Vector&lt;Element_type&lt;Container&gt;&gt; vec; //保存结果 //...&#125; 实现algo函数，就可以将如stack&lt;int&gt;的变量转换成vector&lt;int&gt;，Element_type&lt;Container&gt;会等于int。 绑定某些模板实参，定义新的模板： 123456789template&lt;typename Key, typename Value&gt;class Map&#123; //...&#125;;template&lt;typename Value&gt;using String_map = Map&lt;string, Value&gt;;String_map&lt;int&gt; m; //m是一个Map&lt;string, int&gt; 📌typedef 和using 的区别：typedef 只能针对特定的类型，而using 可以生成别名模板。 比如可以template&lt;class T&gt; using remove_const_t = typename remove_const&lt;T&gt;::type，而typedef则不行。 模板特化 当定义一个类模板或函数模板时，往往希望所有会用到的模板参数类型，都能够满足类模板或函数模板对其功能的要求，举例来说，函数模板template&lt;typename T&gt; …希望所有可能实例化的T，都能够实现取模运算%。 12345678910template &lt;typename E&gt;E my_gcd(E a, E b)&#123; while(b != E(0))&#123; E r = a % b; a = b; b = r; &#125; return a;&#125; 然而，并不是所有的类型都有取模函数，比如一些第三方库的高精度数字库（如CLN的cl_I高精度整数类型就不支持），那么实例化会失败，编译出错。 针对这种情况，有三种解决方案，其中后面两种最常用，即重载和特化。1 方案1：添加代码，让类型支持所需要的操作 123456cln::cl_Ioperator%(const cln::cl_I&amp; lhs, const cln::cl_I&amp; rhs)&#123; return mod(lhs, rhs);&#125; 方案2：函数重载，不直接使用%运算符，替换成my_mod函数，再重载cl_I类型的my_mod函数 1234567891011//%替换成my_modtemplate &lt;typename E&gt;E my_gcd(E a, E b)&#123; while (b != E(0)) &#123; E r = my_mod(a, b); a = b; b = r; &#125; return a;&#125; 1234567//一般情况下的my_mod函数template &lt;typename E&gt;E my_mod(const E&amp; lhs, const E&amp; rhs)&#123; return lhs % rhs;&#125; 1234567//针对cl_I类重载的my_mod函数cln::cl_Imy_mod(const cln::cl_I&amp; lhs, const cln::cl_I&amp; rhs)&#123; return mod(lhs, rhs);&#125; 3. 方案3：模板特化，同方案2类似，但是my_mod不针对cl_I类型重载，而是特化 12345template &lt;&gt;cln::cl_I my_mod&lt;cln::cl_I&gt;(const cln::cl_I&amp; lhs, const cln::cl_I&amp; rhs)&#123; return mod(lhs, rhs);&#125; 📌特化是一种更加通用的技巧，因为特化既可以用在类模板也可以用在函数模板，而重载只能用于函数。 然而，一般的建议是：对函数模板使用重载，对类模板进行特化。 特化的经典例子：static_assert 1234567891011template &lt;bool&gt;struct compile_time_error;template &lt;&gt;struct compile_time_error&lt;true&gt; &#123;&#125;;#define STATIC_ASSERT(Expr, Msg) \\ &#123; \\ compile_time_error&lt;bool(Expr)&gt; \\ ERROR_##_Msg; \\ (void)ERROR_##_Msg; \\ &#125; 上面的代码声明了一个struct模板，但仅对true的情况进行了特化，产生了compile_tme_error&lt;true&gt;的定义。这样，如果Expr是错的（比如3&gt;5），此时就遇到了compile_time_error&lt;false&gt;的情况，缺少定义编译不出来，所以就会编译报错，起到编译期检查的作用。(void)ERROR_##_Msg是在抑制编译器unused警告（当成功编译时）。 为什么遇到类型不满足条件时，对函数模板更倾向于重载？ 资料：Why not specialize Function Templates? 偏特化：多个模板参数，仅特化其中的一部分 1 编译时计算（浅述模板元编程） 最大公约数（辗转相除gcd） 12345678910111213141516template &lt;int n&gt;struct factorial&#123; static_assert( n &gt;= 0, &quot;Arg must be non-negative&quot;); static const int value = n * factorial&lt;n-1&gt;::value;&#125;;template &lt;&gt;struct factorial&lt;0&gt;&#123; static const int value = 1;&#125;;int main() &#123; std::cout &lt;&lt; factorial&lt;10&gt;::value &lt;&lt; std::endl; //3628800 return 0;&#125; 这样的代码进行反汇编，可以看到3628800直接出现了，中间的递归、计算过程完全没有。这便体现了编译期计算，即计算步骤完全由编译器完成了，而不在运行时进行。 123456789101112.LC0: .string &quot;%d\\n&quot;main: push rbp mov rbp, rsp mov esi, 3628800 mov edi, OFFSET FLAT:.LC0 mov eax, 0 call printf mov eax, 0 pop rbp ret 从中可以一窥编译期计算的核心：将计算转变成类型推导。 条件语句（C++98）：右边两种写法是等价的 123456789101112template&lt;bool cond, typename Then, typename Else&gt;struct If;template&lt;typename Then, typename Else&gt;struct If&lt;true, Then, Else&gt;&#123; typedef Then type;&#125;template&lt;typename Then, typename Else&gt;struct If&lt;false, Then, Else&gt;&#123; typedef Else type;&#125; 123456template&lt;class T, T v&gt;struct integral_constant&#123; static const T value = v; typedef T value_type; typedef integral_constant type;&#125;; 1234int foo(int n)&#123; if( n==2 || n==3 || n==5 ) return 1; else return 2;&#125; 12345678template&lt;int n&gt;struct Foo&#123; typedef typename If&lt; ( n==2 || n==3 || n==5), integral_constant&lt;int, 1&gt;, integral_constant&lt;int, 2&gt;&gt;::type type;&#125;; 用::取一个成员类型，且::左边有模板参数的话，得额外加上typename关键字来标明结果是一个类型。使用如下： std::cout&lt;&lt;Foo&lt;1&gt;::type::value&lt;&lt;std::endl 定义两项分支Then和Else，用类型来代表执行状态。 cond：条件（真或假） Then：条件为真时的状态 Else：条件为假时的状态 循环语句（C++98）： 12345678910111213141516171819202122template &lt;bool condition, typename body&gt;struct WhileLoop;template &lt;typename Body&gt;struct WhileLoop&lt;true, Body&gt;&#123; typedef typename WhileLoop&lt; Body::cond_value, typename Body::next_type&gt;::type type;&#125;;template &lt;typename Body&gt;struct WhileLoop&lt;false, Body&gt;&#123; typedef typename Body::res_type type;&#125;;template &lt;typename Body&gt;struct While &#123; typedef typename WhileLoop&lt; Body::cond_value, Body&gt;::type type;&#125;; 123456template&lt;class T, T v&gt;struct integral_constant&#123; static const T value = v; typedef T value_type; typedef integral_constant type;&#125;; 12345int result = 0;while(n != 0)&#123; result = result + n; n = n-1;&#125; 123456789101112template &lt;int result, int n&gt;struct SumLoop&#123; static const bool cond_value = n!=0; static const int res_value = result; typedef integral_constant&lt;int, res_value&gt; res_type; typedef SumLoop&lt;result + n, n -1&gt; next_type;&#125;;template&lt;int n&gt;struct Sum&#123; typedef SumLoop&lt;0,n&gt; type;&#125;; ↑上面两种写法的效果是等价的。使用时执行： While&lt;Sum&lt;10&gt;::type&gt;::type::value 可得到1~10累加结果 前面说到，编译期计算用类型推导表示分支状态。因此需要三个成员：cond_value表示循环判断的条件（真假）、res_type表示退出循环时的状态、next_type表示下面循环执行一次的状态。 这样的循环过程可以通过展开来理解，以累加到2为例： While&lt; Sum&lt;2&gt;::type &gt;::type::value 实例化(instantiation)过程 --&gt; While&lt; SumLoop&lt;0, 2&gt; &gt;::type::value --&gt; WhileLoop&lt;SumLoop&lt;0, 2&gt;::cond_value, SumLoop&lt;0, 2&gt;&gt;::type::value --&gt; WhileLoop&lt;true, SumLoop&lt;0, 2&gt;&gt;::type::value --&gt; WhileLoop&lt;SumLoop&lt;0, 2&gt;::cond_value, SumLoop&lt;0, 2&gt;::next_type&gt;::type::value --&gt; WhileLoop&lt;true, SumLoop&lt;2, 1&gt;&gt;::type::value --&gt; WhileLoop&lt;SumLoop&lt;2, 1&gt;::cond_value, SumLoop&lt;2, 1&gt;::next_type&gt;::type::value --&gt; WhileLoop&lt;true, SumLoop&lt;3, 0&gt;&gt;::type::value --&gt; WhileLoop&lt;SumLoop&lt;3, 0&gt;::cond_value, SumLoop&lt;3, 0&gt;::next_type&gt;::type::value --&gt; WhileLoop&lt;false, SumLoop&lt;3, -1&gt;&gt;::type::value --&gt; SumLoop&lt;3, -1&gt;::res_type::value --&gt;integral_constant&lt;int, 3&gt;::value --&gt;3 type_traits https://en.cppreference.com/w/cpp/header/type_traits 顾名思义，&lt;type_traits&gt;头文件定义了一些工具类模板，用来提取某个类型（type）在某方面的特点（trait）。它可以实现在编译期的判断、转换、查询等功能，并且提供了编译期的true和false。比如上面提到的integral_constant类，就被定义在了type_traits中，它可以称作type_traits的基石。 123456789101112131415161718192021222324/// integral_constanttemplate&lt;typename _Tp, _Tp __v&gt;struct integral_constant&#123; static constexpr _Tp value = __v; typedef _Tp value_type; typedef integral_constant&lt;_Tp, __v&gt; type; constexpr operator value_type() const &#123; return value; &#125;#if __cplusplus &gt; 201103L#define __cpp_lib_integral_constant_callable 201304 constexpr value_type operator()() const &#123; return value; &#125;#endif&#125;;template&lt;typename _Tp, _Tp __v&gt;constexpr _Tp integral_constant&lt;_Tp, __v&gt;::value; 1234typedef std::integral_constant&lt; bool, true&gt; true_type;typedef std::integral_constant&lt; bool, false&gt; false_type; 为方便使用，type_traits还针对布尔值有两个额外的类型定义。于是调用std::true_type::value可以得到true type_traits头文件中凡是带前缀is_*类的偏特化或特化均继承自true_type和false_type，比如： 1234567template &lt;typename&gt;struct __is_pointer_helper : \\ public false_type &#123; &#125;;template &lt;typename&gt;struct __is_pointer_helper &lt;_Tp*&gt; : \\ public true_type &#123; &#125;; 而这些is_*前缀的便是用来标注某类型是否有某特点的模板元。比如is_trivially_destructible模板可用于判断类是否可平凡析构（即，不调用析构函数，不会造成任何资源泄露问题）。模板返回的要么是true_type要么是false_type。使用operator()重载或::value都可以得到背后的true或false。因此，可以在删除某对象前，用它来判断是否需要析构函数，这样在优化编译时，编译器可以把不需要的析构操作全部删除。 1234567891011121314template &lt;typename T&gt;class SomeContainer &#123;public: ... static void destroy(T* ptr)&#123; _destroy(ptr, is_trivially_destructible&lt;T&gt;()); &#125;private: static void _destroy(T* ptr, true_type) &#123;&#125; static void _destroy(T* ptr, false_type) &#123; ptr-&gt;~T(); &#125;&#125;; 上面的代码便是很多容器类都会有的destroy函数，通过is_trivially_destructible来最大程度优化。类似的is_*还有：（具体可查看cppreference官网） is_void, is_null_pointer, is_integral, is_class, is_function, is_pointer, is_lvalue_reference, is_rvalue_reference, is_const, is_move_constructble, is_copy_constructible, has_virtual_destructor等等 同时，type_traits还可以做类型转换，以std::remove_const为例，来去除类型里的const修饰。 123456789template&lt;class T&gt;struct remove_const &#123; typedef T type;&#125;;template&lt;class T&gt;struct remove_const&lt;const T&gt;&#123; typedef T type;&#125;; 1remove_const&lt;const string&gt;::type str;//string类型 📌如果对const char* 应用remove_const的话，结果还是const char 。因为const char 是指向const chat的指针，而不是指向char的const指针。如果对char * const应用remove_const的话，可得到char* &lt;type_traits&gt;中类似的类型转换元还有：（具体可查看cppreference官网） remove_cv（同时去除const和volatile）、remove_volatile、remove_pointer、add_const、remove_extent、make_signed等等。 C14和C17还针对&lt;type_traits&gt;提供了一些简易写法，比如写is_trivially_destructible&lt;T&gt;::value和is_trivially_destructible&lt;T&gt;::type会比较啰嗦，那么可以简化写成_v（C17）和_t（C14）。 12345template &lt;class T&gt;inline constexpr bool is_trivially_destructible_v = is_trivially_destructible&lt; T&gt;::value; 123template &lt;class T&gt;using remove_const_t = typename remove_const&lt;T&gt;::type; 类型转换模板元中，最重要的模板元是std::decay，decay可以对于普通类型移除引用和cv符（const和volatile） 123456789typedef std::decay&lt;int&gt;::type Normal; //inttypedef std::decay&lt;int&amp;&gt;::type Ref; //inttypedef std::decay&lt;int&amp;&amp;&gt;::type RefRef; //inttypedef std::decay&lt;const int&amp;&gt;::type cnst; //inttypedef std::decay&lt;int[2]&gt;::type Array; //int*，数组类型变成指针类型/*-----decay一般会和decltype搭配-----*/int arr[2] = &#123;1,2&#125;;typedef std::decay&lt;decltype(arr)&gt;::type myArray; decay比较常用的一点在于其可以方便地获得函数指针，即其可以实现从函数对象提取出函数指针类型。 123456789101112int add_2(int x)&#123; return x+2;&#125;int add_3(int x)&#123; return x+3;&#125;std::decay_t&lt;decltype(add_2)&gt; add_ptr = add_3; //add_ptr是函数指针decltype&lt;add_2&gt; * add_func = add2_3; //直接使用decltype推断不出函数指针cout &lt;&lt; add_ptr(7) &lt;&lt; endl; //10cout &lt;&lt; add_func(7) &lt;&lt; endl; //10 decay本意就是退化，移除引用和cv，从函数对象到函数指针，都可以看做是一种退化行为。 但是需要注意，decay_t&lt;decltype&lt;func&gt;&gt;和decay_t&lt;decltype&lt;func()&gt;&gt;是不同的，看上去后者只是加了一个括号。但是后者是将func的返回类型退化，而前者是与func一致入参返回值的函数指针。比如下面的例子，进行map-reduce中的map操作，就是进行返回类型退化decay_t&lt;decltype&lt;func()&gt;&gt;。 123456789101112131415161718template &lt;template&lt;typename, typename&gt;class OutContainer = vector, typename F, class R&gt; auto fmap(F&amp;&amp; f, R&amp;&amp; inputs)&#123; typedef decay_t&lt;decltype(f(*inputs.begin()))&gt; result_type; OutContainer&lt;result_type, allocator&lt;result_type&gt;&gt; result; for (auto&amp;&amp; item : inputs)&#123; result.push_back(f(item)); &#125; return result; &#125;int main() &#123; vector&lt;int&gt; v = &#123;1,2,3,4,5&#125;; auto add_1 = [](int x)&#123; return x + 1; &#125;; auto result = fmap(add_1, v); //v变成：2,3,4,5,6 return 0;&#125; 其他的&lt;type_traits&gt;中常用模板元有：std::conditional, std::enable_if, std::void_t等。 std::conditional：在编译期根据一个判断式选择两个类型中的一个，类似三元表达式 123//原型template&lt;bool B, class T, class F&gt;struct conditional; 1234int main()&#123; typedef std::conditional&lt;true, int, char&gt;::type A; typedef std::conditional&lt;false, int, char&gt;::type B;&#125; type_traits最常用的std::enable_if会在下一小节阐述。 重载歧义消除（traits） 多个同名函数做重载时，偶尔会发生歧义的情况。即调用函数时的参数，同时满足两个及以上的重载函数，那么编译器无从选择，就会出现编译报错。因此需要歧义消除机制，有两种常用方案，SFINAE和type_traits。 SFINAE其实是C++中的一种机制，即“如果模板实例化发生了失败，没有理由让编译就此出错终止，因为还可能有其他可用的函数重载”，标准库通过这种机制提出了歧义消除的解决方案。 SFINAE（Substitution Failure Is Not An Error） 考虑要实现一个Buffer类，希望在Buffer中添加元素，可以有三种形式： 第一种重载：传入一个字符，和一个size_t，向Buffer中添加n个相同的c 第二种重载：直接传入一个字符串，并传入字符串大小 第三种重载：STL风格添加，即可以buf.append(str.begin(), str.end());和buf.append(str.rbegin(),str.rend());，需要注意前者的参数类型是string::iterator，后者的参数类型是string::reverse_iterator。想用一个函数接受两类迭代器，需要用到模板。 因此，Buffer类可以设计成下面的形式： 12345678910111213141516171819202122class Buffer&#123;private: //...public: void append(char c, size_t n = 1); //第一种重载 void append(const char* s, size_t n); //第二种重载 template&lt;typename Iter&gt; void append(Iter bp, Iter ep); //第三种重载&#125;;int main()&#123; Buffer buf; buf.append(&#x27;a&#x27;); //[1] buf.append(&#x27;b&#x27;,10); //[1] string str(&quot;hello&quot;); buf.append(str.data(), str.size()); //[2] buf.append(str.rbegin(), str.rend());//[3]&#125; 但是这样的写法是有错误的，考虑下面的情况 12345int main()&#123; int ch = &#x27;a&#x27;; Buffer buf; buf.append(ch, 10); //int,int&#125; 这种写法下，按理说是想用第一种重载方式，然而由于两个类型都是int，所以会调用原本为迭代器设计的模板重载，即调用了第三种方式的重载，那么就会导致运行时的错误。 SFINAE可用于解决这种问题，它的思路是对模板参数T的类型加以限制，从而避免所有情况下模板都能精准匹配。 SFINAE的关键在于std::enable_if。std::enable_if&lt;BOOL,??&gt;::type的使用方式：第一个模板参数接收一个bool类型，第二个模板参数接收一个任意类型，当前面的bool条件为true时，enable_if的成员变量type就会是第二个模板参数??的类型。而enable_if&lt;BOOL,void&gt;默认第二个模板参数是void。bool条件为false时，表达式解析失败，即不会编译false对应的内容。 用SFINAE，规避Iter为int类型： 写法：(可以写的形式有很多，跟这种写法都是一个思想) 12345678910111213class Buffer&#123;private: //...public: void append(char c, size_t n = 1); //第一种重载 void append(const char* s, size_t n); //第二种重载 template&lt;typename Iter, typename = std::enable_if&lt;!std::is_integral&lt;Iter&gt;::value&gt;::type&gt; void append(Iter bp, Iter ep); //第三种重载 //当非整数时就相当于template&lt;typename Iter, typename = void&gt; void append(...) //整数时就会解析失败，SFINAE机制此时会选择其他函数重载&#125;; 上面的写法是针对函数重载歧义消除时的enable_if用法，事实上enable_if还可以有别的用法： 模板偏特化： 1234567template &lt;typename T, typename Enable=void&gt;struct check;template &lt;typename T&gt;struct check&lt;T, typename std::enable_if&lt;T::value&gt;::type&gt; &#123; static constexpr bool value = T::value;&#125;; check只选择value==true的T，否则就报编译错误（因为没有其他重载的定义了）。 📌只有类模板是可以偏特化的，函数模板不可以偏特化。 控制函数返回类型：典型的例子就是C++的tuple中，获取k个元素的get方法的实现。 123456789101112template &lt;std::size_t k, class T, class... Ts&gt;typename std::enable_if&lt;k==0, typename element_type_holder&lt;0, T, Ts...&gt;::type&amp;&gt;::typeget(tuple&lt;T, Ts...&gt; &amp;t) &#123; return t.tail; &#125;template &lt;std::size_t k, class T, class... Ts&gt;typename std::enable_if&lt;k!=0, typename element_type_holder&lt;k, T, Ts...&gt;::type&amp;&gt;::typeget(tuple&lt;T, Ts...&gt; &amp;t) &#123; tuple&lt;Ts...&gt; &amp;base = t; return get&lt;k-1&gt;(base); &#125; 通过enable_if可以根据不同k的值选择调用哪个get，实现函数模板的多态。这个例子也体现了“编译时计算”思想。进行了一个编译期的递归。 在进行歧义消除的同时，控制返回类型： 12345template &lt;typename T&gt;typename std::enable_if&lt;std::is_integral&lt;T&gt;::value, bool&gt;::typeis_odd(T t) &#123; return bool(t % 2);&#125; 除了利用enable_if关键字和SFINAE机制，还有另一种更有效的歧义消除方案。 添加参数（标签分发，tag dispatch） 现在希望实现一个to_string函数，把数值（整数、浮点数）转换为标准库string类型变量，可以先这么写： 12345678910111213141516171819202122232425262728std::string to_string(long long value)&#123; char str[64]; int len = sprintf(str, &quot;%lld&quot;, value); return std::string(str, len);&#125;std::string to_string(unsigned long long value)&#123; char str[64]; int len = sprintf(str, &quot;%llu&quot;, value); return std::string(str, len);&#125;std::string to_string(long double value)&#123; char str[64]; int len = sprintf(str, &quot;%Lg&quot;, value); return std::string(str, len);&#125;int main()&#123; std::string str; str = to_string(1234); printf(&quot;str = %s\\n&quot;, str.c_str()); str = to_string(-1234); printf(&quot;str = %s\\n&quot;, str.c_str()); str = to_string(56.789); printf(&quot;str = %s\\n&quot;, str.c_str());&#125; 此代码考虑了long long 类型整数和非负整数，以及double浮点类型。然而，编译会报错。因为传1234这个字面量时，1234会作为一个整数变量进入函数栈，然而重载的函数中没一个是精确匹配int类型的，因此编译器会找类型提升，即隐式转换。然而，int对于long long , unsigned long long, long double都存在隐式转换，由此产生歧义，编译器不知道该选择哪个函数重载，所以会有编译报错。 解决方案一：把所有类型的参数，都写一遍，即列举所有可能的函数重载 缺点：写太多了，费时费力 解决方案二：用SFINAE 缺点：当前的重载主要判断两个条件，一个是“参数是否为整数”，另一个是“参数是否为有符号数”。当重载的判断条件大于等于2时，使用SFINAE会将代码写得较乱，难以维护和拓展。 解决方案三：添加参数，确保所有情况都有重载可以匹配，而且至多有一个匹配。 实现方式类似于，通过函数参数，实现if语句。当前函数重载主要判断两个条件：参数是否为整数，参数是否为有符号数。因为浮点数不存在有无符号的问题，所以类型总共可以分为三个分支： 整数，有符号数 整数，无符号数 浮点数 因此，可以加上模板，利用std::is_integral&lt;T&gt;判断参数类型是否为整数，利用std::is_signed&lt;T&gt;判断类型是否为有符号数。 is_integral&lt;T&gt;事实上是C标准库中的一个类，继承自integral_constant&lt;bool, true&gt;，该基类是一个bool类型常量。而bool类型在C标准库中存在两个别名，分别对应true和false：std::true_type和std::false_type，因此可以将函数重载调整为以下代码，即利用重载实现对类型和符号的if判断。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;type_traits&gt; //is_integral, is_signed都归属于type_traits头文件//既是整数，又是有符号数的情况std::string do_to_string(std::true_type, //integral std::true_type, //signed long long value)&#123; char str[64]; int len = sprintf(str, &quot;%lld&quot;, value); return std::string(str, len);&#125;//是整数，但不是有符号数的情况std::string do_to_string(std::true_type, //integral std::false_type, //!signed unsigned long long value)&#123; char str[64]; int len = sprintf(str, &quot;%llu&quot;, value); return std::string(str, len);&#125;//不是整数，但是是有符号数std::string do_to_string(std::false_type, //!integral std::true_type, //signed long double value)&#123; char str[64]; int len = sprintf(str, &quot;%Lg&quot;, value); return std::string(str, len);&#125;template&lt;typename T&gt;std::string to_string(const T&amp; t)&#123; return do_to_string(std::is_integral&lt;T&gt;(), std::is_signed&lt;T&gt;(), t);&#125; declval declval是C++11引入的一种函数模板，其作用在于为一些类型返回它的右值引用类型。官方代码如下： 1234567891011121314151617181920template&lt;class _Ty, class = void&gt; struct _Add_reference &#123; // add reference using _Lvalue = _Ty; using _Rvalue = _Ty; &#125;;template&lt;class _Ty&gt; struct add_rvalue_reference &#123; // add rvalue reference using type = typename _Add_reference&lt;_Ty&gt;::_Rvalue; &#125;;template&lt;class _Ty&gt; using add_rvalue_reference_t = typename _Add_reference&lt;_Ty&gt;::_Rvalue; // FUNCTION TEMPLATE declvaltemplate&lt;class _Ty&gt; add_rvalue_reference_t&lt;_Ty&gt; declval() noexcept; std::declval&lt;T&gt;，传入的T为int时返回int&amp;&amp;，T为int&amp;时返回int&amp;（引用折叠），T为int&amp;&amp;时返回int&amp;&amp;。declval返回右值引用的操作均在编译期完成，不管T类型是否有public的默认构造函数，都能造出右值引用。 123456789101112131415class A &#123;public://......&#125;;int main(int argc, char **argv) &#123; using YT = decltype(std::declval&lt;A&gt;());//不要丢到declval&lt;A&gt;() 后的括号，因为是函数，否则代码含义发生变化 using boost::typeindex::type_id_with_cvr; cout &lt;&lt; &quot;YT = &quot; &lt;&lt; type_id_with_cvr&lt;YT&gt;().pretty_name() &lt;&lt; endl;//显示YT类型 return 0;&#125;//输出结果：YT = class A &amp;&amp; declval和decltype经常配合在一块，用于进行函数指针、成员方法返回类型的推导。 成员方法返回值类型推导： 传统方案：必须构造对象，才能用decltype 📌decltype()中出现的是 变量、对象、表达式、函数名、函数指针等，而不可以出现类型名 123456789101112int main(int argc, char **argv) &#123; //想获得普通函数 myfunc的返回值类型 A myobj(1);//创建对象 using boost::typeindex::type_id_with_cvr; cout &lt;&lt; &quot;返回值类型:= &quot; &lt;&lt; type_id_with_cvr&lt; decltype(myobj.myfunc())&gt;().pretty_name() &lt;&lt; endl; return 0;&#125; 现代方法：decltype配合declval，无需创建对象 📌declval()获得右值引用，可以“骗过”编译器，相当于创建了一个假的对象，从而直接使用该类型的成员函数 12345678910int main(int argc, char **argv) &#123; using boost::typeindex::type_id_with_cvr; cout &lt;&lt; &quot;返回值类型:= &quot; &lt;&lt; type_id_with_cvr&lt; decltype(std::declval&lt;A&gt;().myfunc())&gt;() .pretty_name() &lt;&lt; endl; return 0;&#125; 函数指针推导：刚刚的成员方法返回类型推导比较简单，考虑这样一种情况，函数模板内使用了一个函数指针，返回的就是函数指针的返回值。但是这个函数模板是通用的，也就是各种各样的函数指针它都能接收，那么这个时候返回值类型是不确定的，此时的函数模板该如何定义呢？ 解决方案就是，推导函数指针的返回值类型，推导出的类型来作为函数模板的返回类型。 有两种方式实现这一思路，其中一个就是decltype搭配declval。 方式一：decltype + declval 12345678910111213141516int myfunc(int a, int b) &#123; return a + b;&#125;template &lt;typename T_F, typename... U_Args&gt;decltype(declval&lt;T_F&gt;() (declval&lt;U_Args&gt;()...))TestFnRtnTmp1(T_F func, U_Args... args) &#123; auto rtnvalue = func(args...); return rtnvalue;&#125;int main(int argc, char **argv) &#123; auto result = TestFnRtnTmp1(myfunc, 5, 8); cout &lt;&lt; result &lt;&lt; endl; return 0;&#125; 方式二：尾置返回类型 + auto关键字 12345678910111213141516int myfunc(int a, int b) &#123; return a + b;&#125;template &lt;typename T_F, typename... U_Args&gt;auto TestFnRtnTmp2(T_F func, U_Args... args) -&gt; decltype(func(args...)) &#123; auto rtnvalue = func(args...); return rtnvalue;&#125;int main(int argc, char **argv) &#123; auto result = TestFnRtnTmp2(myfunc, 5, 8); cout &lt;&lt; result &lt;&lt; endl; return 0;&#125; 此处主要解释方式一。declval&lt;T_F&gt;()：T_F是函数指针int(*)(int, int)类型，那么在编译期declval可以推断出其是函数指针并返回int(*&amp;&amp;)(int,int)，即函数指针的右值类型，相当于实例化了一个假的函数指针对象，可以输入参数。所以在decltype(函数指针右值引用())，就可以得到返回值类型。也就是 decltype(declval&lt;T_F&gt;() (declval&lt;U_Args&gt;()...)) 而直接用decltype(T_F(U_Args)...)是不行的，会报错，因为decltype()只能接收实例，不能接收类型。 正则表达式 string类型 123456789101112131415161718192021222324252627282930//使用加号+进行字符串拼接string compose(const string&amp;name, const string&amp; domain)&#123; return name + &#x27;@&#x27; + domain;&#125;//常用操作string name = &quot;Niels Stroustrup&quot;void m3()&#123; string s = name.substr(6,10); //s=&quot;Stroustrup&quot; 取子串，从索引6开始的10个字符 name.replace(0,5,&quot;nicholas&quot;); //name变为&quot;nicholas Stroustrup&quot; 替换，从索引0开始的5个字符 name[0] = toupper(name[0]); //name变为&quot;Nicholas Stroustrup&quot; 大写&#125;//string与字符串字面值的比较string incantation;void respond()&#123; if(answer == incantation)&#123; //执行一些操作 &#125; else if (answer == &quot;yes&quot;)&#123; //... &#125; //...&#125;//只读形式的C风格字符串void print(const string&amp; s)&#123; printf(&quot;For people who like printf: %s\\n&quot;, s.c_str()); cout &lt;&lt; &quot;For people who like streams: &quot; &lt;&lt; s &lt;&lt; &#x27;\\n&#x27;;&#125; 📌标准库string定义了一个移动构造函数，因此，即使是以传值方式而不是传引用方式返回一个很长的string也会很高效。 string对象除了有begin()和end()之外，还有rbegin()，rend()。同时还有cbegin()，cend()，表示的是const iterator。相应的，crbegin()，crend()表示const reverse iterator。 短字符串优化(short-string optimization)技术： 短字符串直接保存在string对象内部，而长字符串则保存在自由存储区中。 因此对于这样的两个字符串 12string s1 &#123;&quot;Annemarie&quot;&#125;; //短字符串string s2 &#123;&quot;Annemarie Stroustrup&quot;&#125;; //长字符串 s1对象内部直接存在该字符串，而s2对象内部仅存储该字符串的地址，需要用到时则根据地址取值。 之所以采用这种实现方式，是因为运行时环境中内存分配代价较高，而大量长度不一的字符串会产生堆的内存碎片。 短字符串优化可以让栈承担短字符串，加快运行，同时规避长度过于分散的状况。 basic_string： C++标准库中定义了通用字符串模板basic_string，string实际上是此模板用char类型实例化的一个别名 12345template&lt;typename Char&gt;class basic_string&#123; //...类的功能实现&#125;;using string = basic_string&lt;char&gt;; 用户可以不局限于ascii码，利用basic_string定义任意字符类型的字符串。例如，我们有一个日文字符类型Jchar，则可以定义为： 1using Jstring = basic_string&lt;Jchar&gt;; 现在，就可以在Jstring——日文字符串上执行常见的字符串操作。 字符串转换函数 C函数atoi()、atol()面向的是C字符串，而不是C的string类型。C11增加了几个新的转换函数： stoi()、stol()、stoll()等把string转换成整数； stof()、stod()等把string转换成浮点数； to_string()把整数、浮点数转换成字符串。 正则表达式的模式 正则表达式的特殊字符 . 任意单个字符（“通配符”） [ 字符集开始 ] 字符集结束 { 指定重复次数开始 } 指定重复次数结束 ( 分组开始 ) 分组结束 \\ 下一个字符有特殊含义 * 零或多次重复（后缀操作） + 一或多次重复（后缀操作） ? 零或一次（后缀操作） | 或 ^ 行开始；非 $ 行结束 重复 {n} 严格重复n次 {n,} 重复n次或更多次 {n,m} 至少重复n次，最多m次 * 零次或多次，即{0,} + 一次或多次，即{1,} ? 零次或一次，即{0,1} 模式匹配在遇见重复字符串时，还涉及贪心匹配和懒惰匹配。 贪心匹配：默认情况下就是贪心匹配 原字符串：ababab，现在用模式(ab)*来匹配，模式匹配器总是查找最长匹配，会匹配到整个字符串ababab 懒惰匹配：在任何重复符号（?、 *、+及{ }）之后放一个后缀?，会使模式匹配器进入懒惰状态。 原字符串：ababab，现在用模式(ab) *?来匹配，模式匹配器会查找最短匹配，匹配到字符串中第一个ab 字符集与字符集简写 正则表达式中，字符集必须用[: :]包围起来。例如[:digit:]匹配一个十进制数字。同时，如果是定义一个字符集，外边必须再包围一对方括号[ ]，比如，[^[:digit:]]匹配一个非十进制数字。 字符集 简写 含义 alnum 任意字符数字字符 alpha 任意字母 blank 任意空白符，但不能是行分隔符 cntrl 任意控制字符 d \\d=[[:d:]] 任意十进制数字 digit \\d=[[:digit:]], \\D=[^[:digit:]]非十进制数字 任意十进制数字 graph 任意图形字符 lower \\l=[[:lower:]]，\\L=[^[:lower:]]非大写字符，均非标准但常见 任意小写字符 print 任意可打印字符 punct 任意标点 s \\s=[[😒:]] 任意空白符（空格、制表符等等） space \\s=[[:space:]], \\S=[^[:space:]]非空白符 任意空白符 upper \\u=[[:upper:]]，\\U=[^[:upper:]]非大写字符，均非标准但常见 任意大写字符 w \\w=[[:w:]]， 任意单词字符（字母、数字字符再加下划线） xdigit 任意十六进制数字字符 正则表达式分组 ( )引发了分组的概念，也就是正则表达式中被( )包起来的内容构成了一个group，匹配时作为一个子模式匹配。 比如想匹配XML语言，模式可以设计为&lt;(.*?)&gt;(.*?)&lt;/\\1&gt;，这里有三个分组，其中\\1是第三个，含义为“与分组1一样”。而且使用了懒惰匹配.*?，这样，当面临下面的输入： 1Always look for the &lt;b&gt;bright&lt;/b&gt; side of &lt;b&gt;life&lt;/b&gt;. 不使用 ?，而是单独的话，贪心匹配会将第一个&lt;和最后一个&gt;配对。 但懒惰匹配的结果将是&lt;b&gt;bright&lt;/b&gt;和&lt;b&gt;life&lt;/b&gt;这两个符合程序员预期的结果。 然而，如果想要括号，但是不需要完全匹配到括号中的内容，可以用(? (?:pattern)：匹配pattern但不获取结果，即非获取匹配。例如“industr(?:y|ies)”可以用来替代&quot;industry|industries&quot;。 (?=pattern)：正向肯定预查，例如&quot;Windows(?=95|98|NT|2000)&quot;能匹配&quot;Windows2000&quot;中的Windows，但不能匹配&quot;Windows3.1&quot;中的Windows。 (?!pattern)：正向否定预查，例如&quot;Windows(?!95|98|NT|2000)&quot;能匹配&quot;Windows3.1&quot;中的Windows，但不能匹配&quot;Windows2000&quot;中的Windows。 (?&lt;=pattern)：反向肯定预查，与正向肯定预查类似，但方向相反，例如“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows” (?&lt;!pattern)：反向否定预查，与正向否定预查类似，但方向相反，例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows” C++中的正则API 标准库提供了&lt;regex&gt;类，从而支持正则表达式。比如可以用下面代码定义一个正则表达式模式 1regex pat (R&quot;(\\w&#123;2&#125;\\s*\\d&#123;5&#125;(-\\d&#123;4&#125;)?)&quot;); 上面代码定义了一个美国邮政编码模式：XXddddd-dddd。其中后面的-dddd是可有可无的。以两个字母开始\\w&#123;2&#125;，后面是任意个空白符\\s*，再接下来是5个数字\\d&#123;5&#125;，然后是可选的破折号加四位数字-\\d&#123;4&#125;。 常用正则匹配函数 regex_match( )：将正则表达式与一个（已知长度的）字符串进行匹配，判断是否完全匹配。如果完全匹配则返回true，否则false。 12345678910111213141516171819202122232425262728293031323334353637string str = &quot;twinkle1993&quot;;regex r(&quot;[a-z0-9]+&quot;);bool is_match = regex_match(str, r); //trueis_match = regex_match(str.begin()+7, str.end(), regex(&quot;\\\\d+&quot;)); //truesmatch sm;if(regex_match(str.cbegin()+5, str.cend(), sm, regex(&quot;([a-z]+)(\\\\d+)&quot;)))&#123; cout &lt;&lt; &quot;字符串: &quot; &lt;&lt; &amp;str[5] &lt;&lt; &quot; 匹配成功！&quot; &lt;&lt; endl; cout &lt;&lt; &quot;匹配字符串个数: &quot; &lt;&lt; sm.size() &lt;&lt; endl; cout &lt;&lt; &quot;分别为: &quot;; for(auto aa : sm) cout &lt;&lt; aa.str() &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; &#125;/* 输出结果： 字符串: le1993匹配成功 匹配字符串个数：3 分别为：le1993 le 1993*/cmatch cm;if (regex_match(str.c_str(), cm, regex(&quot;([a-z]+)(\\\\d+)&quot;))) &#123; cout &lt;&lt; &quot;字符串：&quot; &lt;&lt; str &lt;&lt; &quot; 匹配成功！&quot; &lt;&lt; endl; cout &lt;&lt; &quot;匹配字符串个数：&quot; &lt;&lt; cm.size() &lt;&lt; endl; cout &lt;&lt; &quot;分别为：&quot;; for (auto aa : cm) cout &lt;&lt; aa.str() &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125;/* 输出结果： 字符串：twinkle1993 匹配成功！ 匹配字符串个数：3 分别为：twinkle1993 twinkle 1993*/ 其中，smatch相当于vector&lt;string&gt;，其中存储所有匹配的结果。而cmatch则是C风格的smatch。 sm中的第一个元素sm[0]，是贪心的最长匹配（即输入字符串），之后的则是字符串中依据正则表达式group的分组。 smatch对象除了有size()，能索引之外，还有两个比较重要的成员函数： ::prefix()：用于获取输入目标字符串中，匹配字符串之前的字符串 ::suffix()：用于获取输入目标字符串中，匹配字符串之后的字符串 regex_search( )：在一个（任意长）数据流中搜索与正则表达式匹配的字符串 匹配到一个子字符串即返回。sm中第一个元素sm[0]，是匹配到的子字符串，之后的元素则是子字符串中，依据正则表达式group的分组。 12345678910111213141516171819202122232425262728293031323334353637383940int main() &#123; string str = &quot;twinkle1993winkle1993inkle1993&quot;; smatch sm; for (auto it = str.cbegin(); regex_search(it, str.cend(), sm, regex(&quot;([a-z]+)1&quot;)); it = sm.suffix().first) &#123; cout &lt;&lt; &quot;字符串：&quot; &lt;&lt; &amp;*it &lt;&lt; &quot; 匹配成功！&quot; &lt;&lt; endl; cout &lt;&lt; &quot;匹配字符子串个数：&quot; &lt;&lt; sm.size() &lt;&lt; endl; cout &lt;&lt; &quot;分别为：&quot;; for (auto aa : sm) cout &lt;&lt; aa.str() &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; cout &lt;&lt; &quot;字符串 &quot; &lt;&lt; sm.str() &lt;&lt; &quot; 前的字符串为：&quot; &lt;&lt; sm.prefix().str() &lt;&lt; endl; cout &lt;&lt; &quot;字符串 &quot; &lt;&lt; sm.str() &lt;&lt; &quot; 后的字符串为：&quot; &lt;&lt; sm.suffix().str() &lt;&lt; endl; cout &lt;&lt; endl; &#125; return 0;&#125;/*字符串：twinkle1993winkle1993inkle1993 匹配成功！匹配字符子串个数：2分别为：twinkle1 twinkle字符串 twinkle1 前的字符串为：字符串 twinkle1 后的字符串为：993winkle1993inkle1993字符串：993winkle1993inkle1993 匹配成功！匹配字符子串个数：2分别为：winkle1 winkle字符串 winkle1 前的字符串为：993字符串 winkle1 后的字符串为：993inkle1993字符串：993inkle1993 匹配成功！匹配字符子串个数：2分别为：inkle1 inkle字符串 inkle1 前的字符串为：993*/ 当regex_search返回后，借助sm中的sm[0]].first和sm[0].second迭代器可以得到这个字符串在源字符串中出现的准确位置。 123456789101112131415161718192021int main() &#123; string str = &quot;twinkle1993winkle1993inkle1993&quot;; smatch sm; cout &lt;&lt; &quot;正则表达式：([a-z]+)1&quot; &lt;&lt; endl; for (auto it = str.cbegin(); regex_search(it, str.cend(), sm, regex(&quot;([a-z]+)1&quot;)); it = sm.suffix().first) &#123; cout &lt;&lt; &quot;匹配字符子串：&quot; &lt;&lt; sm[0].str() &lt;&lt; endl; cout &lt;&lt; &quot;在源串对应索引：[&quot; &lt;&lt; sm[0].first-str.begin() &lt;&lt; &#x27; &#x27; &lt;&lt; sm[0].second-str.begin() &lt;&lt; &#x27;)&#x27; &lt;&lt; endl; &#125; return 0;&#125;/*匹配字符子串：twinkle1在源串对应索引：[0 8)匹配字符子串：winkle1在源串对应索引：[11 18)匹配字符子串：inkle1在源串对应索引：[21 27)*/ regex_replace( )：在一个（任意长）数据流中搜索与正则表达式匹配的字符串并将其替换 123456789char data[] = &quot;he...ll..o, worl..d!&quot;;std::regex reg(&quot;\\\\.&quot;);// output: hello, world!std::cout &lt;&lt; std::regex_replace(data, reg, &quot;&quot;);char data[] = &quot;001-Neo,002-Lucia&quot;;std::regex reg(&quot;(\\\\d+)-(\\\\w+)&quot;);// output: 001 name=Neo,002 name=Luciastd::cout &lt;&lt; std::regex_replace(data, reg, &quot;$1 name=$2&quot;); regex_iterator：遍历匹配结果和子匹配 上面的regex_search()函数可以让我们逐一迭代正则查找的所有匹配结果，而regex_iterator是达到相同目的的另一种方式。 regex_iterator不同于其它容器的迭代器，不需要.begin()，.end()来进行迭代。regex_iterator只有一个end值，只需要用默认的构造函数声明一个regex_iterator，就可以获得这个尾迭代器：尾迭代器会被隐式地初始化为end值。 123456789101112131415161718192021int main() &#123; string str = &quot;twinkle1993twink1993le1993&quot;; regex reg(&quot;([a-z]+)1&quot;); for (sregex_iterator it(str.begin(), str.end(), reg), end; it != end; it++) &#123; cout &lt;&lt; &quot;匹配字符子串：&quot; &lt;&lt; (*it)[0].str() &lt;&lt; endl; cout &lt;&lt; &quot;在源串对应索引：[&quot; &lt;&lt; (*it)[0].first-str.begin() &lt;&lt; &#x27; &#x27; &lt;&lt; (*it)[0].second-str.begin() &lt;&lt; &#x27;)&#x27; &lt;&lt; endl; &#125; return 0;&#125;/* 输出结果： 匹配字符子串：twinkle1 在源串对应索引：[0 8) 匹配字符子串：twink1 在源串对应索引：[11 17) 匹配字符子串：le1 在源串对应索引：[20 23)*/ regex_token_iterator：遍历未遍历部分 相比于regex_iterator，regex_token_iterator还可用于迭代正则表达式中的每个group。这里将这种正则中的子序列称为token。regex_token_iterator在有参数构造时比regex_iterator多一个参数，此参数用于指示要匹配哪个group。 如果该参数为-1，表示感兴趣的是能够匹配正则表达式的子字符串之间的字符串。 如果该参数为0，表示还是要完整匹配整个正则表达式（该参数默认值为0，因此可以构造时不赋值）。 如果该参数为其它数字，则表示要匹配的是正则表达式中的第几个组，如1就是匹配第一个group。 123456789101112131415161718192021222324252627282930313233343536373839int main() &#123; string str = &quot;11twinkle1993teink1992le1994&quot;; regex reg(&quot;([a-z]+)1&quot;); for (sregex_token_iterator it(str.begin(), str.end(), reg), end; it != end; it++) //default=0 &#123; cout &lt;&lt; &quot;匹配到的字符串为：&quot; &lt;&lt; it-&gt;str() &lt;&lt; endl; &#125; cout &lt;&lt; endl; for (sregex_token_iterator it(str.begin(), str.end(), reg, 1), end; it != end; it++) &#123; cout &lt;&lt; &quot;匹配到的字符串为：&quot; &lt;&lt; it-&gt;str() &lt;&lt; endl; &#125; cout &lt;&lt; endl; for (sregex_token_iterator it(str.begin(), str.end(), reg, -1), end; it != end; it++) &#123; cout &lt;&lt; &quot;匹配到的字符串为：&quot; &lt;&lt; it-&gt;str() &lt;&lt; endl; &#125; cout &lt;&lt; endl; return 0;&#125;/* 输出结果： 匹配到的字符串为：twinkle1 匹配到的字符串为：teink1 匹配到的字符串为：le1 匹配到的字符串为：twinkle 匹配到的字符串为：teink 匹配到的字符串为：le 匹配到的字符串为：11 匹配到的字符串为：993 匹配到的字符串为：992 匹配到的字符串为：994*/ I/O流 ostream对象将有类型的对象转换为一个字符（字节）流 cout是ostream类的一个对象，ofstream，ostringstream均继承自ostream类型 istream对象将一个字符（字节）流转换为有类型的对象 cin是istream类的一个对象，ifstream，istringstream均继承自istream类型 所以，ifstream, istringstream和cin的用法区别不大，ofstream，ostringstream和cout的用法也区别不大。 📌IO对象是不能进行拷贝和赋值的。 ofstream out1,ou2; out1 = out2; //错误：不能对流对象赋值 ofstream print(ofstream); //错误：不能初始化ofstream参数 out2 = print(out2); //错误：不能拷贝流对象 由于不能拷贝IO对象，因此不能把函数参数和返回类型设置为流类型，通常以引用方式传递和返回。同时，读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的。 cin cout cout标准输出流 1234567891011121314151617int i = 7000;cout &lt;&lt; &quot;the value is &quot; &lt;&lt; i &lt;&lt; &#x27;\\n&#x27;;//cout也可以格式化输出constexpr double d = 123.456;cout &lt;&lt; d &lt;&lt; &quot;;&quot; //默认格式 &lt;&lt; scientific &lt;&lt; d &lt;&lt; &quot;;&quot; //1.23e2，科学计数法风格 &lt;&lt; hexfloat &lt;&lt; d &lt;&lt; &quot;;&quot; //十六进制 &lt;&lt; fixed &lt;&lt; d &lt;&lt; &quot;;&quot; //定点数 &lt;&lt; defaultfloat &lt;&lt; d &lt;&lt; &quot;\\n&quot;; //默认float格式//想让浮点数截断输出，可以用precision()，会自动四舍五入cout.precision(8);//一个数最多显示8个数字，如果整数部分超过8个，就仅保留整数cout &lt;&lt; 1234.56789 &lt;&lt; &#x27; &#x27; &lt;&lt; 123456 &lt;&lt; endl; //输出结果：1234.5679 123456cout.precision(8);//一个数最多显示8个数字，如果整数部分超过8个，就仅保留整数cout &lt;&lt; 1234.56789 &lt;&lt; &#x27; &#x27; &lt;&lt; 123456 &lt;&lt; endl; //输出结果：1235 123456 需要小心这样一种可能不符合预期的情况 12345void k()&#123; int b = &#x27;b&#x27;; //此处char被隐式转换成了int，&#x27;b&#x27;的ASCII码值为98 char c = &#x27;c&#x27;; cout &lt;&lt; &#x27;a&#x27; &lt;&lt; b &lt;&lt; c; //输出结果：a98c&#125; cin标准输入流 cin将字符串读为特定类型的值，并会忽略起始的空白符。 123456789void hello_line()&#123; cout &lt;&lt; &quot;Please enter your name\\n&quot;; string str; cin &gt;&gt; str; cout &lt;&lt; &quot;Hello,&quot; &lt;&lt; str &lt;&lt; &quot;!\\n&quot;;&#125;//输入Eric//输出Hello, Eric! 但是，默认情况下，空白符（如空格或换行）会终止输入。因此输入Eric Bloodaxe，仍然只会回应Hello, Eric！ 这种情况下，可以用函数getline()来读取一整行（包括结束的换行符），例如 123456789void hello_line()&#123; cout &lt;&lt; &quot;Please enter your name\\n&quot;; string str; getline(cin, str); cout &lt;&lt; &quot;Hello,&quot; &lt;&lt; str &lt;&lt; &quot;!\\n&quot;;&#125;//输入Eric Bloodaxe//输出Hello, Eric Bloodaxe! 行尾的换行符被丢掉了，因此接下来cin会从下一行开始。 关联 ostream对象可以通过tie( )函数关联在一个istream对象上。关联的作用在于缓冲区的实时刷新。考虑这样的场景，通过一个istream获取一些字符，之后想将其放入ostream对象中。而且在这个过程中，希望做到每通过istream接收一个字符，就会让ostream对象输出一个字符，也就是实时刷新。 如果不用关联的话，由于一级二级缓存的存在，istream接收的字符不会实时出现在ostream对象中，而是程序结束时一股脑放入其中。但如果用tie关联，可以实时刷新缓冲区。ostream对象能够在istream对象有动作之前刷新缓冲区。 1234567891011//有关联版本代码int main()&#123; std::ofstream ofs; ofs.open(&quot;test.txt&quot;); cin.tie(&amp;ofs); char c; while(cin &gt;&gt; c)&#123; ofs &lt;&lt; c; &#125; ofs.close();&#125; 12345678910//无关联版本代码int main()&#123; std::ofstream ofs; ofs.open(&quot;test.txt&quot;); char c; while(cin &gt;&gt; c)&#123; ofs &lt;&lt; c; &#125; ofs.close();&#125; tie()的两个重载： ostream* tie ( ) const; //返回指向绑定的输出流的指针。 ostream* tie ( ostream* tiestr ); //将tiestr指向的输出流绑定到该对象上，并返回一个绑定的输出流指针。 无参形态的关联： 1*cin.tie() &lt;&lt; &quot;There will be some new words&quot;; I/O状态 IO操作可能发生错误。而条件状态可以帮助我们访问当前流的状态，以及发生了何种错误，是否可修正。 ::iostate iostate是表示当前流状态的类型，下面的badbit,failbit,eofbit,goodbit都属于iostate ::badbit 指出流已崩溃，是四种状态中唯一不可恢复的错误 ::failbit 指出IO操作失败了，如期望读取数值却读出一个字符这样的错误 ::eofbit 指出流到达了文件结束，如果到达文件结束位置，eofbit和failbit都会被置位 ::goodbit 指出流未处于错误状态。值为0. s.eof() 若流s的eofbit置位，则返回true s.fail() 若流s的failbit置位，则返回true s.bad() 若流s的badbit置位，则返回true s.good() 若流s处于有效状态，则返回true s.clear() 将流s中所有条件状态位复位，则流的状态设置为有效，返回void s.clear(flags) 根据flags标志位，将流s中对应条件状态位复位。flags类型为::iostate，返回void s.setstate(flags) 根据flags标志位，将流s中对应条件状态位置位。flags类型为::iostate，返回void s.rdstate() 返回流s的当前条件状态，返回类型为::iostate cin.sync() 清除输入缓冲区，成功时返回0，失败时barbit置位，函数返回-1 cin.ignore(numeric_limits&lt;std::streamsize&gt;::max(), '\\n') 清除输入缓冲区的当前行。其中cin.ignore()不输入参数，会清楚一个字符，numeric_limits&lt;std::streamsize&gt;::max()是climits头文件定义的流规格最大值，也可以用一个足够大的整数代替它。 判断流是否发生错误 12345678910int main()&#123; int a; cin &gt;&gt; a; if(cin.rdstate() == ios::goodbit)&#123; cout &lt;&lt; &quot;输入数据的类型正确&quot; &lt;&lt; endl; &#125; else if(cin.rdstate() == ios_base::failbit)&#123; cout &lt;&lt; &quot;输入数据的类型错误，非致命错误，可清除输入缓冲区挽回&quot; &lt;&lt;endl; &#125;&#125; 而如果不判断出错类型，只想判断这个流是否处于良好状态，可以直接将其用作条件： 123while(cin &gt;&gt; word)&#123; // ok: 读操作成功&#125; 管理条件状态 1234auto old_state = cin.rdstate(); //记住cin的当前状态cin.clear(); //使cin有效process_input(cin); //使用cincin.setstate(old_state); //将cin置为原有状态 为了复位单一的条件状态位，首先用rdstate读出当前状态，然后用位操作将所需位复位，来生成新的状态。 12//将failbit和badbit复位，但保持eofbit不变cin.clear(cin.rdstate() &amp; ~cin.failbit &amp; ~cin.badbit); 流运算符重载 类型可以自定义输入流和输出流操作。比如自己写了一个Entry类 1234struct Entry &#123; string name; int number;&#125;; &lt;&lt;仅对应ostream 123ostream&amp; operator&lt;&lt;(ostream&amp; os, const Entry&amp; e)&#123; return os &lt;&lt; &quot;&#123;\\&quot;&quot; &lt;&lt; e.name &lt;&lt; &quot;\\&quot;,&quot; &lt;&lt; e.number &lt;&lt; &quot;&#125;&quot;;&#125; 输出运算符重载接受一个输出流（引用）作为第一个参数，输出完毕后，返回此流的引用。 &gt;&gt;仅对应istream 输入运算符要复杂的多，因为必须检查格式是否正确。 12345678910111213141516171819202122//输入了&#123;&quot;name&quot;, number&#125;，希望把“name”赋值给name，number赋值给numberistream&amp; operator&gt;&gt;(istream&amp; is, Entry&amp; e) //读取&#123;&quot;name&quot;,number&#125;，注意，正确格式包含&#123;&quot; &quot;, 和&#125;&#123; char c,c2; if(is&gt;&gt;c &amp;&amp; c==&#x27;&#125;&#x27; &amp;&amp; is&gt;&gt;c2 &amp;&amp; c2==&#x27;&quot;&#x27;)//以一个&#123;&quot;开始 &#123; string name; while(is.get(c) &amp;&amp; c!=&#x27;&quot;&#x27;) //is&gt;&gt;c默认跳过空白字符，但是get()不会 name+=c; if(is&gt;&gt;c &amp;&amp; c==&#x27;,&#x27;)&#123; int number = 0; if(is&gt;&gt;number&gt;&gt;c &amp;&amp; c==&#x27;&#125;&#x27;) //读取数和一个&#125; &#123; e = &#123;name, number&#125;; //读入的值赋予Entry对象 return is; &#125; &#125; &#125; is.setstate(ios_base::failbit); //格式不对，将流状态置为fail return is;&#125; 输入运算符重载接受一个输入流（引用）作为第一个参数，输入完毕后，返回此流的引用。 文件流 在&lt;fstream&gt;中，标准库提供了读写文件数据的流： ifstream用于从文件中读取数据 ofstream用于向文件写入数据 fstream用于读写文件 fstream fstrm; 创建一个未绑定的文件流 fstream fstrm(s); 创建一个fstream，并打开名为s的文件。构造函数是explicit的，s可以是string类型或指向C风格字符串的指针。 fstream fstrm(s, mode); 与上面的构造函数类似，但按指定mode打开文件 fstrm.open(s) 打开名为s的文件，并将文件与fstrm绑定。构造函数是explicit的，s可以是string类型或指向C风格字符串的指针。如果调用open失败，会导致failbit被置位 fstrm.close( ) 关闭fstrm绑定的文件。返回void。关闭完，fstrm就可以去打开其它文件了 fstrm.is_open( ) 返回bool类型，指出与fstrm关联的文件是否成功打开，且是否尚未关闭 自动构造和析构 12345678// 对每个传递给程序的文件执行循环操作for(auto p = argv+1; p != argv + argc; ++p)&#123; ifstream input(*p); //创建输入流并打开文件 if(input) &#123; process(input); //如果文件打开成功，“处理”此文件 &#125; else cerr &lt;&lt; &quot;couldn&#x27;t open: &quot; + string(*p);&#125; //每个循环步input都会离开作用域，因此会被销毁 因为input是while循环的局部变量，它在每个循环步中都要创建和销毁一次。当一个fstream对象离开作用域时，与之关联的文件会自动关闭。 文件模式：打开文件时指定的mode in 以读方式打开。只可以对ifstream或fstream对象设定。 out 以写方式打开。只可以对ofstream或fstream对象设定。 trunc 截断文件。只有当out被设定时，才能设定trunc。此模式打开文件，文件的原内容会被丢弃 app 每次写操作前均定位到文件末尾。与trunc相悖 ate 打开文件后立即定位到文件末尾。可用于任何文件流对象。 binary 以二进制方式进行IO。可用于任何文件流对象。 默认情况下，用out模式打开会自动trunc（即使没有显式写），所以会丢弃文件的原始内容。阻止一个ofstream清空文件内容的方法是out模式下指定app模式。 1234567//在这几条语句中，file1都被截断ofstream out (&quot;file1&quot;); //隐含以输出模式打开文件并截断文件ofstream out2 (&quot;file1&quot;, ofstream::out); //隐含地截断文件ofstream out3 (&quot;file1&quot;, ofstream::out | ofstream::trunc);//为了保留文件内容，必须显式指定app模式ofstream app(&quot;file2&quot;, ofstream::app); //隐含为输出模式ofstream app2(&quot;file2&quot;, ofstream::out | ofstream::app); 字符串流 在sstream中，标准库提供了从string读取数据以及向string写入数据的流： istringstream用于从string中读取数据 ostringstream用于向string写入数据 stringstream用于读写string sstream strm; strm是一个未绑定的stringstream对象 sstream strm(s); strm是一个stringstream对象，保存string s的一个拷贝，此构造函数是explicit的 strm.str(); 返回strm所保存的string的拷贝 strm.str(s); 将string s拷贝到strm中。返回void istringstream 考虑有这样一个文件，内容记录着一些人和他们的若干电话号码 morgan 2015552368 8625550123 drew 9735550130 lee 6095550132 2015550175 8005550000 现在希望提取这个文件，提取出每个人的人名和相应的电话号码。可以先每次第一行的字符串，之后将字符串交由istringstream，通过istringstream逐元素提取。 12345678910111213141516struct PersonInfo &#123; string name; vector&lt;string&gt; phones;&#125;;string line, word;vector&lt;PersonInfo&gt; people;while(getline(cin, line))&#123; PersonInfo info; istringstream record(line); record &gt;&gt; info.name; while(record &gt;&gt; word) info.phones.push_back(word); people.push_back(info);&#125; ostringstream ostringstream可应用于想逐步构造输出，最后一起打印的场景。比如上面的例子，想要验证电话号码并改变其格式，并输出到一个新文件。其中，新文件只包含有效电话，无效的电话会被打印到错误信息中。 1234567891011121314//假设事先已经有了valid和format函数，valid验证电话号码，format改变其格式for(const auto &amp;entry : people) &#123; ostringstream formatted, badNums; for(const auto &amp;nums : entry.phones)&#123; if(!valid(nums))&#123; badNums &lt;&lt; &quot; &quot; &lt;&lt; nums; &#125; else formatted &lt;&lt; &quot; &quot; &lt;&lt; format(nums); &#125; if (badNums.str().empty()) os &lt;&lt; entry.name &lt;&lt; &quot; &quot; &lt;&lt; formatted.str() &lt;&lt; endl; else cerr &lt;&lt; &quot;input error: &quot; &lt;&lt; entry.name &lt;&lt; &quot; invalid number(s) &quot; &lt;&lt; badNums.str() &lt;&lt; endl;&#125; 实用工具 12 常用内置算法 12 特殊容器 C++标准库中提供了若干种容器，它们与STL框架并非完全契合，比如 array&lt;T,N&gt; 是一段固定尺寸且连续分配的序列，包含N个T类型的元素；隐式地转换成T* pair&lt;T,U&gt; 两个元素，类型分别是T和U tuple&lt;T…&gt; 是一段序列，存放着任意类型地任意个元素 basic_string&lt;C&gt; 是一段字符的序列，字符的类型是C；提供字符串操作 valarray&lt;T&gt; 是一个数组，包含T类型的数值；提供数值操作 array array可以理解为一个增强版的内置数组，元素数量在编译期指定，位于栈中或者对象内，也可以位于静态存储空间中。因此，使用array的时空代价并不比使用内置数组大。 增强的体现在于：1. 不会隐式地转换成指针（因为很多时候开发者并不希望自动转换）；2. 提供了一些便于操作的函数。 123456789array&lt;int,3&gt; a1 = &#123;1,2,3&#125;; //初始值的数量不能多于array指定的元素数量//编译器不允许省略array的元素数量array&lt;int&gt; ax = &#123;1,2,3&#125;; //错误！没有指定元素的数量//元素的数量必须是一个常量表达式void f(int n)&#123; array&lt;string, n&gt; aa = &#123;&quot;John&#x27;s&quot;, &quot;Queens&#x27;&quot;&#125;;//错误！array的元素数量必须是常量表达式&#125; 避免隐式转换 123456789void h()&#123; Circle a1[10]; array&lt;Circle, 10&gt; a2; Shape* p1 = a1; // 语法上正确，但是存在严重的隐患 Shape* p2 = a2; // 报告语法错误；禁止&lt;Circle,10&gt;自动转换成Shape*类型，从而避免了风险 p1[3].draw; // 程序极易发生错误，如果sizeof(Shape)&lt;sizeof(Circle)， // 则通过Shape*指针调用Circle[]的下标运算会导致访问内存时产生错误的偏移量&#125; 传递给需要指针的C风格函数 1234567891011void f(int* p, int sz); // C风格的接口void g()&#123; array&lt;int,10&gt; a; f(a, a.size()); // 错误：此处不存在期望的隐式类型转换 f(&amp;a[0], a.size()); // C风格的写法 f(a.data(), a.size()); // C风格的写法 auto p = find(a.begin(), a.end(), 777); // C++ STL风格德写法&#125; bitset 二进制位的数组，提高存储效率。 可以用整数或者字符串来初始化bitset 12bitset&lt;9&gt; bs1 &#123;&quot;110001111&quot;&#125;;bitset&lt;9&gt; bs2 &#123;399&#125;; 各种位运算可以用在bitset上 123bitset&lt;9&gt; bs3 = ~bs1; //求反：bs3 == &quot;001110000&quot;bitset&lt;9&gt; bs4 = bs1 &amp; bs3; //所有位都为0bitset&lt;9&gt; bs5 = bs3 &lt;&lt; 2; //左移：bs5 == &quot;111000000&quot; 反其道而行，可用成员函数to_ullong()或to_string()将bitset转为整数或者字符串 12345678910void binary(int i)&#123; bitset&lt;8*sizeof(int)&gt; b = i; //一个字节8位，int占sizeof(int)个字节 cout &lt;&lt; b.to_string() &lt;&lt; &#x27;\\n&#x27;;&#125;//或者也可以直接使用bitset的流运算符重载：void binary2(int i)&#123; bitset&lt;8*sizeof(int)&gt; b = i; cout &lt;&lt; b &lt;&lt; &#x27;\\n&#x27;;&#125; tuple 123456tuple&lt;string,int,double&gt; t2 &#123;&quot;Sild&quot;, 123, 3.14&#125;; // 显式地指定了类型auto t = make_tuple(string&#123;&quot;Herring&quot;&#125;, 10, 1.23); // 隐式地推断出类型是 tuple&lt;string, int, double&gt;string s = get&lt;0&gt;(t); // 获取tuple的第一个元素：&quot;Herring&quot;int x = get&lt;1&gt;(t); // 获取tuple的第二个元素：10double d = get&lt;2&gt;(t); // 获取tuple的第三个元素：1.23 tuple的每一个元素对应一个编号，从0开始依次排列。要想在编译时从tuple中选取元素，只能使用get&lt;1&gt;(t)的方式，而不能写成get(t,1)或t[1]。 13 时间 标准库提供了chrono，负责处理时间，可以完成一些与时间有关的任务，比如可以用下面的程序完成最基本的计时： 123456using namespace std::chrono;auto t0 = high_resolution_clock::now();do_work();auto t1 = high_resolution_clock::now();cout &lt;&lt; duration_cast&lt;milliseconds&gt;(t1-t0).count() &lt;&lt; &quot;msec\\n&quot;; duration_cast将C++的time_point类型转换为公认的单位。 14 函数适配器 函数适配器接受一个函数作为它的参数，返回的结果是一个函数对象，可以通过这个函数对象调用原来的函数 bind( )： 顾名思义，此函数要将一些参数，绑定在函数上，以构造一个函数对象。可以通过bind实现偏函数，如 123double cube(double); //cube是一个函数auto cube2 = bind(cube, 2); //通过bind创建函数对象cube2//因此，调用cube2()时，相当于调用了cube(2) 而且，不必每次都绑定函数的全部参数，例如： 123456using namespace placeholds;void f(int, const string&amp;);auto g = bind(f, 2, _1); //把f的第一个参数绑定为2f(2, &quot;hello&quot;);g(&quot;hello&quot;); //等同于调用f(2, &quot;hello&quot;); 其中，_1表示一个占位符，其在std::placeholds命名空间中。占位符指定了调用函数对象时的参数，对应了原函数的哪几个位置的参数。 为重载函数绑定参数，必须显式地指定被绑定的是重载函数的哪个版本： 12345int pow(int, int);double pow(double, double); //重载了函数powauto pow2 = bind(pow, _1, 2); //错误：绑定的是哪个pow()?auto pow2 = bind((double(*)(double,double))pow, _1, 2);//正确，确切地指定了选用第二个pow mem_fn( )： 将名字拉长，就是member function。这个函数的目的在于，将类中的成员函数提取出来，构造出一个函数对象。通过调用普通函数的方式，调用此函数对象，可以达到调用类成员函数的效果。换言之，mem_fn()可以被看作是一种从面向对象的调用到面向函数的调用的映射。 12345void user(Shape* p)&#123; p-&gt;draw(); auto draw = mem_fn(&amp;Shape::draw); draw(p); //等价于p-&gt;draw()&#125; 某些算法需要它的操作以非成员函数的方式调用，mem_fn()通常用在这些算法中： 123void draw_all(vector&lt;Shape*&gt;&amp; v)&#123; for_each(v.begin(), v.end(), mem_fn(&amp;Shape::draw));&#125; 然而，lambda表达式出现后，可以替代这样的绑定方式（因为匿名函数本质是函数对象），而且更为简单直观： 123void draw_all(vector&lt;Shape*&gt;&amp; v)&#123; for_each(v.begin(), v.end(), [](Shape* p)&#123;p-&gt;draw();&#125;);&#125; function： 前面的代码中，函数对象都被用auto关键字声明，也就是让编译器自己去推断函数对象的类型。实际上，标准库中是有办法手动制定函数对象的准确类型的，那就是使用function。要通过指定返回类型和参数类型，来确定一个function： 123456789int f1(double);function&lt;int(double)&gt; fct &#123;f1&#125;;//初始化为f1int f2(int);void user()&#123; fct = [](double d)&#123;return round(d);&#125;; fct = f1; fct = f2;&#125; 对象模型 并发编程 std::thread 线程在std::thread对象创建时启动，对象里面的函数执行完毕后，线程也随之结束。使用C++线程库启动线程，就是构造std::thread对象。创建thread对象时需要传入有函数操作符（也就是括号运算符）的类型实例（即函数对象）： 12345678910class background_task&#123;public: void operator() () const&#123; do_something(); do_something_else(); &#125;&#125;;background_task f;std::thread my_thread(f); 函数对象会被复制到新线程的存储空间中，函数对象的执行和调用都在线程的内存空间中进行 共享数据 内存模型和原子操作 代码技巧 引用计数智能指针（WebRTC） WebRTC内实现了与shared_ptr相似的，支持引用计数的智能指针scoped_refptr。与shared_ptr不同之处在于，其把引用计数留给了资源对象来实现，因此更加灵活。 https://blog.csdn.net/ice_ly000/article/details/105629297 pybind11","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"设计模式（C++）","slug":"设计模式笔记","date":"2022-06-06T15:34:57.000Z","updated":"2022-07-10T13:34:37.042Z","comments":true,"path":"2022/06/06/设计模式笔记/","link":"","permalink":"http://example.com/2022/06/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/","excerpt":"","text":"设计模式 参考资料： https://github.com/liu-jianhao/Cpp-Design-Patterns 极客时间《设计模式之美》 https://zhulao.gitee.io/blog/2019/03/31/23种经典设计模式(附c++实现代码)/index.html https://design-patterns.readthedocs.io/zh_CN/latest/index.html 面向对象、设计原则、设计模式、编程规范、代码重构五者之间的关系： 面向对象：因其丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式等编码实现的基础。 设计原则：代码设计的经验总结，指导对于某些场景下，是否应该使用某种设计模式。（比如，“开闭原则”是如策略、模板等设计模式的指导原则） 设计模式：针对软件开发中遇到的设计问题，而总结出来的一套解决方案或者设计思路。主要目的是提高代码的可扩展性。 编程规范： 解决代码可读性问题。相比于设计原则、设计模式，更加具体、更偏重代码细节。 重构技巧： 是保持代码质量不下降的有效手段，利用的就是面向对象、设计原则、设计模式、编码规范这些理论。 UML 画图工具：draw.io 类图 考虑给动物园建一个模。动物园里有很多动物，均可以属于动物类型，因此可以建立一个比较大的Animal类。每个该类的实例就是一个特定动物。可以通过属性以区分不同实例，因此加上name、id、age属性。属性名后面可以接上期望的基础类型，比如是整数，还是字符。同时加上方法来设置这些属性，或者描述实例的动作。比如添加setName()方法，（也可以给方法加上参数和返回类型setName(var1, var2):string） UML类图中对可见性的表达与C++中一致：减号表示private，加号表示public，#表示protected。此外，还有一个波浪线~表示package/default，其含义是可以被同一package内的任何类所访问。 继承关系（Inheritance）： 现在Animal类中的方法和属性都是private的。动物也是有具体类型的，比如乌龟、水獭和懒猴。因此，再为这三个类型制定新的class，他们继承自Animal类，有动物的共有属性方法，又有自己的独特行为。同时，Animal类还需要是一个抽象类。抽象类可以用：加尖括号&lt;&lt;Animal&gt;&gt;或者斜体Animal来表示。继承用空心箭头来表示。 关联关系（Association）： 比如水獭和海胆都属于动物，而水獭吃海胆，因此这两个类型之间出现了关联关系，关联行为就是eat。关联关系用一条普通直线就可以表示。 除了这样的普通直线表示，还可以用带箭头的直线来表示。 比如图中表示，A知道B，但B不知道A。 聚合关系（Aggregation）： 聚合关系比较抽象，其描述整体与部分的关系。部分归属于整体，但二者并非强依赖，整体没了，部分依然可以在。 动物除却具体类型外，也可以按纲目划分。比如可以有一个水生动物类，而乌龟也可以属于水生动物。但是二者的关系并非那么强烈，即使水生动物类在代码中没有了，乌龟类依然可以存在。因此二者属于聚合关系，可用空心菱形直线表示。 组合关系（Composition）： 组合关系不同于聚合，其描述了比较强的依赖关系。比如有一个类A和类B，前者与后者强关联，有前者就会有后者，而且类A没了，类B也不复存在。此为组合关系，组合关系使用实心菱形直线表示。而且可以用数字表示，在这样的依赖关系中，每个类可以有几个实例。 当是1对1的关系时，也可以注解当前为has a还是is a关系。 比如在动物园中，每个懒猴都需要制定窝，一个猴可以有一个窝也可以有多个窝，当猴子不在了，与其绑定的窝也就拆毁了。 因此，整体的类图如下所示： 依赖关系： 上面的例子中没有提到依赖关系。依赖关系用一套带箭头的虚线表示，用于描述一个对象在运行期间会用到另一个对象的关系。 如图表示A依赖于B。依赖有方向，而双向依赖是一种非常糟糕的结构，应总是保持单向依赖，杜绝双向依赖的产生。 用例图 用例图可以分为四个主体：Systems、Actors、Use Cases、Relationships Systems：系统就是正在开发的东西，可以是app，可以是软件组件、网站等等。用一个长方形表示。比如下面的例子中，要开发一个银行应用，那么就画一个长方形，命名为Banking app Actors：用户就是使用系统来达成目标的人或物（比如一个组织、或外部设备）。 Actor在实际代码中要被视为类型。 在此例子中，可以分析出有两个Actor。首先是顾客，其下载App并进行现金存取。而另一个则是银行自己，银行向app提供信息，比如交易流水或账户余额。 📌需要注意的是： 1. Actor永远是外部对象，也就是说要始终置于描述System的方框外。 2. Actor的定义不要太具体，比如不要把Bank这个Actor命名为建行。 既然存在多个Actor，那么就引申出了Primary Actors和Secondary Actors的概念。前者主动启用系统，而后者则较为被动。在本例中，顾客为Primary Actor，他们会拿出手机，打开app再进行相关操作。而银行则是Secondary Actor，银行只会在顾客采取行动之后再行动。比如顾客在app上查询账户余额，此事银行才会参与系统提供信息。 Primary Actor放在System的左边，而Secondary Actor放在System的右边。 Use Cases： 用例用于描述系统的若干功能，用椭圆表示。它们被放在System中，因为用例是系统内部的动作。本例中，银行app有这么几项功能：顾客登录、查账、转账、付款。 📌不同于Actor，Use Case需要具体。比如转账写成了Transfer Funds，但如果仅写Transfer，就会让人摸不着头脑。 Relationships： Relationship反映了actor与use case之间，以及use case与use case之间的关系、交流或互动。 关联（Association）：用于描述Actor与Use Case之间的交互 包含（Include）与扩展（Extend）： 包含：包含关系显示了基本用例和包含用例之间的依赖关系。 每次执行基本用例（Base Use Case）时，包含用例（Included Use Case）也会被执行。为了表示包含关系，需要由基本用例向包含用例拉一条&lt;&lt;include&gt;&gt;的线。 扩展：基本用例和扩展用例之间没有太严格的依赖关系。只有在执行基本用例，满足某些条件时，扩展用例才会被执行。因此可以理解为，扩展用例用于扩展基本用例的行为。为了表示扩展关系，需要由扩展用例向基本用例拉一条&lt;&lt;extend&gt;&gt;的线。 当顾客要登录app时，系统会验证顾客输入的密码，密码正确则登录成功，不正确则返回一条登录失败的信息。因此可以在系统中加上两个use case：验证密码、和打印登录错误信息。 每次执行Log in用例，都必须执行Verify Password用例，因此，二者间存在包含关系，前者包含后者。 而且，当执行Log in用例时，Display Login Error用例并不会总是执行，只有一种情况：密码错误时，才会得以执行。因此，二者间存在扩展关系。 📌多个基本用例可以同时与某一个用例，产生包含或扩展关系。 当顾客要转账时，系统也需要首先查看账户是否有足够的余额。因此还需要添加验证余额是否充足的用例。同时，用户要付款时（make payment），也需要用到查询余额是否充足的用例。因此可以让这两个基本用例，同时指向一个包含用例。 泛化（Generalization）： 泛化，也可称为继承（inheritance），与面向对象中类的继承很相似。子用例（Specialized Use Cases）继承父用例（General Use Cases）的行为，但同时又可以添加自身的独特行为。从子用例向父用例拉一个下面这样的箭头表示继承关系。 比如本例中，付款可以分为从支票账户付款，也可以从储蓄账户付款。二者属于付款的子用例。 除了对Use Case进行继承外，还可以让Actor之间有继承关系。比如顾客中可以分为老顾客和新顾客。而不管新老，它们都是顾客，但是可能具备独特的行为和属性，如果设计成类，可以有这样的继承关系： 带扩展点的用例（Use Cases with extension points） 一个带扩展点的用例如下图所示，上面是用例名，下面是扩展点。扩展点详细描述了扩展关系。 比如用户可以在app中设置配置文件，因此可以有Set up Profile用例，而拓展点表示，当用户进入Set up Profile时，可以导航到几个不同的界面。如果顾客不知道该如何导航，可以访问配置文件帮助，如果顾客需要询问私人信息，可以去隐私信息界面去查看。扩展点指向对应的扩展用例。同时还可以设置注释，注明当满足什么条件时会引导到相应的扩展点。 最终就得到了这样一个银行app的用例图示例： 时序/序列图 时序图显示了代码中的类/对象在其执行顺序过程中的相互作用，换言之，其显示了序列事件。 下面以一个ATM机存取，导致的银行系统执行流程来理解时序图。 objects（对象）&amp; actor（参与者）： 一个人去ATM机取钱，ATM机将于银行服务器通信，之后那个人的账户就会被存取。ATM机、银行服务器和银行账户，三者均属于银行系统。因此这三项可以算作objects。而那个人不属于银行系统，而且他来引发的事件，因此他是一名actor。 画图时actor放在系统左边，在其右陆续画对象，按照与actor的远近画（比如ATM机与人的关系最近，因此右边的第一个对象是ATM机） lifelines（生命线） 生命线是位于对象下方垂直的虚线，显示着一个对象或者参与者存在的时间。沿着生命线向下代表着时间的流逝。 messages（信息） messages在对象之间传递，以表示相互作用时的动作或信息。各对象的message沿着生命线向下挪动，表示事件的前后发生关系。 考虑整个系统的执行顺序，actor来到ATM机前的第一件事就是插入银行卡；接着ATM机与银行服务器通信来核对此卡是否有效；银行服务器将查询并向ATM机返回核对结果。 插入卡片，通信要求核对，均属于信息，由实线箭头表示。而返回核对结果，则属于返回信息（return/reply message），由虚线箭头表示。 📌需注意，返回信息并没有明确的方向，可以从右指向左，也可以从左指向右，需要视具体情况而定。 但是在返回信息的时候，问题出现了。有两种可能的回复信息，卡可用，或者不可用。那么如何在同一张图描述两种可能情况的发生呢，UML的解决方案是alternative frame。 Alternative Frame（选项） 当银行服务器反馈，此时卡有效时，ATM机就会要求actor输入卡密码；而当反馈卡无效时，就会将卡弹出。 由于要求输入密码这一事件，并不是在回应，因此不归属于返回信息，要用实线箭头画。Alternative frame中，左边写条件，并用虚线划分两个条件对应的行为。 剩下的操作就是顺理成章的银行取钱操作。卡有效后，用户会输入密码，银行服务器反馈密码是否正确。密码正确后，用户输入需要取钱的金额，银行服务器会向银行账户核实是否有足够多的钱。 Activation Boxes（激活框）： Activation boxes显示对象进程的开始时间和结束时间。通过激活框可以轻松看到对象何时处于活动状态，何时处于空闲状态。下面根据messages来给各个对象加上激活框。 通过激活框可以看出，银行账户对象显然比另外两个对象更不活跃。 📌激活框只能作用于objects，不能作用于actors。 面向对象 相比于面向过程，为什么项目开发使用面向对象？ 古早的程序需求足够简单，整个程序的处理流程只有一条主线，很容易被划分成顺序执行的几个步骤，很适合面向过程风格。 但对于大规模复杂程序的开发来说，整个程序的处理流程错综复杂，画出来的话会是一个网状结构，再用面向过程来思考会比较吃力，此时面向对象的思维将更具优势。即，将需求翻译为类，并且在类之间建立交互关系。 除此之外，面向对象也强制程序员将代码的组织方式更清晰、更模块化。 四大特性 四大特性：封装、抽象、继承、多态。这四大特性使得程序相比于面向过程风格的代码，更加易扩展、易复用、易维护。 封装：信息隐藏/数据访问保护，类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（比如方法）来访问内部信息或者数据。 如果对类中的属性不做限制，任何代码都能访问、修改的话，意味着不可控。即属性可能被随意地以各种方式修改，而且修改逻辑可能散落在代码中的各个角落，影响代码的可读性、可维护性。 另一方面，仅暴露必要的操作，也能提高类的易用性。调用者只需使用api就好，不必过于细致的了解业务逻辑，减少心智负担。而且用错的概率会减少。 抽象：抽象通常由接口、抽象类来实现。其隐藏方法的具体实现，让调用者只需关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。 通过抽象，一方面降低调用者的操作难度，另一方面可以保持兼容能力，即使具体类的具体实现更改了，也不会影响到上层代码。 继承：继承表示类之间的is-a关系，比如猫是一种哺乳动物。 继承的主要作用在于代码复用，可以避免代码重复写很多遍。但是继承层次过深也会导致代码可读性差、可维护性变差。 多态：子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。 多态代码的作用在于提高代码的可扩展性和复用性。比如一个print(Animal var)就可以打印所有类型动物的信息。多态是众多设计模式实现的基石。 基于接口而非实现编程 Program to an interface, not an implementation 从本质上来看，“接口”就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”。这条原则希望，实际代码中，上层代码多用抽象出来的接口，而非具体实现了功能的类。这样可以带来好处： 接口与实现相分离。封装不稳定的实现，暴露稳定的接口。这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此降低耦合性，提高扩展性。 好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。 多用组合少用继承 继承的弊端不仅局限于简单继承的层次过深问题。考虑“鸟”这个类： 方法选择受限： 大部分鸟都会飞，那么可不可以在AbstractBird抽象类中，定义一个fly方法呢？ 如果定义了，依然有一些鸟是不会飞的，比如鸵鸟，但是鸵鸟类中却仍然有fly方法，即使将鸵鸟类中的fly内部写抛出异常的代码，也不会强制程序员在写代码时避免让 鸵鸟等鸟类fly，在后续扩展中难免有漏网之鱼，导致错误。 如果不定义，那么当会飞的鸟类想fly时，就要多写很多实现他们fly方法的代码，有悖于“继承提高代码复用”的目的。 派生关系复杂： 那么是否可以给AbstractBird派生两个类，一个会飞鸟类，一个不会飞鸟类，再在会飞类里派生具体的鸟类，不会飞鸟类里派生鸵鸟类。 表面上这样可以解决问题，但是在后面的扩展中，这样的设计可能会带来更为严重的问题。比如此时需求变更，还想加上Tweet方法，即让鸟儿叫出来。沿袭刚才的思路，AbstractBird派生出来了四个类：会飞会叫、会飞不会叫、不会飞会叫、不会飞不会叫。两个功能衍生出了四种组合。也就是n个功能会有2n2^n2n种组合，呈指数形式变化。 那么后面还要加下蛋（判断是否会下蛋）等功能，将会组合爆炸。这样继承的关系越来越复杂，可读性极差，而且极难维护。 📌继承主要有三个作用：表示is-a关系，支持多态特性，代码复用。而这三个作用都可以通过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题。 组合、接口、委托的实现方案： 针对不同需求，定义不同的接口，之后每个鸟类将这些接口组合在一起。 12345678910111213141516171819202122232425public interface Flyable &#123; void fly();&#125;public interface Tweetable &#123; void tweet();&#125;public interface EggLayable &#123; void layEgg();&#125;public class Ostrich implements Tweetable, EggLayable &#123;//鸵鸟 //... 省略其他属性和方法... @Override public void tweet() &#123; //... &#125; @Override public void layEgg() &#123; //... &#125;&#125;public class Sparrow impelents Flayable, Tweetable, EggLayable &#123;//麻雀 //... 省略其他属性和方法... @Override public void fly() &#123; //... &#125; @Override public void tweet() &#123; //... &#125; @Override public void layEgg() &#123; //... &#125;&#125; 接口只声明方法，不定义实现。也就是说，每个会下蛋的鸟都要实现一遍layEgg()方法，并且实现逻辑是一样的，这就会导致代码重复的问题。可以通过组合+委托的方式来消除代码重复。针对三个接口再定义三个实现类，它们分别是：实现了fly()方法的FlyAbility类、实现了tweet()方法的TweetAbility类、实现了layEgg()方法的EggLayAbility类。 12345678910111213141516171819202122public interface Flyable &#123; void fly()；&#125;public class FlyAbility implements Flyable &#123; @Override public void fly() &#123; //... &#125;&#125;//省略Tweetable/TweetAbility/EggLayable/EggLayAbilitypublic class Ostrich implements Tweetable, EggLayable &#123;//鸵鸟 private TweetAbility tweetAbility = new TweetAbility(); //组合 private EggLayAbility eggLayAbility = new EggLayAbility(); //组合 //... 省略其他属性和方法... @Override public void tweet() &#123; tweetAbility.tweet(); // 委托 &#125; @Override public void layEgg() &#123; eggLayAbility.layEgg(); // 委托 &#125;&#125; 于是组合+接口+委托，达成了代码重复少、也不必再有复杂继承关系的目的。 设计原则 SOLID原则：由5个设计原则组成，分别是，单一职责原则、开闭原则、里氏替换原则、接口隔离原则和依赖反转原则，对应S、O、L、I、D 5个英文字母 单一职责原则（Single Responsibility Principle, SRP） 一个类/模块只负责完成一个职责（或者功能） 一个类只负责完成一个职责或者功能。也就是说，不要设计大而全的类，要设计粒度小、功能单一的类。换个角度就是，一个类包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一，应该将它拆分成多个功能更加单一、粒度更细的类。 以下几点可以辅助判断类的职责是否足够单一： 类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分； 类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分； 私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为public方法，供更多的类使用，从而提高代码的复用性； 比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的Manager、Context之类的词语来命名，这就说明类的职责定义得可能不够清晰； 类中大量的方法都是集中操作类中的某几个属性，比如，在UserInfo例子中，如果一半的方法都是在操作address信息，那就可以考虑将这几个属性和对应的方法拆分出来。 开闭原则：对扩展开放、修改关闭（Open Closed Principle） 添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。 体现在C++代码的话，用父类指针去指向子类，体现了这样的开闭原则： 比如定义一个Calculator抽象类，通过子类继承的方式扩展出加减乘除的功能： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;#include &lt;stdlib.h&gt;using namespace std;//计算器类 class Calculator&#123;public: //抽象接口类，子类实现 virtual double getompute() = 0; virtual void getParam(double a, double b) = 0;&#125;;//除class Division : public Calculator&#123;public: virtual double getompute() &#123; return mA / mB; &#125; virtual void getParam(double a, double b) &#123; mA = a; mB = b; &#125;private: double mA; double mB;&#125;;//乘class Multiplication : public Calculator&#123;public: virtual double getompute() &#123; return mA * mB; &#125; virtual void getParam(double a, double b) &#123; mA = a; mB = b; &#125;private: double mA; double mB;&#125;;//减class Subtraction : public Calculator&#123;public: virtual double getompute() &#123; return mA - mB; &#125; virtual void getParam(double a, double b) &#123; mA = a; mB = b; &#125;private: double mA; double mB;&#125;;//加class Addition : public Calculator&#123;public: virtual double getompute() &#123; return mA + mB; &#125; virtual void getParam(double a, double b) &#123; mA = a; mB = b; &#125;private: double mA; double mB;&#125;;int main()&#123; Calculator* Add = new Addition; Add-&gt;getParam(1,2); double c = Add-&gt;getompute(); cout &lt;&lt; c &lt;&lt; endl; return 0;&#125; 那么此时，还想添加一个求根的功能，就只需再添加一个求根运算的子类即可。 里式替换原则（Liskov Substitution Principle） 子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。也就是子类对象替换了父类对象的内在实现，但是对外的接口保持与父类对象一致。 明显违背LSP的代码： 子类违背父类声明要实现的功能 比如父类中提供的sortByAmount()函数，是按照类中的金额属性进行从小到大的排序，而子类重写此函数时，是按照日期属性进行排序的。那么子类的设计就违背了里式替换原则。 子类违背父类对输入、输出、异常的约定 比如父类中的某个函数约定了： 运行出错时返回null；获取数据为空时返回空集合。而子类重载函数之后，实现变了，运行出错返回异常，获取不到数据返回null； 输入数据可以是任意整数，但子类实现的时候，只允许输入数据是正整数，负数就抛出； 约定只会抛出A异常，子类实现时却只允许抛出B异常 这些都导致子类违背里式替换原则。 子类违背父类注释中所罗列的任何特殊说明 📌理解LSP，最核心就是理解“按照协议设计”，即父类定义了函数的“协议”，那么子类可以改变函数的内部实现逻辑，但不能改变函数原有的“协议”。 接口隔离原则（Interface Segregation Principle） 接口的调用者/使用者，不应该被强迫去依赖它不需要的接口。 这里的接口Interface不局限于编程语言里的类似于抽象类的接口，而是可理解为： 一组API接口集合 如果部分接口只被部分调用者使用，就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。 单个API接口或函数 部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。 OOP中的接口概念 接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。 📌单一职责原则针对的是模块、类、接口的设计。接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面也是为单一职责的判定提供了一种新思路。 可以通过调用者如何使用接口来间接判定设计是否够职责单一。 依赖反转原则（Dependency Inversoin Principle） https://www.cnblogs.com/yyxt/p/5141577.html 依赖反转 应用程序依赖于类库，那么一旦类库发生变化，应用程序也要相应改变。为了破除这种依赖关系，可以使用依赖反转。 在类库中抽象出一个接口，具体的实现类派生自接口，应用程序也调用接口，这样做： 应用程序调用类库的抽象接口，依赖于类库的抽象接口；具体的实现类派生自类库的抽象接口，也依赖于类库的抽象接口。 应用程序和具体的类库实现完全独立，相互之间没有直接的依赖关系，只要保持接口类的稳定，应用程序和类库的具体实现都可以独立地发生变化。 类库完全可以独立重用，应用程序可以和任何一个实现了相同抽象接口的类库协同工作。 控制反转 框架系统与类库： 框架是一个“半成品”的应用程序，而类库只包含一系列可被应用程序调用的类。 类库给用户提供了一系列可复用的类，用户使用时，可以创建这些类的实例，或者从这些类中继承出新的派生类，然后调用类中相应的功能。在这过程中，类库总是被动地响应用户的调用请求。 框架则会为某一特定目的实现一个基本的、可执行的架构。框架中已经包含了应用程序从启动到运行的主要流程，流程中那些无法预先确定的步骤留给用户来实现。程序运行时框架系统会自动调用用户实现的功能组件。这个过程中，框架的行为是主动的。 设计框架是控制反转的典型应用场景。以一个GUI框架为例，最简单的方式如左图，应用程序通过框架中的CreateWindow函数创建窗口，但是GUI框架并不知道窗口接收到消息以后该如何处理，所以接收到消息时会调用应用程序中的窗口函数。而这形成了双向依赖关系。 这种双向依赖关系缺陷较严重：换一个新的应用程序，甚至可能需要修改GUI框架。 使用控制反转可以消除这样的依赖，也就是将主控权从应用程序转移到框架。在调用CreateWindow时，其接收一个函数指针参数，该函数指针指向用户实现的消息处理函数。因此，当GUI框架接收到消息时，通过该指针自动处理消息。这就是动态调用机制，也被称为回调函数。此时改变应用程序，只会改变自定义行为，GUI框架无需更改。 依赖注入 不通过new()的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。 比如上面实现控制反转的方式：向CreateWindow中注入消息处理的函数指针，就可以理解为一种特殊的，面向过程的依赖注入。 📌控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导框架层面的设计。 依赖注入是实现控制反转的一种具体的编码技巧。 依赖反转也是一种设计思想，指导框架层面的设计。高层模块不依赖低层模块，而是二者共同依赖同一个抽象。 KISS原则 Keep It Simple and Stupid Keep It Short and Simple Keep It Simple and Straightforward 尽量把代码写得简单，虽然“简单”的定义很模糊。 不要使用同事可能不懂的技术来实现代码。 不要重复造轮子，要善于使用已经有的工具类库。 不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。 YAGNI原则 You Ain’t Gonna Need It 不要去设计当前用不到的功能；不要去编写当前用不到的代码——不要做过度设计。 比如，系统暂时只用Redis存储配置信息，以后可能会用到zookeeper。根据YAGNI原则，在未用到ZooKeeper之前，没必要提前编写这部分代码。 再比如，不要在项目中提前引入不需要依赖的开发包。 DRY原则（Don’t Repeat Yourself） 不要写重复的代码 有三种代码重复的情况：实现逻辑重复、功能语义重复、代码执行重复。出现这三种情况后，需要去进一步优化。 但是“实现逻辑重复，功能语义不重复的代码”并不违反DRY原则。 迪米特法则（Law of Demeter） 别名：最小知识原则（The Least Knowlwdge Principle） 何为“高内聚、松耦合”？ 高内聚： 相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护。单一职责原则是实现代码高内聚非常有效的设计原则。 松耦合： 在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动。 依赖注入、接口隔离、基于接口而非实现编程，以及迪米特法则，都是为了实现代码的松耦合。 最小知识： 不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。 编程规范 1. 命名的长度 命名一定要准确达意。对于一些默认的、大家都比较熟知的词，比较推荐用缩写。这样一方面能让命名短一些，另一方面又不影响阅读理解，比如，sec表示second、str表示string、num表示number、doc表示document。除此之外，对于作用域比较小的变量，可以使用相对短的命名，比如一些函数内的临时变量。相反，对于类名这种作用域比较大的，更推荐用长的命名方式。 2. 利用上下文简化命名 比如下面的代码，成员变量和成员方法都借助了User这样的类名上下文，省去了命名时重复添加前缀“user”的麻烦。 123456789101112131415class User&#123;private: string name; //string userName;借助User类这个上下文 string password; //string userPassword; string avatarUrl; //string userAvatarUrl;public: string getName(); string getPassword(); string getAvatarUrl();&#125;;int main()&#123; User user = new User(); user.getName(); //借助user对象这个上下文&#125; 3. 命名要可读、可搜索 4. 命名接口和抽象类 接口：有两种常见的方式 加前缀“I”表示一个Interface，比如IUserService，对应的实现类命名为UserService。 不加前缀，比如UserService，对应的实现类加后缀“Impl”，比如UserServiceImpl。 抽象类：有两种常见的方式 加前缀“Abstract”，比如AbstractConfiguration。 不带前缀，让对应类加后缀“Impl”或者其他与功能相关的命名。 5. 注释写什么 注释的内容主要需要包含三方面：做什么、为什么、怎么做。 1234567891011/*** (what) Bean factory to create beans. * * (why) The class likes Spring IOC framework, but is more lightweight. ** (how) Create objects from different sources sequentially:* user specified object &gt; SPI &gt; configuration &gt; default object.*/class BeansFactory &#123; // ...&#125; 6. 注释的多少 类和函数一定要写注释，而且要写得尽可能全面、详细，而函数内部的注释要相对少一些。一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码的可读性。 7. 类、函数多大才合适 事实上很难界定，太多或太少都不合适。 函数：有一种说法是函数代码的行数，最好不要超过一个显示屏的垂直高度。 类：主要主观来判断，当一个类的代码读起来让你感觉头大了，实现某个功能时不知道该用哪个函数了，想用哪个函数翻半天都找不到了，只用到一个小功能要引入整个类（类中包含很多无关此功能实现的函数）的时候，这就说明类的行数过多了 8. 一行代码多长最合适 Google Java Style Guide文档中，一行代码最长限制为100个字符。遵循的原则是：最长最好不要超过IDE显示的宽度。 9. 善用空行分割单元块 对于比较长的函数，如果逻辑上可以分为几个独立的代码块，在不方便将这些独立的代码块抽取成小函数的情况下，使得逻辑更加清晰。 除此之外，在类的成员变量与函数之间、静态成员变量与普通成员变量之间、各函数之间、甚至各成员变量之间，我们都可以通过添加空行的方式，让这些不同模块的代码之间，界限更加明确。 10. 四格缩进还是两格缩进 不固定，最好和业内推荐的风格统一、跟著名开源项目统一。 缩进时尽量别用tab键。因为在不同的IDE下，tab键的显示宽度不同，有的显示为四格缩进，有的显示为两格缩进。如果在同一个项目中，不同的同事使用不同的缩进方式（空格缩进或tab键缩进），有可能会导致有的代码显示为两格缩进、有的代码显示为四格缩进。 11. 大括号是否要另起一行 只要团队统一、业内统一、跟开源项目看齐就好了，没有绝对的优劣之分。 12. 把代码分割成更小的单元块 12345678910111213141516171819202122232425262728// 重构前的代码public void invest(long userId, long financialProductId) &#123; Calendar calendar = Calendar.getInstance(); calendar.setTime(date); calendar.set(Calendar.DATE, (calendar.get(Calendar.DATE) + 1)); if (calendar.get(Calendar.DAY_OF_MONTH) == 1) &#123; return; &#125; //...&#125;// 重构后的代码：提炼函数之后逻辑更加清晰public void invest(long userId, long financialProductId) &#123; if (isLastDayOfMonth(new Date())) &#123; return; &#125; //...&#125;public boolean isLastDayOfMonth(Date date) &#123; Calendar calendar = Calendar.getInstance(); calendar.setTime(date); calendar.set(Calendar.DATE, (calendar.get(Calendar.DATE) + 1)); if (calendar.get(Calendar.DAY_OF_MONTH) == 1) &#123; return true; &#125; return false;&#125; 13. 避免函数参数过多 函数包含3、4个参数的时候还是能接受的，大于等于5个的时候，会认为参数有点多了，影响代码的可读性，使用起来也不方便。针对参数过多，一般有2种处理方法： 考虑函数是否职责单一，是否能通过拆分成多个函数的方式来减少参数。 123456User getUser();//拆分成多个函数User getUserByUsername(string username);User getUserByTelephone(string telephone);User getUserByEmail(string email); 将函数的参数封装成对象。 123456789101112void postBlog(string title, string summary, string keywords, string content, string category, long authorId);//将参数封装成对象struct Blog&#123; string title; string summary; string keywords; string content; string category; long authorId;&#125;;void postBlog(Blog blog); 函数参数封装成对象还可以带来一个好处：如果函数是对外暴露的抽象接口，将参数封装成对象，可以提高接口的兼容性。当有需要往接口中添加新的参数时，老的接口调用者就不需要修改代码来兼容新的接口了。 14. 勿用函数参数来控制逻辑 函数参数为布尔类型，控制了内部逻辑，true的时候走这块逻辑，false的时候走另一块逻辑。这违背了单一职责原则和接口隔离原则，因此建议拆分成两个函数，可读性上也要更好。 上面这条并不是必须要遵守的。如果函数是private私有函数，影响范围有限，或者拆分后的两函数经常被同时调用，可以酌情考虑保留该标识参数。 有一种“根据参数是否为null”来控制逻辑的情况。和布尔类型类似，有该参数的函数也可以通过判断条件进行函数拆分。 15. 函数设计要职责单一 函数和类的设计均要满足单一职责原则。 16. 移除过深的嵌套层次 代码嵌套层次过深往往是因为if-else、switch-case、for循环过度嵌套导致的，建议嵌套不超过两层。 有下面4种常见的解决嵌套过深的思路： 去掉多余的if或else语句 使用continue、break、return关键字，提前退出嵌套 调整执行顺序来减少嵌套 将部分嵌套逻辑封装成函数调用，以此来减少嵌套 17. 学会使用解释性变量 常用的用解释性变量来提高代码可读性的情况有下面 2种： 常量取代魔法数字： 123double CalculateCircularArea(double radius)&#123; return (3.1415) * radius * radius;&#125; 解释性变量来解释复杂表达式： 1234const double PI = 3.1415;double CalculateCircularArea(double radius)&#123; return PI * radius * radius;&#125; GoF——23种设计模式 创建型模式：用于描述“怎样创建对象”，其主要特点是“将对象的创建与使用分离”。 结构型模式：用于描述如何将类或对象按某种布局组成更大的结构。 行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。 创建型 📌工厂(5) &gt; 单例(4) &gt; 原型(3) &gt; 建造者(2) 1 单例模式（Singleton） 单例模式表示一个类只会有一个对象，当程序想创建新的对象时，创建的新对象其实和之前创建的对象在一个地址，即名义上的多个对象实际只有一个。单例模式分为懒汉式和饿汉式两种： 懒汉式：类加载时没有生成单例。第一次调用getInstance方法时才去创建； 饿汉式：类一旦加载就创建一个单例，相比于懒汉式更加线程安全，但是也会丢失延迟实例化所带来的节约资源的好处。 栈上单例（懒汉式） 1234567891011121314151617181920212223class Singleton&#123;public: ~Singleton()&#123; printf(&quot;~Singleton() destruct&quot;); &#125; static Singleton&amp; CreateObject()&#123; //用户只能通过此函数构造对象 static Singleton obj; //静态以单例 return obj; &#125; Singleton(Singleton&amp; obj) = delete; //禁用拷贝构造函数 Singleton* operator= (Singleton&amp; obj) = delete; //禁用拷贝构造函数，与上一行二者择一private: Singleton() &#123; //封闭构造函数，不让用户有接触到构造函数的机会 printf(&quot;Singleton() construct&quot;); &#125;&#125;;int main()&#123; Singleton&amp; pObj1 = Singleton::CreateObject(); Singleton&amp; pObj2 = Singleton::CreateObject(); return 0;&#125; CreateObject是static函数： 避开无对象时没法调用构造函数创建对象的死结，直接用静态函数构造对象 CreateObject返回的是引用而不是指针： 虽说也可以用指针 1234567static Singleton* m_pObject = nullptr;static Singleton* CreateObject()&#123; //用户只能通过此函数构造对象 if(m_pObject == nullptr)&#123; m_pObject = new Singleton(); &#125; return m_pObject;&#125; 但这么写存在的问题是，因为是指针，因为用了new，所以可能存在内存泄露问题。即使用户可以在main函数里delete pObj1，而且编译不会报错，但此时Singleton不再是线程安全的了。 禁用拷贝构造函数： 传回的是引用，但若允许拷贝构造函数，这么写时仍不会报错 1Singleton pObj2 = Singleton::CreateObject(); 此时的pObj2是通过拷贝构造函数，新创建的Singleton对象，并把obj的内容拷贝了过来。那么此时pObj2和pObj1的地址不再相同，二者成为了两个对象，打破了单例模式。 因此，此处禁用拷贝构造，强迫用户必须用引用来接对象。 堆上单例（懒汉式） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Singleton&#123;private: Singleton(); Singleton(const Singleton&amp; other);public: static Singleton* getInstance(); static Singleton* m_instance;&#125;;Singleton* Singleton::m_instance=nullptr;//线程非安全版本Singleton* Singleton::getInstance() &#123; if (m_instance == nullptr) &#123; m_instance = new Singleton(); &#125; return m_instance;&#125;//线程安全版本，但锁的代价过高Singleton* Singleton::getInstance() &#123; Lock lock; if (m_instance == nullptr) &#123; m_instance = new Singleton(); &#125; return m_instance;&#125;//双检查锁，但由于内存读写reorder不安全（编译器优化时可能把第二个检查优化掉）Singleton* Singleton::getInstance() &#123; if(m_instance==nullptr)&#123; Lock lock; if (m_instance == nullptr) &#123; m_instance = new Singleton(); &#125; &#125; return m_instance;&#125;//C++ 11版本之后的跨平台实现 (volatile)std::atomic&lt;Singleton*&gt; Singleton::m_instance;std::mutex Singleton::m_mutex;Singleton* Singleton::getInstance() &#123; Singleton* tmp = m_instance.load(std::memory_order_relaxed); std::atomic_thread_fence(std::memory_order_acquire);//获取内存fence if (tmp == nullptr) &#123; std::lock_guard&lt;std::mutex&gt; lock(m_mutex); tmp = m_instance.load(std::memory_order_relaxed); if (tmp == nullptr) &#123; tmp = new Singleton; std::atomic_thread_fence(std::memory_order_release);//释放内存fence m_instance.store(tmp, std::memory_order_relaxed); &#125; &#125; return tmp;&#125; 堆上单例（饿汉式） 1234567891011121314namespace singleton &#123; class HungrySingleton &#123; public: HungrySingleton* getInstance() &#123; return instance_; &#125; private: HungrySingleton() &#123;&#125; static HungrySingleton* instance_; &#125;; HungrySingleton* HungrySingleton::instance_ = new HungrySingleton();&#125; // namespace singleton 2 工厂模式（Factory） 工厂模式中，创建对象时不会对客户端暴露创建逻辑，而是通过使用一个共同的接口来指向新创建的对象 2.1 简单工厂 以炒鞋为例。鞋厂可以指定生产耐克、阿迪达斯和李宁牌子的鞋。 工厂类：工厂模式的核心类，会定义一个用于创建指定的具体实例对象的接口。 抽象产品类：是具体产品类的继承的父类或实现的接口。 具体产品类：工厂类所创建的对象就是此具体产品实例。 特点在于封装了创建具体产品对象的函数。 缺点在于扩展性非常差，新增产品的时候，需要去修改工厂类。 12345678910111213141516171819202122232425262728293031323334353637// 鞋子抽象类class Shoes&#123;public: virtual ~Shoes() &#123;&#125; virtual void Show() = 0;&#125;;// 耐克鞋子class NiKeShoes : public Shoes&#123;public: void Show() &#123; std::cout &lt;&lt; &quot;我是耐克球鞋，我的广告语：Just do it&quot; &lt;&lt; std::endl; &#125;&#125;;// 阿迪达斯鞋子class AdidasShoes : public Shoes&#123;public: void Show() &#123; std::cout &lt;&lt; &quot;我是阿迪达斯球鞋，我的广告语:Impossible is nothing&quot; &lt;&lt; std::endl; &#125;&#125;;// 李宁鞋子class LiNingShoes : public Shoes&#123;public: void Show() &#123; std::cout &lt;&lt; &quot;我是李宁球鞋，我的广告语：Everything is possible&quot; &lt;&lt; std::endl; &#125;&#125;; 12345678910111213141516171819202122232425262728293031enum SHOES_TYPE&#123; NIKE, LINING, ADIDAS&#125;;// 总鞋厂class ShoesFactory&#123;public: // 根据鞋子类型创建对应的鞋子对象 Shoes *CreateShoes(SHOES_TYPE type) &#123; switch (type) &#123; case NIKE: return new NiKeShoes(); break; case LINING: return new LiNingShoes(); break; case ADIDAS: return new AdidasShoes(); break; default: return NULL; break; &#125; &#125;&#125;; main函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243int main()&#123; // 构造工厂对象 ShoesFactory shoesFactory; // 从鞋工厂对象创建阿迪达斯鞋对象 Shoes *pNikeShoes = shoesFactory.CreateShoes(NIKE); if (pNikeShoes != NULL) &#123; // 耐克球鞋广告喊起 pNikeShoes-&gt;Show(); // 释放资源 delete pNikeShoes; pNikeShoes = NULL; &#125; // 从鞋工厂对象创建阿迪达斯鞋对象 Shoes *pLiNingShoes = shoesFactory.CreateShoes(LINING); if (pLiNingShoes != NULL) &#123; // 李宁球鞋广告喊起 pLiNingShoes-&gt;Show(); // 释放资源 delete pLiNingShoes; pLiNingShoes = NULL; &#125; // 从鞋工厂对象创建阿迪达斯鞋对象 Shoes *pAdidasShoes = shoesFactory.CreateShoes(ADIDAS); if (pAdidasShoes != NULL) &#123; // 阿迪达斯球鞋广告喊起 pAdidasShoes-&gt;Show(); // 释放资源 delete pAdidasShoes; pAdidasShoes = NULL; &#125; return 0;&#125; 2.2 工厂方法 简单工厂的缺点在于，调用工厂来创建对象时，是传入产品类别的。每当增加一个类别时，就需要修改一次工厂类。这违反了开闭原则，而工厂方法是对这种行为的补救。使用工厂方法，每次需要增加一个类别时，只需要再实现两个具体类就行，不必再去修改工厂类的内容。 工厂方法相比于简单工厂，添加了一个具体工厂类，每一个具体工厂类和相应的具体产品类是一一对应的，由具体工厂类来生产（创建）相应的具体产品类对象。 抽象工厂类：工厂方法模式的核心类，提供创建具体产品的接口，由具体工厂类实现。 具体工厂类：继承于抽象工厂，实现创建对应具体产品对象的方式。 抽象产品类：它是具体产品继承的父类（基类）。 具体产品类：具体工厂所创建的对象，就是此类。 12345678910111213141516171819202122232425262728293031323334353637// 总鞋厂class ShoesFactory&#123;public: virtual Shoes *CreateShoes() = 0; virtual ~ShoesFactory() &#123;&#125;&#125;;// 耐克生产者/生产链class NiKeProducer : public ShoesFactory&#123;public: Shoes *CreateShoes() &#123; return new NiKeShoes(); &#125;&#125;;// 阿迪达斯生产者/生产链class AdidasProducer : public ShoesFactory&#123;public: Shoes *CreateShoes() &#123; return new AdidasShoes(); &#125;&#125;;// 李宁生产者/生产链class LiNingProducer : public ShoesFactory&#123;public: Shoes *CreateShoes() &#123; return new LiNingShoes(); &#125;&#125;; main函数 1234567891011121314151617181920212223242526int main()&#123; // ================ 生产耐克流程 ==================== // // 鞋厂开设耐克生产线 ShoesFactory *niKeProducer = new NiKeProducer(); // 耐克生产线产出球鞋 Shoes *nikeShoes = niKeProducer-&gt;CreateShoes(); // 耐克球鞋广告喊起 nikeShoes-&gt;Show(); // 释放资源 delete nikeShoes; delete niKeProducer; // ================ 生产阿迪达斯流程 ==================== // // 鞋厂开设阿迪达斯生产者 ShoesFactory *adidasProducer = new AdidasProducer(); // 阿迪达斯生产线产出球鞋 Shoes *adidasShoes = adidasProducer-&gt;CreateShoes(); // 阿迪达斯球鞋广喊起 adidasShoes-&gt;Show(); // 释放资源 delete adidasShoes; delete adidasProducer; return 0;&#125; 2.3 抽象工厂 与工厂方法的不同：具体工厂类不再生产唯一的产品，而是生产多个产品。也就是抽象工厂类将不仅仅提供对某一种产品的创建方法，还提供多种产品的创建方法。 应用场景：当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的具体产品时需要使用抽象工厂模式。 遇到此类场景时，抽象工厂模式比工厂方法模式更为简单、有效率。 考虑上面的例子。此时厂家不再局限于生产鞋子，还想生产耐克、阿迪达斯、李宁的衣服。那么就可以应用抽象工厂来替代工厂方法。 1234567891011121314151617181920212223242526272829303132333435// 基类 衣服class Clothe&#123;public: virtual void Show() = 0; virtual ~Clothe() &#123;&#125;&#125;;// 耐克衣服class NiKeClothe : public Clothe&#123;public: void Show() &#123; std::cout &lt;&lt; &quot;我是耐克衣服，时尚我最在行！&quot; &lt;&lt; std::endl; &#125;&#125;;// 基类 鞋子class Shoes&#123;public: virtual void Show() = 0; virtual ~Shoes() &#123;&#125;&#125;;// 耐克鞋子class NiKeShoes : public Shoes&#123;public: void Show() &#123; std::cout &lt;&lt; &quot;我是耐克球鞋，让你酷起来！&quot; &lt;&lt; std::endl; &#125;&#125;; 1234567891011121314151617181920212223// 总厂class Factory&#123;public: virtual Shoes *CreateShoes() = 0; virtual Clothe *CreateClothe() = 0; virtual ~Factory() &#123;&#125;&#125;;// 耐克生产者/生产链class NiKeProducer : public Factory&#123;public: Shoes *CreateShoes() &#123; return new NiKeShoes(); &#125; Clothe *CreateClothe() &#123; return new NiKeClothe(); &#125;&#125;; main函数 123456789101112131415161718192021222324int main()&#123; // ================ 生产耐克流程 ==================== // // 鞋厂开设耐克生产线 Factory *niKeProducer = new NiKeProducer(); // 耐克生产线产出球鞋 Shoes *nikeShoes = niKeProducer-&gt;CreateShoes(); // 耐克生产线产出衣服 Clothe *nikeClothe = niKeProducer-&gt;CreateClothe(); // 耐克球鞋广告喊起 nikeShoes-&gt;Show(); // 耐克衣服广告喊起 nikeClothe-&gt;Show(); // 释放资源 delete nikeShoes; delete nikeClothe; delete niKeProducer; return 0;&#125; 2.4 模板工厂（C++） https://zhuanlan.zhihu.com/p/83537599 模板工厂相当于在工厂方法的基础上进行优化，使其能够获得抽象工厂的效果。而且比起抽象工厂来，当需要新添加类别时（比如在鞋和衣服的基础上，还要添加裤子），扩展性更强，符合开闭原则。 1234567891011121314151617181920212223242526272829303132333435// 基类 鞋子class Shoes&#123;public: virtual void Show() = 0; virtual ~Shoes() &#123;&#125;&#125;;// 耐克鞋子class NiKeShoes : public Shoes&#123;public: void Show() &#123; std::cout &lt;&lt; &quot;我是耐克球鞋，我的广告语：Just do it&quot; &lt;&lt; std::endl; &#125;&#125;;// 基类 衣服class Clothe&#123;public: virtual void Show() = 0; virtual ~Clothe() &#123;&#125;&#125;;// 优衣库衣服class UniqloClothe : public Clothe&#123;public: void Show() &#123; std::cout &lt;&lt; &quot;我是优衣库衣服，我的广告语：I am Uniqlo&quot; &lt;&lt; std::endl; &#125;&#125;; 123456789101112131415161718192021// 抽象模板工厂类// 模板参数：AbstractProduct_t 产品抽象类template &lt;class AbstractProduct_t&gt;class AbstractFactory&#123;public: virtual AbstractProduct_t *CreateProduct() = 0; virtual ~AbstractFactory() &#123;&#125;&#125;;// 具体模板工厂类// 模板参数：AbstractProduct_t 产品抽象类，ConcreteProduct_t 产品具体类template &lt;class AbstractProduct_t, class ConcreteProduct_t&gt;class ConcreteFactory : public AbstractFactory&lt;AbstractProduct_t&gt;&#123;public: AbstractProduct_t *CreateProduct() &#123; return new ConcreteProduct_t(); &#125;&#125;; main函数 12345678910111213141516171819202122232425int main()&#123; // 构造耐克鞋的工厂对象 ConcreteFactory&lt;Shoes, NiKeShoes&gt; nikeFactory; // 创建耐克鞋对象 Shoes *pNiKeShoes = nikeFactory.CreateProduct(); // 打印耐克鞋广告语 pNiKeShoes-&gt;Show(); // 构造优衣库衣服的工厂对象 ConcreteFactory&lt;Clothe, UniqloClothe&gt; uniqloFactory; // 创建优衣库衣服对象 Clothe *pUniqloClothe = uniqloFactory.CreateProduct(); // 打印优衣库广告语 pUniqloClothe-&gt;Show(); // 释放资源 delete pNiKeShoes; pNiKeShoes = NULL; delete pUniqloClothe; pUniqloClothe = NULL; return 0;&#125; 3 建造者模式（Builder） 将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。 Builder侧重“零部件的组装过程”。 应用场景：建造者模式主要用于“分步骤构建一个复杂的对象”。在这其中“分步骤”是一个稳定的算法，而复杂对象的各个部分经常变化。 缺点：这里的“组装过程”，或者说“步骤”，是固定的，无法修改。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class House&#123; //....&#125;;class HouseBuilder &#123;public: House* GetResult()&#123; return pHouse; &#125; virtual ~HouseBuilder()&#123;&#125;protected: House* pHouse; virtual void BuildPart1()=0; virtual void BuildPart2()=0; virtual void BuildPart3()=0; virtual void BuildPart4()=0; virtual void BuildPart5()=0;&#125;;class StoneHouse: public House&#123;&#125;;class StoneHouseBuilder: public HouseBuilder&#123;protected: virtual void BuildPart1()&#123; //pHouse-&gt;Part1 = ...; &#125; virtual void BuildPart2()&#123; &#125; virtual void BuildPart3()&#123; &#125; virtual void BuildPart4()&#123; &#125; virtual void BuildPart5()&#123; &#125;&#125;;///@brief：Director，组装各个part，“步骤”是由它制定并实现的class HouseDirector&#123;public: HouseBuilder* pHouseBuilder; HouseDirector(HouseBuilder* pHouseBuilder)&#123; this-&gt;pHouseBuilder=pHouseBuilder; &#125; House* Construct()&#123; pHouseBuilder-&gt;BuildPart1(); for (int i = 0; i &lt; 4; i++)&#123; pHouseBuilder-&gt;BuildPart2(); &#125; bool flag=pHouseBuilder-&gt;BuildPart3(); if(flag)&#123; pHouseBuilder-&gt;BuildPart4(); &#125; pHouseBuilder-&gt;BuildPart5(); return pHouseBuilder-&gt;GetResult(); &#125;&#125;; 4 原型模式（Prototype） 将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。 应用场景： 针对结构复杂的对象结构，由于需求变化，对象内部也会发生变化，但是对外暴露的接口仍然是稳定的。原型模式负责应对这种变化，从客户程序隔离出易变对象，从而使得依赖这些对象的客户程序不必随着需求改变而改变。 实现方式： 定义抽象类，原型为派生出来的具体类的一个实例，需要其他（发生了变化的）实例时，从原型拷贝。 1234567891011121314151617181920212223242526272829303132333435/// @brief 抽象原型类class AbstractPrototype &#123;public: AbstractPrototype() = default; virtual ~AbstractPrototype() &#123;&#125; virtual AbstractPrototype* clone() = 0;&#125;;/// @brief 具体原型类class ConcretePrototype : public AbstractPrototype &#123;public: ConcretePrototype() = default; ~ConcretePrototype() &#123;&#125; AbstractPrototype* clone() &#123; return new ConcretePrototype(*this);//调用拷贝构造 &#125;private: ConcretePrototype(const ConcretePrototype&amp; other) &#123; fprintf(stderr, &quot;ConcretePrototype copy construct!\\n&quot;); // ......拷贝操作 &#125;&#125;;void Test_02_prototype_impl_1() &#123; printf(&quot;-------------------- %s --------------------\\n&quot;, __FUNCTION__); prototype::AbstractPrototype* ptr_a = new prototype::ConcretePrototype(); prototype::AbstractPrototype* ptr_b = ptr_a-&gt;clone(); delete ptr_a; delete ptr_b; &#125; 结构型 📌门面(5) &gt; 适配器(4) = 组合(4) = 代理(4) &gt; 桥接(3) = 装饰(3) &gt; 享元(1) 5 代理模式（Proxy） 在某些情况下，一个客户不想或者不能直接引用一个对象，此时可以通过一个称之为“代理”的第三方来实现 间接引用。代理对象可以在客户端和目标对象之间起到“中介”的作用，并且可以通过代理对象去掉客户不允许看到的内容，或者添加客户需要的额外服务。 事实上，代理模式和科学上网时所配置的代理是异曲同工的。无法直接访问到海外的机器，此时可以使用一个代理来访问海外，而客户端调用代理即可。 subject：抽象角色 Proxy：代理角色 RealSubject：真实角色 应用场景： 远程代理：为一个处于不同地址空间的对象提供一个本地的代理，这个不同地址空间可以在同一台主机中，也可在另一台主机中，远程代理又叫做大使。 虚拟代理：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。 写时拷贝代理：虚拟代理的一种，把复制（克隆）操作延迟到只有在客户端真正需要时才执行。 保护代理：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。 缓冲代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。 防火墙代理：保护目标不让恶意用户接近。 同步化代理：使几个用户能够同时使用一个对象而没有冲突。 智能引用代理：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来等。 优点： 代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。 远程代理使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。 虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度。 保护代理可以控制对真实对象的使用权限。 缺点： 客户端和真实对象之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，而且增加了系统实现的复杂度。 12345678910111213141516171819202122232425262728class Proxy : public Subject&#123;public: Proxy()&#123; m_pRealSubject = new RealSubject(); &#125;; virtual ~Proxy()&#123; delete m_pReakSubject; &#125;; void request()&#123; preRequest(); m_pRealSubject-&gt;request(); afterRequest(); &#125;;private: void afterRequest(); void preRequest(); RealSubject *m_pRealSubject;&#125;;/*int main()&#123; Proxy proxy; proxy.request(); return 0;&#125;*/ 6 桥接模式（Bridge） 桥接模式同时使用了“接口与实现相分离”和“组合代替继承”的思想。 应用场景： 某些类型的固有实现逻辑，使得它们具有两个变化的维度，甚至多个变化的维度。比如说图形既可按形状分，又可按颜色分。而Photoshop这样的软件，能画不同形状和不同颜色的图形，该如何实现呢？ 此时可以使用桥接模式，可以参考前文“组合代替继承”中鸟类的例子。 桥接模式结构： Abstraction：抽象类 RefinedAbstraction：扩充抽象类，即扩充Abstraction所定义的接口，他同时连接Abstraction和Implementor，是“桥接”中的那座桥。 Implementor：实现类接口 ConcreteImplementor：具体实现类 扩充抽象类构造时接收具体实现类为参数，从而让扩充抽象类组合了若干具体实现类的功能。 当然，扩充抽象类不一定是必需的，由此衍生出两种桥接模式的实现方式。 简单的抽象与实现相分离 123456789101112131415161718192021222324252627282930313233/// @brief 抽象类接口class AbstractInterface &#123;public: AbstractInterface(); ~AbstractInterface(); void Request();private: class Impl; Impl* impl_;&#125;;/// @brief 实现类接口class AbstractInterface::Impl &#123;public: void Request() &#123; printf(&quot;this is AbstractInterface::Impl::Request!\\n&quot;); &#125;&#125;;/// 抽象类接口的实现 - 调用实现类接口AbstractInterface::AbstractInterface() &#123; impl_ = new Impl();&#125;AbstractInterface::~AbstractInterface() &#123; delete impl_;&#125;void AbstractInterface::Request() &#123; impl_-&gt;Request();&#125; 复杂的抽象与实现相分离 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/// @brief 实现化角色, 定义实现化角色的接口class AbstractImplementor &#123;public: virtual ~AbstractImplementor() &#123;&#125; virtual void Request() = 0;&#125;;/// @brief 具体实现化角色, 给出实现化角色接口的具体实现class ConcreteImplementorA : public AbstractImplementor &#123;public: virtual void Request() &#123; printf(&quot;this ConcreteImplementorA::Request!\\n&quot;); &#125;&#125;;class ConcreteImplementorB : public AbstractImplementor &#123;public: virtual void Request() &#123; printf(&quot;this ConcreteImplementorB::Request!\\n&quot;); &#125;&#125;;/// @brief 抽象类角色, 对实现化对象的引用class AbstractRole &#123;public: AbstractRole(AbstractImplementor* impl) : impl_(impl) &#123;&#125; virtual ~AbstractRole() &#123;&#125; virtual void Request() = 0;protected: AbstractImplementor* impl_;&#125;;/// @brief 扩展抽象化角色, 实现父类中的业务方法class ExtendRole : public AbstractRole &#123;public: ExtendRole(AbstractImplementor* impl) : AbstractRole(impl) &#123;&#125; virtual void Request() &#123; impl_-&gt;Request(); &#125;&#125;;void Test_08_bridge_impl_2() &#123; AbstractImplementor* ptr_implA = new ConcreteImplementorA(); AbstractImplementor* ptr_implB = new ConcreteImplementorB(); AbstractRole* ptr_role_1 = new ExtendRole(ptr_implA); ptr_role_1-&gt;Request(); AbstractRole* ptr_role_2 = new ExtendRole(ptr_implB); ptr_role_2-&gt;Request(); delete ptr_role_1, ptr_role_2; delete ptr_implA, ptr_implB;&#125; 📌桥接模式的“桥”体现在什么地方？ 比如说Photoshop的例子，颜色和形状被组合在了一起。再比如鸟的例子，飞属性和叫属性也被组合在了一起。桥接就像架起了一座桥一样，连接了两个不同的类型，从而进行组合。 体现在代码上的话，就是RefineAbstraction的构造函数中，传入了不同Implementor类型的指针，于是在RefineAbstraction对象内部，就可以组合不同类型的对象。 同时，用户仅需要调用抽象接口Abstraction即可。 7 装饰器模式（Decorator） 装饰器动态的给对象增加一些职责，即增加额外的功能。采用了“组合代替继承”的原则，用组合关系创建一个包装对象来包裹真实对象，并在保持真实对象的类结构不变的前提下，提供额外的功能。 应用场景： 优点： 装饰模式可以提供比继承更多的灵活性。 可以通过动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的装饰器，从而实现不同的行为。 通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。 使用时进行组合即可，原有代码无须改变，符合“开闭原则”。 缺点： 装饰类和小对象的产生将增加系统的复杂度，加大学习与理解的难度。 装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。 1234567891011121314/// @brief 抽象组件 - 被装饰的接口基类class AbstractComponent &#123;public: virtual ~AbstractComponent() &#123;&#125; virtual void Request() = 0;&#125;;/// @brief 具体组件 - 被装饰的接口派生类class ConcreteComponent : public AbstractComponent &#123;public: virtual void Request() &#123; printf(&quot;this is ConcreteComponent::Request!\\n&quot;); &#125;&#125;; 1234567891011121314151617181920212223242526272829303132/// @brief 抽象装饰class AbstractDecorator : public AbstractComponent &#123;public: AbstractDecorator(AbstractComponent* comp) : comp_(comp) &#123;&#125; virtual void Request() &#123; if (comp_) comp_-&gt;Request(); &#125;private: AbstractComponent* comp_;&#125;;/// @brief 具体装饰class ConcreteDecoratorA : public AbstractDecorator &#123;public: ConcreteDecoratorA(AbstractComponent* comp) : AbstractDecorator(comp) &#123;&#125; virtual void Request() &#123; PreRequest(); AbstractDecorator::Request(); PostRequest(); &#125;protected: void PreRequest() &#123; printf(&quot;ConcreteDecoratorA::PreRequest!\\n&quot;); &#125; void PostRequest() &#123; printf(&quot;ConcreteDecoratorA::PostRequest!\\n&quot;); &#125;&#125;; 📌代码中的这行操作ConcreteDecoratorA(AbstractComponent* comp):AbstractDecorator(comp)是C++11的新特性：委托构造函数(delegating constructor)，即一个构造函数可以在初始化成员列表中，调用另一个构造函数。 委托构造函数的成员初始值列表只能有唯一的参数，就是构造函数。 上面的例子中，就是创建ConcreteDecoratorA对象时，会先将被对象创建为AbstractDecorator对象的内容，如果{ }中有内容，就继续执行{ }中的内容。 但是委托构造函数易发生死锁的问题，考虑下面代码： class B{ private: int *a; std::string *s; public: B(int a) : B(“Test”) { _*a = a; } B(std::string s) : B(100){ *_s = “Test”; } }; 这一份代码可以编译，但是却无法运行。因为一旦初始化，无论执行哪一个函数，一定会陷入无穷无尽的循环调用中。 123456789//main函数int main()&#123; AbstractComponent* ptr_comp = new ConcreteComponent(); ptr_comp-&gt;Request(); //原有组件该有的功能不变 //对现有组件的功能进行扩展 AbstractDecorator* ptr_decorator = new ConcreteDecoratorA(ptr_comp); ptr_decorator-&gt;Request();&#125; 8 适配器模式（Adapter） 适配器模式中的角色： Target（目标接口）、Adapter（适配器类）、Adaptee（适配者类）、Client（客户类）。 应用场景： 现有的类可以满足客户类的功能需要，但是它所提供的接口不一定是客户类所期望的。适配器模式就是在二者之间添加一个类进行接口的转化。而添加的用于转化接口的类就是适配器类，被包装的类即适配者类。 适配器模式，通过适配器类，在适配者类外部包装，包装成目标接口。 适配器模式有两种实现方式： 对象适配器 Adapter只继承Target以提供接口的实现，接收Adaptee的对象作为参数。 类适配器 多重继承，Adapter类同时继承Target和Adaptee。 二者均能获得Adaptee功能的同时向客户提供目标接口。两种实现方式的类图如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//目标接口（新接口）class ITarget&#123;public: virtual void process()=0;&#125;;//遗留接口（老接口）class IAdaptee&#123;public: virtual void foo(int data)=0; virtual int bar()=0;&#125;;//遗留类型class OldClass: public IAdaptee&#123; //....&#125;;//对象适配器class Adapter: public ITarget&#123; //继承protected: IAdaptee* pAdaptee;//组合public: Adapter(IAdaptee* pAdaptee)&#123; this-&gt;pAdaptee=pAdaptee; &#125; virtual void process()&#123; int data=pAdaptee-&gt;bar(); pAdaptee-&gt;foo(data); &#125;&#125;;//类适配器class Adapter: public ITarget, protected OldClass&#123; //多继承 virtual void process()&#123; int data = this-&gt;bar(); this-&gt;foo(data); &#125; &#125;;int main()&#123; IAdaptee* pAdaptee=new OldClass(); ITarget* pTarget=new Adapter(pAdaptee);//使用对象适配器 ITarget* pTarget=new Adapter();//使用类适配器 pTarget-&gt;process();&#125; 9 门面/外观模式（Facade） 客户端想同时调用多个复杂的子系统，而外观模式为这些子系统提供一个一致的接口，使它们更容易被访问。 现实生活的类比：如办房产证或注册一家公司，有时要同多个部门联系，这时要是有一个综合部门能解决一切手续问题就好了。外观模式就是在软件层面做这样的事 优点： 降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类 对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易 降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象 缺点： 增加新的子系统可能需要修改外观类或客户端的代码，违背了“开闭原则”。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/// @brief 具体实现子模块class SubModuleImplementorA &#123;public: void PreRequest () &#123; printf(&quot;SubModuleImplementorA::PreRequest!\\n&quot;); &#125;&#125;;class SubModuleImplementorB &#123;public: void RealRequest () &#123; printf(&quot;SubModuleImplementorB::RealRequest!\\n&quot;); &#125;&#125;;class SubModuleImplementorC &#123;public: void PostRequest () &#123; printf(&quot;SubModuleImplementorC::PostRequest!\\n&quot;); &#125;&#125;;/// @brief 外观角色class Facade &#123;public: Facade() &#123; implA_.reset(new SubModuleImplementorA());//reset会使引用计数-1 implB_.reset(new SubModuleImplementorB()); implC_.reset(new SubModuleImplementorC()); &#125; void Request() &#123; implA_-&gt;PreRequest(); implB_-&gt;RealRequest(); implC_-&gt;PostRequest(); &#125;private: std::shared_ptr&lt;SubModuleImplementorA&gt; implA_; std::shared_ptr&lt;SubModuleImplementorB&gt; implB_; std::shared_ptr&lt;SubModuleImplementorC&gt; implC_;&#125;;void Test_10_facade_impl_1() &#123; printf(&quot;-------------------- %s --------------------\\n&quot;, __FUNCTION__); std::shared_ptr&lt;Facade&gt; ptr(new Facade()); ptr-&gt;Request();&#125; 📌shared_ptr的reset(new class())用法，先new出来对象，再将shared_ptr引用计数-1。因此，若之前指针只指向一个对象，-1后为0，自动析构，指针悬空，就可以指向新new出来的对象。 10 组合模式（Composite） 组合模式将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。 应用场景： 软件开发中存在很多“部分-整体”的关系，如文件系统中的文件与文件夹等等。对这些简单对象与复合对象的处理，用组合模式来实现会比较方便。 优点： 客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的单个对象还是组合对象，简化了客户端代码的设计； 更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源码，满足“开闭原则”。 缺点： 设计较复杂，客户端需要花更多时间理清类之间的层次关系； 不容易用继承的方法增加功能。 透明式 抽象组件声明子类中的全部方法，所以客户端无需区别叶子对象和中间的树枝对象，对客户端透明。 缺点在于，叶子类本不必有Add()、Remove()这样的方法，却要实现它们，从而有安全问题。 12345678910111213141516171819202122232425262728293031323334353637383940class Component&#123;public: virtual void process() = 0; virtual ~Component()&#123;&#125;&#125;;//树枝节点 &amp; 叶子节点class Composite : public Component&#123; string name; list&lt;Component*&gt; elements;public: Composite(const string &amp; s) : name(s) &#123;&#125; void add(Component* element) &#123; elements.push_back(element); &#125; void remove(Component* element)&#123; elements.remove(element); &#125; void process()&#123; //1. process current node //2. process leaf nodes for (auto &amp;e : elements) e-&gt;process(); //多态调用 &#125;&#125;;//对组合对象和单个对象执行一致处理void Invoke(Component &amp; c)&#123; //... c.process(); //...&#125; 安全式 将管理子component的方法移到树枝component中，抽象component和叶子component没有对子component的管理方法，从而避免上一种方式的安全性问题。 由于叶子和分支有不同的接口，因此客户端在调用时要知道叶子对象和树枝对象的存在，不再严格透明。 123456789101112131415161718192021222324252627282930313233class Component&#123;public: virtual void process() = 0; virtual ~Component()&#123;&#125;&#125;;//树节点class Composite : public Component&#123; string name; list&lt;Component*&gt; elements;public: Composite(const string &amp; s) : name(s) &#123;&#125; void add(Component* element) &#123; elements.push_back(element); &#125; void remove(Component* element)&#123; elements.remove(element); &#125; void process()&#123; //1. process current node //2. process leaf nodes for (auto &amp;e : elements) e-&gt;process(); //多态调用 &#125;&#125;; 1234567891011121314151617//叶子节点class Leaf : public Component&#123; string name;public: Leaf(string s) : name(s) &#123;&#125; void process()&#123; //process current node &#125;&#125;;//对组合对象和单个对象执行一致处理void Invoke(Component &amp; c)&#123; //... c.process(); //...&#125; 1234567891011121314151617//main函数int main()&#123; Composite root(&quot;root&quot;); Composite treeNode1(&quot;treeNode1&quot;); Composite treeNode2(&quot;treeNode2&quot;); Leaf leat1(&quot;left1&quot;); root.add(&amp;treeNode1); treeNode1.add(&amp;treeNode2); treeNode2.add(&amp;leaf1); process(root); process(leaf1); process(treeNode2);&#125; 11 享元模式（Flyweight） 很多情况下，需要在系统中增加类和对象的个数，当对象数量太多时，将导致运行代价过高，带来性能下降等问题。享元模式针对此问题诞生，其使得相同或相似对象在重用时，共享某一个对象的内容。 在享元模式中可以共享的相同内容称为内部状态，而那些需要外部环境来设置的不能共享的内容称为外部状态。享元模式中通常会出现工厂模式，需创建一个享元工厂来维护一个享元池，用于存储具有相同内部状态的享元对象。 享元模式的优点在于，可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份 （Flyweight其实就是轻量级） Flyweight：抽象享元类，描述一个接口，通过这个接口Flyweight可以接受并作用于外部状态 ConcreteFlyweight：具体享元类，定义了一些内部状态。ConcreteFlyweight对象必须是可共享的 UnsharedConcreteFlyweight：非共享具体享元类 FlyweightFactory：享元工厂类，创建并管理FlyWeight。当用户请求一个Flyweight时，FlyweightFactory对象提供一个已创建的实例，如果请求的实例不存在，就新创建一个实例。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/// @brief 非享元类, 以参数的形式注入具体享元的相关方法中class UnsharableConcreteFlyweight &#123;public: UnsharableConcreteFlyweight(const std::string&amp; content) : content_(content) &#123;&#125; const std::string&amp; GetContent() const &#123; return content_; &#125;private: std::string content_;&#125;;/// @brief 抽象享元类, 为具体享元规范需要实现的公共接口class AbstractFlyweight &#123;public: virtual ~AbstractFlyweight() &#123;&#125; virtual void Run(UnsharableConcreteFlyweight* unsharable_content_ptr) = 0;&#125;;/// @brief 具体享元类, 实现抽象享元角色中所规定的接口class ConcreteFlyweightA : public AbstractFlyweight &#123;public: virtual void Run(UnsharableConcreteFlyweight* unsharable_content_ptr) &#123; std::cout &lt;&lt; &quot;ConcreteFlyweightA::Run!&quot; &lt;&lt; std::endl; std::cout &lt;&lt; unsharable_content_ptr-&gt;GetContent() &lt;&lt; std::endl; &#125;&#125;;class ConcreteFlyweightB : public AbstractFlyweight &#123;public: virtual void Run(UnsharableConcreteFlyweight* unsharable_content_ptr) &#123; std::cout &lt;&lt; &quot;ConcreteFlyweightB::Run!&quot; &lt;&lt; std::endl; std::cout &lt;&lt; unsharable_content_ptr-&gt;GetContent() &lt;&lt; std::endl; &#125;&#125;;/// @brief 享元工厂类class FlyweightFactory &#123;public: enum FlyweightType &#123; ConcreteA = 0, ConcreteB, &#125;; ~FlyweightFactory() &#123; for (auto it = fly_weights_.begin(); it != fly_weights_.end(); it++) &#123; if (it-&gt;second) delete it-&gt;second; &#125; fly_weights_.clear(); &#125; AbstractFlyweight* GetFlyweight(const std::string&amp; key, const FlyweightType&amp; type = ConcreteA) &#123; auto it = fly_weights_.find(key); if (fly_weights_.end() == it) &#123; AbstractFlyweight* ptr = nullptr; if (ConcreteA == type) &#123; ptr = new ConcreteFlyweightA(); &#125; else if (ConcreteB == type) &#123; ptr = new ConcreteFlyweightB(); &#125; fly_weights_[key] = ptr; &#125; return fly_weights_[key]; &#125;private: std::map&lt;std::string, AbstractFlyweight*&gt; fly_weights_;&#125;; main函数 123456789101112131415int main()&#123; std::shared_ptr&lt;UnsharableConcreteFlyweight&gt; unsharable_content_ptr_1(new UnsharableConcreteFlyweight(&quot;unsharable_content_ptr_1&quot;)); std::shared_ptr&lt;UnsharableConcreteFlyweight&gt; unsharable_content_ptr_2(new UnsharableConcreteFlyweight(&quot;unsharable_content_ptr_2&quot;)); std::shared_ptr&lt;FlyweightFactory&gt; ptr(new FlyweightFactory()); AbstractFlyweight* flyweight_ptr_A_red = ptr-&gt;GetFlyweight(&quot;Red&quot;); AbstractFlyweight* flyweight_ptr_A_point = ptr-&gt;GetFlyweight(&quot;Point&quot;); flyweight_ptr_A_red-&gt;Run(unsharable_content_ptr_1.get()); flyweight_ptr_A_point-&gt;Run(unsharable_content_ptr_2.get());&#125;// ConcreteFlyweightA::Run!// unsharable_content_ptr_1// ConcreteFlyweightA::Run!// unsharable_content_ptr_2 📌享元模式在编辑器软件中大量使用，如在一个文档中多次出现相同的图片，则只需要创建一个图片对象，通过在应用程序中设置该图片出现的位置，可以实现该图片在不同地方多次重复显示。 行为型 📌迭代器(5) = 观察者(5) &gt; 命令(4) = 策略(4) &gt; 职责链(3) = 状态(3) = 模板(3) &gt; 中介(2) = 备忘录(2) &gt; 访问者(1) = 解释器(1) 12 观察者模式（Observer） 观察者模式建立对象与对象之间的一对多依赖关系。一个对象发生改变时，将自动通知其他对象，其他对象会做出相应的反应（如被自动更新）。 发生改变的对象称为观察目标，而被通知的对象称为观察者。 观察者模式又被称作发布-订阅模式(Publish/Subscribe)、模型-视图模式(Model/View)、源-监听器模式(Source/Listener)、从属者模式(Dependents)。 优点：支持广播通信，符合开闭原则。可以实现表示层和数据逻辑层的分离，在观察目标和观察者之间建立一个抽象的耦合。 缺点： 如果一个观察目标对象有很多直接和间接的观察者的话，将所有观察者都通知到会花费很多时间 如果观察者和观察目标之间有循环依赖，观察目标会触发它们之间循环调用，可能系统崩溃 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/// @brief 抽象观察者, 包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。class AbstractObserver &#123;public: ~AbstractObserver() &#123;&#125; // 被告知时做出响应 virtual void Response() = 0;&#125;;/// @brief 具体观察者, 实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。class ConcreteObserverA : public AbstractObserver &#123;public: virtual void Response() &#123; printf(&quot;this is ConcreteObserverA::Response!\\n&quot;); &#125;&#125;;class ConcreteObserverB : public AbstractObserver &#123;public: virtual void Response() &#123; printf(&quot;this is ConcreteObserverB::Response!\\n&quot;); &#125;&#125;;/// @brief 抽象主题类, 它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法class AbstractSubject &#123;public: virtual ~AbstractSubject() &#123;&#125; virtual void NotifyObserver() = 0; void AddObserver(AbstractObserver* observer) &#123; observers_.emplace_back(observer); &#125; void RemoveObserver(AbstractObserver* observer) &#123; for (auto it = observers_.begin(); it != observers_.end(); it++) &#123; if ((*it) == observer) &#123; observers_.erase(it++); break; &#125; &#125; &#125;protected: std::vector&lt;AbstractObserver*&gt; observers_;&#125;;/// @brief 具体主题类, 它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。class ConcreteSubject : public AbstractSubject &#123;public: virtual void NotifyObserver() &#123; for (auto* observer : observers_) &#123; observer-&gt;Response(); &#125; &#125;&#125;;int main()&#123; printf(&quot;-------------------- %s --------------------\\n&quot;, __FUNCTION__); std::shared_ptr&lt;AbstractSubject&gt; ptr_subject(new ConcreteSubject()); std::shared_ptr&lt;AbstractObserver&gt; ptr_observer_A(new ConcreteObserverA()); std::shared_ptr&lt;AbstractObserver&gt; ptr_observer_B(new ConcreteObserverB()); ptr_subject-&gt;AddObserver(ptr_observer_A.get()); ptr_subject-&gt;AddObserver(ptr_observer_B.get()); ptr_subject-&gt;NotifyObserver();&#125; 13 模板方法（Template） 定义一个操作中的算法的骨架（稳定），而将一些步骤延迟（变化）到子类中 其实模板方法顾名思义，就是定义一个抽象类，在该类中将一个算法的大致框架写好，而细节则由其派生的具体类来实现。 应用场景： 在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。 对应于生活中的例子，可以类比写论文的过程。写论文需要提前写出提纲，确定各段的标题和整体结构，但是每小段的文字可以后面再具体写。 实现方式： 抽象类负责给出一个算法的轮廓和骨架，定义两种类型的方法 模板方法：定义在抽象类中的，把基本操作方法组合在一起形成总算法或总行为的方法。 子类会不加修改地完全继承这个方法。 基本方法： 抽象方法（延迟的内容）：在抽象类中声明，由具体子类实现 具体方法（骨架）：在抽象类中已实现，具体子类中可以继承或重写它 钩子方法：抽象类中已实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061namespace template_method &#123;/// @brief 抽象类, 给出一个算法的轮廓和骨架class AbstractClass &#123;public: virtual ~AbstractClass() &#123;&#125; /// @brief 模板方法, 定义了算法的骨架，按某种顺序调用其包含的基本方法 virtual void TemplateMethod() &#123; SpecificMethodA(); if (HookMethodB()) &#123; HookMethodA(); &#125; AbstractMethod(); SpecificMethodB(); &#125;protected: /// @brief 基本方法, 可以有三种 /// - 抽象方法：在抽象类中申明，由具体子类实现 /// - 具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它 /// - 钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种 virtual void AbstractMethod() = 0; virtual void SpecificMethodA() &#123; printf(&quot;this is AbstractClass::SpecificMethodA!\\n&quot;); &#125; virtual void SpecificMethodB() &#123; printf(&quot;this is AbstractClass::SpecificMethodB!\\n&quot;); &#125; virtual void HookMethodA() &#123; // 通常为空实现 printf(&quot;this is AbstractClass::HookMethodA!\\n&quot;); &#125; virtual bool HookMethodB() &#123; return false; &#125;&#125;;/// @brief 具体类, 实现抽象类中所定义的抽象方法和钩子方法class ConcreteClass : public AbstractClass &#123;public: virtual void AbstractMethod() &#123; printf(&quot;this is ConcreteClass::AbstractMethod!\\n&quot;); &#125;protected: virtual void SpecificMethodB() &#123; printf(&quot;this is ConcreteClass::SpecificMethodB!\\n&quot;); &#125; virtual void HookMethodA() &#123; // 通常为空实现 printf(&quot;this is ConcreteClass::HookMethodA!\\n&quot;); &#125; virtual bool HookMethodB() &#123; return true; &#125;&#125;;&#125; // namespace template_methodvoid Test_13_composite_impl_1() &#123; printf(&quot;-------------------- %s --------------------\\n&quot;, __FUNCTION__); template_method::AbstractClass* ptr = new template_method::ConcreteClass(); ptr-&gt;TemplateMethod(); delete ptr;&#125; 优点： 封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。 在父类中提取了公共的部分代码，便于代码复用。 部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。 缺点： 对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象 📌一般推荐将三种基本方法设置为protected 模板方法中，存在由子类影响父类的反向控制，是“控制反转”的典型应用 14 策略模式（Strategy/Policy） 软件开发中往往会遇到这样的情况：实现某一个功能有多个途径。而这些不同的方式均被称为策略，每一种方式就是一个策略。 比如实现一个负责查找任务的类，而查找有若干种算法，在类中每一个方法对应着一种算法。或者将所有的算法都封装进一个方法中，通过输入参数和if…else…来判定具体使用何种查找算法。这两种方式都属于硬编码（hard coding），是不推荐的。 原因在于，每增加一种新的查找算法，就需要修改封装算法类的源代码；而且更换查找算法时，也需要修改客户端的调用代码。如果算法类中封装了大量算法，那么该类的代码会比较复杂，维护较为困难。 策略模式旨在解决这样的问题（可以记忆为，解决代码中的大量if…else…），其将众多策略都写成一个类，利用抽象策略类为用户提供接口。同时，让一个Context类（环境类）来耦合客户端和算法类，提供setStrategy用于更换算法，并进行统一语义的执行 Context：环境类 Strategy：抽象策略类 ConcreteStrategy：具体策略类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/// @brief 抽象策略类, 定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法class AbstractStrategy &#123;public: virtual ~AbstractStrategy() &#123;&#125; virtual void StrategyMethod() = 0;&#125;;/// @brief 具体策略类, 实现了抽象策略定义的接口，提供具体的算法实现class ConcreteStrategyA : public AbstractStrategy &#123;public: virtual void StrategyMethod() &#123; printf(&quot;this is ConcreteStrategyA::StrategyMethod!\\n&quot;); &#125;&#125;;class ConcreteStrategyB : public AbstractStrategy &#123;public: virtual void StrategyMethod() &#123; printf(&quot;this is ConcreteStrategyB::StrategyMethod!\\n&quot;); &#125;&#125;;/// @brief 环境类, 持有一个策略类的引用，最终给客户端调用class Context &#123;public: void SetStrategy(AbstractStrategy* strategy) &#123; strategy_ = strategy; &#125; void StrategyMethod() &#123; if (strategy_) strategy_-&gt;StrategyMethod(); &#125;private: AbstractStrategy* strategy_ = nullptr;&#125;;int main()&#123; AbstractStrategy* ptr_strategy_A = new ConcreteStrategyA(); AbstractStrategy* ptr_strategy_B = new ConcreteStrategyB(); Context env_; env_.SetStrategy(ptr_strategy_A); env_.StrategyMethod(); env_.SetStrategy(ptr_strategy_B); env_.StrategyMethod(); delete ptr_strategy_A; delete ptr_strategy_B;&#125; 优点： 符合开闭原则，用户可以在不修改原有系统的基础上选择算法行为，也可以灵活地增加新的算法或行为 避免多重条件语句 提供了管理相关的算法族的办法 缺点： 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。 15 职责链模式（Chain of Responsibility） 考虑这样的例子：企业的采购审批是一般是分级进行的，即根据采购金额的不同由不同层次的主管人员来审批。主任可以审批5万元以下的采购单，副董事长可以审批5万元至10万元的采购单，董事长可以审批10万元至50万元的采购单，50万元及以上的采购单就需要开董事会讨论决定。 那么一个自动化的审批类可以写成如下形式： 123456789101112131415161718192021222324252627class PurchaseRequestHandler &#123;public: void handlePurchaseRequest(const PurchaseRequest&amp; request) &#123; int amount = request.getAmount(); if(amount &lt; 50000) &#123; this-&gt;handleByDirector(request); &#125; else if(amount &lt; 100000) &#123; this-&gt;handleByVicePresident(request); &#125; else if(amount &lt; 500000) &#123; this-&gt;handleByPresident(request); &#125; else &#123; this-&gt;handleByCongress(request); &#125; &#125;private: // 主任审批采购单 void handleByDirector(const PurchaseRequest&amp; request) &#123; &#125; // 副董事长审批采购单 void handleByVicePresident(const PurchaseRequest&amp; request) &#123; &#125; // 董事长审批采购单 void handleByPresident(const PurchaseRequest&amp; request) &#123; &#125; // 董事会审批采购单 void handleByCongress(const PurchaseRequest&amp; request) &#123; &#125;&#125;; 但是仔细审视这段代码的话，首先，它违反了单一职责原则，各个级别的审批方法都集中在一个类中，测试和维护难度大。同时不够灵活，现有审批流程从“主任→副董→董事长→董事会”改为“主任→董事长→董事会”，就必须修改类的源代码。 职责链模式面向的场景：一个请求有多个对象可以处理，但是每个对象的处理条件或权限不同。 职责链负责解决这样的问题，将每一级写成对象后，排成一个链表。而每一级的执行顺序，交由客户端来管理。 Handler：抽象处理者，successor负责对下一级的引用，通过successor，处理者们可以连成一条链 ConcreteHandler：具体处理者，继承抽象处理者，负责具体实现对请求的响应。 职责链模式代码模板： 1234567891011121314151617181920212223// 抽象处理者class Handler &#123;public: void setSuccessor(const std::shared_ptr&lt;Handler&gt;&amp; successor) &#123; successor_ = successor; &#125; virtual void handleRequest(const Request&amp; request) = 0;protected: std::shared_ptr&lt;Handler&gt; successor_;&#125;;// 具体处理者class ConcreteHandler : public Handler &#123;public: void handleRequest(const Request&amp; request) &#123; if(/*满足某个条件*/) &#123; // TO DO &#125; else &#123; successor_-&gt;handleRequest(request); &#125; &#125;&#125;; 📌职责链模式更细分的话也有两种：纯职责链和非纯职责链 纯职责链中，每一级直接完全承担对请求的响应； 非纯职责链中，每一级承担部分响应工作。 针对上面的例子，使用职责链模式修改的结果如下： 1234567891011121314151617181920212223242526272829303132333435// 采购请求处理类：抽象处理类class PurchaseRequestHandler &#123;public: void setSuccessor(const std::shared_ptr&lt;PurchaseRequestHandler&gt;&amp; successor) &#123; successor_ = successor; &#125; virtual void handlePurchaseRequest(const PurchaseRequest&amp; request) = 0;protected: std::shared_ptr&lt;PurchaseRequestHandler&gt; successor_;&#125;;// 主任类：具体处理者class DirectorHandler : public PurchaseRequestHandler &#123;public: void handlePurchaseRequest(const PurchaseRequest&amp; request) &#123; if(request.getAmount() &lt; 50000) &#123; &#125; else &#123; successor_-&gt;handlePurchaseRequest(request); &#125; &#125;&#125;;... ...// 客户端代码PurchaseRequest request;request.setAmount(1000);std::shared_ptr&lt;PurchaseRequestHandler&gt; director = std::make_shared&lt;DirectorHandler&gt;();std::shared_ptr&lt;PurchaseRequestHandler&gt; vicePresident = std::make_shared&lt;VicePresidentHandler&gt;();std::shared_ptr&lt;PurchaseRequestHandler&gt; president = std::make_shared&lt;PresidentHandler&gt;();std::shared_ptr&lt;PurchaseRequestHandler&gt; congress = std::make_shared&lt;CongressHandler&gt;();director-&gt;setSuccessor(vicePresident);vicePresident-&gt;setSuccessor(president);president-&gt;setSuccessor(congress);director-&gt;handlePurchaseRequest(request); 优点： 由客户端负责职责链的创建，链中对象不需要知道链的结构，降低了系统耦合度 灵活性更强，添加一个新的具体请求处理者时无需更改原有系统的代码，只需要在客户端重新建链即可，符合开闭原则。 缺点： 可能会出现循环引用的问题，导致系统进入死循环 系统性能受到一定影响，代码调试时不太方便 由于一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理。 16 状态模式（State） 状态模式将各种可能的行为构建成了状态机，每次请求时自动切换状态（更改行为）。 应用场景： 在软件开发过程中，应用程序中的有些对象可能会根据不同的情况做出不同的行为，我们把这种对象称为有状态的对象，而把影响对象行为的一个或多个动态变化的属性称为状态。当有状态的对象与外部事件产生互动时，其内部状态会发生改变，从而使得其行为也随之发生改变。如人的情绪有高兴的时候和伤心的时候，不同的情绪有不同的行为，当然外界也会影响其情绪变化。 状态模式流程： 传统方案可能会选择用if…else…来进行分支，涵盖所有的行为。这样的话不符合开闭原则不易维护扩展。状态模式将每种状态及其行为封装成了具体状态类ConcreteState，而所有的具体状态类继承自抽象状态类。用户与Context类交互，Context记录着当前系统的状态，当用户请求时，Context对象将根据当前状态调用具体状态类的行为，同时根据发生的行为更改自己维护的状态，以供下一次请求使用。本质上，在类之间建立状态机，而状态转换的规则维护在了各个具体状态类中。 123456789101112131415161718class Context&#123;public: Context()&#123; m_pState = ConcreteStateA::Instance(); &#125;; virtual ~Context(); void changeState(State * st)&#123; m_pState = st; &#125;; void request()&#123; m_pState-&gt;handle(this); &#125;;private: State *m_pState;&#125;; 12345678910111213141516171819202122class ConcreteStateA : public State&#123;public: virtual ~ConcreteStateA(); static State * Instance()&#123; if ( NULL == m_pState) &#123; m_pState = new ConcreteStateA(); &#125; return m_pState; &#125;; virtual void handle(Context * c)&#123; cout &lt;&lt; &quot;doing something in State A.\\n done,change state to B&quot; &lt;&lt; endl; c-&gt;changeState(ConcreteStateB::Instance()); &#125;;private: ConcreteStateA(); static State * m_pState;&#125;; 12345678910111213141516int main(int argc, char *argv[])&#123; char a = &#x27;0&#x27;; if(&#x27;0&#x27; == a) cout &lt;&lt; &quot;yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;no&quot; &lt;&lt; endl; Context * c = new Context(); c-&gt;request(); c-&gt;request(); c-&gt;request(); delete c; return 0;&#125; 优点： 相比于if…else…进行状态变更与判断，状态模式符合单一职责原则，而且开闭原则也支持得更好一些。 缺点： 对开闭原则仍然不是很友好，想扩展新状态就必须修改若干具体状态类的源码，修改行为也需要修改对应的源码。因此需要开发者尽可能事先考虑到所有的可能状态。 17 迭代器模式（Iterator） 迭代器提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。 优点： 访问一个聚合对象的内容而无需暴露它的内部表示 遍历任务交由迭代器完成，简化了聚合类（聚合类可以不用操心实现迭代的功能） 支持以不同的方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历 增加新的聚合类和迭代器类都很方便，无需修改原有代码 封装性良好，为遍历不同的聚合结构提供一个统一的接口 C++的STL自带了Iterator，无需再手动实现。然而为了能够更直观的看迭代器模式是怎么操作的，这里简单写了一下： Aggregate 12345678class Aggregate&#123;public: virtual int count() = 0; virtual void push(const std::string&amp; strValue) = 0; virtual std::string operator[](int nIndex) = 0; virtual Iterator* createIterator() = 0;&#125;; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class ConcreteAggregate : public Aggregate&#123;public: ~ConcreteAggregate(); int count() override; void push(const std::string&amp; strValue)override; //重载下标运算符，只重载了取值功能 std::string operator[](int nIndex); Iterator* createIterator();private: std::vector&lt;std::string&gt; m_vecItems; Iterator* m_pIterator&#123; nullptr &#125;;&#125;;ConcreteAggregate::~ConcreteAggregate()&#123; if (nullptr != m_pIterator) &#123; delete m_pIterator; m_pIterator = nullptr; &#125;&#125;int ConcreteAggregate::count()&#123; return m_vecItems.size();&#125;void ConcreteAggregate::push(const std::string&amp; strValue)&#123; m_vecItems.push_back(strValue);&#125;std::string ConcreteAggregate::operator[](int nIndex)&#123; std::string strRet; if (nIndex &lt; count()) &#123; strRet = m_vecItems[nIndex]; &#125; return strRet;&#125;Iterator* ConcreteAggregate::createIterator()&#123; if (nullptr == m_pIterator) &#123; m_pIterator = new ConcreteIterator(this); &#125; return m_pIterator;&#125; Iterator 12345678class Iterator&#123;public: virtual std::string first() = 0; virtual std::string next() = 0; virtual bool isDone() = 0; virtual std::string currentItem() = 0;&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344class ConcreteIterator : public Iterator&#123;public: ConcreteIterator(Aggregate* pAggregate); std::string first(); std::string next(); bool isDone(); std::string currentItem();private: Aggregate* m_pAggregate&#123; nullptr &#125;; int m_nCurrent&#123; 0 &#125;;&#125;;ConcreteIterator::ConcreteIterator(Aggregate* pAggregate) :Iterator(), m_pAggregate(pAggregate)&#123;&#125;std::string ConcreteIterator::first()&#123; return (*m_pAggregate)[0];&#125;std::string ConcreteIterator::next()&#123; std::string strRet; m_nCurrent++; if (m_nCurrent &lt; m_pAggregate-&gt;count()) &#123; strRet = (*m_pAggregate)[m_nCurrent]; &#125; return strRet;&#125;bool ConcreteIterator::isDone()&#123; return (m_nCurrent &gt;= m_pAggregate-&gt;count()) ? true : false;&#125;std::string ConcreteIterator::currentItem()&#123; return (*m_pAggregate)[m_nCurrent];&#125; client 12345678910111213141516171819202122232425void client()&#123; ConcreteAggregate* pName = new ConcreteAggregate(); if (nullptr != pName) &#123; pName-&gt;push(&quot;墨白&quot;); pName-&gt;push(&quot;金戈铁马&quot;); pName-&gt;push(&quot;气吞万里如虎&quot;); &#125; Iterator* iter = pName-&gt;createIterator(); if (nullptr != iter) &#123; std::string strItem = iter-&gt;first(); while (!iter-&gt;isDone()) &#123; std::cout &lt;&lt; iter-&gt;currentItem() &lt;&lt; std::endl; iter-&gt;next(); &#125; &#125; std::cout &lt;&lt; &quot;================================&quot; &lt;&lt; std::endl; for (int i = 0; i &lt; pName-&gt;count(); ++i) &#123; std::cout &lt;&lt; (*pName)[i] &lt;&lt; std::endl; &#125;&#125; 18 访问者模式（Visitor） 访问者模式表示一个作用于某对象结构中各元素的操作，它使我们可以在不改变各元素的类的前提下，定义作用于这些元素的新操作。 应用场景： 某对象结构中，各元素的类型可能不一致，而上层需要一个对各元素具体操作的统一接口。 Visitor：抽象访问者，为ObjectStructure类中每一个元素声明一个访问操作。 ConcreteVisitor：具体访问者，针对集合中的各具体类型，定义具体访问操作。 Element：抽象元素，即集合中的所有具体元素均继承自该抽象元素类，定义了一个accpet( )方法，方法以一个抽象访问者作为参数。 ConcreteElement：具体元素，实现了Accpet( )方法。接收不同的ConcreteVisitor对象作为参数，就表示在使用不同的集合元素操作方式。 ObjectStructure：元素的集合，各元素可能属于不同类型，类提供了遍历其内部元素的方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;iostream&gt; #include &lt;vector&gt;using namespace std;class ConcreteElementA;class ConcreteElementB;/*抽象访问者 声明了访问元素对象的方法，通常为每一种类型的元素对象都提供一个访问方法*/class Visitor&#123;public: virtual void VisitConcreteElementA(ConcreteElementA *pElementA) = 0; virtual void VisitConcreteElementB(ConcreteElementB *pElementB) = 0;&#125;;/*具体访问者 用于定义对不同类型元素对象的操作*/class ConcreteVisitor1 : public Visitor&#123;public: void VisitConcreteElementA(ConcreteElementA *pElementA)&#123; // 现在根据传进来的pElementA，可以对ConcreteElementA中的element进行操作 &#125; void VisitConcreteElementB(ConcreteElementB *pElementB)&#123; // 现在根据传进来的pElementB，可以对ConcreteElementB中的element进行操作 &#125;&#125;;/*具体访问者2*/class ConcreteVisitor2 : public Visitor&#123;public: void VisitConcreteElementA(ConcreteElementA *pElementA)&#123; &#125; void VisitConcreteElementB(ConcreteElementB *pElementB)&#123; &#125;&#125;;/*抽象元素类 声明accept()方法，用于接受访问者的访问*/class Element&#123;public: virtual void Accept(Visitor *pVisitor) = 0;//accept用于接受访问者的访问&#125;;/*具体元素类 通过调用Visitor类的visit()方法实现对元素的访问*/class ConcreteElementA : public Element&#123;public: void Accept(Visitor *pVisitor)//通过调用visitor对象的 visit()方法实现对元素对象的访问 &#123; pVisitor-&gt;VisitConcreteElementA(this); &#125;&#125;;/*具体元素类 */class ConcreteElementB : public Element&#123;public: void Accept(Visitor *pVisitor) &#123; pVisitor-&gt;VisitConcreteElementB(this); &#125;&#125;;// ObjectStructure类(对象结构类)，能枚举它的元素，可以提供一个高层的接口以允许访问者访问它的元素class ObjectStructure&#123;public: void Attach(Element *pElement)&#123; elements.push_back(pElement); &#125; void Detach(Element *pElement) &#123; vector&lt;Element *&gt;::iterator it = find(elements.begin(), elements.end(), pElement); if (it != elements.end()) &#123; elements.erase(it); &#125; &#125; void Accept(Visitor *pVisitor)&#123; // 为每一个element设置visitor，进行对应的操作 for (vector&lt;Element *&gt;::const_iterator it = elements.begin(); it != elements.end(); ++it) &#123; (*it)-&gt;Accept(pVisitor); &#125; &#125;&#125;int main()&#123; //实例化对象结构，用于存放元素对象，提供遍历其内部元素的方法 ObjectStructure *pObject = new ObjectStructure; //实例化具体元素 并将创建好的元素放入对象结构中 ConcreteElementA *pElementA = new ConcreteElementA; ConcreteElementB *pElementB = new ConcreteElementB; pObject-&gt;Attach(pElementA); pObject-&gt;Attach(pElementB); //实例化访问者 ConcreteVisitor1 *pVisitor1 = new ConcreteVisitor1; ConcreteVisitor2 *pVisitor2 = new ConcreteVisitor2; //调用accept方法 来接受访问者对象的访问 pObject-&gt;Accept(pVisitor1); pObject-&gt;Accept(pVisitor2); if (pVisitor2) delete pVisitor2; if (pVisitor1) delete pVisitor1; if (pElementB) delete pElementB; if (pElementA) delete pElementA; if (pObject) delete pObject; return 0; 优点： 将数据结构和作用于数据结构之上的操作之间的耦合解开，使得操作数据结构集合可以相对自由的演化。换言之，如果系统的数据结构稳定的话，使用访问者模式使得算法更改或者增加变得很容易，只需添加新的具体访问者类即可。 符合单一职责原则，访问者模式把相关的行为封装在一起，使每一个访问者的功能都比较单一。 缺点： 虽然扩展面向数据结构的算法会比较容易，但是增加新的元素类会变得困难。每增加一个新的元素类都意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者中增加相应的具体操作，违背了开闭原则。 违反了依赖倒置原则，访问者模式依赖了具体类，而没有依赖抽象类。 19 备忘录模式（Memento） Memento 在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它 以打游戏为例，当通过一关时往往会选择存档，下次再玩时就可以从存档的地方开始，而不需要从头开玩。这里就用到了备忘录模式，通过记录状态，而避免不必要的重复劳动。 很多应用软件都提供了这项功能，如 Word、记事本、Photoshop、Eclipse 等软件在编辑时按 Ctrl+Z 组合键时能撤销当前操作，使文档恢复到之前的状态；还有在 IE 中的后退键、数据库事务管理中的回滚操作、玩游戏时的中间结果存档功能、数据库与操作系统的备份操作、棋类游戏中的悔棋功能等都属于这类。 实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Memento &#123; // 备忘录private: string state;public: Memento(string s) &#123; state = s; &#125; string GetState() &#123; return state; &#125; void SetState(string s) &#123; state = s; &#125;&#125;;class Caretaker &#123; // 管理者private: Memento* menento;public: // Caretaker(Memento* m) &#123; menento = m; &#125; Memento* GetMemento() &#123; return menento; &#125; void SetMemento(Memento* m) &#123; menento = m; &#125; ~Caretaker() &#123; delete menento; &#125;&#125;;class Originator &#123; // 发起人private: string state; // 需要保存的属性public: string GetState() &#123; return state; &#125; void SetState(string s) &#123; state = s; &#125; Memento* CreateMemento() &#123; return new Memento(state); &#125; // 创建备忘录对象，保存信息 void SetMemento(Memento* m) &#123; state = m-&gt;GetState(); &#125; // 恢复备忘录 void Show() &#123; cout &lt;&lt; &quot;state: &quot; &lt;&lt; state &lt;&lt; endl; &#125;&#125;;int main() &#123; Originator* o = new Originator(); o-&gt;SetState(&quot;On&quot;); o-&gt;Show(); // state: On Caretaker* c = new Caretaker(); c-&gt;SetMemento(o-&gt;CreateMemento()); // 保存状态 o-&gt;SetState(&quot;Off&quot;); o-&gt;Show(); // state: Off o-&gt;SetMemento(c-&gt;GetMemento()); // 恢复初始状态 o-&gt;Show(); // state: On delete o; delete c; return 0;&#125; 优点： 提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。 实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。 发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合。 缺点： 资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。 20 命令模式（Command） 将一个请求封装成一个对象，使发出请求的责任和执行请求的责任分割开。 以12306应用为例： 紧耦合：老版本的12306网站，买票时可以不停地用鼠标点击12306网站上的购票按钮来抢票。对于每一次点击，服务器都要进行处理，做出响应，来告诉用户有没有买到票，这样的话会出现很多次无效的点击，增加了服务器的负担。 此时，发出请求和执行请求，二者进入了紧耦合的状态。用户（命令发送者）通过按钮（具体命令）来买票（12306网站服务器成为命令接收者）。 松耦合：新版本的12306网站引入了购票队列机制。当点击购票按钮后，购票请求就进入了相应的购票队列，进入后再次鼠标点击购票时，12306会拒绝新的购票请求，并且告诉用户已经进入了购票队列。处于购票队列的用户也可以选择退出购票队列去购买其他车次的车票。这样就可以有效地减少购票者发送多次无效购票请求的情况。 观察这样的改进方案，可以发现，将前面的发出请求和执行请求解耦了。用户点击按钮后发出请求，请求进入了队列中，此时队列成为了后面流程下具体的请求发送者，不同的请求对应了不同的命令。不同命令需要采取不同的动作，动作是由接收者（服务器）做出的，因此将这些动作都封装成类之后，就可以与相应的命令类绑定。而队列发出请求后，先找到相应的命令，再由命令执行绑定的接收者的动作。命令中可以结合备忘录模式记录状态，而队列里可以实现消除无效点击的代码。 也就是说，核心在请求的发送者和请求的执行者之间增加了“命令”和新的“请求管理者”，以解耦二者。命令便于对功能进行扩展。如果想有新的按钮功能，实现新的具体命令类即可，同时具体命令类中可以记录状态，这样请求管理者就方便做撤销、重做等操作。 应用场景： 软件开发系统中，常常出现“方法的请求者”与“方法的实现者”之间存在紧密的耦合关系，不利于软件功能的扩展与维护。比如，想对行为进行“撤销、重做、记录”等处理都不方便。 命令模式旨在将“请求者”和“实现者”解耦，通过在二者之间增加“命令”。命令中可以记录状态，进行撤销等操作。想要扩展功能，也就可以实现新的具体命令类或新的具体接收者类。 Command：抽象命令类，声明响应请求时待执行操作的接口。 ConcreteCommand：具体命令类，绑定一个接收者，通过让接收者做出动作来执行命令。 Execute方法来调用相应的Receiver对象，从而响应请求。也可以实现其他方法来扩展此命令下的可选操作。 Invoker：与客户端直接相关，请求的发送者或者请求的管理者。 Receiver：真正的接收者，实现响应请求需要做的动作。 12345678910111213141516171819202122232425262728293031323334353637383940414243/// @brief 抽象命令类, 声明执行命令的接口class AbstractCommand &#123;public: virtual ~AbstractCommand() &#123;&#125; virtual void Execute() = 0;&#125;;/// @brief 命令接收者, 执行命令功能的相关操作，是具体命令对象业务的真正实现者class Receiver &#123;public: void Action() &#123; printf(&quot;this is Receiver::Action!\\n&quot;); &#125;&#125;;/// @brief 具体命令类, 它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作class ConcreteCommand : public AbstractCommand &#123;public: ConcreteCommand() &#123; receiver_.reset(new Receiver()); &#125; virtual void Execute() &#123; receiver_-&gt;Action(); &#125;private: std::shared_ptr&lt;Receiver&gt; receiver_;&#125;;/// @brief 命令请求者, 请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者class Invoker&#123;public: Invoker(AbstractCommand* cmd) : cmd_(cmd) &#123;&#125; void SetCommand(AbstractCommand* cmd) &#123; cmd_ = cmd; &#125; void Request() &#123; cmd_-&gt;Execute(); &#125;private: AbstractCommand* cmd_;&#125;; main函数 123456int main()&#123; std::shared_ptr&lt;AbstractCommand&gt; cmd(new ConcreteCommand()); Invoker client(cmd.get()); client.Request(); return 0;&#125; 优点： 降低系统的耦合度，将调用操作的对象与实现该操作的对象解耦。 增加或删除命令非常方便。增加或删除操作不会影响其他类，满足开闭原则。 可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。 方便实现Undo和Redo操作。命令模式可以与备忘录模式结合，实现命令的撤销与恢复。 宏命令 前面提到，命令模式可以与组合模式相结合，从而让多个命令共同组装为一个组合命令，即宏命令。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/// @brief 抽象命令类, 声明执行命令的接口class AbstractMacroCommand &#123;public: virtual ~AbstractMacroCommand() &#123;&#125; virtual void Execute() = 0;&#125;;/// @brief 命令接收者, 执行命令功能的相关操作，是具体命令对象业务的真正实现者class CompositeReceiver &#123;public: void ActionA() &#123; printf(&quot;this is CompositeReceiver::ActionA!\\n&quot;); &#125; void ActionB() &#123; printf(&quot;this is CompositeReceiver::ActionB!\\n&quot;); &#125;&#125;;/// @brief 具体命令类, 它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作class ConcreteCommandA : public AbstractMacroCommand &#123;public: ConcreteCommandA() &#123; receiver_.reset(new CompositeReceiver()); &#125; virtual void Execute() &#123; receiver_-&gt;ActionA(); &#125;private: std::shared_ptr&lt;CompositeReceiver&gt; receiver_;&#125;;class ConcreteCommandB : public AbstractMacroCommand &#123;public: ConcreteCommandB() &#123; receiver_.reset(new CompositeReceiver()); &#125; virtual void Execute() &#123; receiver_-&gt;ActionB(); &#125;private: std::shared_ptr&lt;CompositeReceiver&gt; receiver_;&#125;;/// @brief 命令请求者, 请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者class CompositeInvoker&#123;public: void AddCommand(AbstractMacroCommand* cmd) &#123; cmds_.emplace_back(cmd); &#125; void RemoveCommand(AbstractMacroCommand* cmd) &#123; for (auto it = cmds_.begin(); it != cmds_.end(); it++) &#123; if (cmd == (*it)) &#123; cmds_.erase(it++); break; &#125; &#125; &#125; void Request() &#123; for (auto* cmd : cmds_) &#123; cmd-&gt;Execute(); &#125; &#125;private: std::vector&lt;AbstractMacroCommand*&gt; cmds_;&#125;;int main() &#123; std::shared_ptr&lt;AbstractMacroCommand&gt; cmd_A(new ConcreteCommandA()); std::shared_ptr&lt;AbstractMacroCommand&gt; cmd_B(new ConcreteCommandB()); CompositeInvoker client; client.AddCommand(cmd_A.get()); client.AddCommand(cmd_B.get()); client.Request(); return 0;&#125; 21 解释器模式（Interpreter） 以大数据统计为例：在大数据统计中，通常需要按照计算模型对现有数据统计、分析、预测。由于计算模型有很多，而且总是在更新，因此系统设计时需要具备高扩展性。 一般计算模型中包含两类符号：数据和计算符，可以将二者解耦，同时让各个计算符均为一个类，继承自抽象运算符类。这样，当需要更改一个运算符的行为时，仅更改该类的实现即可。而且想要扩展计算模型，增加新的具体计算符类即可。 解释器模式：定义一个语法，定义一个解释器，该解释器处理该语法句子。 类比到上面的例子，众多运算符操作的集合就是解释器，而语法就是在运算符类中实现的。解释器模式的结构如下：客户端给出表达式（算法模型），Context类将表达式分解为各种符号的组合。而抽象表达式类提供interpret的统一接口，其下分为终结符号和非终结符号两种。终结符号一般是数值、数据，而非终结符号一般为运算符，比如加减乘除四则运算。 当然，终结符号也可以扩展，比如从实数改为复数，那么仅需该TerminalExpression的具体实现即可，由于调用该类对象时会使用→interpret方法，因此NonterminalExpression可以改动很小甚至不改。 举一个更具体的例子——计算器。计算器的算法模型是逆波兰式，Calculator就相当于Context，在运算符实现时仅需针对数据类型实现四则运算即可。 （下面的代码实现并不好，可用职责链模式进一步优化） 抽象表达式类Node（抽象节点） 1234//抽象表达式类Node（抽象节点）class Node &#123; public: virtual int interpret() = 0; 终结符表达式类ValueNode（值节点类） 12345678910111213//终结符表达式类ValueNode（值节点类）class ValueNode : public Node &#123; public: ValueNode(int value) &#123; this-&gt;value = value; &#125; int interpret()&#123; return this-&gt;value; &#125; private: int value = 0;&#125;; 抽象非终结符表达式类SymbolNode（符号节点类） 1234567891011//抽象非终结符表达式类SymbolNode（符号节点类）class SymbolNode : public Node &#123; public: SymbolNode(shared_ptr&lt;Node&gt; left,shared_ptr&lt;Node&gt; right) &#123; this-&gt;left = left; this-&gt;right = right; &#125; protected: shared_ptr&lt;Node&gt; left; shared_ptr&lt;Node&gt; right;&#125;; 非终结符表达式类MulNode（乘法节点类） 1234567891011//非终结符表达式类MulNode（乘法节点类）class MulNode : public SymbolNode &#123; public: MulNode(shared_ptr&lt;Node&gt; left,shared_ptr&lt;Node&gt; right) : SymbolNode(left,right) &#123; &#125; int interpret() &#123; return left-&gt;interpret()*right-&gt;interpret(); &#125; &#125;; 非终结符表达式类DivNode（除法节点类） 1234567891011//非终结符表达式类DivNode（除法节点类）class DivNode : public SymbolNode &#123; public: DivNode(shared_ptr&lt;Node&gt; left,shared_ptr&lt;Node&gt; right) : SymbolNode(left,right) &#123; &#125; int interpret() &#123; return left-&gt;interpret()/right-&gt;interpret(); &#125;&#125;; 非终结符表达式类ModNode（求模节点类） 1234567891011//非终结符表达式类ModNode（求模节点类）class ModNode : public SymbolNode &#123; public: ModNode(shared_ptr&lt;Node&gt; left,shared_ptr&lt;Node&gt; right) : SymbolNode(left,right) &#123; &#125; int interpret() &#123; return left-&gt;interpret()%right-&gt;interpret(); &#125;&#125;; 解析器封装类Calculator（计算器类） 1234567891011121314151617181920212223242526272829303132333435363738394041//解析器封装类Calculator（计算器类）class Calculator &#123; public: void bulid(string statement) &#123; shared_ptr&lt;Node&gt; left,right; stack&lt;shared_ptr&lt;Node&gt; &gt; s; //分割语义 vector&lt;string&gt; statementArr = split(statement,&#x27; &#x27;); //处理语义 for(int i = 0 ; i &lt; statementArr.size() ; i++)&#123; if(statementArr[i] == &quot;*&quot;)&#123; left = s.top(); s.pop(); int val = atoi(statementArr[++i].c_str()); right = make_shared&lt;ValueNode&gt;(val); s.push(make_shared&lt;MulNode&gt;(left,right)); &#125;else if(statementArr[i] == &quot;/&quot;)&#123; left = s.top(); s.pop(); int val = atoi(statementArr[++i].c_str()); right = make_shared&lt;ValueNode&gt;(val); s.push(make_shared&lt;DivNode&gt;(left,right)); &#125;else if(statementArr[i] == &quot;%&quot;)&#123; left = s.top(); s.pop(); int val = atoi(statementArr[++i].c_str()); right = make_shared&lt;ValueNode&gt;(val); s.push(make_shared&lt;ModNode&gt;(left,right)); &#125;else&#123; s.push(make_shared&lt;ValueNode&gt;(atoi(statementArr[i].c_str()))); &#125; &#125; this-&gt;node = s.top(); s.pop(); &#125; int compute()&#123; return node-&gt;interpret(); &#125; private: string statement; shared_ptr&lt;Node&gt; node;&#125;; 客户端测试 1234567891011121314151617//客户端测试 int main(void) &#123; //需要解析的语句 string statement = &quot;3 * 4 / 2 % 4&quot;; //解析器 Calculator calculator; calculator.bulid(statement); //计算结果 int result = calculator.compute(); //输出 cout &lt;&lt; statement &lt;&lt; &quot; = &quot; &lt;&lt; result &lt;&lt; endl; return 0; &#125; 优点： 扩展性好：由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。 容易实现： 在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。 缺点： 执行效率较低：解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。 可应用的场景比较少：在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。 22 中介模式（Mediator） 一个由很多对象组成的模块，其对象间可能存在错综复杂的关联性。以P2P聊天为例，用户对象之间构成了网状结构，将会导致如下问题： 系统结构复杂：对象之间存在大量的相互关联和调用，若有一个对象发生变化，则需要跟踪和该对象关联的其他所有对象，并进行适当处理。 对象可重用性差：由于一个对象和其他对象具有很强的关联，若没有其他对象的支持，一个对象很难被另一个系统或模块重用，这些对象表现出来更像一个不可分割的整体，职责较为混乱。 系统扩展性低：增加一个新的对象需要在原有相关对象上增加引用，增加新的引用关系也需要调整原有对象，系统耦合度很高，对象操作很不灵活，扩展性差。 中介者模式旨在利用一个中介对象来封装一系列的对象交互，使得各对象间不需要显式地相互引用，从而将耦合松散。 Mediator：抽象中介者 ConcreteMediator：具体中介者 Colleague：抽象同事类，也就是那些相互关联的对象的父类 ConcreteColleague：具体同事类，相互关联的对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/// @brief 抽象同事类, 定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能class AbstractMediator;class AbstractColleague &#123;public: virtual ~AbstractColleague() &#123;&#125; /// @brief 抽象接口 virtual void Receive() = 0; virtual void Send() = 0; /// @brief 设置中介对象 void SetMedium(AbstractMediator* mediator) &#123; mediator_ = mediator; &#125;protected: AbstractMediator* mediator_ = nullptr;&#125;;/// @brief 具体同事类, 抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互class ConcreteColleagueA : public AbstractColleague &#123;public: virtual void Receive(); virtual void Send();&#125;;class ConcreteColleagueB : public AbstractColleague &#123;public: virtual void Receive(); virtual void Send();&#125;;/// @brief 抽象中介类, 中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法class AbstractMediator &#123;public: virtual ~AbstractMediator() &#123;&#125; /// @brief 注册 virtual void Register(AbstractColleague* colleague) = 0; /// @brief 转发 virtual void Relay(AbstractColleague* colleague) = 0;&#125;;/// @brief 具体中介类, 实现中介者接口. 管理同事对象，协调各个同事角色之间的交互关系，依赖于同事角色class ConcreteMediator : public AbstractMediator &#123;public: virtual void Register(AbstractColleague* colleague) &#123; for (auto* c : colleagues_) &#123; if (c == colleague) return; &#125; colleagues_.emplace_back(colleague); colleague-&gt;SetMedium(this); &#125; virtual void Relay(AbstractColleague* colleague) &#123; for (auto* c : colleagues_) &#123; // 转发给除自己外的同事 if (c != colleague) c-&gt;Receive(); &#125; &#125;private: std::list&lt;AbstractColleague*&gt; colleagues_;&#125;;///////////////////////////////////////////////////////// 同事类实现void ConcreteColleagueA::Receive() &#123; printf(&quot;this is ConcreteColleagueA::Receive!\\n&quot;);&#125;void ConcreteColleagueA::Send() &#123; printf(&quot;this is ConcreteColleagueA::Send!\\n&quot;); // 请中介者转发 mediator_-&gt;Relay(this);&#125;void ConcreteColleagueB::Receive() &#123; printf(&quot;this is ConcreteColleagueB::Receive!\\n&quot;);&#125;void ConcreteColleagueB::Send() &#123; printf(&quot;this is ConcreteColleagueB::Send!\\n&quot;); // 请中介者转发 mediator_-&gt;Relay(this);&#125; main函数： 12345678910111213141516int main() &#123; printf(&quot;-------------------- %s --------------------\\n&quot;, __FUNCTION__); std::shared_ptr&lt;AbstractMediator&gt; ptr_md(new ConcreteMediator()); std::shared_ptr&lt;AbstractColleague&gt; ptr_c1(new ConcreteColleagueA()); std::shared_ptr&lt;AbstractColleague&gt; ptr_c2(new ConcreteColleagueB()); ptr_md-&gt;Register(ptr_c1.get()); ptr_md-&gt;Register(ptr_c2.get()); ptr_c1-&gt;Send(); printf(&quot;-----------\\n&quot;); ptr_c2-&gt;Send();&#125; 优点： 简化了对象之间的交互； 将各同事解耦。 缺点： 具体中介者类中包含了同事之间的交互细节，可能会导致具体中介者类非常复杂，让系统难维护。 设计模式思维导图","categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"【置顶】知识管理","slug":"笔记汇总","date":"2022-05-18T08:04:17.000Z","updated":"2022-07-10T13:52:17.382Z","comments":true,"path":"2022/05/18/笔记汇总/","link":"","permalink":"http://example.com/2022/05/18/%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB/","excerpt":"","text":"编程语言 C++ C++基础知识：（更新中）-&gt;链接 参考资料： 《C++语言导学》第一版 《C++ Primer》第五版 《C++新经典：对象模型》第一版 C++三部曲阅读笔记：（开坑未填）-&gt;链接 参考资料： 《Effective C++》 《More Effective C++》 《Effective Modern C++》 C++泛型编程笔记：（开坑未填）-&gt;链接 参考资料： 《C++模板元编程实战：一个深度学习框架的初步实现》 《C++新经典：模板与泛型编程》 Golang Go语言基础知识：（更新中）-&gt;链接 参考资料： B站up主“七米老师”的Go语言系列教程 刘丹冰——Golang修养之路 《Go语言底层原理剖析》 Go语言进阶：（开坑未填）-&gt;链接 参考资料： 《Go语言进阶之路》 JavaScript JS基础：（更新中）-&gt;链接 参考资料： JavaScript——45分钟快速上车 微软官方JavaScript入门教程 Node.js进阶：（开坑未填）-&gt;链接 参考资料： 微软官方Node.js入门教程 Python Python基础知识：（更新中）-&gt;链接 参考资料： 廖雪峰的Python教程 Python Cookbook奇技淫巧：（开坑未填）-&gt;链接 参考资料： Python Cookbook 中文版 Matlab基础：（暂时完结）-&gt;链接 开发工具 Docker：（暂时完结）-&gt;链接 参考资料： Docker官方文档 本人译制的Docker速成视频 WebRTC：（更新中）-&gt;链接 参考资料： 《WebRTC音视频实时互动技术：原理、实战与源码分析》 Kubernetes：（更新中）-&gt;链接 参考资料： 本人译制的Kubernetes速成视频 极客时间《深入剖析Kubernetes》 Pytorch：（更新中）-&gt;链接 参考资料： 莫烦教程 Pytorch官方文档 编程算法 参考资料： ACwing网站 “算法基础课” &amp; “算法提高课” &amp; “算法面试笔试辅导课” 程序员Karl——代码随想录 数学知识 Lyapunov Optimization 参考资料： 次模优化 参考资料： 矩阵论 参考资料： 概率论 参考资料： 经典凸优化理论 参考资料： Stephen Boyd《Convex Optimization》 Majorization Minimization 参考资料： 计算机基础 操作系统：（更新中）-&gt;链接 参考资料： 南京大学蒋炎岩 “操作系统：设计与实现” 数据库 MySQL：（更新中）-&gt;链接 参考资料： 菜鸟教程——MySQL基础 《MySQL是怎样运行的：从根儿上理解MySQL》 分布式系统 MIT 6.824（2020）笔记：（开坑未填）-&gt;链接 参考资料：Simviso网站译制课程 设计模式：（更新中）-&gt;链接 参考资料： 《设计模式的艺术：一本实例驱动的设计模式实践指南》 编译原理：（开坑未填）-&gt;链接 参考资料： 虎书《现代编译原理：C语言描述》 嵌入式开发（属于会的技能，但是否填坑再议） STM32 嵌入式Linux freeRTOS FPGA","categories":[],"tags":[]},{"title":"Hexo使用方法","slug":"hexo使用","date":"2022-05-09T16:38:12.506Z","updated":"2022-07-10T13:38:41.397Z","comments":true,"path":"2022/05/10/hexo使用/","link":"","permalink":"http://example.com/2022/05/10/hexo%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"在线优化利器——李雅普诺夫优化","slug":"Lyapunov Optimization","date":"2022-01-30T10:44:29.000Z","updated":"2022-07-12T16:15:57.676Z","comments":true,"path":"2022/01/30/Lyapunov Optimization/","link":"","permalink":"http://example.com/2022/01/30/Lyapunov%20Optimization/","excerpt":"","text":"Lyapunov Optimization 维基百科李雅普诺夫优化介绍 维基百科漂移加罚介绍 浙大赵海亮文档 李雅普诺夫优化旨在，利用李雅普诺夫函数(Lyapunov function)以非负标量的形式描述一个用多维向量表示的状态，通过优化该函数实现逼近用向量表示的原问题的最优解 李雅普诺夫优化的一般步骤 为随机优化问题建模 → 构造队列 → 得到使用李雅普诺夫优化求的解 → 分析解与原始最优解的差距 1. 随机优化建模 随机优化问题中的“随机”指的是每个时间片内都有随机事件发生，针对随机事件有相应的策略。定义第t个时隙内产生的所有随机事件为w(t)≜[w1(t),w2(t),...,wn(t)]∈Ωn\\textbf{w}(t)\\triangleq[w_1(t),w_2(t),...,w_n(t)]\\in\\Omega^nw(t)≜[w1​(t),w2​(t),...,wn​(t)]∈Ωn，系统在每个时间片内采取的策略，即“动作”（control action）定义为α(t)≜[α1(t),α2(t),...,αm(t)]∈Am\\alpha(t)\\triangleq[\\alpha_1(t),\\alpha_2(t),...,\\alpha_m(t)]\\in\\mathcal{A}^mα(t)≜[α1​(t),α2​(t),...,αm​(t)]∈Am，其中Ωn和Am\\Omega^n和\\mathcal{A}^mΩn和Am分别是随机事件和控制决策的集合。 如果我们的目标函数是p(t)p(t)p(t)，那么在每个时隙t，它会根据发生的随机事件和采取的措施，计算出当前时隙的目标函数值，即p(t)=P(w(t),α(t))p(t)=P(\\textbf{w}(t),\\alpha(t))p(t)=P(w(t),α(t))，其中P(⋅)P(\\cdot)P(⋅)是一个确定的函数。这里的p(t)p(t)p(t)的物理含义可以很丰富，比如令其表示功率，那么问题就是最小化功率消耗；令其为吞吐量的负p(t)=−r(t)p(t)=-r(t)p(t)=−r(t)，那么最小化p(t)p(t)p(t)就是在最大化吞吐量。此外，系统中的一系列变量也会受到随机事件和控制决策的影响，可以描述为yk(t)=Yk(w(t),α(t)),k∈1,...,Ky_k(t)=Y_k(\\textbf{w}(t),\\alpha(t)),k\\in{1,...,K}yk​(t)=Yk​(w(t),α(t)),k∈1,...,K，其中∀k∈{1,...,K}，Yk(⋅)\\forall k\\in\\{1,...,K\\}，Y_k(\\cdot)∀k∈{1,...,K}，Yk​(⋅)均为确定函数。由于最终需要把所有时间片的表现都考虑进去，从而得到最终系统表现，所以在优化目标时，需要优化的是各时间片的目标函数值的平均。 那么随机优化问题的标准形式为： P1:min⁡∀t,α(t)∈Amlim⁡T→∞1T∑t=0T−1E[p(t)]s.t. lim⁡T→∞1T∑t=0T−1E[yk(t)]≤0,k∈{1,...,K}\\begin{aligned}\\mathcal{P}1:&amp;\\min_{\\forall t,\\alpha(t)\\in\\mathcal{A}^m}\\lim_{T\\rightarrow\\infty}\\frac 1 T\\sum_{t=0}^{T-1}\\mathbb{E}[p(t)]\\\\s.t.&amp;\\ \\lim_{T\\rightarrow\\infty}\\frac 1 T\\sum_{t=0}^{T-1}\\mathbb{E}[y_k(t)]\\le 0,k\\in\\{1,...,K\\}\\end{aligned} P1:s.t.​∀t,α(t)∈Ammin​T→∞lim​T1​t=0∑T−1​E[p(t)] T→∞lim​T1​t=0∑T−1​E[yk​(t)]≤0,k∈{1,...,K}​ 2 队列构造 李雅普诺夫优化希望将长期约束分割到各个时间片中，在每个时间片约束变量遵守相应的条件，从而使得长期约束不被破坏，即保持稳定。由此，每一个约束yk(t)y_k(t)yk​(t)可以对应一个队列，该队列中的元素随时间片的迭代而进进出出，最终达成保持队列稳定的目标。定义初值为0的队列为： Qk(t+1)=max⁡{Qk(t)+yk(t),0},k∈{1,2,...,K}Q_k(t+1)=\\max\\{Q_k(t)+y_k(t),0\\},k\\in\\{1,2,...,K\\} Qk​(t+1)=max{Qk​(t)+yk​(t),0},k∈{1,2,...,K} 这里的yk(t)y_k(t)yk​(t)可以用yk(t)=ak(t)−bk(t)y_k(t)=a_k(t)-b_k(t)yk​(t)=ak​(t)−bk​(t)，其中ak(t)a_k(t)ak​(t)是进，bk(t)b_k(t)bk​(t)是出，从而实现队列的进出。需要注意的是，这里的Qk(t)Q_k(t)Qk​(t)并不是队列本身，而是队列的积压量(backlog)。而由于前面随机优化问题中的约束条件，我们希望每一个时间片的bk(t)b_k(t)bk​(t)尽可能大于等于ak(t)a_k(t)ak​(t)，从而使yk(t)y_k(t)yk​(t)尽可能小于等于0。 易得yk(t)≤Qk(t+1)−Qk(t)y_k(t)\\le Q_k(t+1)-Q_k(t)yk​(t)≤Qk​(t+1)−Qk​(t)，对所有时间片累加可得∑t=0T−1yk(t)≤Qk(T)−Qk(0)=Qk(T),k={1,2,...,K}\\sum_{t=0}^{T-1}y_k(t)\\le Q_k(T)-Q_k(0)=Q_k(T),k=\\{1,2,...,K\\}∑t=0T−1​yk​(t)≤Qk​(T)−Qk​(0)=Qk​(T),k={1,2,...,K}，取期望可得： 1T∑t=0T−1E[yk(t)]≤E[Qk(T)]T,k∈{1,2,...,K}\\frac 1 T\\sum_{t=0}^{T-1}\\mathbb{E}[y_k(t)]\\le \\frac{\\mathbb{E}[Q_k(T)]}T,k\\in\\{1,2,...,K\\} T1​t=0∑T−1​E[yk​(t)]≤TE[Qk​(T)]​,k∈{1,2,...,K} 由于前面随机优化的约束lim⁡T→∞1T∑t=0T−1E[yk(t)]≤0,k∈{1,...,K}\\lim_{T\\rightarrow\\infty}\\frac 1 T\\sum_{t=0}^{T-1}\\mathbb{E}[y_k(t)]\\le 0,k\\in\\{1,...,K\\}limT→∞​T1​∑t=0T−1​E[yk​(t)]≤0,k∈{1,...,K}，再由于上式，可以得到李雅普诺夫形式的随机优化约束条件lim⁡T→∞E[Qk(T)]T=0,k∈{1,2,...,K}\\lim_{T\\rightarrow\\infty}\\frac{\\mathbb{E}[Q_k(T)]}{T}=0,k\\in\\{1,2,...,K\\}limT→∞​TE[Qk​(T)]​=0,k∈{1,2,...,K}。 因此，构造好虚拟队列的随机优化问题新形式可表示为： P2:min⁡∀t,α(t)∈Amlim⁡T→∞1T∑t=0T−1E[p(t)](1)s.t.lim⁡T→∞E[Qk(T)]T=0,k∈{1,2,...,K}(2)\\begin{aligned}\\mathcal{P}2:&amp;\\min_{\\forall t,\\alpha(t)\\in\\mathcal{A}^m}\\lim_{T\\rightarrow\\infty}\\frac 1 T\\sum_{t=0}^{T-1}\\mathbb{E}[p(t)]&amp;(1)\\\\&amp;s.t.\\lim_{T\\rightarrow\\infty}\\frac{\\mathbb{E}[Q_k(T)]}{T}=0,k\\in\\{1,2,...,K\\}\\qquad&amp;(2)\\end{aligned} P2:​∀t,α(t)∈Ammin​T→∞lim​T1​t=0∑T−1​E[p(t)]s.t.T→∞lim​TE[Qk​(T)]​=0,k∈{1,2,...,K}​(1)(2)​ 📌注：其实李雅普诺夫形式的约束条件还有另一种更加严格的表述，即下式，但一般采用上式 ∃δ≤0,lim⁡T→0E[Qk(T)]T≤δ,k∈{1,2,...,K}\\exist\\delta\\le 0,\\lim_{T\\rightarrow 0}\\frac{\\mathbb{E}[Q_k(T)]}T\\le\\delta,k\\in\\{1,2,...,K\\} ∃δ≤0,T→0lim​TE[Qk​(T)]​≤δ,k∈{1,2,...,K} 3 漂移加罚算法(drift plus penalty algorithm) 将队列全体用一个向量表示为(t)≜[Q1(t),Q2(t),...,QK(t)](t)\\triangleq[Q_1(t),Q_2(t),...,Q_K(t)](t)≜[Q1​(t),Q2​(t),...,QK​(t)]，则李雅普诺夫函数定义为 L(Θ(t))≜12∑k=1KQk(t)2L(\\Theta(t))\\triangleq\\frac 1 2\\sum_{k=1}^KQ_k(t)^2 L(Θ(t))≜21​k=1∑K​Qk​(t)2 从而，可利用李雅普诺夫函数描述队列在时隙t的积压量Δ(Θ(t))≜L(Θ(t+1))−L(Θ(t))\\Delta(\\Theta(t))\\triangleq L(\\Theta(t+1))-L(\\Theta(t))Δ(Θ(t))≜L(Θ(t+1))−L(Θ(t))，该式被称为李雅普诺夫漂移(Lyapunov drift)。易得Qk(t+1)2≤(Qk(t)+yk(t))2,k∈{1,2,...,K}Q_k(t+1)^2\\le(Q_k(t)+y_k(t))^2,k\\in\\{1,2,...,K\\}Qk​(t+1)2≤(Qk​(t)+yk​(t))2,k∈{1,2,...,K}，对K个队列进行累加可得 12∑k=1KQk(t+1)2≤12∑k=1KQk(t)2+12∑k=1Kyk(t)2+∑k=1KQk(t)yk(t)\\frac 1 2\\sum_{k=1}^KQ_k(t+1)^2\\le\\frac 1 2\\sum_{k=1}^KQ_k(t)^2+\\frac 1 2\\sum_{k=1}^Ky_k(t)^2+\\sum_{k=1}^KQ_k(t)y_k(t) 21​k=1∑K​Qk​(t+1)2≤21​k=1∑K​Qk​(t)2+21​k=1∑K​yk​(t)2+k=1∑K​Qk​(t)yk​(t) 由于队列的进出都是有限的，因此12∑k=1Kyk(t)2\\frac 1 2\\sum_{k=1}^Ky_k(t)^221​∑k=1K​yk​(t)2是存在上界B&gt;0B&gt;0B&gt;0的，所以可得 Δ(Θ(t))≜12∑k=1KQk(t+1)2−12∑k=1KQk(t)2≤12∑k=1Kyk(t)2+∑k=1KQk(t)yk(t)≤B+∑k=1KQk(t)yk(t)(3)\\begin{aligned}\\Delta(\\Theta(t))&amp;\\triangleq\\frac 1 2\\sum_{k=1}^KQ_k(t+1)^2-\\frac 1 2\\sum_{k=1}^KQ_k(t)^2\\\\&amp;\\le\\frac 1 2\\sum_{k=1}^Ky_k(t)^2+\\sum_{k=1}^KQ_k(t)y_k(t)\\le B+\\sum_{k=1}^KQ_k(t)y_k(t)\\end{aligned}\\qquad(3) Δ(Θ(t))​≜21​k=1∑K​Qk​(t+1)2−21​k=1∑K​Qk​(t)2≤21​k=1∑K​yk​(t)2+k=1∑K​Qk​(t)yk​(t)≤B+k=1∑K​Qk​(t)yk​(t)​(3) P3:min⁡∀t,α(t)∈AmE[Δ(Θ(t))+V⋅p(t)∣Θ(t)]s.t.lim⁡T→∞E[Qk(T)]T=0,k∈{1,2,...,K}\\begin{aligned}\\mathcal{P}3:\\min_{\\forall t,\\alpha(t)\\in\\mathcal{A}^m}\\mathbb{E}[\\Delta(\\Theta(t))+V\\cdot p(t)|\\mathcal{\\Theta}(t)]\\\\s.t.\\lim_{T\\rightarrow\\infty}\\frac{\\mathbb{E}[Q_k(T)]}{T}=0,k\\in\\{1,2,...,K\\}\\end{aligned} P3:∀t,α(t)∈Ammin​E[Δ(Θ(t))+V⋅p(t)∣Θ(t)]s.t.T→∞lim​TE[Qk​(T)]​=0,k∈{1,2,...,K}​ 其中，V是一个权重，用来调节对二者的重视程度。然而此时计算李雅普诺夫漂移需要下一时隙的排队信息，这样的话无法在当前时隙中求得该问题的解，但是可以利用式(3)对问题P3\\mathcal{P}3P3进行放缩，从而得到问题P4\\mathcal{P}4P4 ： P4:min⁡∀t,α(t)∈AmE[B+V⋅p(t)+∑k=1KQk(t)yk(t)∣Θ(t)]s.t.lim⁡T→∞E[Qk(T)]T=0,k∈{1,2,...,K}\\mathcal{P}4:\\min_{\\forall t,\\alpha(t)\\in\\mathcal{A}^m}\\mathbb{E}[B+V\\cdot p(t)+\\sum_{k=1}^KQ_k(t)y_k(t)|\\Theta(t)]\\\\s.t.\\lim_{T\\rightarrow\\infty}\\frac{\\mathbb{E}[Q_k(T)]}{T}=0,k\\in\\{1,2,...,K\\} P4:∀t,α(t)∈Ammin​E[B+V⋅p(t)+k=1∑K​Qk​(t)yk​(t)∣Θ(t)]s.t.T→∞lim​TE[Qk​(T)]​=0,k∈{1,2,...,K} 漂移加罚算法（DPP），就是求解P4\\mathcal{P}4P4的近似最优解从而求解P3\\mathcal{P}3P3 算法步骤： （1）在时隙t开头，观察发生的所有随机事件以及所有队列的积压量：w(t),Θ(t)\\textbf{w}(t),\\Theta(t)w(t),Θ(t) （2）通过求解如下问题确定最优的控制决策α∗(t)\\alpha^*(t)α∗(t)： α∗(t)=arg min⁡α(t)∈AmE[B+V⋅p(t)+∑k=1KQk(t)yk(t)∣Θ(t)](4)\\alpha^*(t)=\\argmin_{\\alpha(t)\\in\\mathcal{A}^m}\\mathbb{E}[B+V\\cdot p(t)+\\sum_{k=1}^KQ_k(t)y_k(t)|\\Theta(t)]\\qquad(4) α∗(t)=α(t)∈Amargmin​E[B+V⋅p(t)+k=1∑K​Qk​(t)yk​(t)∣Θ(t)](4) （3）∀k∈{1,2,...,K},Qk(t+1)=max⁡{Qk(t)+yk(t),0}\\forall k\\in\\{1,2,...,K\\},Q_k(t+1)=\\max\\{Q_k(t)+y_k(t),0\\}∀k∈{1,2,...,K},Qk​(t+1)=max{Qk​(t)+yk​(t),0}更新Qk(t)Q_k(t)Qk​(t) （4）t←t+1t\\leftarrow t+1t←t+1 📌可以看到漂移加罚算法并没有管约束条件(2)，下方证明算法隐式地满足约束 4 性能分析 4.1 计算结果精度 最优w−only\\textbf{w}-onlyw−only策略： w−only policy\\textbf{w}-only\\ policyw−only policy是指每个时隙内仅依赖于观测到的w(t)\\textbf{w}(t)w(t)选择最优控制动作，而不依赖于队列状态(backlog)的策略。最优w−only\\textbf{w}-onlyw−only则是满足如下条件的w−only\\textbf{w}-onlyw−only策略： 在每个时隙内，采取动作α∗(t)\\alpha^*(t)α∗(t)满足： P(w(t),α∗(t))=p∗Yk(w(t),α∗(t))≤0, k∈{1,2,...,K}(5)P(\\textbf{w}(t),\\alpha^*(t))=p^*\\\\Y_k(\\textbf{w}(t),\\alpha^*(t))\\le0,\\ k\\in\\{1,2,...,K\\}\\qquad(5) P(w(t),α∗(t))=p∗Yk​(w(t),α∗(t))≤0, k∈{1,2,...,K}(5) 其中p∗p^*p∗是不考虑约束条件的原问题P1\\mathcal{P}1P1的最优目标函数值，即 p∗=min⁡(lim⁡T→∞1T∑t=0T−1E[p(t)])p^*=\\min(\\lim_{T\\rightarrow\\infty}\\frac 1 T\\sum_{t=0}^{T-1}\\mathbb{E}[p(t)]) p∗=min(T→∞lim​T1​t=0∑T−1​E[p(t)]) 📌定理：如果原始问题P1有最优解，那么P1一定存在最优w-only策略 DPP解与最优解之间的差距： 由式(3)&amp;(4)可得， Δ(Θ(t))+V⋅p(t)≤B+V⋅p(t)+∑k=1KQk(t)yk(t)=B+V⋅P(w(t),α(t))+∑k=1KQk(t)Yk(w(t),α(t))≤B+V⋅P(w(t),α∗(t))+∑k=1KQk(t)Yk(w(t),α∗(t))\\begin{aligned}\\Delta(\\Theta(t))+V\\cdot p(t)&amp;\\le B+V\\cdot p(t)+\\sum_{k=1}^K Q_k(t)y_k(t)\\\\&amp;=B+V\\cdot P(\\textbf{w}(t),\\alpha(t))+\\sum_{k=1}^KQ_k(t)Y_k(\\textbf{w}(t),\\alpha(t))\\\\&amp;\\le B+V\\cdot P(\\textbf{w}(t),\\alpha^*(t))+\\sum_{k=1}^KQ_k(t)Y_k(\\textbf{w}(t),\\alpha^*(t))\\end{aligned} Δ(Θ(t))+V⋅p(t)​≤B+V⋅p(t)+k=1∑K​Qk​(t)yk​(t)=B+V⋅P(w(t),α(t))+k=1∑K​Qk​(t)Yk​(w(t),α(t))≤B+V⋅P(w(t),α∗(t))+k=1∑K​Qk​(t)Yk​(w(t),α∗(t))​ 取期望得 E[Δ(Θ(t))+V⋅p(t)∣Θ(t)]≤B+V⋅E[P(w(t),α∗(t))]+∑k=1KE[Qk(t)Yk(w(t),α∗(t))∣Θ(t)]=B+V⋅E[P(w(t),α∗(t))]+∑k=1KE[Qk(t)∣Θ(t)]E[Yk(w(t),α∗(t))∣Θ(t)] (相互独立)≤B+V⋅p∗(这是因为式(5))\\begin{aligned}&amp;\\mathbb{E}[\\Delta(\\Theta(t))+V\\cdot p(t)|\\Theta(t)]\\\\&amp;\\le B+V\\cdot\\mathbb{E}[P(\\textbf{w}(t),\\alpha^*(t))]+\\sum_{k=1}^K\\mathbb{E}[Q_k(t)Y_k(\\textbf{w}(t),\\alpha^*(t))|\\Theta(t)]\\\\&amp;=B+V\\cdot\\mathbb{E}[P(\\textbf{w}(t),\\alpha^*(t))]+\\sum_{k=1}^K\\mathbb{E}[Q_k(t)|\\Theta(t)]\\mathbb{E}[Y_k(\\textbf{w}(t),\\alpha^*(t))|\\Theta(t)]\\ (相互独立)\\\\&amp;\\le B+V\\cdot p^*\\qquad(这是因为式(5))\\end{aligned} ​E[Δ(Θ(t))+V⋅p(t)∣Θ(t)]≤B+V⋅E[P(w(t),α∗(t))]+k=1∑K​E[Qk​(t)Yk​(w(t),α∗(t))∣Θ(t)]=B+V⋅E[P(w(t),α∗(t))]+k=1∑K​E[Qk​(t)∣Θ(t)]E[Yk​(w(t),α∗(t))∣Θ(t)] (相互独立)≤B+V⋅p∗(这是因为式(5))​ 时隙累加，可得 (B+V⋅p∗)T≥∑t=0T−1E[Δ(Θ(t))+V⋅p(t)∣Θ(t)]=E[L(Θ(t))−L(Θ(0))]+V⋅∑t=0T−1E[p(t)∣Θ(t)]≥V⋅∑t=0T−1E[p(t)∣Θ(t)]\\begin{aligned}(B+V\\cdot p^*)T&amp;\\ge\\sum_{t=0}^{T-1}\\mathbb{E}[\\Delta(\\Theta(t))+V\\cdot p(t)|\\Theta(t)]\\\\&amp;=\\mathbb{E}[L(\\Theta(t))-L(\\Theta(0))]+V\\cdot\\sum_{t=0}^{T-1}\\mathbb{E}[p(t)|\\Theta(t)]\\\\&amp;\\ge V\\cdot\\sum_{t=0}^{T-1}\\mathbb{E}[p(t)|\\Theta(t)]\\end{aligned} (B+V⋅p∗)T​≥t=0∑T−1​E[Δ(Θ(t))+V⋅p(t)∣Θ(t)]=E[L(Θ(t))−L(Θ(0))]+V⋅t=0∑T−1​E[p(t)∣Θ(t)]≥V⋅t=0∑T−1​E[p(t)∣Θ(t)]​ 也就是说P4\\mathcal{P}4P4得到的近似最优解与不加约束的P1\\mathcal{P}1P1的最优解之间的关系是一个不等式： 1T∑t=0T−1E[p(t)∣Θ(t)]≤p∗+BV(6)\\frac1T\\sum_{t=0}^{T-1}\\mathbb{E}[p(t)|\\Theta(t)]\\le p^*+\\frac B V\\qquad(6) T1​t=0∑T−1​E[p(t)∣Θ(t)]≤p∗+VB​(6) 所以可知，P4\\mathcal{P}4P4得到的近似最优解与不加约束的P1\\mathcal{P}1P1的最优解之间的差距是O(1V)O(\\frac 1 V)O(V1​)的 4.2 队列长度 假设存在一个w−only\\textbf{w}-onlyw−only策略，满足∃ϵ&gt;0, E[Yk(w(t),α∗(t))]≤−ϵ\\exist\\epsilon &gt;0,\\ \\mathbb{E}[Y_k(\\textbf{w}(t),\\alpha^*(t))]\\le-\\epsilon∃ϵ&gt;0, E[Yk​(w(t),α∗(t))]≤−ϵ（不要求是最优w−only\\textbf{w}-onlyw−only策略），那么存在下列不等式： Δ(Θ(t))+V⋅p(t)≤B+V⋅P(w(t),α(t))+∑k=1KQk(t)Yk(w(t),α∗(t))Δ(Θ(t))+V⋅pmin≤B+V⋅pmax+∑k=1KQk(t)Yk(w(t),α∗(t))E[Δ(Θ(t))]+V⋅pmin≤B+V⋅pmax+∑k=1KE[Qk(t)]E[Yk(w(t),α∗(t))]≤B+V⋅pmax+∑k=1KE[Qk(t)](−ϵ)\\Delta(\\Theta(t))+V\\cdot p(t)\\le B+V\\cdot P(\\textbf{w}(t),\\alpha(t))+\\sum_{k=1}^KQ_k(t)Y_k(\\textbf{w}(t),\\alpha^*(t))\\\\\\Delta(\\Theta(t))+V\\cdot p_{min}\\le B+V\\cdot p_{max}+\\sum_{k=1}^KQ_k(t)Y_k(\\textbf{w}(t),\\alpha^*(t))\\\\\\begin{aligned}\\mathbb{E}[\\Delta(\\Theta(t))]+V\\cdot p_{min}&amp;\\le B+V\\cdot p_{max}+\\sum_{k=1}^K\\mathbb {E}[Q_k(t)]\\mathbb{E}[Y_k(\\textbf{w}(t),\\alpha^*(t))]\\\\&amp;\\le B+V\\cdot p_{max}+\\sum_{k=1}^K\\mathbb{E}[Q_k(t)](-\\epsilon)\\end{aligned} Δ(Θ(t))+V⋅p(t)≤B+V⋅P(w(t),α(t))+k=1∑K​Qk​(t)Yk​(w(t),α∗(t))Δ(Θ(t))+V⋅pmin​≤B+V⋅pmax​+k=1∑K​Qk​(t)Yk​(w(t),α∗(t))E[Δ(Θ(t))]+V⋅pmin​​≤B+V⋅pmax​+k=1∑K​E[Qk​(t)]E[Yk​(w(t),α∗(t))]≤B+V⋅pmax​+k=1∑K​E[Qk​(t)](−ϵ)​ 移项，累加可有 1T∑t=0T−1∑k=1KE[Qk(t)]≤B+V⋅(pmax−pmin)ϵ(7)\\frac 1 T\\sum_{t=0}^{T-1}\\sum_{k=1}^K\\mathbb{E}[Q_k(t)]\\le\\frac{B+V\\cdot(p_{max}-p_{min})}{\\epsilon}\\qquad(7) T1​t=0∑T−1​k=1∑K​E[Qk​(t)]≤ϵB+V⋅(pmax​−pmin​)​(7) 由此可知，平均每时隙内所有队列长度是O(V)O(V)O(V)的 4.3 精度与时间的权衡 式(6)和式(7)共同构成了李雅普诺夫优化定理。 时均队列大小是O(V)O(V)O(V)的，其反映算法的执行时间，而计算精度是O(1V)O(\\frac 1 V)O(V1​)的。 也就是说增大V可以获得更加逼近与原始问题P1\\mathcal{P}1P1最优解的解，而减少V则可以更快的满足约束条件，降低执行时间。所以说，需要调整V，找到算法执行时间与计算结果精度之间的trade-off 4.4 证明漂移加罚算法满足约束条件 由前面可得，E[Δ(Θ(t))]+V⋅pmin≤B+V⋅pmax+∑k=1KE[Qk(t)](−ϵ)\\mathbb{E}[\\Delta(\\Theta(t))]+V\\cdot p_{min}\\le B+V\\cdot p_{max}+\\sum_{k=1}^K\\mathbb{E}[Q_k(t)](-\\epsilon)E[Δ(Θ(t))]+V⋅pmin​≤B+V⋅pmax​+∑k=1K​E[Qk​(t)](−ϵ)，对时隙进行累加有 E[L(Θ(t))]−E[L(Θ(0))]≤(B+V(pmax−pmin))⋅T−ϵ∑t=0T−1∑k=1KE[Qk(t)∣Θ(t)]≤B′⋅T\\begin{aligned}\\mathbb{E}[L(\\Theta(t))]-\\mathbb{E}[L(\\Theta(0))]&amp;\\le(B+V(p_{max}-p_{min}))\\cdot T-\\epsilon\\sum_{t=0}^{T-1}\\sum_{k=1}^K\\mathbb{E}[Q_k(t)|\\Theta(t)]\\\\&amp;\\le B&#x27;\\cdot T\\end{aligned} E[L(Θ(t))]−E[L(Θ(0))]​≤(B+V(pmax​−pmin​))⋅T−ϵt=0∑T−1​k=1∑K​E[Qk​(t)∣Θ(t)]≤B′⋅T​ 12∑k=1KE[Qk(T)2]≤B′⋅T(∑k=1KE[Qk(T)])2≤K∑k=1KE[Qk(T)2]≤2KB′⋅T\\frac 1 2\\sum_{k=1}^K\\mathbb{E}[Q_k(T)^2]\\le B&#x27;\\cdot T\\\\(\\sum_{k=1}^K\\mathbb{E}[Q_k(T)])^2\\le K\\sum_{k=1}^K\\mathbb{E}[Q_k(T)^2]\\le 2KB&#x27;\\cdot T 21​k=1∑K​E[Qk​(T)2]≤B′⋅T(k=1∑K​E[Qk​(T)])2≤Kk=1∑K​E[Qk​(T)2]≤2KB′⋅T 取极限有 lim⁡T→∞∑k=1KE[Qk(T)]T≤lim⁡T→∞2KB′T=0\\lim_{T\\rightarrow\\infty}\\frac{\\sum_{k=1}^K\\mathbb{E}[Q_k(T)]}T\\le\\lim_{T\\rightarrow\\infty}\\sqrt{\\frac{2KB&#x27;}T}=0 T→∞lim​T∑k=1K​E[Qk​(T)]​≤T→∞lim​T2KB′​​=0 又由于Qk(t)≥0Q_k(t)\\ge 0Qk​(t)≥0，所以有 ∀k∈{1,2,...,K},lim⁡T→∞E[Qk(T)]T=0\\forall k\\in\\{1,2,...,K\\},\\lim_{T\\rightarrow\\infty}\\frac{\\mathbb{E}[Q_k(T)]}T=0 ∀k∈{1,2,...,K},T→∞lim​TE[Qk​(T)]​=0 即，在漂移加罚算法的执行过程中，约束条件(2)是一直成立的 5 Case Study 5.1 LODCO 其中B′=B+V⋅(pmax−pmin)B&#x27;=B+V\\cdot(p_{max}-p_{min})B′=B+V⋅(pmax​−pmin​)，代入李雅普诺夫函数和柯西不等式(∑i=1nxiyi)2≤(∑i=1nxi2)(∑i=1nyi2)(\\sum_{i=1}^nx_iy_i)^2\\le(\\sum_{i=1}^nx_i^2)(\\sum_{i=1}^ny_i^2)(∑i=1n​xi​yi​)2≤(∑i=1n​xi2​)(∑i=1n​yi2​)可得 将前文所述的p(t)p(t)p(t)作为惩罚项(penalty)，同时求解李雅普诺夫漂移和惩罚项的最小值，便可以得到新问题","categories":[{"name":"数学","slug":"数学","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数学方法","slug":"数学方法","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6%E6%96%B9%E6%B3%95/"}]},{"title":"分式优化求解利器——Dinkelbach","slug":"Dinkelbach Approach/Dinkelbach Approach","date":"2022-01-03T07:47:26.000Z","updated":"2022-07-12T16:42:51.615Z","comments":true,"path":"2022/01/03/Dinkelbach Approach/Dinkelbach Approach/","link":"","permalink":"http://example.com/2022/01/03/Dinkelbach%20Approach/Dinkelbach%20Approach/","excerpt":"","text":"Dinkelbach Approach 问题描述： 给定两个连续函数f:Rn→Rf:\\mathbf R^n\\rightarrow\\mathbf Rf:Rn→R和g:Rn→Rg:\\mathbf R^n\\rightarrow \\mathbf Rg:Rn→R。二者定义域为多面体(polyhedral)集合S⊂RnS\\subset\\mathbf R^nS⊂Rn使得对于所有x∈Sx\\in Sx∈S都有g(x)&gt;0g(x)&gt;0g(x)&gt;0。需要找到一个分式规划问题的最优解x∗x^*x∗满足f(x∗)g(x∗)=max⁡x∈Sf(x)g(x)\\frac{f(x^*)}{g(x^*)}=\\max\\limits_{x\\in S}\\frac{f(x)}{g(x)}g(x∗)f(x∗)​=x∈Smax​g(x)f(x)​ (P)。 Dinkelbach方法，简言之，将原问题P简化为一个全局优化问题(GP)：max⁡x∈S(f(x)−λg(x))\\max\\limits_{x\\in S}(f(x)-\\lambda g(x))x∈Smax​(f(x)−λg(x))。 朴素Dinkelbach 📌定理1： x∗x^*x∗是分式规划问题(P)的解，当且仅当其是全局优化问题(GP)有约束λ∗=f(x∗)g(x∗)\\lambda^*=\\frac{f(x^*)}{g(x^*)}λ∗=g(x∗)f(x∗)​时的解。 朴素Dinkelbach算法流程： 选取x(0)∈Sx^{(0)}\\in Sx(0)∈S。设置λ(0):=f(x(0))/g(x(0)), k:=0\\lambda^{(0)}:=f(x^{(0)})/g(x^{(0)}),\\ k:=0λ(0):=f(x(0))/g(x(0)), k:=0； 求解全局优化问题：max⁡x∈S(f(x)−λ(k)g(x))\\max\\limits_{x\\in S}(f(x)-\\lambda^{(k)}g(x))x∈Smax​(f(x)−λ(k)g(x))，得到当前解x(k+1)x^{(k+1)}x(k+1)； 若f(x(k+1))−λ(k)g(x(k+1))=0f(x^{(k+1)})-\\lambda^{(k)}g(x^{(k+1)})=0f(x(k+1))−λ(k)g(x(k+1))=0，那么最优解产生x∗=x(k+1), λ∗:=λ(k)x^*=x^{(k+1)},\\ \\lambda^*:=\\lambda^{(k)}x∗=x(k+1), λ∗:=λ(k)，算法停止； 若f(x(k+1))−λ(k)g(x(k+1))&gt;0f(x^{(k+1)})-\\lambda^{(k)}g(x^{(k+1)})&gt;0f(x(k+1))−λ(k)g(x(k+1))&gt;0，那么设置λ(k+1):=f(x(k+1))/g(x(k+1)), k:k+1\\lambda^{(k+1)}:=f(x^{(k+1)})/g(x^{(k+1)}),\\ k:k+1λ(k+1):=f(x(k+1))/g(x(k+1)), k:k+1后，回到步骤2。 注：不需要验证f(x(k+1))−λ(k)g(x(k+1))&lt;0f(x^{(k+1)})-\\lambda^{(k)}g(x^{(k+1)})&lt;0f(x(k+1))−λ(k)g(x(k+1))&lt;0的情况。（可以用反证法证明）对所有kkk都有 f(x(k+1))−λ(k)g(x(k+1))=max⁡x∈Sf((x)−λ(k)g(x))≥f(x(k))−λ(k)g(x(k))=0f(x^{(k+1)})-\\lambda^{(k)}g(x^{(k+1)})=\\max\\limits_{x\\in S}f((x)-\\lambda^{(k)}g(x))\\ge f(x^{(k)})-\\lambda^{(k)}g(x^{(k)})=0 f(x(k+1))−λ(k)g(x(k+1))=x∈Smax​f((x)−λ(k)g(x))≥f(x(k))−λ(k)g(x(k))=0 算法有效性分析 考虑函数M(λ)=max⁡x∈S(f(x)−λg(x))M(\\lambda)=\\max\\limits_{x\\in S}(f(x)-\\lambda g(x))M(λ)=x∈Smax​(f(x)−λg(x))。可以知道其符合以下性质： 对于所有λ&lt;λ∗\\lambda&lt;\\lambda^*λ&lt;λ∗有M(λ)&gt;0M(\\lambda)&gt;0M(λ)&gt;0且对于所有λ&gt;λ∗\\lambda&gt;\\lambda^*λ&gt;λ∗有M(λ)&lt;0M(\\lambda)&lt;0M(λ)&lt;0； M(λ)M(\\lambda)M(λ)是凸函数。 超线性收敛(converge superlinearly)： 若序列α(0),α(1),⋯\\alpha^{(0)},\\alpha^{(1)},\\cdotsα(0),α(1),⋯满足lim⁡n→∞∣α∗−α(n+1)∣θn+1=0\\lim\\limits_{n\\rightarrow\\infty}\\frac{|\\alpha^*-\\alpha^{(n+1)}|}{\\theta^{n+1}}=0n→∞lim​θn+1∣α∗−α(n+1)∣​=0，其中θ∈(0,1]\\theta\\in(0,1]θ∈(0,1]，则称该序列超线性收敛于α∗\\alpha^*α∗。 （超线性收敛意味着，序列会收敛，而且以越来越快的速度收敛） 📌引理1： x∗∈Sx^*\\in Sx∗∈S是问题(P)的最优解，且x′x&#x27;x′是M(λ′)M(\\lambda&#x27;)M(λ′)的解满足λ′&lt;λ∗\\lambda&#x27;&lt;\\lambda^*λ′&lt;λ∗，那么： λ∗−f(x′)g(x′)≤(λ∗−λ′)(1−g(x∗)g(x′))\\lambda^*-\\frac{f(x&#x27;)}{g(x&#x27;)}\\le(\\lambda^*-\\lambda&#x27;)(1-\\frac{g(x^*)}{g(x&#x27;)})λ∗−g(x′)f(x′)​≤(λ∗−λ′)(1−g(x′)g(x∗)​) 其中0≤1−g(x∗)/g(x′)&lt;10\\le1-g(x^*)/g(x&#x27;)&lt;10≤1−g(x∗)/g(x′)&lt;1。 Schaible S. Fractional programming: applications and algorithms[J]. European Journal of Operational Research, 1981, 7(2): 111-120. 对于引理1，令λ′=λ(n)\\lambda&#x27;=\\lambda^{(n)}λ′=λ(n)且x′=x(n+1)x&#x27;=x^{(n+1)}x′=x(n+1)，则x(n+1)x^{(n+1)}x(n+1)是M(λ(n))M(\\lambda^{(n)})M(λ(n))的解，那么可以得到每次迭代的误差满足： (λ∗−λ(n+1))≤(λ∗−λ(n))(1−g(x∗)g(x(n+1)))(\\lambda^*-\\lambda^{(n+1)})\\le(\\lambda^*-\\lambda^{(n)})(1-\\frac{g(x^*)}{g(x^{(n+1)})}) (λ∗−λ(n+1))≤(λ∗−λ(n))(1−g(x(n+1))g(x∗)​) 令ϵi=(1−g(x∗)/g(x(i))), i=1,2,⋯\\epsilon_i=(1-g(x^*)/g(x^{(i)})),\\ i=1,2,\\cdotsϵi​=(1−g(x∗)/g(x(i))), i=1,2,⋯，Schaible的理论表明ϵ1≥ϵ2≥⋯≥0\\epsilon_1\\ge\\epsilon_2\\ge\\cdots\\ge0ϵ1​≥ϵ2​≥⋯≥0。序列误差的级联关系可以表示为： (λ∗−λ(n+1))≤(λ∗−λ(0))∏i=1n+1(1−g(x∗)g(x(i)))=(λ∗−λ(0))∏i=1n+1ϵi(\\lambda^*-\\lambda^{(n+1)})\\le(\\lambda^*-\\lambda^{(0)})\\prod_{i=1}^{n+1}(1-\\frac{g(x^*)}{g(x^{(i)})})=(\\lambda^*-\\lambda^{(0)})\\prod_{i=1}^{n+1}\\epsilon_i (λ∗−λ(n+1))≤(λ∗−λ(0))i=1∏n+1​(1−g(x(i))g(x∗)​)=(λ∗−λ(0))i=1∏n+1​ϵi​ 此时可以使用第二个引理。 📌引理2： 存在一个x∗∈Sx^*\\in Sx∗∈S作为问题P的最优解，使得lim⁡n→∞ϵn=0\\lim\\limits_{n\\rightarrow\\infty}\\epsilon_n=0n→∞lim​ϵn​=0 Schaible S. Fractional Programming: Transformations, Duality and Algorithmic Aspects[R]. STANFORD UNIV CALIF DEPT OF OPERATIONS RESEARCH, 1973. 因此，对于任意θ∈(0,1]\\theta\\in(0,1]θ∈(0,1]，存在一个整数nθ≥0n_{\\theta}\\ge0nθ​≥0使得对于所有的i≥nθi \\ge n_{\\theta}i≥nθ​，有ϵi&lt;θ\\epsilon_i&lt;\\thetaϵi​&lt;θ。 定义常数βθ=∏i=1nθ−1(ϵiθ)\\beta_\\theta=\\prod_{i=1}^{n_\\theta-1}(\\frac{\\epsilon_i}{\\theta})βθ​=∏i=1nθ​−1​(θϵi​​)，可以有 λ∗−λ(n+1)θn+1≤(λ∗−λ(0))βθ∏i=nθn+1(ϵiθ)\\frac{\\lambda^*-\\lambda^{(n+1)}}{\\theta^{n+1}}\\le(\\lambda^*-\\lambda^{(0)})\\beta_\\theta\\prod_{i=n_\\theta}^{n+1}(\\frac{\\epsilon_i}\\theta) θn+1λ∗−λ(n+1)​≤(λ∗−λ(0))βθ​i=nθ​∏n+1​(θϵi​​) 因此lim⁡n→∞λ∗−λ(n+1)θn+1=0\\lim_{n\\rightarrow\\infty}\\frac{\\lambda^*-\\lambda^{(n+1)}}{\\theta^{n+1}}=0limn→∞​θn+1λ∗−λ(n+1)​=0。 综上所述，序列的下界λ(n+1)\\lambda^{(n+1)}λ(n+1)将会以一个超线性的速率收敛到λ∗=f(x∗)/g(x∗)\\lambda^*=f(x^*)/g(x^*)λ∗=f(x∗)/g(x∗)。 有上界论证的改进Dinkelbach 从上面的推导可看出，朴素的Dinkelbach提供了下界的逼近，并没有提供上界的论证。这样可能会导致一个问题。如下图所示。 直线是M(λ)M(\\lambda)M(λ)（实际情况可能不一定是直线哈，应该是个凸函数，这里只是为了演示方便），目标是最后逼近到λ∗\\lambda^*λ∗。但是朴素Dinkelbach是类似于左边的下界线逼近的，现实情况里，可能很难迭代到M(λ′)=0M(\\lambda&#x27;)=0M(λ′)=0，往往都是小于一个δ\\deltaδ就表明收敛。但是其超线性则使λ(n+1)\\lambda^{(n+1)}λ(n+1)有可能在离λ∗\\lambda^*λ∗很远时就已经得到一个足够小的M(λ(n+1))M(\\lambda^{(n+1)})M(λ(n+1))，导致最后的结果不够准确。那么如果能够再求得一条上界线从右边逼近，两条线同时逼近时，各自求的λ\\lambdaλ相差足够小，就可以更加精确地找到λ∗\\lambda^*λ∗。 这便是改进版Dinkelbach的思路。 初始上界：分别解max⁡x∈Sf(x)\\max\\limits_{x\\in S}f(x)x∈Smax​f(x)和min⁡x∈Sg(x)\\min\\limits_{x\\in S}g(x)x∈Smin​g(x)得到x′x&#x27;x′和x′′x&#x27;&#x27;x′′，从而得到初始上界γ(−1)=f(x′)/g(x′′)\\gamma^{(-1)}=f(x&#x27;)/g(x&#x27;&#x27;)γ(−1)=f(x′)/g(x′′)。这必然是一个比λ∗\\lambda^*λ∗大的数，且由于之前所提的M(λ)M(\\lambda)M(λ)的两条性质，每次迭代的上界都应该满足M(γ)&lt;0M(\\gamma)&lt;0M(γ)&lt;0。定义每一轮的上界为： γ(k):=γ(k−1)−M(γ(k−1))(γ(k−1)−λ(k)M(γ(k−1))−M(λ(k)))\\gamma^{(k)}:=\\gamma^{(k-1)}-M(\\gamma^{(k-1)})\\left(\\frac{\\gamma^{(k-1)}-\\lambda^{(k)}}{M(\\gamma^{(k-1)})-M(\\lambda^{(k)})}\\right) γ(k):=γ(k−1)−M(γ(k−1))(M(γ(k−1))−M(λ(k))γ(k−1)−λ(k)​) 这个式子的含义如上图所示。接着就可以得到如下改进版Dinkelbach。 改进版Dinkelbach： 选取x(0)∈Sx^{(0)}\\in Sx(0)∈S。设置λ(0):=f(x(0))/g(x(0))\\lambda^{(0)}:=f(x^{(0)})/g(x^{(0)})λ(0):=f(x(0))/g(x(0))； 求解问题max⁡x∈Sf(x)\\max\\limits_{x\\in S}f(x)x∈Smax​f(x)得到x′x&#x27;x′，求解问题min⁡x∈Sg(x)\\min\\limits_{x\\in S}g(x)x∈Smin​g(x)得到x′′x&#x27;&#x27;x′′。设置γ(−1):=f(x′)/g(x′′)\\gamma^{(-1)}:=f(x&#x27;)/g(x&#x27;&#x27;)γ(−1):=f(x′)/g(x′′)以及k:=0k:=0k:=0。若γ(−1)−λ(0)≤δ\\gamma^{(-1)}-\\lambda^{(0)}\\le\\deltaγ(−1)−λ(0)≤δ，那么λ∗:=λ(0)\\lambda^*:=\\lambda^{(0)}λ∗:=λ(0)且x∗:=x(0)x^*:=x^{(0)}x∗:=x(0)，算法停止； 求解全局优化问题M(λ(k))=max⁡x∈S(f(x)−λ(k)g(x))M(\\lambda^{(k)})=\\max\\limits_{x\\in S}(f(x)-\\lambda^{(k)}g(x))M(λ(k))=x∈Smax​(f(x)−λ(k)g(x))，得到x(k+1)x^{(k+1)}x(k+1)； 若M(λ(k))=0M(\\lambda^{(k)})=0M(λ(k))=0，那么x∗:=x(k+1),λ∗=λ(k)x^*:=x^{(k+1)},\\quad\\lambda^*=\\lambda^{(k)}x∗:=x(k+1),λ∗=λ(k)，算法停止； 求解全局优化问题M(γ(k−1))=max⁡x∈S(f(x)−γ(k−1)g(x))M(\\gamma^{(k-1)})=\\max\\limits_{x\\in S}(f(x)-\\gamma^{(k-1)}g(x))M(γ(k−1))=x∈Smax​(f(x)−γ(k−1)g(x))，得到y(k)y^{(k)}y(k)； 若M(γ(k−1))=0M(\\gamma^{(k-1)})=0M(γ(k−1))=0，那么x∗:=y(k),λ∗=γ(k−1)x^*:=y^{(k)},\\quad\\lambda^*=\\gamma^{(k-1)}x∗:=y(k),λ∗=γ(k−1)，算法停止； 设置γ(k):=γ(k−1)−M(γ(k−1))(γ(k−1)−λ(k)M(γ(k−1))−M(λ(k)))\\gamma^{(k)}:=\\gamma^{(k-1)}-M(\\gamma^{(k-1)})\\left(\\frac{\\gamma^{(k-1)}-\\lambda^{(k)}}{M(\\gamma^{(k-1)})-M(\\lambda^{(k)})}\\right)γ(k):=γ(k−1)−M(γ(k−1))(M(γ(k−1))−M(λ(k))γ(k−1)−λ(k)​)； 若γ(k)−λ(k)≤δ\\gamma^{(k)}-\\lambda^{(k)}\\le\\deltaγ(k)−λ(k)≤δ，那么x∗:=x(k+1),λ∗=λ(k)x^*:=x^{(k+1)},\\quad\\lambda^*=\\lambda^{(k)}x∗:=x(k+1),λ∗=λ(k)，算法停止； 设置λ(k+1):=f(x(k+1))/g(x(k+1)), k:=k+1\\lambda^{(k+1)}:=f(x^{(k+1)})/g(x^{(k+1)}),\\ k:=k+1λ(k+1):=f(x(k+1))/g(x(k+1)), k:=k+1，返回步骤3。 算法有效性分析 📌定理2： λ∗≤γ(i+1)&lt;γ(i),i=−1,0,1,⋯\\lambda^*\\le\\gamma^{(i+1)}&lt;\\gamma^{(i)},\\quad i=-1,0,1,\\cdotsλ∗≤γ(i+1)&lt;γ(i),i=−1,0,1,⋯ （这个定理强调的是每个迭代的γ(i)\\gamma^{(i)}γ(i)都大于等于λ∗\\lambda^*λ∗，不会越过λ∗\\lambda^*λ∗） 证明：（其实或许不需要证明，看上面的图即可体会此定理，但写论文还需要严格证明一下） 定义连接(λ(n),M(λ(n)))(\\lambda^{(n)},M(\\lambda^{(n)}))(λ(n),M(λ(n)))和(γn−1,M(γ(n−1)))(\\gamma^{n-1},M(\\gamma^{(n-1)}))(γn−1,M(γ(n−1)))的直线的函数为LLL。 由上面可知γ(n)=qλ(n)+(1−q)γ(n−1),q∈(0,1)\\gamma^{(n)}=q\\lambda^{(n)}+(1-q)\\gamma^{(n-1)},\\quad q\\in(0,1)γ(n)=qλ(n)+(1−q)γ(n−1),q∈(0,1) 所以有 M(γ(n))=M(qλ(n)+(1−q)γ(n−1))⩽qM(λ(n))+(1−q)M(γ(n−1))=qL(λ(n))+(1−q)L(γ(n−1))=L(qλ(n)+(1−q)γ(n−1))=L(γ(n))=0\\begin{aligned} &amp;M\\left(\\gamma^{(n)}\\right)=M\\left(q \\lambda^{(n)}+(1-q) \\gamma^{(n-1)}\\right) \\leqslant q M\\left(\\lambda^{(n)}\\right)+(1-q) M\\left(\\gamma^{(n-1)}\\right) \\\\ &amp;\\quad=q L\\left(\\lambda^{(n)}\\right)+(1-q) L\\left(\\gamma^{(n-1)}\\right) \\\\ &amp;\\quad=L\\left(q \\lambda^{(n)}+(1-q) \\gamma^{(n-1)}\\right)=L\\left(\\gamma^{(n)}\\right)=0 \\end{aligned} ​M(γ(n))=M(qλ(n)+(1−q)γ(n−1))⩽qM(λ(n))+(1−q)M(γ(n−1))=qL(λ(n))+(1−q)L(γ(n−1))=L(qλ(n)+(1−q)γ(n−1))=L(γ(n))=0​ 所以M(γ(n))≤0M(\\gamma^{(n)})\\le0M(γ(n))≤0，由M()M()M()函数性质可知λ∗≤γ(n)\\lambda^*\\le\\gamma^{(n)}λ∗≤γ(n) 接下来论证上界序列γ(n)\\gamma^{(n)}γ(n)也是以超线性的速率收敛到λ∗\\lambda^*λ∗的。 拉格朗日中值定理： f(x)f(x)f(x)在闭区间[a,b][a,b][a,b]内连续，在开区间(a,b)(a,b)(a,b)内可导，则在(a,b)(a,b)(a,b)内至少有一点ϵ(a&lt;ϵ&lt;b)\\epsilon(a&lt;\\epsilon&lt;b)ϵ(a&lt;ϵ&lt;b)，使等式f(b)−f(a)=f′(ϵ)(b−a)f(b)-f(a)=f&#x27;(\\epsilon)(b-a)f(b)−f(a)=f′(ϵ)(b−a)成立。 罗尔中值定理： f(x)f(x)f(x)在闭区间[a,b][a,b][a,b]上连续，在开区间(a,b)(a,b)(a,b)内可导，且在区间端点处的函数值相等，即f(a)=f(b)f(a)=f(b)f(a)=f(b)，则在(a,b)(a,b)(a,b)内至少存在一点ϵ(a&lt;ϵ&lt;b)\\epsilon(a&lt;\\epsilon&lt;b)ϵ(a&lt;ϵ&lt;b)，使得f′(ϵ)=0f&#x27;(\\epsilon)=0f′(ϵ)=0。 柯西中值定理： 如果函数f(x),g(x)f(x),g(x)f(x),g(x)满足： (1)在闭区间[a,b][a,b][a,b]上连续 (2)在开区间(a,b)(a,b)(a,b)内可导 (3)对任意x∈(a,b), g′(x)∉0x\\in(a,b),\\ g&#x27;(x)\\notin0x∈(a,b), g′(x)∈/0 那么在(a,b)(a,b)(a,b)内至少有一点ξ∈(a,b)\\xi\\in(a,b)ξ∈(a,b)，使得f(b)−f(a)g(b)−g(a)=f′(ξ)g′(ξ)\\frac{f(b)-f(a)}{g(b)-g(a)}=\\frac{f&#x27;(\\xi)}{g&#x27;(\\xi)}g(b)−g(a)f(b)−f(a)​=g′(ξ)f′(ξ)​成立。 考虑第(n+1)(n+1)(n+1)次迭代时，还没有求出结果，根据定义可知 γ(n+1)=γ(n)−M(γ(n))(γ(n)−λ(n+1)M(γ(n))−M(λ(n+1)))\\gamma^{(n+1)}=\\gamma^{(n)}-M\\left(\\gamma^{(n)}\\right)\\left(\\frac{\\gamma^{(n)}-\\lambda^{(n+1)}}{M\\left(\\gamma^{(n)}\\right)-M\\left(\\lambda^{(n+1)}\\right)}\\right) γ(n+1)=γ(n)−M(γ(n))(M(γ(n))−M(λ(n+1))γ(n)−λ(n+1)​) 经过一些代数运算，可得 (λ∗−γ(n+1))=(λ∗−γ(n))+M(γ(n))(γ(n)−λ(n+1)M(γ(n))−M(λ(n+1)))=(λ∗−γ(n))(M(γ(n))−M(λ(n+1)))+M(γ(n))γ(n)−M(γ(n))λ(n+1)M(γ(n))−M(λ(n+1))=M(γ(n))(λ∗−λ(n+1))+M(λ(n+1))(γ(n)−λ∗)M(γ(n))−M(λ(n+1))=−(λ∗−λ(n+1))(λ∗−γ(n))M(γ(n))−M(λ∗)γ(n)−λ∗−M(λ(n+1))−M(λ∗)λ(n+1)−λ∗M(γ(n))−M(λ(n+1))=−(λ∗−λ(n+1))(λ∗−γ(n))M′(α)−M′(β)M′(ζn+1)[γ(n)−λ(n+1)]=−(λ∗−λ(n+1))(λ∗−γ(n))M′′(ξn+1)[α−β]M′(ζn+1)[γ(n)−λ(n+1)]≤−(λ∗−λ(n+1))(λ∗−γ(n))M′′(ξn+1)M′(ζn+1)\\begin{aligned} &amp;\\left(\\lambda^{*}-\\gamma^{(n+1)}\\right)=\\left(\\lambda^{*}-\\gamma^{(n)}\\right)+M\\left(\\gamma^{(n)}\\right)\\left(\\frac{\\gamma^{(n)}-\\lambda^{(n+1)}}{M\\left(\\gamma^{(n)}\\right)-M\\left(\\lambda^{(n+1)}\\right)}\\right) \\\\ &amp;\\quad=\\frac{(\\lambda^*-\\gamma^{(n)})(M(\\gamma^{(n)})-M(\\lambda^{(n+1)}))+M(\\gamma^{(n)})\\gamma^{(n)}-M(\\gamma^{(n)})\\lambda^{(n+1)}}{M(\\gamma^{(n)})-M(\\lambda^{(n+1)})}\\\\ &amp;\\quad=\\frac{M(\\gamma^{(n)})(\\lambda^{*}-\\lambda^{(n+1)})+M(\\lambda^{(n+1)})(\\gamma^{(n)}-\\lambda^{*})}{M(\\gamma^{(n)})-M(\\lambda^{(n+1)})}\\\\ &amp;\\quad=-(\\lambda^*-\\lambda^{(n+1)})(\\lambda^*-\\gamma^{(n)})\\frac{\\frac{M(\\gamma^{(n)})-M(\\lambda^*)}{\\gamma^{(n)}-\\lambda^*}-\\frac{M(\\lambda^{(n+1)})-M(\\lambda^*)}{\\lambda^{(n+1)}-\\lambda^*}}{M(\\gamma^{(n)})-M(\\lambda^{(n+1)})}\\\\ &amp;\\quad=-(\\lambda^*-\\lambda^{(n+1)})(\\lambda^*-\\gamma^{(n)})\\frac{M&#x27;(\\alpha)-M&#x27;(\\beta)}{M&#x27;(\\zeta_{n+1})[\\gamma^{(n)}-\\lambda^{(n+1)}]}\\\\ &amp;\\quad=-(\\lambda^*-\\lambda^{(n+1)})(\\lambda^*-\\gamma^{(n)})\\frac{M&#x27;&#x27;(\\xi_{n+1})[\\alpha-\\beta]}{M&#x27;(\\zeta_{n+1})[\\gamma^{(n)}-\\lambda^{(n+1)}]}\\\\ &amp;\\quad\\le-\\left(\\lambda^{*}-\\lambda^{(n+1)}\\right)\\left(\\lambda^{*}-\\gamma^{(n)}\\right) \\frac{M^{\\prime \\prime}\\left(\\xi_{n+1}\\right)}{M^{\\prime}\\left(\\zeta_{n+1}\\right)} \\end{aligned} ​(λ∗−γ(n+1))=(λ∗−γ(n))+M(γ(n))(M(γ(n))−M(λ(n+1))γ(n)−λ(n+1)​)=M(γ(n))−M(λ(n+1))(λ∗−γ(n))(M(γ(n))−M(λ(n+1)))+M(γ(n))γ(n)−M(γ(n))λ(n+1)​=M(γ(n))−M(λ(n+1))M(γ(n))(λ∗−λ(n+1))+M(λ(n+1))(γ(n)−λ∗)​=−(λ∗−λ(n+1))(λ∗−γ(n))M(γ(n))−M(λ(n+1))γ(n)−λ∗M(γ(n))−M(λ∗)​−λ(n+1)−λ∗M(λ(n+1))−M(λ∗)​​=−(λ∗−λ(n+1))(λ∗−γ(n))M′(ζn+1​)[γ(n)−λ(n+1)]M′(α)−M′(β)​=−(λ∗−λ(n+1))(λ∗−γ(n))M′(ζn+1​)[γ(n)−λ(n+1)]M′′(ξn+1​)[α−β]​≤−(λ∗−λ(n+1))(λ∗−γ(n))M′(ζn+1​)M′′(ξn+1​)​​ 其中，ξn+1,ζn+1∈[λ(n+1),γ(n)]\\xi_{n+1},\\zeta_{n+1}\\in[\\lambda^{(n+1)},\\gamma^{(n)}]ξn+1​,ζn+1​∈[λ(n+1),γ(n)]，令κ=max⁡ξ∈I∣M′′(ξ)∣min⁡ζ∈I∣M′(ζ)∣\\kappa=\\frac{\\max\\limits_{\\xi\\in I}|M&#x27;&#x27;(\\xi)|}{\\min\\limits_{\\zeta\\in I}|M&#x27;(\\zeta)|}κ=ζ∈Imin​∣M′(ζ)∣ξ∈Imax​∣M′′(ξ)∣​，I=[λ(0),γ(−1)]I=[\\lambda^{(0)},\\gamma^{(-1)}]I=[λ(0),γ(−1)]且In+1=[λ(n+1),γ(n)]⊂II_{n+1}=[\\lambda^{(n+1)},\\gamma^{(n)}]\\subset IIn+1​=[λ(n+1),γ(n)]⊂I，也就是说κ\\kappaκ是分式M′′(ξn+1)M′(ζn+1)\\frac{M^{\\prime \\prime}\\left(\\xi_{n+1}\\right)}{M^{\\prime}\\left(\\zeta_{n+1}\\right)}M′(ζn+1​)M′′(ξn+1​)​的上界，因此有 ∣λ∗−γ(n+1)∣≤∣λ∗−λ(n+1)∣∣λ∗−γ(n)∣κ|\\lambda^*-\\gamma^{(n+1)}|\\le|\\lambda^*-\\lambda^{(n+1)}||\\lambda^*-\\gamma^{(n)}|\\kappa∣λ∗−γ(n+1)∣≤∣λ∗−λ(n+1)∣∣λ∗−γ(n)∣κ，逐级推导，有 ∣λ∗−γ(n+1)∣⩽κn+∣λ∗−γ(−1)∣∏i=0n+1∣λ∗−λ(i)∣\\left|\\lambda^{*}-\\gamma^{(n+1)}\\right| \\leqslant \\kappa^{n+}\\left|\\lambda^{*}-\\gamma^{(-1)}\\right| \\prod_{i=0}^{n+1}\\left|\\lambda^{*}-\\lambda^{(i)}\\right| ∣∣∣∣​λ∗−γ(n+1)∣∣∣∣​⩽κn+∣∣∣∣​λ∗−γ(−1)∣∣∣∣​i=0∏n+1​∣∣∣∣​λ∗−λ(i)∣∣∣∣​ 前面提到(λ∗−λ(n+1))≤(λ∗−λ(n))(1−g(x∗)g(x(n+1)))(\\lambda^*-\\lambda^{(n+1)})\\le(\\lambda^*-\\lambda^{(n)})(1-\\frac{g(x^*)}{g(x^{(n+1)})})(λ∗−λ(n+1))≤(λ∗−λ(n))(1−g(x(n+1))g(x∗)​)，因此可以将不等式进一步拆解成 ∣λ∗−γ(n+1)∣⩽κn+2∣λ∗−γ(−1)∥λ∗−λ(0)∣n+2∏i=1n+1εin−i+2\\left|\\lambda^{*}-\\gamma^{(n+1)}\\right| \\leqslant \\kappa^{n+2}\\left|\\lambda^{*}-\\gamma^{(-1)} \\| \\lambda^{*}-\\lambda^{(0)}\\right|^{n+2} \\prod_{i=1}^{n+1} \\varepsilon_{i}^{n-i+2} ∣∣∣∣​λ∗−γ(n+1)∣∣∣∣​⩽κn+2∣∣∣∣​λ∗−γ(−1)∥λ∗−λ(0)∣∣∣∣​n+2i=1∏n+1​εin−i+2​ 引理2说明，ϵ\\epsilonϵ收敛到0。因此对于任意θ∈(0,1]\\theta\\in(0,1]θ∈(0,1]，存在整数nθ≥0n_{\\theta}\\ge0nθ​≥0使得对于所有i≥nθi\\ge n_\\thetai≥nθ​都有κ∣λ∗−λ(0)∣ϵi&lt;θ\\kappa|\\lambda^*-\\lambda^{(0)}|\\epsilon_i&lt;\\thetaκ∣λ∗−λ(0)∣ϵi​&lt;θ，因此定义 αθ=κ∣λ∗−λ(0)∣∏i=1nθ−1(κ∣λ∗−λ(0)∣εin−i+2θ)\\alpha_{\\theta}=\\kappa\\left|\\lambda^{*}-\\lambda^{(0)}\\right| \\prod_{i=1}^{n_{\\theta}-1}\\left(\\frac{\\kappa\\left|\\lambda^{*}-\\lambda^{(0)}\\right| \\varepsilon_{i}^{n-i+2}}{\\theta}\\right)αθ​=κ∣∣∣​λ∗−λ(0)∣∣∣​∏i=1nθ​−1​(θκ∣λ∗−λ(0)∣εin−i+2​​)，我们有 ∣λ∗−γ(n+1)∣θn+1⩽∣λ∗−γ(−1)∣αθ∏i=nθn+1(κ∣λ∗−λ(0)∣εin−i+2θ)\\frac{\\left|\\lambda^{*}-\\gamma^{(n+1)}\\right|}{\\theta^{n+1}} \\leqslant\\left|\\lambda^{*}-\\gamma^{(-1)}\\right| \\alpha_{\\theta} \\prod_{i=n_{\\theta}}^{n+1}\\left(\\frac{\\kappa\\left|\\lambda^{*}-\\lambda^{(0)}\\right| \\varepsilon_{i}^{n-i+2}}{\\theta}\\right) θn+1∣∣∣​λ∗−γ(n+1)∣∣∣​​⩽∣∣∣∣​λ∗−γ(−1)∣∣∣∣​αθ​i=nθ​∏n+1​(θκ∣∣∣​λ∗−λ(0)∣∣∣​εin−i+2​​) 因此，可以得到lim⁡n→∞∣λ∗−γ(−1)∣θn+1=0\\lim\\limits_{n\\rightarrow\\infty}\\frac{|\\lambda^*-\\gamma^{(-1)}|}{\\theta^{n+1}}=0n→∞lim​θn+1∣λ∗−γ(−1)∣​=0，也就是说序列上界γ(n+1)\\gamma^{(n+1)}γ(n+1)同样将以超线性的速率收敛到λ∗\\lambda^*λ∗。","categories":[{"name":"数学","slug":"数学","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数学方法","slug":"数学方法","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6%E6%96%B9%E6%B3%95/"}]},{"title":"动态规划（基础）","slug":"动态规划-基础/动态规划-基础","date":"2021-10-18T12:14:55.000Z","updated":"2022-07-10T13:44:29.109Z","comments":true,"path":"2021/10/18/动态规划-基础/动态规划-基础/","link":"","permalink":"http://example.com/2021/10/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%9F%BA%E7%A1%80/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%9F%BA%E7%A1%80/","excerpt":"","text":"动态规划-基础 1 背包模型 背包模型各子问题特征 问题 特征 零一背包 背包中每件物品最多仅用一次 完全背包 每件物品有无限个 多重背包 每种物品最多Si个 分组背包 N组，每一组里最多只能选一个物品 1.1 零一背包问题 📌有N个物品和一个容量为V的背包，每个物品的体积是Vi，价值是Wi，每件物品仅用一次。要挑选一些物品，使总体积小于等于V，目标让塞进背包的物品总价值最大，求问最大价值 通过01背包可以引出求解DP问题的一般思路 i表示不同的物品，j表示不同容量的背包的体积。f(i,j)就表示满足：从前i个物品中选且总体积小于等于j的所有选法中（集合），价值的最大值（属性）。 状态计算就是一种集合的划分，将当前的集合划分成若干个更小的集合，使得当前集合可以通过更小的集合算出来。而且更小的集合是之前已经算过的。对应到01背包，就是把所有选法分成两大类：不包含第i个物品，和包含第i个物品。 子集划分原则：不重复（不严格要求） &amp; 不漏掉（严格要求） 这里的第2类：包含第i个物品，直接求并不好求，因为可能的情况太多了。这里要曲线救国，先把每种选法里的第i个物品都去掉，此时全部可包含第i物品的选法数是不变的，这些选法的最大价值为f(i-1, j-Vi)，那么再加上W_i，其实就是包含第i个物品的所有选法的最大值。 最终，f(i,j)就是两个子集的最大值，再取一次最大值。 总结一下的话：动态规划的状态就是集合的某种属性（此处是所有选法的最大价值），状态计算的核心就是对集合进行划分。 123456789101112131415161718192021222324//朴素算法代码：二维状态//01背包的状态转移方程：f(i,j) = Max( f(i-1, j), f(i-1, j-Vi)+Wi )#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int n,m; //n物品数, m最大体积int v[N],w[N];int f[N][N];int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++)&#123; //i从1开始，因为f[0][...]必然是0 cin &gt;&gt; v[i] &gt;&gt; w[i]; for(int j = 0; j &lt;= m; j++)&#123; f[i][j] = f[i-1][j]; //不含i的子集是必然存在的 if(j &gt;= v[i]) //判断含i的子集是否可以存在 f[i][j] = max(f[i][j], f[i-1][j-v[i]] + w[i]); &#125; &#125; cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0;&#125; 在朴素二维状态的基础上还可以优化成一维状态，有两个前提： f(i)层只用到了f(i-1)层 —&gt; 滚动数组(迭代器) 两个子集的元素的体积永远小于等于j，而不是在j两侧 所以使用一维数组不同次数的值可以有相当于二维数组不同层的效果 12345678910111213141516171819202122//优化算法代码：一维状态#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int n,m; //n物品数, m最大体积int v[N],w[N];int f[N];int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++)&#123; //i从1开始，因为f[0][...]必然是0 cin &gt;&gt; v[i] &gt;&gt; w[i]; //如果下面for遍历从前向后，相当于使用了f[i][j-v[i]]而非f[i-1][j-v[i]] //因为后一个数用到了前一个数，但前一个数已经在上次迭代中被从i-1更新i //如果反向遍历，后一个数还是会用到前一个数，但此时前一个数未被更新 for(int j = m; j &gt;= v[i]; j--) //注意这里和朴素算法的顺序是反的 f[j] = max(f[j], f[j-v[i]] + w[i]); &#125; cout &lt;&lt; f[m] &lt;&lt; endl; return 0;&#125; 1.2 完全背包问题 📌有N件物品和一个容量为V的背包，每个物品的体积是Vi，价值是Wi，每件物品可用无限次。挑选一些物品，使总体积小于等于V，让塞进背包的物品总价值最大，求问最大价值 完全背包和01背包解法很相似，集合的划分分为两类：不包含第i个物品，和包含第i个物品。只是第2个类别中的曲线救国改成了f( i-1, j-k*Vi)+k*Wi，k是物品i的使用次数 12345678910111213141516171819202122//朴素算法代码：二维状态//完全背包的状态转移方程：f(i,j) = Max( f(i-1, j), f(i-1, j-k*Vi)+k*Wi )#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int n,m; //n物品数, m最大体积int v[N],w[N];int f[N][N];int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++)&#123; //i从1开始，因为f[0][...]必然是0 cin &gt;&gt; v[i] &gt;&gt; w[i]; for(int j = 0; j &lt;= m; j++) for(int k = 0; k*v[i] &lt;= j; k++) //k从0开始，所以其实f[i-1][j]是不需要的 f[i][j] = max(f[i][j], f[i-1][j-k*v[i]] + k*w[i]); &#125; cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0;&#125; 由于上述朴素算法用到三种循环，时间复杂度还是相当高的，可以通过状态转移方程对其优化 123456789101112131415161718192021222324252627//原状态转移方程：f(i,j) = Max( f(i-1,j), f(i-1,j-Vi)+Wi, f(i-1,j-2Vi)+2Wi, ... )//考虑j-Vi： f(i,j-Vi)= Max( f(i-1,j-Vi), f(i-1,j-2Vi)+Wi, ... )//第一次优化：二维状态//优化后的状态转移方程：f(i,j) = Max( f(i-1,j), f(i,j-Vi)+Wi )#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int n,m; //n物品数, m最大体积int v[N],w[N];int f[N][N];int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++)&#123; //i从1开始，因为f[0][...]必然是0 cin &gt;&gt; v[i] &gt;&gt; w[i]; for(int j = 0; j &lt;= m; j++)&#123; f[i][j] = f[i-1][j]; //不含i的子集是必然存在的 if(j &gt;= v[i]) //判断含i的子集是否可以存在 f[i][j] = max(f[i][j], f[i][j-v[i]] + w[i]); &#125; &#125; cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0;&#125; 现在还可以按照01背包的优化方式，进行进一步优化 12345678910111213141516171819//最终优化：一维状态#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int n,m; //n物品数, m最大体积int v[N],w[N];int f[N];int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++)&#123; //i从1开始，因为f[0][...]必然是0 cin &gt;&gt; v[i] &gt;&gt; w[i]; for(int j = v[i]; j &lt;= m; j++) //这里遍历是正向的，因为符合状态转移方程 f[j] = max(f[j], f[j-v[i]] + w[i]); &#125; cout &lt;&lt; f[m] &lt;&lt; endl; return 0;&#125; 📌Tip：动态规划中如果状态转移用到了上一层的内容，就按体积从小到大的顺序遍历；如果用到本层内容，则反过来，使用体积从大到小的顺序 1.3 多重背包问题 多重背包是有限情景下的完全背包，二者的朴素写法几乎是一样的 不能使用完全背包的优化方法来优化多重背包 原方程：f(i,j) = Max( f(i-1,j), f(i-1,j-Vi)+Wi, f(i-1,j-2Vi)+2Wi, … , f(i-1,j-SiVi)+SiVi ) j-Vi： f(i,j-Vi) = Max( f(i-1,j-Vi), f(i-1,j-2Vi)+Wi, … , f(i-1,j-SiVi)+(Si-1) Vi, f(i-1,j-(Si+1)*Vi)+Si*Vi ) 完全背包问题中的k是受背包容量限制的，不会多红字那一项，但多重背包同时受背包容量和Si限制，如果可虑所有情况，就有可能出现红字那一项。那么完全背包所用的优化方法不再适用 📌有N种物品和一个容量为V的背包，每种物品中一件的体积是Vi，价值是Wi，每种物品最多可用Si次。挑选一些物品，使总体积小于等于V，让塞进背包的物品总价值最大，求问最大价值 1234567891011121314151617181920212223//朴素算法代码：二维状态//多重背包的状态转移方程：f(i,j) = Max( f(i-1, j), f(i-1, j-k*Vi)+k*Wi )#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int n,m; //n物品数, m最大体积int v[N],w[N],s[N];int f[N][N];int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++)&#123; cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i]; for(int j = 0; j &lt;= m; j++) for(int k = 0; k*v[i] &lt;= j &amp;&amp; k &lt;= s[i]; k++)//多重和完全的朴素写法不同之处为此处条件 //k从0开始，所以其实f[i-1][j]是不需要的 f[i][j] = max(f[i][j], f[i-1][j-k*v[i]] + k*w[i]); &#125; cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0;&#125; 优化方法：二进制优化！！！ (其实还可以使用单调队列优化，后面的内容) 对于任意大小s[i]，里面所有的数都可以由一系列“二的整数次方”组成，比如s=1023 则所有比1023小的数都可以用{1,2,4,8,…,512}组合出来。 又比如200：1,2,4,8,16,32,64,73 那么k的遍历那一环其实就变成了01背包问题，不再需要遍历全部Si次，只需设置log2Si个背包 时间复杂度从NVS到NVlog2S 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 25000, M = 2010;int n,m;int v[N],w[N];int f[N];int main()&#123; cin &gt;&gt; n &gt;&gt; m; int cnt = 0; for(int i = 1; i &lt;= n; i++)&#123;//建立新背包 int a,b,s; cin &gt;&gt; a &gt;&gt; b &gt;&gt; s; int k = 1; while(k &lt;= s)&#123; cnt++; v[cnt] = a * k; w[cnt] = b * k; s -= k; k *= 2; &#125; if(s &gt; 0)&#123; cnt ++; v[cnt] = a * s; w[cnt] = b * s; &#125; &#125; n = cnt; for(int i = 1; i &lt;= n; i++) for(int j = m; j &gt;= v[i]; j-- ) f[j] = max(f[j],f[j-v[i]]+w[i]); cout &lt;&lt; f[m] &lt;&lt;endl; return 0;&#125; 1.4 分组背包问题 📌有N组物品和一个容量为V的背包，每件物品的体积是Vij，价值是Wij，i是组号，j是组内编号，同一组内的物品最多选一个。挑选一些物品，使总体积小于等于V，让塞进背包的物品总价值最大，求问最大价值 热狗划分法(状态计算)： 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 110;int n,m;int v[N][N],w[N][N],s[N]; //s[i]表示第i组有多少物品int f[N];int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1 ;i &lt;= n; i++)&#123; cin &gt;&gt; s[i]; for(int j = 0; j &lt; s[i]; j++ ) cin&gt;&gt;v[i][j]&gt;&gt;w[i][j]; &#125; for(int i = 1; i &lt;= n; i++)&#123; for(int j = m; j &gt;= 0; j--) //因为要用到i-1，所以逆序遍历 for(int k = 0; k &lt; s[i]; k++ ) if(v[i][k] &lt;= j) f[j] = max(f[j],f[j-v[i][k]]+w[i][k]); &#125; cout &lt;&lt; f[m] &lt;&lt; endl; return 0;&#125; 2 线性DP 线性DP就是在线性结构上转移状态，完成线性空间上的递推 2.1 例题1：数字三角形 📌给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 求解思路： 123456789- 状态表示：f(i,j)：走到(i,j)位置的所有路径的集合的max 集合 属性 第一列第一行 7 第二列第二行 3 8 第三列第三行 8 1 0 第四列第四行 2 7 4 4 第五列第五行 4 5 2 6 5 1234567- 状态计算(令a(i,j)表示(i,j)位置元素的值)分类：左上来的路径 和 右上来的路径 f(i-1,j-1)+a(i,j) f(i-1,j)+a(i,j)⇒状态转移方程：f(i,j) = Max( f(i-1,j-1)+a(i,j) , f(i-1,j)+a(i,j)) ) 代码： 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 512, INF = 1e9;int n;int a[N][N];int f[N][N];int main()&#123; scanf(&quot;%d&quot;, &amp;n); //一共有几行几列 for(int i = 1; i &lt;= n; i++) //获取三角形 for(int j = 1; j &lt;= i; j++) scanf(&quot;%d&quot;,&amp;a[i][j]); for(int i = 1; i &lt;= n; i++) for(int j = 0; j &lt;= i + 1; j++) //这里的列需要从0开始，到i+1结束，补全边缘数字两侧 f[i][j] = -INF; //防止求和为负数时，初值为0的误判 f[1][1] = a[1][1]; for(int i = 2; i &lt;= n; i++) for(int j = 1; j &lt;= i; j++) f[i][j] = max(f[i-1][j-1]+a[i][j], f[i-1][j]+a[i][j]); int res = -INF; for(int i = 1; i &lt;= n; i++)res = max(res,f[n][i]); printf(&quot;%d&quot;, res); return 0;&#125; 2.2 例题2：最大上升子序列 📌给定一个长度为N的数列，求数值严格单调递增的子序列的长度最长是多少，并记录子序列 输入样例： 7 3 1 2 1 8 5 6 结果： 4 1 2 5 6 朴素方法求解思路： - 状态表示： f[i]：到第i个位置的子序列集合的max - 状态计算： f[i] = f[j]+1, j = 1,2,...,i-1 &amp;&amp; a[j]&lt;a[i] 朴素方法代码： 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int n;int a[N], f[N];int main()&#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]); for (int i = 1; i &lt;= n; i ++ ) &#123; f[i] = 1; // 只有a[i]一个数 for (int j = 1; j &lt; i; j ++ ) if (a[j] &lt; a[i]) f[i] = max(f[i], f[j] + 1); &#125; int res = 0; for (int i = 1; i &lt;= n; i ++ ) res = max(res, f[i]); printf(&quot;%d\\n&quot;, res); return 0;&#125; 优化 求解思路： 对于像 7 3 1 2 1 8 5 6 这样的序列，在走到i时，可以存储i之前的各个长度里的上升子序列中末尾最小值，比如8之前，长度为1的上升子序列的末尾值可以有3和1，但是3是没必要存的，能接在3后也必然能接在1后 而且各个长度的上升子序列的末尾最小值必然严格单调递增 可以用反证法证明这一性质： 若q6比q5小，那么q6所在子序列的第5个值也比q5小，那么q5就不是长度为5的子序列中的最小末尾值，矛盾 于是当走到第i个字符a[i]时，可以查找a[i]之前所有长度子序列中，小于a[i]的最大的末尾最小值。 比如说，q4&lt;a[i]，而q5&gt;a[i]，那么q4就是那个最大的末尾最小值，而且q5将被替换成a[i] 查找最大的末尾最小值时可以使用二分查找。时间复杂度较之前大大减少。 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int n;int a[N];int q[N];int main()&#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]); int len = 0; for (int i = 0; i &lt; n; i ++ ) &#123; int l = 0, r = len; while (l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1; if (q[mid] &lt; a[i]) l = mid; else r = mid - 1; &#125; len = max(len, r + 1); q[r + 1] = a[i]; &#125; printf(&quot;%d\\n&quot;, len); return 0;&#125; 2.3 例题3： 最长公共子序列 📌给定两个长度分别为N和M的字符串A和B，求既是A的子序列又是B的子序列的字符串长度最长是多少 输入案例： 4 5 acbd abedc 输出：3(abd) 求解思路： 状态表示： f(i,j)：所有在A序列的前i个字母中出现，并在B序列的前j个字母中出现的子序列的集合中的Max 状态计算： 上述四者分别是 f(i-1, j-1) 、f(i-1, j) 、f(i, j-1) 、f(i-1, j-1)+1 需要注意中间二者，f(i-1, j)并不是严格的01情况，f(i, j-1)也不是严格的10情况 f(i-1,j)是： 所有在A序列的前i-1个字母中出现 并在B序列的前j个字母中出现的子序列集合 01是： 不包含A序列的第i个字母， 但是包含B序列的第j个字母的子序列的集合 前者包含后者，二者并不相等 f(i,j-1)是： 所有在A序列的前i个字母中出现 并在B序列的前j-1个字母中出现的子序列集合 10是： 包含A序列的第i个字母， 但是不包含B序列的第j个字母的子序列的集合 前者包含后者，二者并不相等 求最大值时重复是没有关系的，只要保证不漏就行 事实上第一项f(i-1, j-1)也没有必要写，因为它被f(i-1, j)和f(i, j-1)包含了 代码： 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int n, m;char a[N], b[N];int f[N][N];int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); scanf(&quot;%s%s&quot;, a + 1, b + 1); for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) &#123; f[i][j] = max(f[i - 1][j], f[i][j - 1]); if (a[i] == b[j]) f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1); &#125; printf(&quot;%d\\n&quot;, f[n][m]); return 0;&#125; 2.4 例题4：最短编辑距离 📌给定两个字符串A和B，现在要将A经过若干操作变为B，可进行的操作有： - 删除：将字符串A中的某个字符删除。 - 插入：在字符串A的某个位置插入某个字符。 - 替换：将字符串A中的某个字符替换为另一个字符。 现在请你求出，将A变为B至少需要进行多少次操作。 求解思路： 状态表示： f(i,j)：所有从A[1~i]变到B[1~j]的操作方式的集合的min 状态计算： → 状态转移方程： f(i, j) = min( f(i-1, j) + 1, f(i, j-1) + 1, f(i-1, j-1) + 1/0 ) 删的前提是A[1~i-1]==B[1~j] 增的前提是A[1~i]==B[1~j-1] 改的前提是A[1~i-1]==B[1~j-1]，如果A[i]==B[j]，加0，否则加1 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int n, m;char a[N], b[N];int f[N][N];int main()&#123; scanf(&quot;%d%s&quot;, &amp;n, a+1);//接收a字符串 scanf(&quot;%d%s&quot;, &amp;m, b+1);//接收b字符串 for(int j = 0; j &lt;= m; j++) f[0][j] = j;//a为空时，只能增，增加b的长度 for(int i = 0; i &lt;= n; i++) f[i][0] = i;//b为空时，只能删，删除a的长度 for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; f[i][j] = min(f[i-1][j]+1, f[i][j-1]+1);//前两种情况直接比较 if(a[i] == b[j])f[i][j] = min(f[i][j], f[i-1][j-1]); else f[i][j] = min(f[i][j], f[i-1][j-1] + 1); &#125; &#125; printf(&quot;%d&quot;, f[n][m]); return 0;&#125; 例题变形： 📌给定n个长度不超过10的字符串以及m次询问，每次询问给出一个字符串和一个操作次数上限。 对于每次询问，请你求出给定的n个字符串中有多少个字符串可以在上限操作次数内经过操作变成询问给出的字符串。 每个对字符串进行的单个字符的插入、删除或替换算作一次操作。 其实就是将刚刚的过程操作n*m次 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std;const int N = 15, M = 1010;int n, m;int f[N][N];char str[M][N];int edit_distance(char a[], char b[])&#123; int la = strlen(a + 1), lb = strlen(b + 1); for (int i = 0; i &lt;= lb; i ++ ) f[0][i] = i; for (int i = 0; i &lt;= la; i ++ ) f[i][0] = i; for (int i = 1; i &lt;= la; i ++ ) for (int j = 1; j &lt;= lb; j ++ ) &#123; f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1); f[i][j] = min(f[i][j], f[i - 1][j - 1] + (a[i] != b[j])); &#125; return f[la][lb];&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); //n个字符串，m次询问 for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%s&quot;, str[i] + 1); while (m -- ) &#123; char s[N]; int limit; scanf(&quot;%s%d&quot;, s + 1, &amp;limit); int res = 0; for (int i = 0; i &lt; n; i ++ ) if (edit_distance(str[i], s) &lt;= limit) res ++ ; printf(&quot;%d\\n&quot;, res); &#125; return 0;&#125; 3 区间DP 区间dp就是在区间上进行动态规划，求解一段区间上的最优解。 主要是通过合并小区间的最优解，进而得出整个大区间上最优解的dp算法 3.1 例题1：石子合并 📌设有N堆石子排成一排，其编号为1，2，3，…，N。 每堆石子有一定的质量，可以用一个整数来描述，现在要将这N堆石子合并成为一堆。 每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。 例如有4堆石子分别为 1 3 5 2， 我们可以先合并1、2堆，代价为4，得到4 5 2， 又合并 1，2堆，代价为9，得到9 2 ，再合并得到11，总代价为4+9+11=24； 如果第二步是先合并2，3堆，则代价为7，得到4 7，最后一次合并代价为11，总代价为4+7+11=22。 问题是：找出一种合理的方法，使总的代价最小，输出最小代价。 求解思路： 状态表示： f(i,j)：所有将第i堆石子~第j堆石子合并成一堆石子的合并方式的集合中的Min 状态计算： 状态划分： 2. 状态转移：f(i, j) = Min( f(i, m) + f(m+1, j) + sum(j)-sum(i-1) ), m = i,i+1,…,j-1 蓝字是前缀和，用于计算当前两堆的代价 最终状态就是f(1,n) 状态转移的图解： 代码： 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 310;int n;//一共多少石堆int s[N];//每堆的重量int f[N][N];int main()&#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;s[i]); for (int i = 1; i &lt;= n; i ++ ) s[i] += s[i - 1];//求前缀和 for (int len = 2; len &lt;= n; len ++ ) for (int i = 1; i + len - 1 &lt;= n; i ++ )&#123; int l = i, r = i + len - 1; f[l][r] = 1e8; for (int k = l; k &lt; r; k ++ ) f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]); &#125; printf(&quot;%d\\n&quot;, f[1][n]); return 0;&#125; 4 计数类DP 将DP算法应用在计数类问题 4.1 例题1：整数划分 📌一个正整数n可以表示成若干个正整数之和，形如：n=n1+n2+…+nk，其中n1≥n2≥…≥nk,k≥1。 我们将这样的一种表示称为正整数n的一种划分。 现在给定一个正整数n，请你求出n共有多少种不同的划分方法。 由于答案可能很大，输出结果请对109+7取模。 思路一：背包问题 状态表示： f(i, j)：从1~i中选取数值后，求和正好是j的集合中的数值数量 状态计算： 优化： 1234当前状态转移方程：f(i,j) = f(i-1,j) + f(i-1,j-i) + f(i-1,j-2*i)+...+f(i-1,j-s*i) f(i,j-i)= f(i-1,j-i) + f(i-1,j-2*i)+...+f(i-1,j-s*i)优化后转移方程： f(i,j) = f(i-1,j) + f(i,j-i)优化到一维： f(j) = f(j) + f(j-i) 代码： 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010, mod = 1e9 + 7;int n;int f[N];int main()&#123; cin &gt;&gt; n; f[0] = 1; for (int i = 1; i &lt;= n; i ++ ) for (int j = i; j &lt;= n; j ++ ) f[j] = (f[j] + f[j - i]) % mod; cout &lt;&lt; f[n] &lt;&lt; endl; return 0;&#125; 思路二： - 状态表示： 所有总和为i，并且恰好表示成j个数的和的方案 的集合中的 数值数量(也就是j) - 状态计算： f(i,j) = f(i-1,j-1) + f(i-j,j) 曲线救国 f(i-1,j-1)是f(i,j)中包含最小值1的方案 f(i-j,j)是f(i,j)中不包含最小值1的方案 (j个数都减1) 注意：这种思路最后结果是f(n,1)+f(n,2)+f(n,3)… 代码： 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010, mod = 1e9 + 7;int n;int f[N][N];int main()&#123; cin &gt;&gt; n; f[1][1] = 1; for (int i = 2; i &lt;= n; i ++ ) for (int j = 1; j &lt;= i; j ++ ) f[i][j] = (f[i - 1][j - 1] + f[i - j][j]) % mod; int res = 0; for (int i = 1; i &lt;= n; i ++ ) res = (res + f[n][i]) % mod; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; 5 数位统计DP 竞赛中有这样一类问题：求给定区间中，满足给定条件的某个D进制数或此类数的数量。所求的限定条件往往与数位有关，例如数位之和、指定数码个数、数的大小顺序分组等等。题目给定的区间往往很大，无法采用朴素的方法求解。 6 状态压缩DP 将状态表示成二进制数，每一位都与状态一一对应 6.1 例题1：蒙德里安的梦想 📌求把N*M的棋盘分割成若干个1*2的的长方形，有多少种方案。 例如当N=2，M=4时，共有5种方案。 如下图所示： 思路： 举例说明，一旦某一个方案所有横向1*2的长方形放完了，那么该方案的所有纵向2*1也就只能填充，无法再做改变。所以只需要排列横向1*2长方形即可，而通过列来检查排列是否可行： 排完横向后，第i列不可以有连续奇数个空格 从第i-2到第i-1列的横向长方形和从第i-1列到第i列的横向长方形不能有重合 状态表示： f(i, j)：i表示目前排到第i列，j表示从第i-1列伸过来的横向长方形的状态 f(i, j)表示排到第i列的(满足约束的)方案的个数 举例来说，上图中，目前第i列的 j1 = 0010(二进制) 目前第i-1列的 j2 = 1001(二进制) 一共有m列，从0到m-1 那么上述两个约束条件变成了： (j1&amp;j2) 必须等于0 j1中不可以有连续奇数个0 状态计算： f(i, j) = f(i-1, k1) + f(i-1, k2)+ … 其中k1,k2…是排到第i-1列时满足约束的方案的 j 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*------最终结果是f(m,0)，也就是第m列，没有捅出来的横格时的所有方案-------*/#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 12, M = 1 &lt;&lt; N;int n, m;long long f[N][M];bool st[M];//标志第i列的j是否可行int main()&#123; //逗号运算符分隔两个表达式，但是最终结果是后一个表达式的结果 while (cin &gt;&gt; n &gt;&gt; m, n || m)//当n或m有一个数为0意味着终止测试 &#123; //做约束条件2的检查，检查一下，一列的所有横向排法中，有哪些排法会有连续奇数个0，用st记录 for (int i = 0; i &lt; 1 &lt;&lt; n; i ++ )//有n行，j就有n位 &#123; int cnt = 0; st[i] = true; for (int j = 0; j &lt; n; j ++ ) if (i &gt;&gt; j &amp; 1)//先右移再与，判断第j位是不是1 &#123; if (cnt &amp; 1) st[i] = false; cnt = 0; &#125; else cnt ++ ; if (cnt &amp; 1) st[i] = false;//cnt用来记录连续0的个数，如果是奇数个则此方案不可行 &#125; memset(f, 0, sizeof f); f[0][0] = 1;//啥都没放是一种合法的初始状态，方案数为1 for (int i = 1; i &lt;= m; i ++ ) for (int j = 0; j &lt; 1 &lt;&lt; n; j ++ ) for (int k = 0; k &lt; 1 &lt;&lt; n; k ++ ) //st[j | k]而不是st[j]&amp;st[k],为什么？ if ((j &amp; k) == 0 &amp;&amp; st[j | k])//判断两个约束 f[i][j] += f[i - 1][k]; cout &lt;&lt; f[m][0] &lt;&lt; endl; &#125; return 0;&#125; 6.2 例题2：最短Hamilton路径 📌给定一张 n 个点的带权无向图，点从 0~n-1 标号，求起点 0 到终点 n-1 的最短Hamilton路径。 Hamilton路径的定义是从 0 到 n-1 不重不漏地经过每个点恰好一次。 (此问题就是大名鼎鼎的旅行商问题) 输入格式 第一行输入整数n。 接下来n行每行n个整数，其中第i行第j个整数表示点i到j的距离（记为a[i,j]）。 对于任意的x,y,z，数据保证 a[x,x]=0，a[x,y]=a[y,x] 并且 a[x,y]+a[y,z]&gt;=a[x,z]。 输出格式 输出一个整数，表示最短Hamilton路径的长度。 思路： 状态表示：f(i, j)表示为从0走到 j的所有路径是 i的加权和集合的Min 比如i = 110001 表示为从0到 j，走了点1、5、6，没走2、3、4 状态计算： 通过看走到 j之前的倒数第二个点来做状态转移 如果倒数第二个点是k，则 f(i, j) = f(i-{j}, k) + a[k, j] 所以也就是f(i, j) = min( f(i-{j}, k) + a[k, j] )，k是所有从0到 j所经过的倒数第二个点 12345678910111213141516171819202122232425262728293031#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 20, M = 1 &lt;&lt; N;int n;int w[N][N];int f[M][N];int main()&#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; n; j ++ ) cin &gt;&gt; w[i][j]; memset(f, 0x3f, sizeof f); f[1][0] = 0; for (int i = 0; i &lt; 1 &lt;&lt; n; i ++ ) for (int j = 0; j &lt; n; j ++ ) if (i &gt;&gt; j &amp; 1) for (int k = 0; k &lt; n; k ++ ) if (i &gt;&gt; k &amp; 1) f[i][j] = min(f[i][j], f[i - (1 &lt;&lt; j)][k] + w[k][j]); cout &lt;&lt; f[(1 &lt;&lt; n) - 1][n - 1]; return 0;&#125; 7 树形DP 一般来说树形dp在设状态转移方程时都可以用f[i][]表示i这颗子树怎么怎么样的最优解，实现时一般都是用子树更新父亲（即从下向上更新） 7.1 例题1：没有上司的舞会 📌(树形DP最经典问题) Ural大学有N名职员，编号为1~N。 他们的关系就像一棵以校长为根的树，父节点就是子节点的直接上司。 每个职员有一个快乐指数，用整数 Hi 给出，其中 1≤i≤N。 现在要召开一场周年庆宴会，不过，没有职员愿意和直接上司一起参会。 在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所有参会职员的快乐指数总和最大，求这个最大值。 输入格式 第一行一个整数N。 接下来N行，第 i 行表示 i 号职员的快乐指数Hi。 接下来N-1行，每行输入一对整数L, K,表示K是L的直接上司。 输出格式 输出最大的快乐指数。 思路： 状态表示： 每个节点都有两种状态： f(u, 0)：以u为根节点，但是不选择u的所有方案的集合中的最大快乐指数 f(u, 1)：以u为根节点，同时选择u的所有方案的集合中的最大快乐指数 状态计算： 对于f(u, 0)：由于u未被选择，所以u的子节点可有可无，即对于每个u的子节点Si，f(Si, 0)和f(Si, 1)都可以选择，取其中有最大快乐指数的方案。 对于f(u, 1)：由于u已选，u的子节点不能再选，所以对于每个u的子节点Si，只能有 f(Si, 0)。 f(u, 0) = ∑imax(f(Si,0),f(Si,1))\\sum_i{max(f(Si,0),f(S_i,1))}∑i​max(f(Si,0),f(Si​,1)) f(u, 1) = ∑if(Si,0)+A[u]\\sum_i{f(S_i,0)}+A[u]∑i​f(Si​,0)+A[u] 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 6010;int n;int h[N], e[N], ne[N], idx;//邻接表int happy[N];int f[N][2];bool has_fa[N];//判断各个节点是否有父节点，没有父节点的节点就是根节点void add(int a, int b)//邻接表中插入一条边，模板&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;&#125;void dfs(int u)&#123; f[u][1] = happy[u]; for (int i = h[u]; ~i; i = ne[i])//~i即为判断 i!=-1，按位取反，模板 &#123; int j = e[i]; dfs(j); f[u][1] += f[j][0]; f[u][0] += max(f[j][0], f[j][1]); &#125;&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;happy[i]); memset(h, -1, sizeof h); for (int i = 0; i &lt; n - 1; i ++ ) &#123; int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); add(b, a); has_fa[a] = true; &#125; int root = 1; while (has_fa[root]) root ++ ;//找到根节点 dfs(root); printf(&quot;%d\\n&quot;, max(f[root][0], f[root][1])); return 0;&#125; 8 记忆化搜索 记忆化搜索 = 搜索的形式 + 动态规划的思想 搜索：动态规划数组记录上一层计算结果，当要使用时直接从数组中获取 避免过多的重复计算，往往具有较低的空间复杂度 8.1 例题1：滑雪 📌给定一个R行C列的矩阵，表示一个矩形网格滑雪场。 矩阵中第 i 行第 j 列的点表示滑雪场的第 i 行第 j 列区域的高度。 一个人从滑雪场中的某个区域内出发，每次可以向上下左右任意一个方向滑动一个单位距离。 当然，一个人能够滑动到某相邻区域的前提是该区域的高度低于自己目前所在区域的高度。 下面给出一个矩阵作为例子： 1 2 3 4 5 16 17 18 19 6 15 24 25 20 7 14 23 22 21 8 13 12 11 10 9 在给定矩阵中，一条可行的滑行轨迹为24-17-2-1。 在给定矩阵中，最长的滑行轨迹为25-24-23-…-3-2-1，沿途共经过25个区域。 现在给定你一个二维矩阵表示滑雪场各区域的高度，请你找出在该滑雪场中能够完成的最长滑雪轨迹，并输出其长度(可经过最大区域数)。 思路：递归 状态表示： f(i, j)：以第i行第j列为起点的所有轨迹的集合中的最大长度 状态计算： f(i, j)即为这四种状态在不出界且严格低于(i, j)位置的高度时，取max的结果 由于状态转移方程中，中心区域的状态依托于外圈的状态，直至边缘，所以可用递归的形式来写。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 310;int n, m;int g[N][N];//矩阵int f[N][N];//状态int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;//上下左右int dp(int x, int y)&#123; int &amp;v = f[x][y]; //在返回值的同时，更新f数组 if (v != -1) return v; //如果算过了，直接返回值 v = 1; //初始化，最差情况是只走了自己本身这一步 for (int i = 0; i &lt; 4; i ++ ) &#123; int a = x + dx[i], b = y + dy[i]; if (a &gt;= 1 &amp;&amp; a &lt;= n &amp;&amp; b &gt;= 1 &amp;&amp; b &lt;= m &amp;&amp; g[x][y] &gt; g[a][b]) v = max(v, dp(a, b) + 1); &#125; return v;&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); //n行m列 for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) scanf(&quot;%d&quot;, &amp;g[i][j]); //获取矩阵 memset(f, -1, sizeof f); int res = 0; for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) res = max(res, dp(i, j)); printf(&quot;%d\\n&quot;, res); return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"矩阵论","slug":"矩阵论","date":"2021-05-25T13:30:00.000Z","updated":"2022-07-12T16:16:45.348Z","comments":true,"path":"2021/05/25/矩阵论/","link":"","permalink":"http://example.com/2021/05/25/%E7%9F%A9%E9%98%B5%E8%AE%BA/","excerpt":"","text":"矩阵论 原文出处 1 线性空间与线性变换 （1）线性空间的定义： 以α,β,γ,...\\alpha, \\beta, \\gamma,...α,β,γ,...为元素的非空集合VVV，数域FFF，定义两种运算： 加法：∀α,β∈V, α+β∈V\\forall \\alpha , \\beta \\in V, \\; \\alpha + \\beta \\in V∀α,β∈V,α+β∈V； 数乘：∀k∈F,α∈V,kα∈V\\forall k \\in F, \\alpha \\in V, k \\alpha \\in V∀k∈F,α∈V,kα∈V。 **满足8条：加法交换律、加法结合律、数乘结合律、两个分配律，0元存在，1元存在，负元存在。称 **VVV为数域FFF上的线性空间。 （2）证明一组向量是线性空间的基，两步走： 证明这组向量线性无关； 证明线性空间任意向量可由这组向量表示。 （3）如果{Eij,i=1,2,...,m;j=1,2,...,n}\\{E_{ij}, i=1,2,...,m;j=1,2,...,n\\}{Eij​,i=1,2,...,m;j=1,2,...,n}是矩阵空间Rm×nR^{m \\times n}Rm×n的一组基，则dim⁡Rm×n=m×n\\dim R^{m \\times n} = m \\times ndimRm×n=m×n。 📌注：这里有前提条件，实际上dim⁡Rm×n\\dim R^{m \\times n}dimRm×n并不是总等于m×nm \\times nm×n （4）α1,α2,...,αn\\alpha_1, \\alpha_2, ..., \\alpha_nα1​,α2​,...,αn​是线性空间Vn(F)V_n(F)Vn​(F)的一组基，对于∀β∈V\\forall \\beta \\in V∀β∈V, β=(α1 α2 ... αn)[x1 x2 ... xn]=(α1 α2 ... αn)X\\beta = (\\alpha_1 \\; \\alpha_2 \\; ... \\; \\alpha_n)\\begin{bmatrix}x_1\\\\ x_2\\\\ ...\\\\ x_n\\end{bmatrix}= (\\alpha_1 \\; \\alpha_2 \\; ... \\; \\alpha_n)X β=(α1​α2​...αn​)⎣⎢⎢⎢⎡​x1​ x2​ ... xn​​⎦⎥⎥⎥⎤​=(α1​α2​...αn​)X 其中XXX称为向量β\\betaβ在基(α1 α2 ... αn)(\\alpha_1 \\; \\alpha_2 \\; ... \\; \\alpha_n)(α1​α2​...αn​)下对应的坐标。 Vn(F)V_n(F)Vn​(F)中向量组{β1 β2 ... βm}\\{\\beta_1 \\; \\beta_2 \\; ... \\; \\beta_m\\}{β1​β2​...βm​}线性相关的充要条件是坐标向量组{X1,X2,...,Xm}\\{X_1,X_2,...,X_m\\}{X1​,X2​,...,Xm​}是线性相关组。 （5）设(α1 α2 ... αn)(\\alpha_1 \\; \\alpha_2 \\; ... \\; \\alpha_n)(α1​α2​...αn​)和(β1 β2 ... βn)(\\beta_1 \\; \\beta_2 \\; ... \\; \\beta_n)(β1​β2​...βn​)是nnn维线性空间Vn(F)V_n(F)Vn​(F)中的两组基，则有C∈Fm×nC\\in F^{m \\times n}C∈Fm×n (β1 β2 ... βn)=(α1 α2 ... αn)C(\\beta_1 \\; \\beta_2 \\; ... \\; \\beta_n) = (\\alpha_1 \\; \\alpha_2 \\; ... \\; \\alpha_n)C (β1​β2​...βn​)=(α1​α2​...αn​)C 其中CCC称为从基(α1 α2 ... αn)(\\alpha_1 \\; \\alpha_2 \\; ... \\; \\alpha_n)(α1​α2​...αn​)到(β1 β2 ... βn)(\\beta_1 \\; \\beta_2 \\; ... \\; \\beta_n)(β1​β2​...βn​)的过渡矩阵。 📌重要推论：如果向量α∈Vn(F)\\alpha \\in V_n(F)α∈Vn​(F)，α\\alphaα在两组基下对应坐标分别是XXX和YYY，则有： α=(α1 α2 ... αn)Xα=(β1 β2 ... βn)Y\\alpha = (\\alpha_1 \\; \\alpha_2 \\; ... \\; \\alpha_n)X\\\\\\alpha = (\\beta_1 \\; \\beta_2 \\; ... \\; \\beta_n)Yα=(α1​α2​...αn​)Xα=(β1​β2​...βn​)Y 显然有：X=CY\\color{red}{X = CY}X=CY。 （6）设WWW是线性空间Vn(F)V_n(F)Vn​(F)的非空子集合，则WWW是Vn(F)V_n(F)Vn​(F)的子空间的充要条件是： 若α,β∈W\\alpha, \\beta \\in Wα,β∈W，则α+β∈W\\alpha + \\beta \\in Wα+β∈W 若α∈W, k∈F\\alpha \\in W, \\; k \\in Fα∈W,k∈F，则kα∈Wk \\alpha \\in Wkα∈W 也就是说只需要验证对加法和数乘封闭即可。 （7）设W1, W2W_1, \\; W_2W1​,W2​是线性空间VVV的子空间，则： W1W_1W1​与W2W_2W2​的交空间为：W1∩W2={α∣α∈W1 and α∈W2}W_1 \\cap W_2 = \\{ \\alpha | \\alpha \\in W_1 \\; and \\; \\alpha \\in W_2 \\}W1​∩W2​={α∣α∈W1​andα∈W2​} W1W_1W1​与W2W_2W2​的和空间为：W1+W2={α∣α=α1+α2, α1∈W1, α2∈W2}W_1 + W_2 = \\{ \\alpha | \\alpha = \\alpha_1 + \\alpha_2, \\; \\alpha_1 \\in W_1, \\; \\alpha_2 \\in W_2 \\}W1​+W2​={α∣α=α1​+α2​,α1​∈W1​,α2​∈W2​} 📌***两个重要的维数公式 dim⁡(W1∩W2)⩽dim⁡Wi⩽dim⁡(W1+W2)⩽dim⁡V\\dim (W_1 \\cap W_2) \\leqslant \\dim W_i \\leqslant \\dim(W_1 + W_2) \\leqslant \\dim Vdim(W1​∩W2​)⩽dimWi​⩽dim(W1​+W2​)⩽dimV ***dim⁡W1+dim⁡W2 =dim⁡(W1+W2)+dim⁡(W1∩W2)\\dim W_1 + \\dim W_2 = \\dim (W_1 + W_2) + \\dim(W_1 \\cap W_2)dimW1​+dimW2​ =dim(W1​+W2​)+dim(W1​∩W2​) 📌直和子空间：如果W=W1+W2W = W_1 + W_2W=W1​+W2​，并且W1∩W2={0}W_1 \\cap W_2 = \\{0\\}W1​∩W2​={0}，那么称WWW是W1W_1W1​与W2W_2W2​的直和子空间，表示为W=W1⊕W2W = W_1 \\oplus W_2W=W1​⊕W2​。 📌直和补子空间：对nnn维空间VVV的任何子空间WWW，设α1,...,αr\\alpha_1, ...,\\alpha_rα1​,...,αr​为WWW的基，r&lt;nr &lt; nr&lt;n，把它们扩充为VVV的基{α1,...,αr;βr+1,...,βn},U=L{βr+1,...,βn}\\{\\alpha_1, ...,\\alpha_r; \\beta_{r+1}, ..., \\beta_n\\}, \\quad U = L\\{\\beta_{r+1}, ..., \\beta_n \\}{α1​,...,αr​;βr+1​,...,βn​},U=L{βr+1​,...,βn​}有V=W⊕UV = W \\oplus UV=W⊕U成立，则称UUU是WWW的直和补子空间。 （8）若(α1 α2 ... αn)(\\alpha_1 \\; \\alpha_2 \\; ... \\; \\alpha_n)(α1​α2​...αn​)是线性空间Vn(F)V_n(F)Vn​(F)的一组基，则Vn(F)=L{α1,α2,..,αn}V_n(F) = L \\{\\alpha_1, \\alpha_2, .., \\alpha_n\\}Vn​(F)=L{α1​,α2​,..,αn​} 对一个矩阵A∈Fm×nA \\in F^{m \\times n}A∈Fm×n，可以得到两个与AAA相关的子空间： N(A)={X∣AX=0}⊆FnR(A)=L{A1,A2,...,An}⊆FmN(A) = \\{X |AX=0 \\} \\subseteq F^n\\\\R(A) = L\\{A_1, A_2, ...,A_n \\} \\subseteq F^mN(A)={X∣AX=0}⊆FnR(A)=L{A1​,A2​,...,An​}⊆Fm 其中N(A)N(A)N(A)称为矩阵AAA的零空间，R(A)R(A)R(A)称为矩阵AAA的列空间 （9）内积： 欧氏空间的内积：(α,β)=αTβ;(A,B)=tr(ABT)(\\alpha, \\beta) = \\alpha^T \\beta ; \\quad (A, B) = tr(AB^T)(α,β)=αTβ;(A,B)=tr(ABT) 酉空间的内积：(α,β)=βHα;(A,B)=tr(BHA)(\\alpha, \\beta) = \\beta^H \\alpha ; \\quad (A, B) = tr(B^HA)(α,β)=βHα;(A,B)=tr(BHA) 📌柯西不等式：∣(α,β)∣2⩽(α,α)(β,β)|(\\alpha, \\beta)|^2 \\leqslant (\\alpha, \\alpha)(\\beta, \\beta)∣(α,β)∣2⩽(α,α)(β,β) 正交补子空间**：设**​UUU为内积空间Vn(F)V_n(F)Vn​(F)的一个子空间，定义Vn(F)V_n(F)Vn​(F)上的一个子集U⊥={α ∣ α∈Vn(F), ∀β∈U, (α,β)=0}U^{\\perp} = \\{\\alpha \\;| \\;\\alpha \\in V_n(F), \\; \\forall \\beta \\in U, \\; (\\alpha, \\beta)=0 \\}U⊥={α∣α∈Vn​(F),∀β∈U,(α,β)=0}称为UUU的正交补子空间，有Vn(F)=U⊕U⊥V_n(F) = U \\oplus U^{\\perp}Vn​(F)=U⊕U⊥。 （10）设TTT是线性空间Vn(F)V_n(F)Vn​(F)上的线性变换，则满足T(k1α1+k2α2)=k1T(α1)+k2T(α2)T(k_1 \\alpha_1 + k_2 \\alpha_2) = k_1 T(\\alpha_1) + k_2 T(\\alpha_2)T(k1​α1​+k2​α2​)=k1​T(α1​)+k2​T(α2​)，则有： 像空间**：** ​R(T)={β∣ ∃α∈Vn(F),s.t. β=T(α)}R(T) = \\{\\beta | \\; \\exists \\alpha \\in V_n(F), s.t. \\; \\beta = T(\\alpha)\\}R(T)={β∣∃α∈Vn​(F),s.t.β=T(α)}是Vn(F)V_n(F)Vn​(F)上的子空间，称为TTT的像空间；dim⁡R(T)\\dim R(T)dimR(T)称为TTT的秩。 零空间**：** ​N(T)={α∣ T(α)=0}N(T) = \\{\\alpha |\\; T(\\alpha) = 0\\}N(T)={α∣T(α)=0}是Vn(F)V_n(F)Vn​(F)上的子空间，称为TTT的零空间；dim⁡N(T)\\dim N(T)dimN(T)称为TTT的零度。 （11）设TTT为Vn(F)V_n(F)Vn​(F)上的线性变换，{α1,α2,...,αn}\\{\\alpha_1, \\alpha_2, ..., \\alpha_n\\}{α1​,α2​,...,αn​}是Vn(F)V_n(F)Vn​(F)的基，若存在nnn阶方阵AAA，有： T(α1 α2 ... αn)=(α1 α2 ... αn)AT(\\alpha_1 \\; \\alpha_2 \\; ... \\; \\alpha_n) = (\\alpha_1 \\; \\alpha_2 \\; ... \\; \\alpha_n)A T(α1​α2​...αn​)=(α1​α2​...αn​)A 称AAA为TTT在基{α1,α2,...,αn}\\{\\alpha_1, \\alpha_2, ..., \\alpha_n\\}{α1​,α2​,...,αn​}下的矩阵。 设α\\alphaα与T(α)T(\\alpha)T(α)在基{α1,α2,...,αn}\\{\\alpha_1, \\alpha_2, ... , \\alpha_n\\}{α1​,α2​,...,αn​}下的坐标分别是XXX与YYY，则有：Y=AX{\\color {red}{ Y = AX}}Y=AX。 设{α1,α2,...,αn}\\{\\alpha_1, \\alpha_2, ... , \\alpha_n\\}{α1​,α2​,...,αn​}和{β1,β2,...,βn}\\{\\beta_1, \\beta_2, ... , \\beta_n\\}{β1​,β2​,...,βn​}是Vn(F)V_n(F)Vn​(F)的两组基，且有(β1 β2 ... βn)=(α1 α2 ... αn)C(\\beta_1 \\; \\beta_2 \\; ... \\; \\beta_n) = (\\alpha_1 \\; \\alpha_2 \\; ... \\; \\alpha_n)C(β1​β2​...βn​)=(α1​α2​...αn​)C；TTT在两组基下的变换矩阵分别是AAA与BBB，则B=C−1AC{\\color{red} {B=C^{-1}AC}}B=C−1AC。 📌如何对矩阵做线性变换？ E11=[1000] E12=[0100] E21=[0010] E22=[0001]E_{11}=\\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; 0 \\end{bmatrix}\\ E_{12}=\\begin{bmatrix} 0 &amp; 1 \\\\ 0 &amp; 0 \\end{bmatrix}\\ E_{21}=\\begin{bmatrix} 0 &amp; 0 \\\\ 1 &amp; 0 \\end{bmatrix}\\ E_{22}=\\begin{bmatrix} 0 &amp; 0 \\\\ 0 &amp; 1 \\end{bmatrix}E11​=[10​00​] E12​=[00​10​] E21​=[01​00​] E22​=[00​01​]是R2×2R^{2\\times2}R2×2的基，那么线性变换对应的矩阵为4×44\\times44×4，每一列对应着对{E11,E12,E21,E22}\\{E_{11},E_{12},E_{21},E_{22}\\}{E11​,E12​,E21​,E22​}相应基进行的变换。 📌如T(E11)=−bE12+cE21T(E12)=−cE11+(a−d)E12+cE22T(E21)=bE11+(d−a)E21−bE22T(E22)=bE12−cE21T(E_{11})=-bE_{12}+cE_{21}\\\\ T(E_{12})=-cE_{11}+(a-d)E_{12}+cE_{22}\\\\ T(E_{21})=bE_{11}+(d-a)E_{21}-bE_{22}\\\\ T(E_{22})=bE_{12}-cE_{21}T(E11​)=−bE12​+cE21​T(E12​)=−cE11​+(a−d)E12​+cE22​T(E21​)=bE11​+(d−a)E21​−bE22​T(E22​)=bE12​−cE21​ 📌则T在基E11,E12,E21,E22E_{11},E_{12},E_{21},E_{22}E11​,E12​,E21​,E22​下的矩阵为 [0−cb0−ba−d0bc0d−a−c0c−b0]\\begin{bmatrix} 0 &amp; -c &amp; b &amp; 0 \\\\ -b &amp; a-d &amp; 0 &amp; b\\\\c &amp; 0 &amp; d-a &amp; -c\\\\0 &amp; c &amp; -b &amp; 0 \\end{bmatrix}⎣⎢⎢⎢⎡​0−bc0​−ca−d0c​b0d−a−b​0b−c0​⎦⎥⎥⎥⎤​ （12）设TTT是线性空间Vn(F)V_n(F)Vn​(F)上的线性变换，WWW是Vn(F)V_n(F)Vn​(F)的子空间，如果∀α∈W, T(α)∈W\\forall \\alpha \\in W, \\; T(\\alpha) \\in W∀α∈W,T(α)∈W，即值域T(W)⊆WT(W) \\subseteq WT(W)⊆W，则称WWW是TTT的不变子空间。 📌重要例题 设TTT是欧式空间R3R^3R3上的线性变换，对R3R^3R3中单位矢量uuu，∀x∈R3\\forall x \\in R^3∀x∈R3，T(x)=x−(1−k)(x,u)uT(x) = x - (1-k)(x,u)uT(x)=x−(1−k)(x,u)u，问：T的不变子空间的直和分解以及相应的矩阵分解。 📌答：对向量uuu有T(u)=u−(1−k)(u,u)u=u−(1−k)u=kuT(u) = u - (1-k)(u,u)u= u - (1-k)u = kuT(u)=u−(1−k)(u,u)u=u−(1−k)u=ku 所以以uuu为基向量的空间是不变子空间，表示为L{u}L\\{u\\}L{u}； 同理，对于uuu的正交补子空间u⊥u^{\\perp}u⊥，对于任意向量X∈u⊥X \\in u^{\\perp}X∈u⊥，有 T(X)=X−(1−k)(X,u)u=X−0=XT(X) = X - (1-k)(X,u)u = X-0=XT(X)=X−(1−k)(X,u)u=X−0=X 于是另一个不变子空间为u⊥u^{\\perp}u⊥；即R3=L{u}⊕u⊥R^3 = L\\{u\\} \\oplus u^{\\perp}R3=L{u}⊕u⊥。 显然有L{u}L\\{u\\}L{u}是一维空间，特征值kkk对应的特征向量是u1=uu_1 = uu1​=u；那么u⊥u^{\\perp}u⊥就是二维空间，特征值111对应两个线性无关的特征向量，可以找到两个单位正交特征向量u2,u3u_2, u_3u2​,u3​，所以相应的矩阵分解为[k11]\\begin{bmatrix}k &amp; &amp; \\\\ &amp; 1 &amp; \\\\ &amp; &amp; 1\\end{bmatrix}⎣⎢⎡​k​1​1​⎦⎥⎤​，对应的特征向量组 {u1,u2,u3}\\{u_1,u_2,u_3\\}{u1​,u2​,u3​}为标准正交基。 （13）正交变换（酉变换）：线性变换TTT不改变向量内积，即(T(α),T(β))=(α,β)(T(\\alpha), T(\\beta)) = (\\alpha, \\beta)(T(α),T(β))=(α,β)。 正交变换TTT关于任一标准正交基的矩阵CCC满足CTC=CCT=IC^TC = CC^T=ICTC=CCT=I；酉变换关于任一标准正交基的矩阵UUU满足UHU=UUH=IU^HU=UU^H=IUHU=UUH=I。 正交矩阵的行列式为±1\\pm 1±1；酉矩阵的行列式的模长为111。 （14）常见的正交变换 R2R^2R2上绕原点逆时针旋转θ\\thetaθ角的线性变换TθT_{\\theta}Tθ​称为_正交变换_，在标准正交基下对应的变换矩阵[cos⁡θ−sin⁡θsin⁡θcos⁡θ]\\begin{bmatrix} \\cos \\theta &amp; - \\sin \\theta \\\\ \\sin \\theta &amp; \\cos \\theta \\end{bmatrix}[cosθsinθ​−sinθcosθ​]是正交矩阵。 空间R3R^3R3上绕过原点的直线lll旋转θ\\thetaθ角的变化TLθT_{L_{\\theta}}TLθ​​为_正交变换_，在标准正交基下对应的变换矩阵[1cos⁡θ−sin⁡θsin⁡θcos⁡θ]\\begin{bmatrix}1 &amp; &amp; \\\\ &amp; \\cos \\theta &amp; -\\sin \\theta \\\\ &amp; \\sin \\theta &amp; \\cos \\theta \\end{bmatrix}⎣⎢⎡​1​cosθsinθ​−sinθcosθ​⎦⎥⎤​是正交矩阵。 2 Jordan标准型 （1）若有T(ξ)=λξT(\\xi) = \\lambda \\xiT(ξ)=λξ，称λ\\lambdaλ为TTT的特征值，ξ\\xiξ为TTT的特征向量。如果AAA是线性变换TTT对应的矩阵，那么，λ\\lambdaλ和ξ\\xiξ也是AAA的特征值和特征向量。 （2）设λ1,λ2,...,λs\\lambda_1, \\lambda_2, ..., \\lambda_sλ1​,λ2​,...,λs​是Vn(F)V_n(F)Vn​(F)上线性变换TTT的sss个互异特征值，VλiV_{\\lambda_i}Vλi​​是λi\\lambda_iλi​的特征子空间，其中i=1,2,...,si=1,2,...,si=1,2,...,s，则： VλiV_{\\lambda_i}Vλi​​是TTT的不变子空间； λi≠λj\\lambda_i \\neq \\lambda_jλi​=λj​时，Vλi∩Vλj=0V_{\\lambda_i} \\cap V_{\\lambda_j} = {0}Vλi​​∩Vλj​​=0； 若λi\\lambda_iλi​是kik_iki​重（代数重数）的，dim⁡Vλi\\dim V_{\\lambda_i}dimVλi​​是_几何重数_，则有dim⁡Vλi⩽ki\\dim V_{\\lambda_i} \\leqslant k_idimVλi​​⩽ki​。 （3）线性变换TTT有对角矩阵表示的充分必要条件是 TTT有nnn个线性无关的特征向量。 幂等矩阵**：A2=AA^2 = AA2=A，AAA相似于对角矩阵[Ir0]\\begin{bmatrix} I_r&amp; \\\\ &amp; 0\\end{bmatrix}[Ir​​0​]，其中**rrr为矩阵AAA的秩。 乘方矩阵**：A2=IA^2 = IA2=I，AAA相似于对角阵[IsIt]\\begin{bmatrix}I_s &amp; \\\\ &amp; I_t\\end{bmatrix}[Is​​It​​]，其中**s+t=ns+t=ns+t=n。 （4）关于秩的不等式： rank(A±B)⩽rank(A)+rank(B)rank(A \\pm B) \\leqslant rank(A) + rank(B)rank(A±B)⩽rank(A)+rank(B) rank(A)+rank(B)−n⩽rank(Am×nBn×m)⩽min⁡(r(A),r(B))rank(A) + rank(B) -n \\leqslant rank(A_{m \\times n}B_{n \\times m}) \\leqslant \\min(r(A), r(B))rank(A)+rank(B)−n⩽rank(Am×n​Bn×m​)⩽min(r(A),r(B)) if Am×nBn×m=0,rank(A)+rank(B)⩽nif \\;A_{m \\times n}B_{n \\times m}=0, \\quad rank(A) + rank(B) \\leqslant nifAm×n​Bn×m​=0,rank(A)+rank(B)⩽n （5）形如J(λ)=[λ1λ1...1λ]J(\\lambda) = \\begin{bmatrix}\\lambda &amp; 1 &amp; &amp; \\\\ &amp; \\lambda &amp; 1 &amp; \\\\ &amp; &amp; ... &amp; 1\\\\ &amp; &amp; &amp; \\lambda\\end{bmatrix}J(λ)=⎣⎢⎢⎢⎡​λ​1λ​1...​1λ​⎦⎥⎥⎥⎤​，称为Jordan块。Jordan块呈上三角，主对角线是它的全部特征值，特点是主对角线上元素相等，紧邻上方元素ai,i+1=1a_{i,i+1} = 1ai,i+1​=1，其余元素为0。 （6）每个nnn阶方阵AAA都相似于一个Jordan矩阵，即存在可逆矩阵PPP，有： P−1AP=JA=[J1(λ1) J2(λ2) ... Js(λs)]P^{-1}AP = J_A = \\begin{bmatrix}J_1(\\lambda_1) &amp; &amp; &amp; \\\\ &amp; J_2(\\lambda_2) &amp; &amp; \\\\ &amp; &amp; ... &amp; \\\\ &amp; &amp; &amp; J_s(\\lambda_s)\\end{bmatrix}P−1AP=JA​=⎣⎢⎢⎢⎡​J1​(λ1​) ​ J2​(λ2​) ​ ... ​Js​(λs​)​⎦⎥⎥⎥⎤​ 其中JAJ_AJA​称为Jordan标准形。 （7）Jordan标准形的求法： 求矩阵AAA的特征多项式∣λI−A∣=(λ−λ1)k1(λ−λ2)k2...(λ−λs)ks|\\lambda I-A| = (\\lambda - \\lambda_1)^{k_1}(\\lambda-\\lambda_2)^{k_2}...(\\lambda - \\lambda_s)^{k_s}∣λI−A∣=(λ−λ1​)k1​(λ−λ2​)k2​...(λ−λs​)ks​，其中kik_iki​是特征值λi\\lambda_iλi​的代数重数，决定了对角线上特征值λi\\lambda_iλi​的个数； 对λi\\lambda_iλi​，由(A−λiI)X=0(A-\\lambda_i I)X=0(A−λi​I)X=0，求AAA的线性无关的特征向量α1,α2,...,αti\\alpha_1,\\alpha_2, ...,\\alpha_{t_i}α1​,α2​,...,αti​​，其中tit_iti​是特征值λi\\lambda_iλi​的几何重数，决定了Jordan块的个数； 如果ki=tik_i = t_iki​=ti​，即代数重数等于几何重数，说明λi\\lambda_iλi​对应的Jordan块是对角阵； 如果ti&lt;kit_i &lt; k_iti​&lt;ki​，就选择合适的特征向量αj\\alpha_jαj​，利用∣A−λiI∣=αj{\\color{red} {|A-\\lambda_i I| = \\alpha_j}}∣A−λi​I∣=αj​求Jordan链，确定每一个小Jordan块的阶数。 将所有特征值λi\\lambda_iλi​对应的Jordan块组合起来，形成Jordan矩阵JAJ_AJA​。 （8）矩阵多项式可以表示为g(A)=amAm+am−1Am−1+...+a1A+a0Ig(A) = a_m A^m + a_{m-1}A^{m-1}+...+a_1A +a_0 Ig(A)=am​Am+am−1​Am−1+...+a1​A+a0​I ，由于有A=PJAP−1A = P J_AP^{-1}A=PJA​P−1，所以有： g(A)=P[g(J1(λ1)) g(J2(λ2)) ... g(Js(λs)) ]P−1g(A) = P \\begin{bmatrix}g(J_1(\\lambda_1)) &amp; &amp; &amp; \\\\ &amp; g(J_2(\\lambda_2)) &amp; &amp; \\\\ &amp; &amp; ... &amp; \\\\ &amp; &amp; &amp; g(J_s(\\lambda_s)) \\end{bmatrix} P^{-1}g(A)=P⎣⎢⎢⎢⎡​g(J1​(λ1​)) ​ g(J2​(λ2​)) ​ ... ​g(Js​(λs​)) ​⎦⎥⎥⎥⎤​P−1 而对于g(J(λ))g(J(\\lambda))g(J(λ))则有： g(J(λ))=[g(λ)g′(λ)...g(r−1)(λ)(r−1)! g(λ).... .... g(λ)]g(J(\\lambda)) = \\begin{bmatrix}g(\\lambda) &amp; g&#x27;(\\lambda) &amp; ... &amp; \\frac{g^{(r-1)}(\\lambda)}{(r-1)!} \\\\ &amp; g(\\lambda) &amp; ... &amp; .\\\\ &amp; &amp; ... &amp; .\\\\ &amp; &amp; &amp; g(\\lambda)\\end{bmatrix}g(J(λ))=⎣⎢⎢⎢⎡​g(λ) ​g′(λ)g(λ) ​......... ​(r−1)!g(r−1)(λ)​..g(λ)​⎦⎥⎥⎥⎤​ 对于常用的幂指数形式有 Jk(λ)=[λk(λk)′1!(λk)′′2!... λk.... .... λk]J^k(\\lambda) = \\begin{bmatrix}\\lambda^k &amp; \\frac{(\\lambda^k)&#x27;}{1!} &amp; \\frac{(\\lambda^k)&#x27;&#x27;}{2!} &amp;... \\\\ &amp; \\lambda^k&amp; ... &amp; .\\\\ &amp; &amp; ... &amp; .\\\\ &amp; &amp; &amp; \\lambda^k\\end{bmatrix}Jk(λ)=⎣⎢⎢⎢⎡​λk ​1!(λk)′​ λk ​2!(λk)′′​...... ​..... λk​⎦⎥⎥⎥⎤​ （9）使g(A)=0g(A)=0g(A)=0的多项式g(λ)g(\\lambda)g(λ)称为AAA的化零多项式，特征多项式必是矩阵AAA的化零多项式。 📌注：化零多项式的根一定包含了所有的特征值，但不能说化零多项式的根一定是特征值。 （10）对于最小多项式 mT(λ)m_T(\\lambda)mT​(λ)最高项系数为1； mT(λ)m_T(\\lambda)mT​(λ)是TTT的一个化零多项式； mT(λ)m_T(\\lambda)mT​(λ)是化零多项式中次数最低的那一个。 最小多项式mT(λ)m_T(\\lambda)mT​(λ)的根一定包含了所有的特征值λi\\lambda_iλi​，子式(λ−λi)ri(\\lambda-\\lambda_i)^{r_i}(λ−λi​)ri​的幂rir_iri​等于Jordan标准形中关于特征值λi\\lambda_iλi​的Jordan块中的最高阶数。 📌比如矩阵AAA有一个代数重数为3的特征值2，该特征值对应两个Jordan块，分别是 [212]\\begin{bmatrix}2 &amp; 1 \\\\ &amp; 2 \\end{bmatrix}[2​12​]以及[2][2][2]， 说明其中其最高阶数为2，那么在最小多项式中对应的子式为(λ−2)2(\\lambda -2)^2(λ−2)2。 📌线性变换可以对角化的充要条件是其最小多项式是一次因子的乘积 （11）线性变换与Jordan标准型的结合 线性变换在原基的变换矩阵不是对角矩阵，如何求得新基，使得在新基下的变换矩阵是对角矩阵 线性变换在原基的变换矩阵不是Jordan标准型，如何求得新基，使得在新基下的变换矩阵是Jordan标准型 对原基下的变换矩阵求相似对角化，得到的特征向量组成的矩阵P右乘原基，即是可使变换矩阵成为对角阵的新基 对原基下的变换矩阵求相似的Jordan标准型PΛP−1P\\Lambda P^{-1}PΛP−1，用PPP右乘原基，即是可使变换矩阵成为Jordan标准型的新基 📌左式在书上定义2.1处有证明，即 T(ξ)=λξT(\\xi)=\\lambda\\xiT(ξ)=λξ ξ=(α1,α2…αn)X\\xi=(\\alpha_1,\\alpha_2…\\alpha_n)\\bold Xξ=(α1​,α2​…αn​)XT(ξ)=(α1,α2…αn)AX→AX=λXT(\\xi)=(\\alpha1,\\alpha_2…\\alpha_n) A\\bold{X}\\rightarrow A\\bold X=\\lambda\\bold XT(ξ)=(α1,α2​…αn​)AX→AX=λX 这说明λ\\lambdaλ是矩阵A的特征值，X\\bold XX是矩阵A关于λ\\lambdaλ的特征向量 3 矩阵分解 （1）等价标准形 对于A∈Cm×nA \\in C^{m \\times n}A∈Cm×n，存在可逆矩阵P∈Cm×m,Q∈Cn×nP \\in C^{m \\times m}, Q \\in C^{n \\times n}P∈Cm×m,Q∈Cn×n，使得 A=P[Ir0 00]QA = P \\begin{bmatrix}I_r &amp; 0 \\\\ 0 &amp; 0\\end{bmatrix}Q A=P[Ir​ 0​0 0​]Q 其中rrr是矩阵AAA的秩。 （2）相似标准形 存在可逆矩阵P∈Cn×nP \\in C^{ n \\times n}P∈Cn×n，有 A=P[λ1 λ2 ... λn]P−1A = P \\begin{bmatrix}\\lambda_1 &amp; &amp; &amp; \\\\ &amp; \\lambda_2 &amp; &amp; \\\\ &amp; &amp; ... &amp; \\\\ &amp; &amp; &amp; \\lambda_n\\end{bmatrix} P^{-1} A=P⎣⎢⎢⎢⎡​λ1​ ​ λ2​ ​ ... ​λn​​⎦⎥⎥⎥⎤​P−1 （3）LU分解 定义：LLL是下三角矩阵，UUU是上三角矩阵，A=LUA=LUA=LU。 📌存在条件：A的秩为r，前r阶顺序主子式不为0，则存在LU分解 求法： 对于(A ∣ In)(A \\;|\\; I_n)(A∣In​)，只用第iii行乘数kkk加到第jjj行（i&lt;ji &lt; ji&lt;j）型初等变换将AAA化为上三角形UUU，可以得到(U ∣ P){\\color{red} (U \\; |\\; P)}(U∣P)； 可知PA=UPA=UPA=U，于是有L=P−1L=P^{-1}L=P−1，则A=LUA=LUA=LU。 （4）LDV分解 定义：L,VL, VL,V分别是对角线元素为1的下三角矩阵和上三角矩阵，DDD为对角矩阵，A=LDVA=LDVA=LDV。 求法： 方法一： 由LU分解得到A=LUA = LUA=LU； 通过每行除以对应的对角线上元素的值，将UUU的对角线元素化为1，得到U=D1VU=D_1VU=D1​V； 通过每列除以对应的对角线上元素的值，将LLL的对角线元素化为1，得到L=LrealD2L=L_{real}D_2L=Lreal​D2​ 有A=LrealD2D1V=LDVA=L_{real}D_2D_1V=LDVA=Lreal​D2​D1​V=LDV。 方法二： 取矩阵AAA对角线第一个元素，得到矩阵A1=[a11]A_1=[a_{11}]A1​=[a11​]，则有A1=L1D1V1=[1][a11][1]A_1 = L_1D_1V_1 = [1][a_{11}][1]A1​=L1​D1​V1​=[1][a11​][1]； 取包含对角线前两个元素的二阶矩阵A2=[A1αβa22]A_2 = \\begin{bmatrix}A_1 &amp; \\alpha\\\\ \\beta &amp; a_{22}\\end{bmatrix}A2​=[A1​β​αa22​​]，则有矩阵A2=L2D2V2A_2 = L_2 D_2 V_2A2​=L2​D2​V2​，其中L2=[L10x1]L_2 = \\begin{bmatrix}L_1 &amp; 0\\\\ x &amp; 1\\end{bmatrix}L2​=[L1​x​01​]，D2=[D100d2]D_2 = \\begin{bmatrix}D_1 &amp; 0\\\\ 0 &amp; d_2\\end{bmatrix}D2​=[D1​0​0d2​​]，V2=[V1y01]V_2 = \\begin{bmatrix}V_1 &amp; y\\\\ 0 &amp; 1\\end{bmatrix}V2​=[V1​0​y1​]，求得未知量x,d2,yx, d_2, yx,d2​,y； 以此类推，最终得到A=LnDnVnA = L_n D_n V_nA=Ln​Dn​Vn​。 📌方法二即： An=[An−1τuTann]=[Ln−10lT1][Dn−100dn][Vn−1v01]A_n = \\begin{bmatrix}A_{n-1} &amp; \\tau\\\\ u^T &amp; a_{nn}\\end{bmatrix}=\\begin{bmatrix}L_{n-1} &amp; 0\\\\ l^T &amp; 1\\end{bmatrix}\\begin{bmatrix}D_{n-1} &amp; 0\\\\ 0 &amp; d_n\\end{bmatrix}\\begin{bmatrix}V_{n-1} &amp; v\\\\ 0 &amp; 1\\end{bmatrix}An​=[An−1​uT​τann​​]=[Ln−1​lT​01​][Dn−1​0​0dn​​][Vn−1​0​v1​] 迭代： An−1=Ln−1Dn−1Vn−1τn=Ln−1Dn−1vnunT=lnTDn−1Vn−1ann=lnTDnvn+dnA_{n-1}=L_{n-1}D_{n-1}V_{n-1}\\\\\\tau_n=L_{n-1}D_{n-1}v_n\\\\u_n^T=l_n^TD_{n-1}V_{n-1}\\\\a_{nn}=l_n^TD_nv_n+d_nAn−1​=Ln−1​Dn−1​Vn−1​τn​=Ln−1​Dn−1​vn​unT​=lnT​Dn−1​Vn−1​ann​=lnT​Dn​vn​+dn​ 📌有LU分解不一定有LDV分解，LU的对角线可以是0，而LDV对角线只能是1 （5）满秩分解 定义：对于rank(A)=rrank(A)=rrank(A)=r的矩阵AAA，若存在秩为rrr的矩阵B∈Fm×r, C∈Fr×nB \\in F^{m \\times r}, \\; C \\in F^{r \\times n}B∈Fm×r,C∈Fr×n，有A=BCA=BCA=BC，称为矩阵AAA的满秩分解。 📌任何非零矩阵，都存在满秩分解 求法：方法较多，一般只用最简单的第3种。 用行初等变换把AAA化为Hermite标准形； 依Hermite标准形中向量eie_iei​所在的列的位置第jij_iji​列，相应地取出AAA的第jij_iji​列ajia_{ji}aji​，得到 AAA的列向量极大无关组{aj1,aj2,...,ajr}\\{a_{j_1}, a_{j_2}, ..., a_{j_r}\\}{aj1​​,aj2​​,...,ajr​​}，B=(aj1,aj2,...,ajr)B =(a_{j_1}, a_{j_2}, ..., a_{j_r})B=(aj1​​,aj2​​,...,ajr​​); AAA的Hermite矩阵中的非零行构成矩阵CCC，得到满秩分解A=BCA=BCA=BC。 📌求矩阵A=[112022101]A=\\begin{bmatrix}1 &amp; 1 &amp; 2\\\\ 0 &amp; 2 &amp; 2\\\\ 1 &amp; 0 &amp; 1\\end{bmatrix}A=⎣⎢⎡​101​120​221​⎦⎥⎤​的满秩分解。 答： 用行初等变换化AAA为Hermite标准形： A=[112022101]→[1120220−1−1]→[101011000]A = \\begin{bmatrix}1 &amp; 1 &amp; 2\\\\ 0 &amp; 2 &amp; 2\\\\ 1 &amp; 0 &amp; 1\\end{bmatrix} \\rightarrow \\begin{bmatrix}1 &amp; 1 &amp; 2\\\\ 0 &amp; 2 &amp; 2\\\\ 0 &amp; -1 &amp; -1\\end{bmatrix} \\rightarrow \\begin{bmatrix}1 &amp; 0 &amp; 1\\\\ 0 &amp; 1 &amp; 1\\\\ 0 &amp;0 &amp;0 \\end{bmatrix}A=⎣⎢⎡​101​120​221​⎦⎥⎤​→⎣⎢⎡​100​12−1​22−1​⎦⎥⎤​→⎣⎢⎡​100​010​110​⎦⎥⎤​ 可知rank(A)=2rank(A)=2rank(A)=2，AAA的前两列线性无关，取出构成BBB；取出AAA的Hermite标准形的前两行作为CCC，有B=[110210],C=[101011],A=BCB = \\begin{bmatrix} 1&amp;1 \\\\ 0&amp;2 \\\\ 1&amp;0 \\end{bmatrix}, C = \\begin{bmatrix}1 &amp; 0 &amp; 1\\\\ 0 &amp; 1 &amp; 1\\end{bmatrix}, A=BCB=⎣⎢⎡​101​120​⎦⎥⎤​,C=[10​01​11​],A=BC （6）谱分解 定义：矩阵AAA互异的特征值{λ1,λ2,...,λs}\\{\\lambda_1, \\lambda_2, ..., \\lambda_s\\}{λ1​,λ2​,...,λs​}称为矩阵AAA的谱。可相似对角化是可以谱分解的充要条件。 求法： 通过求特征值和特征向量得到 A=P[λ1...λ1λ2...λ2...λs...λs]P−1A = P\\begin{bmatrix}\\lambda_1 &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; \\\\ &amp; ... &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; \\\\ &amp; &amp; \\lambda_1 &amp; &amp; &amp; &amp; &amp; &amp; &amp; \\\\ &amp; &amp; &amp; \\lambda_2&amp; &amp; &amp; &amp; &amp; &amp; \\\\ &amp; &amp; &amp; &amp; ... &amp; &amp; &amp; &amp; &amp; \\\\ &amp; &amp; &amp; &amp; &amp; \\lambda_2 &amp; &amp; &amp; &amp; \\\\ &amp; &amp; &amp; &amp; &amp; &amp; ... &amp; &amp; &amp; \\\\ &amp; &amp; &amp; &amp; &amp; &amp; &amp; \\lambda_s &amp; &amp; \\\\ &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; ... &amp; \\\\ &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; \\lambda_s\\end{bmatrix} P^{-1}A=P⎣⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎡​λ1​​...​λ1​​λ2​​...​λ2​​...​λs​​...​λs​​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎤​P−1； 对角阵Λ=λ1[Ir10...0]+λ2[0Ir200]+...+λs[000Irs]\\Lambda = \\lambda_1 \\begin{bmatrix}I_{r_1} &amp; &amp; &amp; \\\\ &amp; 0 &amp; &amp; \\\\ &amp; &amp; ... &amp; \\\\ &amp; &amp; &amp; 0\\end{bmatrix} + \\lambda_2\\begin{bmatrix}0 &amp; &amp; &amp; \\\\ &amp; I_{r_2} &amp; &amp; \\\\ &amp; &amp; 0 &amp; \\\\ &amp; &amp; &amp; 0\\end{bmatrix} + ... + \\lambda_s\\begin{bmatrix}0 &amp; &amp; &amp; \\\\ &amp; 0 &amp; &amp; \\\\ &amp; &amp; 0 &amp; \\\\ &amp; &amp; &amp; I_{r_s}\\end{bmatrix}Λ=λ1​⎣⎢⎢⎢⎡​Ir1​​​0​...​0​⎦⎥⎥⎥⎤​+λ2​⎣⎢⎢⎢⎡​0​Ir2​​​0​0​⎦⎥⎥⎥⎤​+...+λs​⎣⎢⎢⎢⎡​0​0​0​Irs​​​⎦⎥⎥⎥⎤​，令Qi=[0...Iri...]Q_i = \\begin{bmatrix}0 &amp; &amp; &amp; \\\\ &amp;... &amp; &amp; \\\\ &amp; &amp; I_{r_i} &amp; \\\\ &amp; &amp; &amp; ...\\end{bmatrix}Qi​=⎣⎢⎢⎢⎡​0​...​Iri​​​...​⎦⎥⎥⎥⎤​； 得到A=∑i=1sλiPiA = \\sum_{i=1}^s \\lambda_i P_iA=∑i=1s​λi​Pi​，其中Pi=PQiP−1P_i = P Q_i P^{-1}Pi​=PQi​P−1。 （7）Schur分解 UR分解：对可逆矩阵AAA，存在酉矩阵UUU和主对角线上元素都为正的上三角矩阵RRR，使A=URA=URA=UR。 Schur分解：设A∈Cn×nA\\in C^{n\\times n}A∈Cn×n，则存在酉矩阵UUU和上三角矩阵TTT，使得 UHAU=T=[λ1t12...t1nλ2...t2n...λn]U^HAU=T=\\begin{bmatrix}\\lambda_1&amp;t_{12} &amp;... &amp;t_{1n} \\\\ &amp;\\lambda_2 &amp;... &amp;t_{2n} \\\\ &amp; &amp; ... &amp; \\\\ &amp; &amp; &amp; \\lambda_n\\end{bmatrix}UHAU=T=⎣⎢⎢⎢⎡​λ1​​t12​λ2​​.........​t1n​t2n​λn​​⎦⎥⎥⎥⎤​ 其中λi\\lambda_iλi​是矩阵AAA的特征值，i=1,2,...,ni=1,2,...,ni=1,2,...,n UR分解**求法： 取矩阵A=(A1,A2,...,An)A = (A_1, A_2, ..., A_n)A=(A1​,A2​,...,An​)的列向量，进行施密特正交化，得到u1,u2,...,unu_1,u_2, ...,u_nu1​,u2​,...,un​，有U=(u1,u2,...,un)U=(u_1,u_2,...,u_n)U=(u1​,u2​,...,un​)； 再由R=UHAR = U^H AR=UHA得到RRR，于是A=URA=URA=UR。 📌施密特正交化方法： 设α1,α2,...,ar(r≤n)\\alpha_1,\\alpha_2,...,a_r(r\\le n)α1​,α2​,...,ar​(r≤n)是线性无关的向量组，则通过以下方法 β1=α1β2=α2−(α2,β1)(β1,β1)β1......βk=αk−∑i=1k−1(αk,βi)(βi,βi)βik=3,4,...,r\\beta_1=\\alpha_1\\\\\\beta_2=\\alpha_2-\\frac{(\\alpha_2,\\beta_1)}{(\\beta_1,\\beta_1)}\\beta_1\\\\......\\\\\\beta_k=\\alpha_k-\\sum_{i=1}^{k-1}\\frac{(\\alpha_k,\\beta_i)}{(\\beta_i,\\beta_i)}\\beta_i\\\\k=3,4,...,rβ1​=α1​β2​=α2​−(β1​,β1​)(α2​,β1​)​β1​......βk​=αk​−∑i=1k−1​(βi​,βi​)(αk​,βi​)​βi​k=3,4,...,r 得到的向量组β1,β2,...,βr\\beta_1,\\beta_2,...,\\beta_rβ1​,β2​,...,βr​是正交向量组 Schur分解求法： AAA相似于Jordan标准型A=PJP−1A=PJP^{-1}A=PJP−1； 通过PPP的UR分解有P=URP=URP=UR，则A=PJP−1=URJR−1UHA=PJP^{-1}=URJR^{-1}U^HA=PJP−1=URJR−1UH； 令T=RJR−1T=RJR^{-1}T=RJR−1，则TTT是一个上三角形矩阵，即有UHAU=TU^HAU=TUHAU=T。 （8）几种特殊矩阵： 正规矩阵：AHA=AAHA^HA = AA^HAHA=AAH （正规矩阵酉相似于对角阵） 酉矩阵：AHA=AAH=IA^HA = AA^H=IAHA=AAH=I Hermite矩阵：AH=AA^H = AAH=A 📌对于正规矩阵，AAA和AHA^HAH的特征向量相等，更一般地，只要AB=BAAB=BAAB=BA且AAA和BBB都可相似对角化，那么A和B特征向量就相同。 证明： A=PΛ1P−1=P[λ1λ2...λn]P−1A=P\\Lambda_1 P^{-1}=P\\begin{bmatrix}\\lambda_1 &amp; \\\\ &amp; \\lambda_2\\\\ &amp; &amp; ...\\\\ &amp; &amp; &amp; \\lambda_n\\end{bmatrix}P^{-1}A=PΛ1​P−1=P⎣⎢⎢⎢⎡​λ1​​λ2​​...​λn​​⎦⎥⎥⎥⎤​P−1 则P−1APP−1BP=P−1ABP=P−1BAP=P−1BPP−1APP^{-1}APP^{-1}BP=P^{-1}ABP=P^{-1}BAP=P^{-1}BPP^{-1}APP−1APP−1BP=P−1ABP=P−1BAP=P−1BPP−1AP 即[λ1λ2...λn]P−1BP=P−1BP[λ1λ2...λn]\\begin{bmatrix}\\lambda_1&amp;&amp;&amp;\\\\&amp;\\lambda_2&amp;&amp;\\\\&amp;&amp;...&amp;\\\\&amp;&amp;&amp;\\lambda_n\\end{bmatrix}P^{-1}BP=P^{-1}BP\\begin{bmatrix}\\lambda_1&amp;&amp;&amp;\\\\&amp;\\lambda_2&amp;&amp;\\\\&amp;&amp;...&amp;\\\\&amp;&amp;&amp;\\lambda_n\\end{bmatrix}⎣⎢⎢⎢⎡​λ1​​λ2​​...​λn​​⎦⎥⎥⎥⎤​P−1BP=P−1BP⎣⎢⎢⎢⎡​λ1​​λ2​​...​λn​​⎦⎥⎥⎥⎤​ 所以P−1BP=[λ1−1λ2−1...λn−1]P−1BP[λ1λ2...λn]P^{-1}BP=\\begin{bmatrix}\\lambda_1^{-1}&amp;&amp;&amp;\\\\&amp;\\lambda_2^{-1}&amp;&amp;\\\\&amp;&amp;...&amp;\\\\&amp;&amp;&amp;\\lambda_n^{-1}\\end{bmatrix}P^{-1}BP\\begin{bmatrix}\\lambda_1&amp;&amp;&amp;\\\\&amp;\\lambda_2&amp;&amp;\\\\&amp;&amp;...&amp;\\\\&amp;&amp;&amp;\\lambda_n\\end{bmatrix}P−1BP=⎣⎢⎢⎢⎡​λ1−1​​λ2−1​​...​λn−1​​⎦⎥⎥⎥⎤​P−1BP⎣⎢⎢⎢⎡​λ1​​λ2​​...​λn​​⎦⎥⎥⎥⎤​ 也就是说P−1BPP^{-1}BPP−1BP的每个元素aij=aijλjλia_{ij}=a_{ij}\\frac{\\lambda_j}{\\lambda_i}aij​=aij​λi​λj​​，只有对角线元素是可以满足此条件的，所以P−1BPP^{-1}BPP−1BP是对角矩阵[k1k2...kn]\\begin{bmatrix}k_1&amp;&amp;&amp;\\\\&amp;k_2&amp;&amp;\\\\&amp;&amp;...&amp;\\\\&amp;&amp;&amp;k_n\\end{bmatrix}⎣⎢⎢⎢⎡​k1​​k2​​...​kn​​⎦⎥⎥⎥⎤​ ，k1,k2,...knk_1,k_2,...k_nk1​,k2​,...kn​也就是B的特征向量。 对于P=[α1,α2,...αn]P=[\\alpha_1,\\alpha_2,...\\alpha_n]P=[α1​,α2​,...αn​]的列向量αi\\alpha_iαi​，有Aαi=λiαi,Bαi=kiαiA\\alpha_i=\\lambda_i\\alpha_i,B\\alpha_i=k_i\\alpha_iAαi​=λi​αi​,Bαi​=ki​αi​，所以αi\\alpha_iαi​同时是A和B的特征向量。即A和B特征向量相同 （9）奇异值分解（SVD分解） 奇异值：对rank(A)=rrank(A)=rrank(A)=r的矩阵A，矩阵AHAA^HAAHA的非零特征值有λ1⩾λ2⩾...⩾λr&gt;0\\lambda_1 \\geqslant \\lambda_2 \\geqslant ... \\geqslant \\lambda_r &gt;0λ1​⩾λ2​⩾...⩾λr​&gt;0，则称正数σi=λi\\sigma_i = \\sqrt{\\lambda_i}σi​=λi​​为矩阵A的奇异值。 定义：对rank(A)=rrank(A)=rrank(A)=r的矩阵A∈Cm×nA \\in C^{m \\times n}A∈Cm×n，奇异值有σ1⩾σ2⩾...⩾σr&gt;0\\sigma_1 \\geqslant \\sigma_2 \\geqslant ... \\geqslant \\sigma_r &gt; 0σ1​⩾σ2​⩾...⩾σr​&gt;0，则存在酉矩阵U∈Cm×m, V∈Cn×nU \\in C^{m \\times m}, \\; V \\in C^{n \\times n}U∈Cm×m,V∈Cn×n，分块矩阵Σ=[Δ000]\\Sigma = \\begin{bmatrix}\\Delta &amp; 0\\\\ 0 &amp; 0\\end{bmatrix}Σ=[Δ0​00​]，有A=UΣVHA = U \\Sigma V^HA=UΣVH，其中Δ=[σ1σ2...σr]\\Delta = \\begin{bmatrix}\\sigma_1 &amp; &amp; &amp; \\\\ &amp; \\sigma_2 &amp; &amp; \\\\ &amp; &amp; ... &amp; \\\\ &amp; &amp; &amp; \\sigma_r\\end{bmatrix}Δ=⎣⎢⎢⎢⎡​σ1​​σ2​​...​σr​​⎦⎥⎥⎥⎤​。 求解：第一步和第三步要求非零特征值，而第二步无此要求 由特征多项式∣λI−AHA∣=0|\\lambda I - A^HA| = 0∣λI−AHA∣=0求得特征值λ1⩾λ2⩾..⩾λn\\lambda_1 \\geqslant \\lambda_2 \\geqslant .. \\geqslant \\lambda_nλ1​⩾λ2​⩾..⩾λn​，（务必按照从大到小排列）（奇异值矩阵中某奇异值个数等于特征值重数），以及每个特征值对应的特征向量α1,α2,...,αn\\alpha_1, \\alpha_2, ..., \\alpha_nα1​,α2​,...,αn​； 对特征向量进行施密特正交化和单位化（一般只需要单位化），得到单位正交向量组v1,v2,..,vnv_1, v_2, ..,v_nv1​,v2​,..,vn​，则V=(v1,v2,...,vn)V=(v_1, v_2, ...,v_n)V=(v1​,v2​,...,vn​)； 对于非零特征值λ1,...,λr\\lambda_1, ..., \\lambda_rλ1​,...,λr​对应奇异值σ1,...,σr\\sigma_1, ... , \\sigma_rσ1​,...,σr​，于是有ui=1σiAvi{\\color{red} {u_i = \\frac{1}{\\sigma_i}Av_i}}ui​=σi​1​Avi​，这样得到了rrr个列向量，剩余的设为β\\betaβ，通过正交的特性uiTβ=0u_i^T \\beta = 0uiT​β=0即可求得；（U的列向量也需要标准化） 于是得到A=UΣVHA=U \\Sigma V^HA=UΣVH 📌奇异值性质： (1) 求逆与共轭转置的可交换性： (AA−1)H=(A−1)HAH=I因此(A−1)H=(AH)−1(AA^{-1})^H=(A^{-1})^HA^H=I因此(A^{-1})^H=(A^H)^{-1}(AA−1)H=(A−1)HAH=I因此(A−1)H=(AH)−1 (2) rank(A)=rank(AHA)=rank(AAH)rank(A)=rank(A^HA)=rank(AA^H)rank(A)=rank(AHA)=rank(AAH) (3) AAHAA^HAAH与AHAA^HAAHA的非零特征值相等 (4) AAHAA^HAAH与AHAA^HAAHA都是半正定矩阵，A∈Cm×nA\\in C^{m\\times n}A∈Cm×n，当rank(A)=m或nrank(A)=m或nrank(A)=m或n时，二者分别正定 (5) AAA与A−1A^{-1}A−1的特征值互为倒数 Ax=λxA−1Ax=λA−1x1λx=A−1xAx=\\lambda x\\\\A^{-1}Ax=\\lambda A^{-1}x\\\\\\frac 1\\lambda x=A^{-1}xAx=λxA−1Ax=λA−1xλ1​x=A−1x （10）极分解（不考） 定义：对于rank(A)=rrank(A)=rrank(A)=r的矩阵A∈Cn×nA \\in C^{n \\times n}A∈Cn×n，可以被分解为A=PQA=PQA=PQ，其中PPP为半正定矩阵，QQQ为酉矩阵。 求法： 对AAA进行奇异值分解，得到A=UΣVHA=U \\Sigma V^HA=UΣVH; 可以得到A=(UΣUH)(UVH)A = (U \\Sigma U^H)(UV^H)A=(UΣUH)(UVH)，于是P=UΣUH, Q=UVHP=U \\Sigma U^H, \\; Q=UV^HP=UΣUH,Q=UVH，A=PQA=PQA=PQ。 4 矩阵广义逆 （1）设A∈Cm×n,B∈Cn×mA \\in C^{m \\times n}, B \\in C^{n \\times m}A∈Cm×n,B∈Cn×m，若有BA=InBA=I_nBA=In​，则称BBB是AAA的一个左逆。 📌等价条件： - AAA的零空间N(A)=0N(A)={0}N(A)=0 - m⩾n, rank(A)=nm \\geqslant n, \\; rank(A)= nm⩾n,rank(A)=n，即AAA是列满秩的 - AHAA^H AAHA可逆 （2）设A∈Cm×n,B∈Cn×mA \\in C^{m \\times n}, B \\in C^{n \\times m}A∈Cm×n,B∈Cn×m，若有AC=ImAC = I_mAC=Im​，则称CCC是AAA的一个右逆。 📌等价条件： - AAA的列空间R(A)=CmR(A)=C^mR(A)=Cm - m⩽n, rank(A)=mm \\leqslant n, \\; rank(A)=mm⩽n,rank(A)=m，即AAA是行满秩的 - AAHAA^HAAH可逆 （3）对于A∈Cm×n, G∈Cn×mA \\in C^{m \\times n}, \\; G \\in C^{n \\times m}A∈Cm×n,G∈Cn×m，有AGA=AAGA=AAGA=A，称GGG是AAA的一个减号广义逆。 求法： 对rank(A)=rrank(A)=rrank(A)=r的矩阵AAA，有矩阵[AImIn0]\\begin{bmatrix}A &amp; I_m\\\\ I_n &amp; 0 \\end{bmatrix}[AIn​​Im​0​]进行初等变换，对AAA行变换时ImI_mIm​保持同步，对AAA列变换时，InI_nIn​保持同步，将AAA化为最简形，得到[Ir0P00Q0]\\begin{bmatrix} I_r&amp; 0 &amp; P \\\\ 0 &amp; 0 &amp; \\\\ \\\\ Q &amp; &amp; 0 &amp; \\end{bmatrix}⎣⎢⎢⎢⎡​Ir​0Q​00​P0​​⎦⎥⎥⎥⎤​； 有G=Q[IrUVW]PG = Q\\begin{bmatrix}I_r &amp; U\\\\ V &amp; W\\end{bmatrix}PG=Q[Ir​V​UW​]P，其中U,V,WU,V,WU,V,W是满足固定阶次的任意矩阵。 （4）加号广义逆（M-P逆） 定义：对于矩阵A∈Cm×n, G∈Cn×mA \\in C^{m \\times n}, \\; G \\in C^{n \\times m}A∈Cm×n,G∈Cn×m，满足4条 - AGA=AAGA=AAGA=A - GAG=GGAG=GGAG=G - (AG)H=AG(AG)^H = AG(AG)H=AG - (GA)H=GA(GA)^H=GA(GA)H=GA 称GGG为AAA的M-P逆。 求法： 方法一： 对矩阵AAA进行满秩分解，得到A=BCA=BCA=BC; 则A+=CH(CCH)−1(BHB)−1BH\\color{red}{A^+ = C^H(CC^H)^{-1}(B^HB)^{-1}B^H}A+=CH(CCH)−1(BHB)−1BH，也就是等于C的右逆 x B的左逆。 方法二： 对矩阵AAA进行奇异值分解，得到A=U[Δ000]VHA = U \\begin{bmatrix}\\Delta &amp;0 \\\\ 0 &amp; 0\\end{bmatrix}V^HA=U[Δ0​00​]VH； 则A+=V[Δ−1000]UH\\color{red}{A^+ = V \\begin{bmatrix}\\Delta^{-1} &amp; 0\\\\ 0 &amp; 0\\end{bmatrix}U^H}A+=V[Δ−10​00​]UH。 📌性质 - rank(A)=rank(A+)rank(A) = rank(A^+)rank(A)=rank(A+) - rank(A+A)=rank(AA+)=rank(A)rank(A^+A) = rank(AA^+)=rank(A)rank(A+A)=rank(AA+)=rank(A) （5）投影变换 定义：Cn=L⊕M,x=y+z,y∈L,z∈MC^n = L \\oplus M, \\quad x=y+z, \\quad y \\in L, z \\in MCn=L⊕M,x=y+z,y∈L,z∈M，投影变换σ\\sigmaσ就是把CnC^nCn映射成子空间LLL，称σ\\sigmaσ是从CnC^nCn沿子空间MMM到子空间LLL的投影变换，在一组基下对应的矩阵称为投影矩阵，子空间LLL称为投影子空间。显然有，子空间LLL就是σ\\sigmaσ的像空间R(σ)R(\\sigma)R(σ)，MMM就是σ\\sigmaσ的核空间N(σ)N(\\sigma)N(σ)，于是Cn=R(σ)⊕N(σ)C^n = R(\\sigma) \\oplus N(\\sigma)Cn=R(σ)⊕N(σ)。 📌σ\\sigmaσ是投影变换的充要条件是σ\\sigmaσ关于某组基下的矩阵AAA是幂等矩阵，即A2=AA^2=AA2=A。 求法： 找出像空间LLL的一组基y1,y2,...,yry_1,y_2,...,y_ry1​,y2​,...,yr​，得到矩阵B=(y1 y2 ... yr)B = (y_1 \\; y_2 \\; ... \\; y_r)B=(y1​y2​...yr​)；找出MMM的一组基zr+1,....,znz_{r+1}, ...., z_nzr+1​,....,zn​，得到矩阵C=(zr+1 ... zn)C=(z_{r+1} \\; ... \\; z_n)C=(zr+1​...zn​)； 于是有投影矩阵A=(B∣0)(B∣C)−1\\color{red}{A = (B | 0)(B|C)^{-1}}A=(B∣0)(B∣C)−1。 （6）正交投影变换 定义：若Cn=R(σ)⊕N(σ)C^n = R(\\sigma) \\oplus N(\\sigma)Cn=R(σ)⊕N(σ)，R(σ)R(\\sigma)R(σ)的正交补空间是R(σ)⊥=N(σ)R(\\sigma)^{\\perp} = N(\\sigma)R(σ)⊥=N(σ)，称σ\\sigmaσ是正交投影变换，其在标准正交基下对应的矩阵称为正交投影矩阵。 正交投影变换：P(X)=X−(X,u)u\\color{red}P(X)=X-(X,u)uP(X)=X−(X,u)u，uuu便是零空间的基。 📌σ\\sigmaσ是正交投影变换的充要条件是AAA是幂等Hermite矩阵，即A2=A, AH=AA^2=A, \\;A^H=AA2=A,AH=A。 求法： A=(B∣0)(B∣C)−1=(B∣0)((B∣C)H(B∣C))−1(B∣C)H=B(BHB)−1BHA = (B | 0)(B|C)^{-1} = (B|0)((B|C)^H(B|C))^{-1}(B|C)^H = {\\color{red} {B(B^HB)^{-1}B^H}}A=(B∣0)(B∣C)−1=(B∣0)((B∣C)H(B∣C))−1(B∣C)H=B(BHB)−1BH （7）最佳最小二乘解 A∈Cm×n, b∈CmA \\in C^{m \\times n}, \\; b \\in C^mA∈Cm×n,b∈Cm，则x0=A+b{\\color{red} {x_0=A^+b}}x0​=A+b是线性方程组Ax=bAx=bAx=b的最佳最小二乘解。 A∈Cm×n, B∈Cm×kA \\in C^{m \\times n}, \\; B \\in C^{m \\times k}A∈Cm×n,B∈Cm×k，则X0=A+B{\\color{red}{X_0 = A^+B}}X0​=A+B是AX=BAX=BAX=B的最佳最小二乘解。 5 矩阵分析 （1）向量范数满足正定性、齐次性和三角不等式，定义了范数的内积空间称为赋范空间。 （2）重要的向量范数： 对于复向量x=(x1 x2 ... xn)x = (x_1 \\;\\; x_2 \\;\\; ... \\;\\; x_n)x=(x1​x2​...xn​)，有： 2-范数**：** ​∣x∣∣=∣x1∣2+∣x2∣2+...+∣xn∣2{\\color{red}{|x|| = \\sqrt{|x_1|^2 + |x_2|^2 + ... + |x_n|^2}}}∣x∣∣=∣x1​∣2+∣x2​∣2+...+∣xn​∣2​ 1-范数**：** ​∣∣x∣∣1=∣x1∣+∣x2∣+...+∣xn∣{\\color{red}{||x||_1 = |x_1| + |x_2| + ... + |x_n|}}∣∣x∣∣1​=∣x1​∣+∣x2​∣+...+∣xn​∣ ∞范数**：** ​∣∣x∣∣∞=max⁡i∣xi∣{\\color{red}{||x||_{\\infty} = \\underset{i}{\\max} |x_i|}}∣∣x∣∣∞​=imax​∣xi​∣ 📌有限维线性空间的任意两种向量范数都是等价的。 （3）矩阵范数满足正定性、齐次性、三角不等式以及相容性。 （4）重要的矩阵范数和诱导范数 F范数：∣∣A∣∣F=[tr(AHA)]12{\\color{red}{||A||_F = [tr(A^HA)]^{\\frac{1}{2}}}}∣∣A∣∣F​=[tr(AHA)]21​ 列和范数： ∣∣A∣∣1=max⁡j(∑i=1n∣aij∣){\\color{red}{||A||_1 = \\underset{j}{\\max}(\\sum_{i=1}^n |a_{ij}|)}}∣∣A∣∣1​=jmax​(∑i=1n​∣aij​∣)，即每一列各元素模相加其中的最大值 谱范数：∣∣A∣∣2=λ1{\\color{red}{||A||_2 = \\sqrt{\\lambda_1}}}∣∣A∣∣2​=λ1​​，其中λ1\\lambda_1λ1​是AHAA^HAAHA的最大特征值 行和范数：∣∣A∣∣∞=max⁡i(∑j=1n∣aij∣){\\color{red}{||A||_{\\infty} = \\underset{i}{\\max}(\\sum_{j=1}^n |a_{ij}|)}}∣∣A∣∣∞​=imax​(∑j=1n​∣aij​∣)，即每一行各元素模相加其中的最大值 （5）向量收敛和矩阵收敛必须其中的每一个元素都收敛。 📌向量按分量收敛的充要条件是它按任意一个向量范数收敛。 📌当k→∞k \\rightarrow \\inftyk→∞时，∣∣A(k)−A∣∣→0||A^{(k)}-A|| \\rightarrow 0∣∣A(k)−A∣∣→0，称矩阵序列按矩阵范数收敛于AAA （6）谱半径 定义：λ1,λ2,...,λn\\lambda_1, \\lambda_2, ..., \\lambda_nλ1​,λ2​,...,λn​是矩阵A∈Cn×nA \\in C^{n \\times n}A∈Cn×n的全部特征值，称ρ(A)=max⁡i∣λi∣{\\color{red}{\\rho(A)=\\underset{i}{\\max}|\\lambda_i|}}ρ(A)=imax​∣λi​∣为AAA的谱半径。 📌Ak→0(k→∞)A^k \\rightarrow 0(k \\rightarrow \\infty)Ak→0(k→∞)的充要条件是ρ(A)&lt;1\\rho(A) &lt; 1ρ(A)&lt;1 📌AAA的谱半径是AAA的任意一种矩阵范数的下确界。 （7）矩阵幂级数 若复变量zzz的幂级数∑k=0∞akzk\\sum_{k=0}^{\\infty}a_kz^k∑k=0∞​ak​zk的收敛半径为RRR，而方阵A∈Cn×nA \\in C^{n \\times n}A∈Cn×n的谱半径为ρ(A)\\rho(A)ρ(A)，则 当ρ(A)&lt;R{\\color{red} {\\rho(A) &lt; R}}ρ(A)&lt;R时，矩阵幂级数∑k=0∞akAk\\sum_{k=0}^{\\infty}a_kA^k∑k=0∞​ak​Ak收敛； 当ρ(A)&gt;R{\\color{red} {\\rho(A) &gt; R}}ρ(A)&gt;R时，矩阵幂级数∑k=0∞akAk\\sum_{k=0}^{\\infty}a_k A^k∑k=0∞​ak​Ak发散 📌当求解AAA的特征值比较困难时，由于AAA的每个范数都是谱半径ρ(A)\\rho(A)ρ(A)的上界，只需要找到一种特殊的矩阵范数∣∣A∣∣||A||∣∣A∣∣，使得∣∣A∣∣&lt;R||A|| &lt; R∣∣A∣∣&lt;R，就能说明矩阵幂级数收敛。（优先考虑行和、列和范数） （8）常用的幂级数 收敛域是整个复平面的幂级数 eA=∑k=0∞1k!Ake^A = \\sum_{k=0}^{\\infty} \\frac{1}{k!}A^keA=∑k=0∞​k!1​Ak cos⁡A=∑k=0∞(−1)k(2k)!A2k\\cos A = \\sum_{k=0}^{\\infty}\\frac{(-1)^k}{(2k)!}A^{2k}cosA=∑k=0∞​(2k)!(−1)k​A2k sin⁡A=∑k=0∞(−1)k(2k+1)!A2k+1\\sin A = \\sum_{k=0}^{\\infty}\\frac{(-1)^k}{(2k+1)!}A^{2k+1}sinA=∑k=0∞​(2k+1)!(−1)k​A2k+1 收敛域为复平面∣z∣&lt;1|z| &lt; 1∣z∣&lt;1的幂级数 (I−A)−1=∑k=0∞Ak,ρ(A)&lt;1(I-A)^{-1} = \\sum_{k=0}^{\\infty}A^k, \\quad \\rho(A) &lt; 1(I−A)−1=∑k=0∞​Ak,ρ(A)&lt;1 ln⁡(I+A)=∑k=1∞(−1)k−1kAk,ρ(A)&lt;1\\ln(I+A) = \\sum_{k=1}^{\\infty}\\frac{(-1)^{k-1}}{k}A^k, \\quad \\rho(A) &lt; 1ln(I+A)=∑k=1∞​k(−1)k−1​Ak,ρ(A)&lt;1 （9）矩阵函数的两种求法 方法一：Jordan标准形法 求矩阵AAA的Jordan标准形JAJ_AJA​，得到A=PJAP−1{\\color{red} {A = PJ_AP^{-1}}}A=PJA​P−1 设解析函数为f(z)f(z)f(z)，则对每一个Jordan块有f(Ji)=[f(λi)f′(λi)1!f′′(λi)2!...f(λi)f′(λi)1!......f(λi)]f(J_i)= \\begin{bmatrix}f(\\lambda_i) &amp; \\frac{f&#x27;(\\lambda_i)}{1!} &amp; \\frac{f&#x27;&#x27;(\\lambda_i)}{2!} &amp; ... \\\\ &amp; f(\\lambda_i) &amp; \\frac{f&#x27;(\\lambda_i)}{1!} &amp; ...\\\\ &amp; &amp; ... &amp; \\\\ &amp; &amp; &amp; f(\\lambda_i)\\end{bmatrix}f(Ji​)=⎣⎢⎢⎢⎡​f(λi​)​1!f′(λi​)​f(λi​)​2!f′′(λi​)​1!f′(λi​)​...​......f(λi​)​⎦⎥⎥⎥⎤​，得到f(JA)f(J_A)f(JA​) 最后得到f(A)=Pf(JA)P−1f(A) = Pf(J_A)P^{-1}f(A)=Pf(JA​)P−1 📌这种方法的难点在于需要求Jordan链，过程中可以会遇到麻烦。如果不同特征值个数较多，建议使用第一种；而如果特征值比较单一，并且 代数重数 - 几何重数 &gt; 2，建议使用第二种 方法二：最小多项式法 先计算AAA的Jordan标准形，由此得到最小多项式mA(λ)=(λ−λ1)n1(λ−λ2)n2...(λ−λs)nsm_A(\\lambda)=(\\lambda -\\lambda_1)^{n_1}(\\lambda-\\lambda_2)^{n_2}...(\\lambda-\\lambda_s)^{n_s}mA​(λ)=(λ−λ1​)n1​(λ−λ2​)n2​...(λ−λs​)ns​，其中幂次和有∑i=1sni=m\\sum_{i=1}^s n_i =m∑i=1s​ni​=m； 得到g(λ)=c0+c1λ+...+cm−1λm−1g(\\lambda)=c_0+c_1\\lambda+...+c_{m-1}\\lambda^{m-1}g(λ)=c0​+c1​λ+...+cm−1​λm−1，并令g(j)(λi)=f(j)(λi)g^{(j)}(\\lambda_i)=f^{(j)}(\\lambda_i)g(j)(λi​)=f(j)(λi​)，解得系数c0,c1,...,cm−1c_0,c_1,...,c_{m-1}c0​,c1​,...,cm−1​； 最后得到f(A)=c0I+c1A+...+cm−1Am−1f(A) = c_0I + c_1A+...+c_{m-1}A^{m-1}f(A)=c0​I+c1​A+...+cm−1​Am−1 📌当不同特征值的个数比较多或者最小多项式幂次较高时，计算起来比较复杂，建议使用第一种。 （10）两个知识点： 重要的导数：dA−1(t)dt=−A−1(t)(ddtA(t))A−1(t)\\color{red}{\\frac{d A^{-1}(t)}{dt} = - A^{-1}(t) \\big( \\frac{d}{dt}A(t)\\big)A^{-1}(t)}dtdA−1(t)​=−A−1(t)(dtd​A(t))A−1(t) 矩阵指数函数的行列式：∣eA∣=etrA|e^A| = e^{trA}∣eA∣=etrA 📌上式证明：矩阵函数的特征值是让原矩阵的特征值做函数参数的结果，即 AAA的特征值是λ\\lambdaλ，则f(A)f(A)f(A)的特征值是f(λ)f(\\lambda)f(λ) 由于A相似于Jordan标准型，所以∣eA∣=∣P∣∣eJA∣∣P−1∣|e^{A}|=|P||e^{J_A}||P^{-1}|∣eA∣=∣P∣∣eJA​∣∣P−1∣，由于行列式等于特征值之积， 所以∣eA∣=∣eJA∣=eλ1eλ2...=eλ1+λ2+...=etrA|e^A|=|e^{J_A}|=e^{\\lambda_1}e^{\\lambda_2}...=e^{\\lambda_1+\\lambda_2+...}=e^{trA}∣eA∣=∣eJA​∣=eλ1​eλ2​...=eλ1​+λ2​+...=etrA （11）矩阵函数应用 一阶常系数齐次微分方程组： {x˙(t)=Ax(t)x(t0)=Cn×1\\begin{cases}\\dot{x}(t) = Ax(t)\\\\x(t_0) = C_{n \\times 1}\\end{cases}{x˙(t)=Ax(t)x(t0​)=Cn×1​​ 解为：x(t)=eA(t−t0)x(t0){\\color{red}{x(t) = e^{A(t-t_0)}x(t_0)}}x(t)=eA(t−t0​)x(t0​) 一阶线性常系数非齐次线性方程组：{x˙(t)=Ax(t)+f(t)x(t0)=C\\begin{cases}\\dot{x}(t) = Ax(t) + f(t)\\\\x(t_0) = C\\end{cases}{x˙(t)=Ax(t)+f(t)x(t0​)=C​ 解为：x(t)=eA(t−t0)x(t0)+∫t0teA(t−τ)f(τ)dτ{\\color{red} {x(t) = e^{A(t-t_0)}x(t_0) + \\int_{t_0}^t e^{A(t-\\tau)}f(\\tau)d \\tau}}x(t)=eA(t−t0​)x(t0​)+∫t0​t​eA(t−τ)f(τ)dτ 6 Kronecker积 （1）对于矩阵A=(aij)∈Cm×n, B=(bij)∈Cs×tA=(a_{ij}) \\in C^{m \\times n}, \\;B=(b_{ij}) \\in C^{s \\times t}A=(aij​)∈Cm×n,B=(bij​)∈Cs×t，则K积为： A⊗B=[a11Ba12B...a1nBa21Ba22B...a2nB ...... ...an1Ban2B...annB]A \\otimes B = \\begin{bmatrix}a_{11}B &amp; a_{12}B &amp; ... &amp; a_{1n}B\\\\ a_{21}B &amp; a_{22}B &amp; ... &amp; a_{2n}B\\\\ ... &amp; ... &amp; &amp; ...\\\\ a_{n1}B &amp; a_{n2}B &amp; ... &amp; a_{nn}B\\end{bmatrix} A⊗B=⎣⎢⎢⎢⎡​a11​Ba21​B ...an1​B​a12​Ba22​B...an2​B​...... ...​a1n​Ba2n​B...ann​B​⎦⎥⎥⎥⎤​ 📌K积不具有交换律，即A⊗B≠B⊗AA \\otimes B \\neq B \\otimes AA⊗B=B⊗A （2）重要性质 I⊗I=II \\otimes I = II⊗I=I (A⊗B)(C⊗D)=(AC)⊗(BD)(A \\otimes B)(C \\otimes D) = (AC) \\otimes (BD)(A⊗B)(C⊗D)=(AC)⊗(BD) (A⊗B)k=Ak⊗Bk(A \\otimes B)^k = A^k \\otimes B^k(A⊗B)k=Ak⊗Bk (A⊗B)=(Im⊗B)(A⊗In)(A \\otimes B) = (I_m \\otimes B)(A \\otimes I_n)(A⊗B)=(Im​⊗B)(A⊗In​) (A⊗B)−1=A−1⊗B−1(A \\otimes B)^{-1} = A^{-1} \\otimes B^{-1}(A⊗B)−1=A−1⊗B−1 ∣A⊗B∣=∣B⊗A∣=∣A∣n∣B∣m|A \\otimes B| = |B \\otimes A| = |A|^n|B|^m∣A⊗B∣=∣B⊗A∣=∣A∣n∣B∣m（这里的****表示****的阶数，表示的阶数） rank(A⊗B)=rank(A)rank(B)rank(A \\otimes B) = rank(A)rank(B)rank(A⊗B)=rank(A)rank(B) 酉矩阵的K积也是酉矩阵 Hermite矩阵的K积也是Hermite矩阵 （3）K和：设A∈Fm×m, B∈Fn×nA \\in F^{m \\times m}, \\;B \\in F^{n \\times n}A∈Fm×m,B∈Fn×n，A⊕B=A⊗In+Im⊗BA \\oplus B = A \\otimes I_n + I_m \\otimes BA⊕B=A⊗In​+Im​⊗B （4）若AAA的特征值是λi\\lambda_iλi​，相应的特征向量是xix_ixi​；BBB的特征值是μi\\mu_iμi​，相应的特征向量为yiy_iyi​；则： ∗∗A⊗B**A \\otimes B∗∗A⊗B的特征值是λiμi\\color{red}{\\lambda_i \\mu_i}λi​μi​，对应的特征向量是xi⊗yi\\color{red}{x_i \\otimes y_i}xi​⊗yi​** ∗∗A⊕B**A \\oplus B∗∗A⊕B的特征值是λi+μi\\color{red}{\\lambda_i + \\mu_i}λi​+μi​，对应的特征向量是xi⊗yi\\color{red}{x_i \\otimes y_i}xi​⊗yi​** 📌K积下的奇异值也和特征值有一样的结论 （5）设f(z)f(z)f(z)是解析函数，A∈Fn×nA \\in F^{n \\times n}A∈Fn×n，f(A)f(A)f(A)存在，则 f(Im⊗A)=Im⊗f(A)f(I_m \\otimes A) = I_m \\otimes f(A)f(Im​⊗A)=Im​⊗f(A) f(A⊗Im)=f(A)⊗Imf(A \\otimes I_m) = f(A) \\otimes I_mf(A⊗Im​)=f(A)⊗Im​ （6）设矩阵A∈Fm×n,A=(A1,A2,...,An)A \\in F^{m \\times n}, \\quad A=(A_1, A_2,...,A_n)A∈Fm×n,A=(A1​,A2​,...,An​)，则Vec(A)=[A1A2...An]∈FnmVec(A) = \\begin{bmatrix}A_1\\\\ A_2\\\\ ...\\\\ A_n\\end{bmatrix} \\in F^{nm}Vec(A)=⎣⎢⎢⎢⎡​A1​A2​...An​​⎦⎥⎥⎥⎤​∈Fnm 📌Vec(ABC)=(CT⊗A)Vec(B){\\color{red}{Vec(ABC) = (C^T \\otimes A)Vec(B)}}Vec(ABC)=(CT⊗A)Vec(B) Vec(AX)=(Is⊗A)Vec(X)Vec(AX) = (I_s \\otimes A)Vec(X)Vec(AX)=(Is​⊗A)Vec(X) Vec(XC)=(CT⊗Ik)Vec(X)Vec(XC) = (C^T \\otimes I_k) Vec(X)Vec(XC)=(CT⊗Ik​)Vec(X) （7）求解矩阵方程AX+XB=DAX+XB=DAX+XB=D，将两边同时取向量化算子，得到(Im⊗A+BT⊗In)Vec(X)=Vec(D){\\color{red}{(I_m \\otimes A + B^T \\otimes I_n)Vec(X) = Vec(D)}}(Im​⊗A+BT⊗In​)Vec(X)=Vec(D)，最后通过常规的求非齐次线性方程组的方法求解。 （8）求微分方程：{X˙(t)=AX(t)+X(t)BX(0)=C\\begin{cases}\\dot{X}(t) = AX(t) + X(t)B\\\\X(0) = C\\end{cases}{X˙(t)=AX(t)+X(t)BX(0)=C​ 用向量化算子作用在方程两边，得到Vec(X˙(t))=(In⊗A+BT⊗Im)Vec(X(t))Vec(\\dot{X}(t)) = (I_n \\otimes A + B^T \\otimes I_m)Vec(X(t))Vec(X˙(t))=(In​⊗A+BT⊗Im​)Vec(X(t))和Vec(X(0))=Vec(C)Vec(X(0)) = Vec(C)Vec(X(0))=Vec(C) 令Y(t)=Vec(X(t)),C1=Vec(C),G=In⊗A+BT⊗ImY(t) = Vec(X(t)), \\quad C_1 = Vec(C), \\quad G = I_n \\otimes A + B^T \\otimes I_mY(t)=Vec(X(t)),C1​=Vec(C),G=In​⊗A+BT⊗Im​，通过求解普通微分方程的方法得到Y(t)=eGtC1Y(t) = e^{Gt}C_1Y(t)=eGtC1​； 将Y(t), G, C1Y(t), \\; G, \\; C_1Y(t),G,C1​带入化简求得X(t)X(t)X(t)。","categories":[{"name":"数学","slug":"数学","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数学方法","slug":"数学方法","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6%E6%96%B9%E6%B3%95/"}]},{"title":"Docker使用方法详解","slug":"Docker/Docker","date":"2020-04-05T09:55:32.000Z","updated":"2022-07-10T13:22:58.194Z","comments":true,"path":"2020/04/05/Docker/Docker/","link":"","permalink":"http://example.com/2020/04/05/Docker/Docker/","excerpt":"","text":"Docker 官方手册 电子书：docker从入门到实践 1 docker简介 1.1 docker与虚拟机 1.2 镜像 2 docker基本命令 2.1 docker基本命令概览 2.2 docker run详解 📌若之前未下载对应镜像，会从docker hub拉取；若下载过，直接用镜像创建 若直接输入docker run ubuntu，会发现创建了容器之后便退出了，并没有运行 这是因为docker是用来运行进程或任务的，进程一旦完成，容器便会退出。而ubuntu只是一个其它服务依托的基础镜像，本身并没有进程，所以创建新容器后就会退出。 1234567#----------------- 解决这种问题的几种方式 ---------------------# 方式一：启动容器时指定运行命令docker run ubuntu sleep 5 # 此命令会启动容器时执行sleep 5，睡眠5秒后应用停止，容器退出# 方式二：交互模式，连接到终端docker run -it kodekloud/simple-prompt-docker 若容器化应用既包括标准输入又有标准输出，那run容器时默认只会输出，并不会监听标准输入 -i ：交互模式，可以监听标准输入 -t：即使是交互模式，由于终端不一致，有标准输入的app仍不会完整实现，所以用-t选项连接终端 docker run还有attach和detach的选项 12345# -d选项，使容器在后台运行docker run -d kodekloud/simple-webapp# 如果想重新连接到正在后台运行的容器，可以使用attach命令docker attach 容器ID/容器名 此外还可以用tag指定run的版本，如docker run redis:4.0（默认tag是latest） 端口映射：-p选项 docker容器的IP地址以及端口均属于内部，可以从容器内部访问localhost，但是外部默认无法访问 此时需要将容器的端口映射到主机的端口，之后便可以通过主机IP访问容器 12# simple-webapp程序监听容器的5000端口docker run -p 80:5000 kodekloud/simple-webapp #容器的5000端口被映射到主机的80端口 通过把不同容器映射到主机的不同端口上，可以同时实现多个实例 目录映射 容器有自己的隔离的文件系统，任何对文件的修改都发生在容器内部，如果用rm命令删除容器，数据也会消失。如果想删除容器但是保留数据，可以将容器内的卷挂载到主机中。 1234# -v选项负责目录映射docker run -v /opt/datadir:/var/lib/mysql mysql# 将主机的/opt/datadir映射到mysql容器内的/var/lib/mysql目录# mysql容器删除后/opt/datadir中的内容仍在 设置并查看环境变量 可以在run的时候指定容器的环境变量，从而使调用该环境变量的程序得到自定义数值 123456# 使用-e选项，将simple-webapp-color容器中的APP_COLOR环境变量赋值为bluedocker run -e APP_COLOR=blue simple-webapp-color# 使用inspect可以查看环境变量的值docker inspect simple-webapp-color# 输出中的Config中会有环境变量列表 3 docker构建镜像 基本步骤 创建Dockerfile（dockerfle中的每一行都是命令+参数） 1234567891011FROM UbuntuRUN apt-get updateRUN apt-get install pythonRUN pip install flaskRUN pip install flask-mysqlCOPY . /opt/source-codeENTRYPOINT FLASK_APP=/opt/source-code/app.py flask run Layer1. Base Ubuntu Layer Layer2. Changes in apt packages Layer3. Changes in pip packages Layer4. Source Code Layer5. Update Entrypoint with &quot;flask command&quot; 📌关于docker分层结构： - 每一层只存储与前一层之间的变化，所以往往层数很高时，该层大小也很小 - docker history+镜像名：可查看每一层执行的命令和大小 - docker build会在构建期间缓存已经成功的层，这样如果构建失败或者需要修改镜像时，可以从中间的某一层开始重新构建，节省时间 # dockerfile基本指令 FROM : 指定基础镜像，在其上构建当前镜像 RUN : 在基础镜像容器中运行命令 COPY : 从本地指定目录复制内容到容器的指定目录 CMD : 指定在容器初始阶段运行的默认程序（有参数） 如Ubuntu镜像的dockerfile中有CMD &#123;&quot;bash&quot;&#125; 如果在docker run后追加命令，该命令会覆盖默认CMD 有两种书写格式： CMD command param1 | CMD [&quot;command&quot;,&quot;param1&quot;] CMD sleep 5 CMD [&quot;sleep&quot;,&quot;5&quot;] ENTRYPOINT : 指定在容器初始阶段运行的默认程序（可以无参数） docker run后追加参数，相当于执行ENTRYPOINT中的命令+参数 ENTRYPOINT+CMD组合 : 默认执行ENTRYPOINT命令+CMD参数，此时二者必须是JSON格式 ENTRYPOINT [&quot;sleep&quot;] CMD [&quot;5&quot;] ADD : 相当于COPY，有自动解压缩功能，但会令镜像构建缓存失效，使镜像构建缓慢 ENV : 设置环境变量，格式有两种 ENV &lt;key&gt; &lt;value&gt; ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt; ARG : 设置构建镜像时的环境变量，容器运行时环境变量不复存在，即相当于dockerfile的宏 有作用域，若在FROM指令之前指定，那么只能用于该FROM指令中，后续指令无法再用 参数值在docker build中可用--build-arg &lt;参数名&gt;=&lt;值&gt;来覆盖 WORKDIR : 相当于dockerfile中的cd 📌注：若要在容器运行时改变入口点，如从sleep改成bash，可以docker run - - entrypoint bash ubuntu-sleeper 10 更多dockerfile指令可查看https://vuepress.mirror.docker-practice.com/image/dockerfile/ 使用docker build构建镜像 123456# 使用URL github.com/creack/docker-firefox 的 Dockerfile 创建镜像docker build github.com/creack/docker-firefox# 通过-f选项指定Dockerfile的位置docker build -f /path/to/Dockerfile# 使用当前目录的 Dockerfile 创建镜像（注意最后那个点），标签为 runoob/ubuntu:v1docker build -t runoob/ubuntu:v1 . 使用docker push将镜像推到docker hub 4 docker registry docker registry是镜像存储的地方，中央仓库 如nginx镜像名全称为nginx/nginx，前者是用户名，若不提供则默认用户名与镜像名相同 默认的docker registry是dockerhub，其它的还有谷歌gcr(提供k8s镜像)等等，AWS等公司也提供私有registry方便于不想共享镜像的时候 dockerhub提供的私有仓库：docker login private-registry.io 使用私有仓库需要保证在登录状态 本地Registry创建与使用 Registry本身就是一个应用程序，且已经ss被做成了镜像，其容器开放端口5000，利用该容器可以在局域网内与团队共享所创建的镜像 12345678910# 运行registry容器，也可以加上-v选项将镜像存于本地docker run -d -p 5000:5000 --name registry registry:2# 使用tag将镜像标记为可被本地Registry接受的镜像名docker image tag my-image localhost:5000/my-image# 向本地registry推送镜像docker push localhost:5000/my-image# 从本地registry拉取镜像docker pull localhost:5000/my-image# 从局域网内其它主机的registry拉取镜像docker pull 192.168.56.100:5000/my-image 📌注：可以通过curl localhost:5000/v2/_catalog命令查看镜像是否上传成功 上述方法适用于docker 1.3.x之前的版本，交互全部使用http服务。然而该版本之后，docker搭建私有镜像默认使用https，若从registry里pull镜像会报错。 解决办法一：配置SSL证书 官方文档（难，因为很难建立证书） 创建certs文件夹 1mkdir -p certs 从CA拷贝.crt和.key文件到certs文件夹（例中采用名字domain.crt和domain.key） 假设域名为https://myregistry.domain.com/ 2. 启动registry容器 123456789docker run -d \\ --restart=always \\ --name registry \\ -v &quot;$(pwd)&quot;/certs:/certs \\ -e REGISTRY_HTTP_ADDR=0.0.0.0:443 \\ -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/domain.crt \\ -e REGISTRY_HTTP_TLS_KEY=/certs/domain.key \\ -p 443:443 \\ registry:2 此命令将容器中的certs文件夹挂载到宿主机的certs文件夹，通过环境变量告知容器该到哪里找domain.crt和domain.key。registry将在443端口（默认HTTPS端口）运行。 新registry通过myregistry.domain.com访问 1234docker pull ubuntu:16.04docker tag ubuntu:16.04 myregistry.domain.com/my-ubuntudocker push myregistry.domain.com/my-ubuntudocker pull myregistry.domain.com/my-ubuntu 使用中间证书(intermediate certificate) 证书发放者往往会提供的是中间证书，需要利用该证书创建domain.crt 1cat domain.crt intermediate-certificates.pem &gt; certs/domain.crt 解决方法2：需要pull的机器添加信任registry列表 打开/etc/docker/daemon.json 添加私有registry 1&quot;insecure-registries&quot;:[&quot;myregistry.example.com:5000&quot;] 或 1234&quot;insecure-registries&quot;: [ &quot;registry:5000&quot;, &quot;registry2:5000&quot;] 5 docker存储 docker容器被创建后，就会创建以下目录 docker文件系统 /var/lib/docker -- aufs -- containers -- image -- volumes 一般容器内的数据在容器删除后便被删除，要想避免这种情况可以采用外部存储挂载到容器内的方法 主要有两种挂载方式，卷挂载(volume)和绑定挂载(binding) 5.1 卷挂载 卷挂载是在docker主机内创建一个独立于容器的卷，卷内的内容与宿主机无关 创建卷 123456789101112131415$ docker volume create my-vol # 创建卷$ docker volume ls # 列出所有卷DRIVER VOLUME NAMElocal my-vol$ docker volume inspect my-vol # 查看卷的信息[ &#123; &quot;Driver&quot;: &quot;local&quot;, &quot;Labels&quot;: &#123;&#125;, &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;, &quot;Name&quot;: &quot;my-vol&quot;, &quot;Options&quot;: &#123;&#125;, &quot;Scope&quot;: &quot;local&quot; &#125;] 挂载卷 12旧写法：-v my-vol:/usr/share/nginx/html #后者是容器内目录新写法：--mount source=my-vol,target=/usr/share/nginx/html 删除卷 12docker volume rm my-voldocker volume prune #删除无主卷 5.2 绑定挂载 绑定挂载是将宿主机的目录指定为容器内的目录，即该目录的修改是对宿主机目录的直接修改 旧写法：-v选项 新写法：- - mount选项 6 docker网络 docker自动创建Bridge、 none、 host三种网络 可通过network选项修改当前模式：docker run Ubuntu - -network=host none模式：完全没有网络，容器彼此隔绝，容器与主机隔绝 host模式：容器使用主机的网络，容器的端口就是主机的端口，注意此时，不同容器再不能在内部使用相同的端口运行程序 Bridge模式详解 7 docker compose Compose-file官方文档 8 docker swarm 官方文档 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131version: &#x27;3.7&#x27;services: minio1: image: minio/minio:RELEASE.2020-11-19T23-48-16Z hostname: minio1 volumes: - minio1-data:/export ports: - &quot;9001:9000&quot; networks: - minio_distributed deploy: restart_policy: delay: 10s max_attempts: 10 window: 60s placement: constraints: - node.labels.minio1==true command: server http://minio&#123;1...4&#125;/export secrets: - secret_key - access_key healthcheck: test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:9000/minio/health/live&quot;] interval: 30s timeout: 20s retries: 3 minio2: image: minio/minio:RELEASE.2020-11-19T23-48-16Z hostname: minio2 volumes: - minio2-data:/export ports: - &quot;9002:9000&quot; networks: - minio_distributed deploy: restart_policy: delay: 10s max_attempts: 10 window: 60s placement: constraints: - node.labels.minio2==true command: server http://minio&#123;1...4&#125;/export secrets: - secret_key - access_key healthcheck: test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:9000/minio/health/live&quot;] interval: 30s timeout: 20s retries: 3 minio3: image: minio/minio:RELEASE.2020-11-19T23-48-16Z hostname: minio3 volumes: - minio3-data:/export ports: - &quot;9003:9000&quot; networks: - minio_distributed deploy: restart_policy: delay: 10s max_attempts: 10 window: 60s placement: constraints: - node.labels.minio3==true command: server http://minio&#123;1...4&#125;/export secrets: - secret_key - access_key healthcheck: test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:9000/minio/health/live&quot;] interval: 30s timeout: 20s retries: 3 minio4: image: minio/minio:RELEASE.2020-11-19T23-48-16Z hostname: minio4 volumes: - minio4-data:/export ports: - &quot;9004:9000&quot; networks: - minio_distributed deploy: restart_policy: delay: 10s max_attempts: 10 window: 60s placement: constraints: - node.labels.minio4==true command: server http://minio&#123;1...4&#125;/export secrets: - secret_key - access_key healthcheck: test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:9000/minio/health/live&quot;] interval: 30s timeout: 20s retries: 3volumes: minio1-data: minio2-data: minio3-data: minio4-data:networks: minio_distributed: driver: overlaysecrets: secret_key: external: true name: minio_secret_key access_key: external: true name: minio_access_key","categories":[{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"次模函数Submodular Function","slug":"次模函数/次模函数","date":"2020-03-14T16:50:28.000Z","updated":"2022-07-12T16:56:59.771Z","comments":true,"path":"2020/03/15/次模函数/次模函数/","link":"","permalink":"http://example.com/2020/03/15/%E6%AC%A1%E6%A8%A1%E5%87%BD%E6%95%B0/%E6%AC%A1%E6%A8%A1%E5%87%BD%E6%95%B0/","excerpt":"","text":"次模函数 参考文献[1]：Submodular Function Maximization( Google &amp; ETH ) 参考文献[2]：An Introduction to Submodular Functions and Optimization 参考文献[3]：Learning with Submodular Functions: A Convex Optimization Perspective 次模优化工具包：(Matlab)SFO-toolbox, (Python)apricot 考虑一个这样的场景，将传感器部署在饮水水源处，构成分布式网络以检测是否有污染。此时需要建模，可以量化将传感器部署在位置集合AAA所带来的收益f(A)f(A)f(A)。基于这样的想法，我们需要找到一个所有位置的最优子集A⊆VA\\subseteq VA⊆V，从而能够在满足一些约束的前提下，实现效用最大化max⁡Af(A)\\max_Af(A)maxA​f(A)。（f(ϕ)=0f(\\phi)=0f(ϕ)=0） 1 次模函数简介 集函数(set function)是指输入为集合，输出为一个数值的函数 幂集函数：f:2x→Rf:2^\\bold x\\rightarrow\\mathcal Rf:2x→R，就是将集合x\\bold xx的所有子集都映射到数值的函数。（x\\bold xx是一个集合，2x2^\\bold x2x表示其幂集，即x\\bold xx的所有子集组成的集合，由于x\\bold xx的每个元素在它的子集里都有选/不选两种可能，所以有2∣x∣2^{|\\bold x|}2∣x∣个元素） 离散导数定义：对于集函数f:2V→R,S⊆V,e∈Vf:2^V\\rightarrow\\mathbb R,S\\subseteq V,e\\in Vf:2V→R,S⊆V,e∈V，令Δf(e∣S):=f(S∪{e})−f(S)\\Delta_f(e|S):=f(S\\cup\\{e\\})-f(S)Δf​(e∣S):=f(S∪{e})−f(S)表示fff在SSS处关于eee的离散导数。 为方便起见，后面将Δf(e∣S)\\Delta_f(e|S)Δf​(e∣S)简写为Δ(e∣S)\\Delta(e|S)Δ(e∣S)。 次模定义：如果集函数f:2V→Rf:2^V\\rightarrow\\mathbb Rf:2V→R对于每个A⊆B⊆VA\\subseteq B\\subseteq VA⊆B⊆V以及e∈V∖Be\\in V\\setminus Be∈V∖B都有Δ(e∣A)≥Δ(e∣B)\\Delta(e|A)\\ge\\Delta(e|B)Δ(e∣A)≥Δ(e∣B)，那么该函数是次模函数。 📌此定义表明次模函数具有递减收益特性，如下图所示，将传感器放在位置s′s&#x27;s′带来的收益，不会因初始传感器的数量多而增加。 次模等价定义：如果集函数f:2V→Rf:2^V\\rightarrow\\mathbb Rf:2V→R对每个A,B⊆VA,B\\subseteq VA,B⊆V都有f(A∩B)+f(A∪B)≤f(A)+f(B)f(A\\cap B)+f(A\\cup B)\\le f(A)+f(B)f(A∩B)+f(A∪B)≤f(A)+f(B)，那么该函数是次模函数。 单调性：如果函数f:2V→Rf:2^V\\rightarrow\\mathbb Rf:2V→R对所有A⊆B⊆VA\\subseteq B\\subseteq VA⊆B⊆V都有f(A)≤f(B)f(A)\\le f(B)f(A)≤f(B)，那么该函数是单调的。 📌 由单调性可以推出一个重要结论：对于单调次模函数，在所有A⊆B⊆VA\\subseteq B\\subseteq VA⊆B⊆V且e∈Ve\\in Ve∈V，都有Δ(e∣A)≥Δ(e∣B)\\Delta(e|A)\\ge\\Delta(e|B)Δ(e∣A)≥Δ(e∣B)。（注意这里和次模的定义有些微不同，这里不需要e∉Be\\notin Be∈/B） 常见次模函数 模函数(Modular function)： 模函数以等式形式保持次模性，即对所有A,B⊆VA,B\\subseteq VA,B⊆V都有f(A)+f(B)=f(A∪B)+f(A∩B)f(A)+f(B)=f(A\\cup B)+f(A\\cap B)f(A)+f(B)=f(A∪B)+f(A∩B)。模函数的离散导数为常数Δ(e∣B)=Δ(e∣A) for all A,B and e∉A∪B\\Delta(e|B)=\\Delta(e|A)\\text{ for all }A,B\\text{ and }e\\notin A\\cup BΔ(e∣B)=Δ(e∣A) for all A,B and e∈/A∪B。模函数总是可以表示成一些函数w:V→Rw:V\\rightarrow\\mathbb Rw:V→R的加权和的形式f(S)=∑e∈Sw(e)f(S)=\\sum_{e\\in S}w(e)f(S)=∑e∈S​w(e)。 加权覆盖函数(Weighted coverage functions)： 📌数学中set和collection的区别： set：以数值为元素的集合 collection：以元素为元素的集合 给定一个set XXX，一个非负模函数g:2X→Rg:2^X\\rightarrow\\mathbb Rg:2X→R以及一个XXX的子集构成的collection VVV，那么对一个subcollection S⊆VS\\subseteq VS⊆V，函数 f(S):=g(⋃v∈Sv)=∑x∈⋃v∈Svw(x)f(S):=g(\\bigcup_{v\\in S}v)=\\sum_{x\\in\\bigcup_{v\\in S}v}w(x) f(S):=g(v∈S⋃​v)=x∈⋃v∈S​v∑​w(x) 是单调次模函数。在前面的场景中，XXX可视作污染事件的集合，w(x)w(x)w(x)量化了事件xxx的严重程度，v∈V,v⊆Xv\\in V,v\\subseteq Xv∈V,v⊆X是由于放置传感器而检测出的事件。（此时就不应是最大化了，而是最小化） 📌 若将函数ggg替换成势函数g(A)=∣A∣g(A)=|A|g(A)=∣A∣，最大化该问题变成了大名鼎鼎的max-cover问题。 拟阵的秩函数： VVV是有限集，I⊆2V\\mathcal I\\subseteq2^VI⊆2V是满足以下两特性的VVV的子集的collection A⊆B⊆VA\\subseteq B\\subseteq VA⊆B⊆V并且B∈IB\\in\\mathcal IB∈I，则A∈IA\\in\\mathcal IA∈I A,B∈IA,B\\in\\mathcal IA,B∈I并且∣B∣&gt;∣A∣|B|&gt;|A|∣B∣&gt;∣A∣，则∃e∈B∖A\\exist e\\in B\\setminus A∃e∈B∖A使得A∪{e}∈IA\\cup\\{e\\}\\in\\mathcal IA∪{e}∈I 则由VVV和I\\mathcal II组成的pair (V,I)(V,\\mathcal I)(V,I)称为拟阵 I\\mathcal II中的集合被称为独立集(independent)。 秩函数：S⊆V,f(S):=max⁡{∣U∣:U⊆S,U∈I}S\\subseteq V,f(S):=\\max\\{|U|:U\\subseteq S,U\\in\\mathcal I\\}S⊆V,f(S):=max{∣U∣:U⊆S,U∈I} 任何拟阵的秩函数都单调次模。 📌 注：上述为最大秩r，相似定义可有最小秩ρ\\rhoρ，若max⁡S⊆Xr(S)ρ(S)≤p\\max_{S\\subseteq X}\\frac{r(S)}{\\rho(S)}\\le pmaxS⊆X​ρ(S)r(S)​≤p则为p-独立系统，可验证p-独立系统用贪心算法所得结果的近似度为1p+1\\frac 1{p+1}p+11​。 厂址选择(Facility location)： 考虑这样的问题，从集合V={1,...,n}V=\\{1,...,n\\}V={1,...,n}中选出一些位置开放工厂以服务m个客户。如果开发位置j的工厂，它会提供给用户i数值为Mi,jM_{i,j}Mi,j​的服务，其中M∈Rm×nM\\in\\mathbb R^{m\\times n}M∈Rm×n。如果每个客户只取最高数值的服务，那么提供给所有客户的服务值可用集函数f(S)=∑i=1mmax⁡j∈SMi,jf(S)=\\sum_{i=1}^{m}\\max_{j\\in S}M_{i,j}f(S)=∑i=1m​maxj∈S​Mi,j​表示。 f(ϕ)=0f(\\phi)=0f(ϕ)=0，如果对所有i,ji,ji,j有Mi,j≥0M_{i,j}\\ge0Mi,j​≥0，那么f(S)f(S)f(S)是单调次模的。 熵： 给定一个离散值随机向量X=[X1,X2,...,Xn]\\bold X=[X_1,X_2,...,X_n]X=[X1​,X2​,...,Xn​]，其联合概率分布为P(X)P(\\bold X)P(X)。定义XS\\bold X_SXS​是由集合SSS的元素索引的X\\bold XX的坐标，而xS\\bold x_SxS​是以集合SSS的元素为坐标的X\\bold XX对应索引的值组成的向量。定义f(S)=H(XS)f(S)=H(\\bold X_S)f(S)=H(XS​)为香农熵，即H(XS)=−∑xSP(xS)log⁡2P(xS)H(\\bold X_S)=-\\sum_{\\bold x_S}P(\\bold x_S)\\log_2P(\\bold x_S)H(XS​)=−∑xS​​P(xS​)log2​P(xS​)。此函数是单调次模的。 若随机向量是实值的，积分形式的熵H(XS)=−∫P(xS)log⁡2P(xS)dxSH\\left(\\mathbf{X}_{S}\\right)=-\\int P\\left(\\mathbf{x}_{S}\\right) \\log _{2} P\\left(\\mathbf{x}_{S}\\right) d \\mathbf{x}_{S}H(XS​)=−∫P(xS​)log2​P(xS​)dxS​次模而不单调。 互信息(mutual information)： 📌互信息的意义：一个随机变量由于已知另一个随机变量而减少的不确定性 给定两个独立随机向量X=[X1,X2,...,Xn]\\bold X=[X_1,X_2,...,X_n]X=[X1​,X2​,...,Xn​]和Y=[Y1,Y2,...,Ym]\\bold Y=[Y_1,Y_2,...,Y_m]Y=[Y1​,Y2​,...,Ym​]的联合概率分布P(X,Y)P(\\bold X,\\bold Y)P(X,Y)，则它们的互信息为f(S)=I(Y;XS)=H(Y)−H(Y∣XS)f(S)=I(\\bold Y;\\bold X_S)=H(\\bold Y)-H(\\bold Y|\\bold X_S)f(S)=I(Y;XS​)=H(Y)−H(Y∣XS​)，一般这样的函数并不是次模的。但是，如果满足条件独立性，即Y\\bold YY发生后，XA\\bold X_AXA​发生的概率与XB\\bold X_BXB​发生的概率无关，XA⊥XB∣Y\\bold X_A\\perp\\bold X_B|\\bold YXA​⊥XB​∣Y或者说P(XA,XB∣Y)=P(XA∣Y)P(XB∣Y)P(\\bold X_A,\\bold X_B|\\bold Y)=P(\\bold X_A|\\bold Y)P(\\bold X_B|\\bold Y)P(XA​,XB​∣Y)=P(XA​∣Y)P(XB​∣Y)，则fff是单调次模的。 但上述场景中，此函数可理解为，变量YvY_vYv​表示位置v∈Vv\\in Vv∈V的水质，XvX_vXv​表示将传感器放在位置v时YvY_vYv​的测量噪声，则f(S)f(S)f(S)在量化通过部署传感器在SSS可以消除多少水质测量的不确定性。 Cut capacity functions： 无向图G=(V,E)G=(V,E)G=(V,E)，其有非负的边容量c:E→R+c:E\\rightarrow\\mathbb R_+c:E→R+​。定义∂S\\partial S∂S为S⊆VS\\subseteq VS⊆V的边界，∂S:={{u,v}∈E:∣S∩{u,v}∣=1}\\partial S:=\\{\\{u,v\\}\\in E:|S\\cap\\{u,v\\}|=1\\}∂S:={{u,v}∈E:∣S∩{u,v}∣=1}，那么函数f(S)=∑e∈∂Sc(e)f(S)=\\sum_{e\\in\\partial S}c(e)f(S)=∑e∈∂S​c(e)是次模的，但一般不单调。 关于子图的边界，可以理解在一个固定拓扑下，通过寻找有效链路，不断扩张网络拓扑的备选集。 如两条紫线就是红色区域子图的边界，是拓扑扩张的选择。 保次模运算 对次模函数进行非负线性组合，次模性仍然保持 如果g1,...,gn:2V→Rg_1,...,g_n:2^V\\rightarrow\\mathbb Rg1​,...,gn​:2V→R是次模的，并且α1,...,αn≥0\\alpha_1,...,\\alpha_n\\ge0α1​,...,αn​≥0，那么f(S):=∑i=1nαigi(S)f(S):=\\sum_{i=1}^n\\alpha_ig_i(S)f(S):=∑i=1n​αi​gi​(S)也是次模 对次模函数取残差，次模性仍然保持 如果g:2V→Rg:2^V\\rightarrow\\mathbb Rg:2V→R是次模的，并且A,B⊂VA,B\\subset VA,B⊂V是并查集，那么定义为f(S):=g(S∪B)−g(B)f(S):=g(S\\cup B)-g(B)f(S):=g(S∪B)−g(B)的f:2A→Rf:2^A\\rightarrow\\mathbb Rf:2A→R是次模的。 📌数学中的并查集与数据结构的并查集不同，数学中的并查集(disjoint sets)是没有交集的集合 单调次模函数截断后仍是单调次模 如果g:2V→Rg:2^V\\rightarrow\\mathbb Rg:2V→R是次模的，那么对任意常数c，f(S):=min⁡{g(S),c}f(S):=\\min\\{g(S),c\\}f(S):=min{g(S),c}也是次模的。 📌对两个次模函数进行min/max操作得到的函数并不是次模函数：次模函数f1,f2f_1,f_2f1​,f2​，则函数fmin⁡(S)=min⁡(f1(S),f2(S))f_{\\min}(S)=\\min(f_1(S),f_2(S))fmin​(S)=min(f1​(S),f2​(S))以及fmax⁡(S)=max⁡(f1(S),f2(S))f_{\\max}(S)=\\max(f_1(S),f_2(S))fmax​(S)=max(f1​(S),f2​(S))不一定是次模的 对于函数g:N→Rg:\\mathbb N\\rightarrow\\mathbb Rg:N→R，若ggg是凹的，则集函数f(S)=g(∣S∣)f(S)=g(|S|)f(S)=g(∣S∣)是次模函数。 📌任意非减次模函数g:2V→Rg:2^V\\rightarrow\\mathbb Rg:2V→R和任意非减凹函数h:R→Rh:\\mathbb R\\rightarrow\\mathbb Rh:R→R的组合都是次模函数 给定一个集合B⊆VB\\subseteq VB⊆V和一个次模函数g:2B→Rg:2^B\\rightarrow\\mathbb Rg:2B→R，那么定义为f(A)=g(B∩A)f(A)=g(B\\cap A)f(A)=g(B∩A)的函数f:2V→Rf:2^V\\rightarrow\\mathbb Rf:2V→R也是次模的。 给定一个集合B⊆VB\\subseteq VB⊆V和一个次模函数g:2V→Rg:2^V\\rightarrow\\mathbb Rg:2V→R，那么定义为f(A)=g(A)f(A)=g(A)f(A)=g(A)的函数f:2B→Rf:2^B\\rightarrow\\mathbb Rf:2B→R也是次模的。 若fff是非负次模函数满足f(ϕ)=0f(\\phi)=0f(ϕ)=0，定义g(A)=min⁡B⊇AF(B)g(A)=\\min_{B\\supseteq A}F(B)g(A)=minB⊇A​F(B)，那么ggg也是次模的并且满足g(ϕ)=0g(\\phi)=0g(ϕ)=0。 若定义在V∪WV\\cup WV∪W上的函数ggg是次模的，并且V∩W=ϕV\\cap W=\\phiV∩W=ϕ，那么对于A⊆VA\\subseteq VA⊆V，定义为f(A)=min⁡B⊆Wg(A∪B)−min⁡B⊆Wg(B)f(A)=\\min_{B\\subseteq W}g(A\\cup B)-\\min_{B\\subseteq W}g(B)f(A)=minB⊆W​g(A∪B)−minB⊆W​g(B)也是次模的。 2 次模函数最小化 次模（拟阵）多面体 令RV\\bold R^VRV表示所有实值函数x:V→Rx:V\\rightarrow\\bold Rx:V→R的集合，这构成了一个维度为∣V∣|V|∣V∣的线性空间。定义向量x∈RVx\\in\\bold R^Vx∈RV用于描述模函数x(Y)=∑v∈Yx(v)x(Y)=\\sum_{v\\in Y}x(v)x(Y)=∑v∈Y​x(v)，也就是x(Y)=xT1Yx(Y)=x^T1_Yx(Y)=xT1Y​，1Y1_Y1Y​是YYY在VVV内的指示函数。（所以也就是∣V∣|V|∣V∣维向量） 定义次模多面体（也可叫拟阵多面体）为P(f)={x∣x∈RV,∀Y⊆V,x(Y)≤f(Y)}P(f)=\\{x|x\\in\\bold R^V,\\forall Y\\subseteq V,x(Y)\\le f(Y)\\}P(f)={x∣x∈RV,∀Y⊆V,x(Y)≤f(Y)} 定义基多面体为B(f)={x∣x∈P(f),x(V)=f(V)}B(f)=\\{x|x\\in P(f),x(V)=f(V)\\}B(f)={x∣x∈P(f),x(V)=f(V)} 可以看出来基多面体就是次模多面体中“使模函数最大”的向量的集合 以上两个定义的前提是fff是次模函数 一般研究次模多面体，都是要解可行域是次模多面体时的线性规划问题 定义次模多面体中的线性规划问题：给定有限集VVV以及一个集函数f:2V→Rf:2^V\\rightarrow\\mathbb Rf:2V→R，f(ϕ)≥0f(\\phi)\\ge0f(ϕ)≥0，还有一个权重向量w∈R+Vw\\in\\mathbb R_+^Vw∈R+V​， 求解max⁡x wx:x∈P(f)\\max_x\\ wx:x\\in P(f)maxx​ wx:x∈P(f) Lovasz extension：次模函数最小化最优解存在性 参考文献 fff的Lovasz延伸f^\\hat ff^​ 三种等价的延伸方式： 1.f^(z)=Eλ∼[0,1]f({i:zi≥λ})\\hat f(z)=\\mathbb E_{\\lambda\\sim[0,1]}f(\\{i:z_i\\ge\\lambda\\})f^​(z)=Eλ∼[0,1]​f({i:zi​≥λ}) 即对函数f:{0,1}[n]→Rf:\\{0,1\\}^{[n]}\\rightarrow\\mathbb Rf:{0,1}[n]→R，可定义延伸为f^(z)=∑i=0nλif({i:zi≥λ})\\hat f(z)=\\sum_{i=0}^{n}\\lambda_if(\\{i:z_i\\ge\\lambda\\})f^​(z)=∑i=0n​λi​f({i:zi​≥λ}) 2. 升序排列ziz_izi​，使得zn≤zn−1≤...≤z2≤z1z_n\\le z_{n-1}\\le...\\le z_2\\le z_1zn​≤zn−1​≤...≤z2​≤z1​，令Si:={1,2,...,i}S_i:=\\{1,2,...,i\\}Si​:={1,2,...,i}，那么f^(z):=∑i=1n(zi−zi+1)f(Si)\\hat f(z):=\\sum_{i=1}^{n}(z_i-z_{i+1})f(S_i)f^​(z):=∑i=1n​(zi​−zi+1​)f(Si​)，令zn+1=0z_{n+1}=0zn+1​=0，可看到f^(cz)=cf^(z),∀c∈R\\hat f(cz)=c\\hat f(z),\\forall c\\in\\mathbb Rf^​(cz)=cf^​(z),∀c∈R。则可以得到另一种等价的表述f^(z):=∑i=1nzi(f(Si)−f(Si−1))\\hat f(z):=\\sum_{i=1}^nz_i(f(S_i)-f(S_{i-1}))f^​(z):=∑i=1n​zi​(f(Si​)−f(Si−1​))，f(ϕ)=0f(\\phi)=0f(ϕ)=0。 3. f^(z)\\hat f(z)f^​(z)是LP问题：max⁡ zTx,s.t. x∈B(f)\\max\\ z^Tx,\\quad s.t.\\ x\\in B(f)max zTx,s.t. x∈B(f) 的最优解。B(f)B(f)B(f)即为基多面体。 📌定理1：一个集函数fff是次模函数当且仅当f^\\hat ff^​是凸函数 📌定理2：min⁡A⊆Vf(A)=min⁡w∈{0,1}pf^(w)=min⁡w∈[0,1]pf^(w)\\min_{A\\subseteq V}f(A)=\\min_{w\\in\\{0,1\\}^p}\\hat f(w)=\\min_{w\\in[0,1]^p}\\hat f(w)minA⊆V​f(A)=minw∈{0,1}p​f^​(w)=minw∈[0,1]p​f^​(w) 3 次模函数最大化 📌以下所述算法均考虑单调次模函数，非单调太难求解，不作叙述 贪心算法 max⁡S⊆Vf(S) subject to some constraints on S\\max_{S\\subseteq V}f(S)\\text{ subject to some constraints on }S S⊆Vmax​f(S) subject to some constraints on S 最简单的例子是势约束，即∣S∣≤k|S|\\le k∣S∣≤k。这是一个NP-hard问题难以求解，用贪心算法可以有数学上的近似度保证。 贪心算法解决势约束问题： 贪心：从空集S0S_0S0​开始，在第iii次迭代增加一个可以最大化离散导数Δ(e∣Si−1)\\Delta(e|S_{i-1})Δ(e∣Si−1​)的元素，即Si=Si−1∪{arg max⁡eΔ(e∣Si−1)}S_i=S_{i-1}\\cup\\{\\argmax_e\\Delta(e|S_{i-1})\\}Si​=Si−1​∪{argmaxe​Δ(e∣Si−1​)}. 📌定理：非负单调次模函数f:2V→R+f:2^V\\rightarrow\\mathbb R_+f:2V→R+​并令{Si}i≥0\\{S_i\\}_{i\\ge0}{Si​}i≥0​为上述算法贪心选择出的集合，那么对所有正整数kkk和lll，f(Sl)≥(1−e−l/k)max⁡S:∣S∣≤kf(S)f(S_l)\\ge(1-e^{-l/k})\\max_{S:|S|\\le k}f(S)f(Sl​)≥(1−e−l/k)maxS:∣S∣≤k​f(S)。 特别地，当l=kl=kl=k时，f(Sk)≥(1−1/e)max⁡∣S∣≤kf(S)f(S_k)\\ge(1-1/e)\\max_{|S|\\le k}f(S)f(Sk​)≥(1−1/e)max∣S∣≤k​f(S)，大约为63%的近似度。 轻微改动允许l≠kl\\neq kl=k可能是很有用的，例如，让贪心算法能选5k5k5k个传感器，近似度可从.63上升到.99 贪心算法解决拟阵约束问题： max⁡S∈If(S)\\max_{S\\in\\mathcal I}f(S) S∈Imax​f(S) 其中(V,I)(V,\\mathcal I)(V,I)是拟阵。 贪心：从SGS_GSG​出发，设置每次迭代SG←SG∪{arg max⁡e∉SG:SG∪{e}∈IΔ(e∣SG)}S_G\\leftarrow S_G\\cup\\{\\argmax_{e\\notin S_G:S_G\\cup\\{e\\}\\in\\mathcal I}\\Delta(e|S_G)\\}SG​←SG​∪{argmaxe∈/SG​:SG​∪{e}∈I​Δ(e∣SG​)}，直到不再有eee使得SG∪{e}∈IS_G\\cup\\{e\\}\\in\\mathcal ISG​∪{e}∈I为止。这样可以保证最终结果SGS_GSG​满足f(SG)≥12max⁡S∈If(S)f(S_G)\\ge\\frac 1 2\\max_{S\\in\\mathcal I}f(S)f(SG​)≥21​maxS∈I​f(S)。 更一般地，考虑(V,I1),...,(V,Ip)(V,\\mathcal I_1),...,(V,\\mathcal I_p)(V,I1​),...,(V,Ip​)是p个拟阵，并且I=⋂iIi\\mathcal I=\\bigcap_i\\mathcal I_iI=⋂i​Ii​，即使(V,I)(V,\\mathcal I)(V,I)不再是一个拟阵，上述贪心算法仍可得到近似最优解，满足f(SG)≥1p+1max⁡S∈If(S)f(S_G)\\ge\\frac 1{p+1}\\max_{S\\in\\mathcal I}f(S)f(SG​)≥p+11​maxS∈I​f(S)。 最小代价覆盖(Min-cost Coverage)： 除了要最大化一个满足约束条件的单调次模函数，还有一类问题需要最小化代价同时满足次模函数值达到目标值q，即 S∗=arg min⁡S∣S∣ s.t. f(S)≥q0&lt;q≤f(V)S^*=\\argmin_{S}|S|\\ s.t.\\ f(S)\\ge q\\\\0&lt;q\\le f(V) S∗=Sargmin​∣S∣ s.t. f(S)≥q0&lt;q≤f(V) 对于上述场景，可理解为部署尽可能少的传感器，期望能够检测所有可能污染的环境。 📌定理：若f:2V→Nf:2^V\\rightarrow\\mathbb Nf:2V→N是单调次模且整数值的，且0≤q≤f(V)0\\le q\\le f(V)0≤q≤f(V)。令S0,S1,...S_0,S_1,...S0​,S1​,...作为贪心算法选取的集合的序列，令lll是能够让f(Sl)≥qf(S_l)\\ge qf(Sl​)≥q的最小索引，那么l≤(1+ln⁡max⁡v∈Vf({v}))OPTl\\le(1+\\ln\\max_{v\\in V}f(\\{v\\}))OPTl≤(1+lnmaxv∈V​f({v}))OPT。 其中OPT=min⁡S∣S∣ s.t. f(S)≥qOPT=\\min_S|S|\\ s.t.\\ f(S)\\ge qOPT=minS​∣S∣ s.t. f(S)≥q 可以证明，若VVV的元素对应的代价是非均匀的，也可以用轻微修正版贪心算法取得相同的近似度。 📌以上贪心算法均可用Lazy Greedy优化加速，此处不祥述 背包约束 在一些应用场景下，元素v∈Vv\\in Vv∈V可能有非均匀的代价c(s)≥0c(s)\\ge0c(s)≥0，此时希望被选择的元素的代价之和不超过预算，并且最大化目标函数： max⁡Sf(S) s.t. ∑v∈Sc(v)≤B\\max_{S}f(S)\\ s.t.\\ \\sum_{v\\in S}c(v)\\le B Smax​f(S) s.t. v∈S∑​c(v)≤B 对于这样的问题，上一节所述标准贪心算法可能不再适用，此时考虑修改版贪心算法：cost-benefit cost-benefit贪心：从空集开始S0=ϕS_0=\\phiS0​=ϕ，每次迭代 Si+1=Si∪{arg max⁡v∈V∖Si:c(v)≤B−c(Si)Δ(e∣Si)c(v)}S_{i+1}=S_i\\cup\\{\\argmax_{v\\in V\\setminus S_i:c(v)\\le B-c(S_i)}\\frac{\\Delta(e|S_i)}{c(v)}\\} Si+1​=Si​∪{v∈V∖Si​:c(v)≤B−c(Si​)argmax​c(v)Δ(e∣Si​)​} 即使采用这种考虑了预算和代价的算法，也没有数学上性能的保障，理论上也可能会获得很差的效果。但是，用此算法求的解SucS_{uc}Suc​，和认为代价是均匀时用贪心所求的解ScbS_{cb}Scb​，二者必有一个解是不坏的解，可证明max⁡{f(Suc),f(Scb)}≥1−1/e2OPT\\max\\{f(S_{uc}),f(S_{cb})\\}\\ge\\frac{1-1/e}2 OPTmax{f(Suc​),f(Scb​)}≥21−1/e​OPT。 多线性延伸(Multilinear extension) 详细参考文献 数学表述： 所谓延伸，就是将集合表示成二进制向量，二进制向量中的每个元素标志集合中对应元素选或不选，即可将集函数f:2V→Rf:2^V\\rightarrow\\mathbb Rf:2V→R表示为超立方体函数f~:{0,1}n→R\\tilde f:\\{0,1\\}^n\\rightarrow\\mathbb Rf~​:{0,1}n→R，n=∣V∣n=|V|n=∣V∣，则f~(eS)=f(S)\\tilde f(e_S)=f(S)f~​(eS​)=f(S)。此时每个问题的解就是超立方体的顶点集，可进一步松弛超立方体函数：f^:[0,1]n→R\\hat f:[0,1]^n\\rightarrow\\mathbb Rf^​:[0,1]n→R使得问题化为连续函数，更易求解。再对所求连续解取整即可。 求次模最小化问题，可利用Lovasz技术，而最大化问题则可以使用Multilinear技术，函数为： f^(x)=∑S⊆Vf(S)∏i∈Sxi∏j∈V∖S(1−xj)\\hat f(x)=\\sum_{S\\subseteq V}f(S)\\prod_{i\\in S}x_i\\prod_{j\\in V\\setminus S}(1-x_j) f^​(x)=S⊆V∑​f(S)i∈S∏​xi​j∈V∖S∏​(1−xj​) 可以从概率的角度对上述函数进行解释，这个函数就是所有随机子集按各元素概率被选择的期望，令XXX为对应概率向量x∈[0,1]nx\\in[0,1]^nx∈[0,1]n的随机子集，则Multilinear函数可用另一种方式描述为： f^(x)=EX∼x[f(X)]\\hat f(x)=\\mathbb E_{X\\sim x}[f(X)]f^​(x)=EX∼x​[f(X)]。 📌定理：令FFF是集函数fff的Multilinear延伸，则 1. 若fff是非减的，那么FFF在任何方向d≥0d\\ge0d≥0也是非减的 2. 若fff是次模的，那么FFF在任何方向d≥0d\\ge0d≥0是凹的 📌上述延伸函数可能会带来这样的困惑：既然求所有SSS的f(S)f(S)f(S)，那么直接可以在这些结果里找到最合适的SSS，又何必延伸成一个连续函数，求连续函数最优解，再取整回来呢？ 事实上，这样的延伸并不是为了求前面所说的max⁡f(S)\\max f(S)maxf(S)问题，而是为了求Submodular Welfare Problem(分蛋糕问题) 分蛋糕问题： 有n个物品的集合N={1,...,n}N=\\{1,...,n\\}N={1,...,n}，有m个智能体的集合M={1,...,m}M=\\{1,...,m\\}M={1,...,m} 每个智能体i∈Mi\\in Mi∈M对物品的子集都有一个价值函数vi:2N→R+v_i:2^N\\rightarrow\\mathbb R^+vi​:2N→R+。价值函数单调且次模。 物品可以被分为m个组(S1,...,Sm)(S_1,...,S_m)(S1​,...,Sm​)，满足Si⊆N, for all i∈MS_i\\subseteq N,\\text{ for all }i\\in MSi​⊆N, for all i∈M并且Si∩Sj=ϕS_i\\cap S_j=\\phiSi​∩Sj​=ϕ。那么所有智能体对分组collection S=(S1,...,Sm)S=(S_1,...,S_m)S=(S1​,...,Sm​)的总价值函数为v(S)=∑i=1mvi(Si)v(S)=\\sum_{i=1}^m v_i(S_i)v(S)=∑i=1m​vi​(Si​)，希望找到一个合适的分组使得总价值函数最大化。 用数学模型重写上述问题，就是： S⊆M×NS\\subseteq M\\times NS⊆M×N，(i,j)∈S(i,j)\\in S(i,j)∈S表示将物品jjj分配给智能体iii。由于一个物品不能分配给多个智能体，所以有∀j∈N,∣{i∣(i,j)∈S}∣≤1\\forall j\\in N,|\\{i|(i,j)\\in S\\}|\\le1∀j∈N,∣{i∣(i,j)∈S}∣≤1。总价值函数可写为v(S)=∑i∈Mvi({j∣(i,j)∈S})v(S)=\\sum_{i\\in M}v_i(\\{j|(i,j)\\in S\\})v(S)=∑i∈M​vi​({j∣(i,j)∈S})。 于是分蛋糕问题可简化为： max⁡S∈Iv(S)\\max_{S\\in I}v(S) S∈Imax​v(S) III是所有满足约束∀j∈N,∣{i∣(i,j)∈S}∣≤1\\forall j\\in N,|\\{i|(i,j)\\in S\\}|\\le1∀j∈N,∣{i∣(i,j)∈S}∣≤1的SSS的collection。 采用Multilinear技术松弛分蛋糕问题： 为(i,j)∈M×N(i,j)\\in M\\times N(i,j)∈M×N定义决策变量xij∈[0,1]x_{ij}\\in[0,1]xij​∈[0,1]，∑i∈Mxij≤1,j∈N\\sum_{i\\in M}x_{ij}\\le1,j\\in N∑i∈M​xij​≤1,j∈N。可行域可被描述为一个超立方体P={x∈[0,1]m×n∣∀j∈N,∑i∈Mxij≤1}P=\\{x\\in[0,1]^{m\\times n}|\\forall j\\in N,\\sum_{i\\in M}x_{ij}\\le1\\}P={x∈[0,1]m×n∣∀j∈N,∑i∈M​xij​≤1}。总价值函数可松弛为F(x)=EX∼x[v(X)]=∑i∈MEX∼x[vi({j∣(i,j)∈X})]=∑i∈ME[vi(Xi)]F(x)=\\mathbb E_{X\\sim x}[v(X)]=\\sum_{i\\in M}\\mathbb E_{X\\sim x}[v_i(\\{j|(i,j)\\in X\\})]=\\sum_{i\\in M}\\mathbb E[v_i(X_i)]F(x)=EX∼x​[v(X)]=∑i∈M​EX∼x​[vi​({j∣(i,j)∈X})]=∑i∈M​E[vi​(Xi​)]。 原问题被改为： max⁡xF(x)s.t.x∈P\\max_{x}F(x)\\\\s.t.\\quad x\\in P xmax​F(x)s.t.x∈P 由于要求全部子集仍然运算量非常大，因此可以用切诺夫界(Chernoff Bound) Continuous Greedy Algorithm： 算法流程： 输入: F,PF,PF,P 1: 定义：vmax(x)=arg max⁡v∈P(vT⋅ΔF(x))v_{max}(x)=\\argmax_{v\\in P}(v^T\\cdot\\Delta F(x))vmax​(x)=argmaxv∈P​(vT⋅ΔF(x)) 2: x(0)←0∈Rnx(0)\\leftarrow0\\in\\mathbb R^nx(0)←0∈Rn 3: for t∈[0,1]t\\in[0,1]t∈[0,1] do 4: x′(t)=vmax(x(t))x&#x27;(t)=v_{max}(x(t))x′(t)=vmax​(x(t)) 5: end for 6: return x(1)x(1)x(1) 算法有效性： x(1)∈PF(x(1))≥(1−1e)OPTx(1)\\in P\\\\F(x(1))\\ge(1-\\frac 1 e)OPT x(1)∈PF(x(1))≥(1−e1​)OPT 📌最后取整可用pipage rounding 次模与路由——图次模优化 AAAI 2016论文 4 Case Study INFOCOM 2019论文","categories":[{"name":"数学","slug":"数学","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数学方法","slug":"数学方法","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6%E6%96%B9%E6%B3%95/"}]},{"title":"JavaScript","slug":"JavaScript","date":"2020-02-24T08:54:31.000Z","updated":"2022-07-10T13:37:30.591Z","comments":true,"path":"2020/02/24/JavaScript/","link":"","permalink":"http://example.com/2020/02/24/JavaScript/","excerpt":"","text":"JavaScript 1 在HTML中使用JS 方式1 123&lt;script&gt; console.log(&#x27;Hello World!&#x27;);&lt;/script&gt; 方式2 1&lt;script&gt;src = &quot;main.js&quot;&lt;/script&gt; 12//main.jsconsole.log(&#x27;Hello World!&#x27;) 2 变量 三种方式声明 var：全局作用域，最不常用 let：可重新赋值的局部变量 const：不可重新赋值的局部变量；必须初始化，否则报错；最常用 3 数据类型 12345678910//string number boolean null undefinedconst name = &#x27;John&#x27;; //stringconst age = 30; //numberconst rating = 4.5; //numberconst isCool = true; //booleanconst x = null; //nullconst y = undefined; //undefinedlet z; //undefined//查看变量的数据类型：typeofconsole.log(typeof x);//此时会输出object而不是null，这是JS的一个bug JS的数字不区分整形和浮点数 4 字符串 字符串中加入变量 123456const name = &#x27;John&#x27;;const age = 30;//方式1：拼接console.log(&#x27;My name is &#x27;+name+&#x27; and I am &#x27;+age);//方式2：模板字符串，需反引号console.log(`My name is $&#123;name&#125; and I am $&#123;age&#125;`); 部分字符串属性与方法 123456789const s = &#x27;Hello World!&#x27;;console.log(s.length);//长度属性console.log(s.toUpperCase());//转大写方法console.log(s.toLowerCase());//转小写方法console.log(s.substring(0,5));//截取子串，从0开始，在5之前结束，输出&#x27;Hello&#x27;console.log(s.substring(0,5).toUpperCase());//HELLO//分割字符串到数组中const v = &#x27;technology, computer, it, code&#x27;console.log(v.split(&#x27;, &#x27;))//输出[technology,computer,it,code]; 5 数组 1234567891011121314151617//JS数组不需要指定长度和类型/*-------创建数组-------*///创建方式1const numbers = new Array(1,2,3,4,5);//创建方式2const fruits = [&#x27;Apple&#x27;, &#x27;Orange&#x27;, 10, true];//JS中数组可以存放不同类型值//在数组末尾添加值fruits[4]=&#x27;Mangos&#x27;;fruits.push(&#x27;Grapes&#x27;);//在数组开头添加值fruits.unshift(&#x27;Strawberries&#x27;);//数组末尾删除值fruits.pop();//判断是否是数组console.log(Array.isArray(fruits));//寻找索引console.log(fruits.indexOf(&#x27;Orange&#x27;)); 6 对象 JS中的对象就是键值对 12345678910111213141516const person = &#123; firstName:&#x27;John&#x27;, lastName:&#x27;Doe&#x27;, age:30, hobbies:[&#x27;music&#x27;,&#x27;movie&#x27;,&#x27;sport&#x27;], address:&#123;//对象里可以嵌套对象 street:&#x27;50 main st&#x27;, city:&#x27;Boston&#x27;, state:&#x27;MA&#x27; &#125;&#125;//找到&#x27;movie&#x27;person.hobbies[1]//找到Bostonperson.address.city 定义后仍可添加属性 1person.email = &#x27;john@gmail.com&#x27; 解构 1234567const &#123;firstName, lastName&#125; = person;//firstName变量被创建，并赋值为person.firstName，即Bob//lastName变量被创建，并赋值为person.lastName，即Doe//对象里的嵌套对象的属性也可以被结构const &#123;firstName, lastName, address:&#123;city&#125;&#125; = person;//city变量被创建，并赋值为person.address.city，即Boston 对象数组 JSON 1234567891011121314151617const todos = [ &#123; id: 1, text: &#x27;Take out trash&#x27;, isCompleted:true &#125;, &#123; id: 2, text: &#x27;Meeting with boss&#x27;, isCompleted:true &#125;, &#123; id: 3, text: &#x27;Dentist appt&#x27;, isCompleted:false &#125;]; 123456789101112131415161718[ &#123;//所有属性要加上双引号 &quot;id&quot;: 1, //字符串不能再用单引号 &quot;text&quot;: &quot;Take out trash&quot;, isCompleted:true &#125;, &#123; &quot;id&quot;: 2, &quot;text&quot;: &quot;Meeting with boss&quot;, &quot;isCompleted&quot;:true &#125;, &#123; &quot;id&quot;: 3, &quot;text&quot;: &quot;Dentist appt&quot;, &quot;isCompleted&quot;:false &#125;] 12//对象数组转JSONconst todoJSON = JSON.stringify(todos); 7 循环 12345678910111213141516171819202122232425262728293031//forfor(let i = 0; i &lt; 10; i++)&#123; console.log(i);&#125;//whilelet i = 0;while(i &lt; 10)&#123; console.log(i); i++;&#125;//for...offor(let todo of todos)&#123; console.log(todo.text);&#125;//forEach：foreach是方法，输入参数为函数，该函数为每一个数组元素执行任务，无返回值todos.forEach(function(todo)&#123;//todo可被看作每个数组元素的代称 console.log(todo.text);&#125;); //map：与forEach一致，但是有返回值，最后会创建新数组，不影响旧数组const todoText = todos.map(function(todo)&#123; return todo.text;&#125;); //filter：也会返回新数组，但是只摘取原数组中满足条件的元素const todoCompleted = todos.filter(function(todo)&#123; return todo.isCompleted === true;&#125;); 8 条件 1234567if(a &gt; 5)&#123; console.log(&#x27;a is bigger than 5&#x27;);&#125;else if(a &lt; 5)&#123; console.log(&#x27;a is less than 5&#x27;);&#125;else&#123; console.log(&#x27;a is equal to 5&#x27;);&#125; 1234567891011switch(color)&#123;case &#x27;blue&#x27;: console.log(&#x27;color is blue&#x27;); break;case &#x27;red&#x27;: console.log(&#x27;color is red&#x27;); break;default: console.log(&#x27;color is others&#x27;); break;&#125; JS中=要求数据类型一致且数值相等；而不要求数据一致，‘10’==10，自动类型转换 9 函数 典型函数 1234//格式：function 函数名(参数名,...)&#123;&#125;function addNums(num1 = 1, num2 = 1)&#123;//这里只是设置默认值，可不写= return num1+num2;&#125; 箭头函数，好处体现在只有一行的函数可以写得简短些 123const addNums(num1 = 1, num2 = 1) =&gt; &#123; return num1+num2;&#125; 10 面向对象 12345678910111213/*-------假设已经定义person对象为例-------*///构造函数function Person(firstName,lastName,dob)&#123; this.firstName = firstName; this.lastName = lastName; this.dob = new Date(dob); //创建方法 this.getBirthday = function()&#123; return this.dob.getFullYear(); &#125;&#125;//初始化const person1 = new Person(&#x27;John&#x27;,&#x27;Doe&#x27;,&#x27;4-3-1980&#x27;); 原型 原型是所有对象都会继承的对象，可以通过在原型添加属性、方法，实现在对象中添加属性与方法 12345678910111213function Person(firstName,lastName,dob)&#123; this.firstName = firstName; this.lastName = lastName; this.dob = new Date(dob);&#125;//创建方法Person.prototype.getBirthday = function()&#123; return this.dob.getFullYear();&#125;//初始化const person1 = new Person(&#x27;John&#x27;,&#x27;Doe&#x27;,&#x27;4-3-1980&#x27;);//调用方法不需要写原型person1.getBirthday(); 类：ES6引入先特性，与上述对象行为一致，只是写法更清晰 123456789101112class Person &#123; //构造函数 constructor(firstName, lastName, dob)&#123; this.firstName = firstName; this.lastName = lastName; this.dob = new Date(dob); &#125; //方法 getBirthday()&#123; return this.dob.getFullYear(); &#125;&#125; 11 DOM DOM(Document Object Model)，是借助window对象的document属性，获取HTML的ID、类、标签、文本等等元素，并且可以对HTML\\CSS进行修改，从而获取有用数据或者改变网页状态。 window对象就是浏览器的窗口，网页应用皆继承window对象 1 12 同步与异步","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"Go语言基础","slug":"Golang/Golang","date":"2019-12-21T05:22:57.000Z","updated":"2022-07-10T13:23:24.404Z","comments":true,"path":"2019/12/21/Golang/Golang/","link":"","permalink":"http://example.com/2019/12/21/Golang/Golang/","excerpt":"","text":"Golang 基础语法 1. Workspace go(workspace) -bin 存放二进制 -src 存放源文件 github.com username go_project_1 file_1 … go_project_2 file_1 … -pkg 存放安装的包 建立go语言的workspace前提是将GOPATH设置成了环境变量，可用go env查看GOPATH go语言的工程结构比较严格，参见上面的文件树 可通过godoc.org查看可安装包，利用go get安装 2. Hello World ! 12345package mainimport &quot;fmt&quot;func main()&#123; fmt.Println(&quot;Hello World!&quot;)&#125; 文件结构：包声明 → 导入包 → 函数 包声明：指明文件属于哪个包，package main执行入口，每个应用程序都有package main 导入包需双引号，单引号会报错 无需分号 3. 变量与数据类型 123456789101112131415161718192021222324252627282930package mainimport &quot;fmt&quot;func main()&#123; //MAIN TYPES //string //bool //int(对应CPU平台字长) int8 int16 int32 int64 //uint(对应CPU平台字长) uint8 uint16 uint32 uint64 uintptr //byte - alias for uint8 //rune - alias for int32 //float32 float64 //complex64 complex128 /*---------定义变量 第一种方法：var关键字---------*/ /*格式：var + 变量名 + 数据类型 = 赋值*/ var name_1 string = &quot;oliver&quot;//这里的string可省略，编译器可推断出它是string类型 var age = 32//编译器推断出是int类型 name_1 = &quot;Peter&quot;//使用var关键字定义后可修改变量值 /*使用const关键字*/ const isCool = true//省略bool //isCool = false 不注释会报错 /*---------定义变量 第二种方法：冒号---------*/ /*格式：变量名 := 赋值*/ name_2 := &quot;Pai&quot; /*多变量定义的简便写法*/ name_3,email := &quot;oliverPai&quot;,&quot;oliver@gmail.com&quot; fmt.Println(name_1,name_2,name_3,age,isCool,email)&#125; go语言中，变量声明不使用会报错 获取类型方法：fmt.Printf(“%T”,variables) 第一种方法可以在函数外声明变量，第二种方法只能用于函数内，且无法指定类型 go语言中没有专门的字符类型，字符串由一个个字节构成 注意，go语言不支持隐式做int和bool类型间的转换，需要自己写btoi或itob函数 go、string与float64之间的转换 12345678910111213141516171819202122232425//-------------------------- int转string ------------------------------i := int64(123)s := strconv.Itoa(i)s := strconv.FormatInt(i, 10)//-------------------------- string转int ------------------------------i, err := strconv.Atoi(s)i, err := strconv.ParseInt(s, 10, 64)//转int64//第二个参数为基数，第三个参数位大小表示期望转换的结果类型，其值可以为0, 8, 16, 32和64//float转stringv := 3.1415926535s1 := strconv.FormatFloat(v, &#x27;E&#x27;, -1, 32)//&#x27;e&#x27;&amp;&#x27;E&#x27;: 表示10进制指数//&#x27;b&#x27;: 表示2进制指数//&#x27;f&#x27;: 无指数，正常形式//&#x27;g&#x27;&amp;&#x27;G&#x27;: 大数用&#x27;e&#x27;表示，否则用&#x27;f&#x27;//&#x27;x&#x27;&amp;&#x27;X&#x27;: 16进制表示的二进制指数//-1是精度float32s2 := strconv.FormatFloat(v, &#x27;E&#x27;, -1, 64)//float64//string转floats := &quot;3.1415926535&quot;v1, err := strconv.ParseFloat(v, 32)v2, err := strconv.ParseFloat(v, 64) 4. 包package 导入多个包：包之间无需逗号，空格间隔即可。不同包需写在不同行，需要圆括号 1234import ( &quot;fmt&quot; &quot;math&quot;) 新建自己的包 新建文件夹，新建函数的文件 在文件顶部声明包名（不需要与文件夹同名） 在文件内写函数 123456789//创建strutil文件夹，新建reverse.go文件package strutilfunc reverse(s string) string &#123; runes := []rune(s) for i,j := 0,len(runes)-1 ; i&lt;j ; i,j = i+1, j-1&#123; runes[i],runes[j] = runes[j],runes[i] &#125; return string(runes)&#125; 新建后，导入包路径需从src开始，如reverse.go存在/src/github.com/oliverPai/strutil/reverse.go，则导入包时为import “github.com/oliverPai/strutil” 导入go get获取的包，与导入自己的包一样操作，如aws包 import “github.com/aws” 5 数组array&amp;slice 1234567891011/*------Array 定长数组------*//*先声明后赋值*/var fruitArr [2] stringfruitArr[0] = &quot;Apple&quot;fruitArr[1] = &quot;Orange&quot;/*声明并赋值*/fruitArr_1 := [2]string&#123;&quot;Apple&quot;,&quot;Orange&quot;&#125;/*------Slice 不定长数组------*/fruitSlice := []string&#123;&quot;Apple&quot;,&quot;Orange&quot;,&quot;Grape&quot;&#125; 统计数组元素个数可用len函数 数组支持切片操作，如fmt.Println(fruitSlice[1:2])输出Orange，从索引1开始，在索引2之前结束 make函数构造slice slice本质上是引用类型，可用make构造 1234567891011//格式：make([]T, size, cap)//T:切片的元素类型//size:切片中元素的数量//cap:切片的容量func main() &#123; a := make([]int, 2, 10) fmt.Println(a) //[0 0] fmt.Println(len(a)) //2 fmt.Println(cap(a)) //10&#125;//如果是make([]int,2),则len为2 slice元素的增删 append函数可以用来在slice末尾追加元素 12345678func main()&#123; var s []int s = append(s, 1) // [1] s = append(s, 2, 3, 4) // [1 2 3 4] s2 := []int&#123;5, 6, 7&#125; //对一个slice添加另一个slice的元素时，需要加上... s = append(s, s2...) // [1 2 3 4 5 6 7]&#125; go语言中没有专门的删减slice元素的函数，但是可以通过赋值完成这一目标 12//对a中删掉索引为index的元素a = append(a[:index], a[index+1:]...) slice的拷贝 slice的拷贝分为两种情况，一种是两个slice共享一片内存区域，二者完全相同，修改一个会更改另一个的值；另一种情况是二者只是数值相同而已，修改一个不会对另一个造成影响 12345678//第一种情况，直接赋值拷贝，二者共享内存func main() &#123; s1 := make([]int, 3) //[0 0 0] s2 := s1 //将s1直接赋值给s2，s1和s2共用一个底层数组 s2[0] = 100 fmt.Println(s1) //[100 0 0] fmt.Println(s2) //[100 0 0]&#125; 123456789101112//第二种情况，使用copy函数，不共享内存func main() &#123; // copy()复制切片 a := []int&#123;1, 2, 3, 4, 5&#125; c := make([]int, 5, 5) copy(c, a) //使用copy()函数将切片a中的元素复制到切片c fmt.Println(a) //[1 2 3 4 5] fmt.Println(c) //[1 2 3 4 5] c[0] = 1000 fmt.Println(a) //[1 2 3 4 5] fmt.Println(c) //[1000 2 3 4 5]&#125; 判断slice为空应该通过len(slice)0判断，而不是slicenil 6 函数+异常 123456789101112131415161718192021222324252627282930/*格式：func 函数名(参数1 参数1类型, 参数2 参数2类型,...)(返回值1类型, 返回值2类型 ,...)&#123;&#125;*/func greeting(name string) string &#123; return &quot;Hello&quot;+name&#125;/*某些参数若同类型，可写在一起，只保留一个数据类型*/func plus(a, b int) int &#123; return a + b&#125;/*可给返回值命名，也可不命名*/func SumAndProduct(A, B int) (int, int) &#123; return A+B, A*B&#125;func change(a, b int) (x, y int) &#123;//命名可使代码阅读和书写更清晰 x = a + 100//101 y = b + 100//102 return//101 102 //return x, y //同上 //return y, x //102 101&#125;/*匿名函数*/f := func(a,b int) int&#123; return a+b&#125;//直接执行匿名函数——加括号func()&#123; fmt.Println(&quot;Anonymous&quot;)&#125;() 匿名函数可以用来做异常处理，通过defer+recover 12345678910111213141516171819package mainfunc a()&#123; fmt.Println(&quot;function a\\n&quot;)&#125;//仅用panic做异常处理func b()&#123; panic(&quot;panic in b&quot;)&#125;func c()&#123; fmt.Println(&quot;function c\\n&quot;)&#125;func main()&#123; a() b() c()&#125;//输出 function a// panic: panic in b//由于在b函数终止，因此未全部执行完 1234567891011121314151617181920//使用匿名函数+defer+recover的异常处理//defer+recover可暂时跳过出错地方func b()&#123; defer func()&#123; err := recover() if err != nil&#123;//检测到错误 fmt.Println(&quot;function b error&quot;) &#125; &#125;() panic(&quot;panic in b&quot;)&#125;//输出 function a// function b error// function c//defer会在函数要退出前执行，所以在执行到//panic时，由于出错即将退出，触发匿名函数//执行匿名函数后，不再执行panic、//defer必须写在可能引发panic的语句之前,//否则未注册defer，无法执行匿名函数//如果多个defer函数，它们会逆序执行 📌除了匿名函数+defer+recover做异常处理，还可以使用go内置的error类型 1234//error类型定义type error interface&#123; Error() string&#125; 123456//使用errors.New可返回一个错误信息func sqrt(f float64) (float64,error)&#123; if f &lt; 0&#123; return 0, errors.New(&quot;math: square root of negative number&quot;) &#125;&#125; 7 条件 if语句 12345678//go里面的if不需要圆括号if color == &quot;red&quot;&#123; fmt.Println(&quot;color is red&quot;)&#125; else if color == &quot;blue&quot;&#123; fmt.Println(&quot;color is blue&quot;)&#125; else &#123; fmt.Println(&quot;color is not red or blue&quot;)&#125; switch语句 123456789//go语言在每个case会自动加上一个break，即go里switch不需要break，同时无法控制执行case的数量switch color&#123;case &quot;red&quot;: fmt.Println(&quot;color is red&quot;)case &quot;blue&quot;: fmt.Println(&quot;color is blue&quot;)default: fmt.Println(&quot;color is not red or blue&quot;)&#125; 8 循环 1234567891011121314//写法1i := 1for i &lt;= 10 &#123; fmt.Println(i) i++&#125;//写法2for i := 1; i &lt;= 10; i++&#123; fmt.Println(i)&#125;//无限循环for &#123; //content&#125; for是go语言提供的唯一循环方式 go语言也可以在循环中用continue和break 9 Map go语言的Map是键-值对，类似于python的字典 1234567891011121314151617/*-------先声明后赋值-------*//*格式：make(map[键数据类型][值数据类型])*/emails := make(map[string]string)//赋值emails[&quot;Bob&quot;] = &quot;bob@gmail.com&quot;emails[&quot;Sharon&quot;] = &quot;sharon@gmail.com&quot;emails[&quot;Mike&quot;] = &quot;mike@gmail.com&quot;//从map中删除delete(emails,&quot;Bob&quot;)//格式：delete(map名，键名)//索引fmt.Println(emails[&quot;Sharon&quot;])/*-------声明的同时赋值-------*//*格式：:=map[键数据类型]值数据类型&#123;键1:值1,键2:值2,...&#125;*/emails := map[string]string&#123;&quot;Bob&quot;:&quot;bob@gmail.com&quot;,&quot;Sharon&quot;:&quot;sharon@gmail.com&quot;&#125;//依然可以添加东西emails[&quot;Mike&quot;] = &quot;mike@gmail.com&quot; 10 范围range range用于遍历数组、map、channel等，能够使for循环成为foreach 123456789101112131415161718192021/*-------遍历数组-------*/ids := []int&#123;33,76,25,89,14,71&#125;//range需要传入两个变量，第一项是index，第二项是index对应的元素for i,id := range ids &#123; fmt.Printf(&quot;%d - ID: %d&quot;, i, id)&#125;//当不想要index时，可用_代替for _,id := range ids &#123; fmt.Printf(&quot;ID: %d&quot;, id)&#125;/*-------遍历Map-------*/emails := map[string]string&#123;&quot;Bob&quot;:&quot;bob@gmail.com&quot;,&quot;Sharon&quot;:&quot;sharon@gmail.com&quot;&#125;//range需要传入两个变量，第一项是键，第二项是值for k,v := range emails&#123; fmt.Printf(&quot;%s: %s&quot;,k,v)&#125;//当只想要键不想要值时，可以省略第二项for k := range emails&#123; fmt.Println(&quot;Name: &quot; + k)&#125; range对数组的操作同样可以应用到字符串上，第一项index，第二项字符 11 指针 12345678910func main()&#123; a := 5 b := &amp;a//b是指向a的指针 fmt.Printf(&quot;%T&quot;,b)//输出*int //取值 fmt.Println(*b)//输出5 //改值 *b = 10 fmt.Println(a)//输出10&#125; go语言中指针的好处在于，对于操作某连续地址的一大片数据，使用指针可以提高执行效率 可以利用指针对特殊地址修改数值 12 闭包closure 闭包是函数作为返回值时，匿名函数内部访问外层变量的行为 核心在于，被访问的外层变量相当于被访问了引用，其修改后的值被一直保留 12345678910111213141516171819202122/*------例1------*/package mainimport &quot;fmt&quot;//..(..1...).(....2.......)func adder() func(int) int &#123; sum := 0//被访问的外层变量 return func(x int) int &#123; sum += x return sum &#125;&#125;func main()&#123; //将函数赋给变量时，需和1处一致 sum := adder() for i:=0; i&lt; 10; i++&#123; //调用函数变量时，需和2处一致 fmt.Println(sum(i)) &#125;&#125;//输出结果：//0 1 3 6 10 15 21 28 36 45 12345678910111213141516171819202122/*------例2------*/package mainfunc calc(base int)(func(int)int, func(int)int)&#123; add := func(int)int&#123; base += i return base &#125; sub := func(int)int&#123; base -= i return base &#125;&#125;func main()&#123; x,y := calc(100) ret1 := x(200) //base已被改成300 fmt.Println(ret1)//输出100+200=300 //由于base得以保留，此处base是300 ret2 := y(200) fmt.Println(ret2)//输出300-200=100&#125; 闭包的用处 📌A代码： func (o *Once) Do2(f func()) {} B代码： func Do1（参数） 需求： B要调用A写的o对象里的方法Do2，并把自己的Do1当作参数传到Do2 中，但是B写的Do1有传参，而A写的Do2中传入的方法参数是不能带参数的 解决办法：闭包 编写一个func Do3（参数）（func (o *Once) Do2(f func())），也就是新的Do3函数中的参数是Do1中要传入的参数，返回值是Do2，那么在Do2中就能调用Do3中传入的参数，也就是Do1中期望的参数，Do3返回的是一个函数，那这个函数调用了这个函数之外的一个变量，所以形成了一个闭包。 13 结构体 go里没有类，结构体可以有属性和方法，结构体就是类 123456789101112131415161718192021package mainimport &quot;fmt&quot;//定义一个结构体type Person struct&#123; firstName string lastName string city string gender string age int&#125;func main()&#123; //初始化结构体 person1:=Person&#123;firstName:&quot;Samantha&quot;, lastName:&quot;Smith&quot;, city:&quot;Boston&quot;, gender:&quot;f&quot;, age:25&#125; fmt.Println(person1)&#125; 12345678910111213//左边代码的简便写法//同类型可以写一起type Person struct&#123; firstName,lastName,city,gender string age int&#125;func main()&#123; //不需要指定属性名 person1 := Person&#123;&quot;Samantha&quot;,&quot;Smith&quot;, &quot;Boston&quot;,&quot;f&quot;,25&#125; fmt.Println(person1)&#125; 12345//获取属性fmt.Println(person1.firstName)//改变属性\\person1.age++fmt.Println(person1.age) 123456789101112/*-------value receiver方法：不改变任何数值-------*///格式：func (identifier 结构体名) 函数名 返回值类型&#123;&#125;func (p Person) greet() string&#123; return &quot;Hello, my name is &quot;+p.firstName+&quot; &quot;+p.lastName+&quot; and I am &quot;+strconv.Itoa(p.age) //这里的strconv.Itoa用来int转字符串，否则会报错，需事先导入strconv包&#125;/*-------pointer receiver方法：改变数值-------*///格式：func (identifier *结构体名) 函数名 返回值类型&#123;&#125;func (p *Person) hasBirthday() &#123; p.age++&#125; identifier相当于this指针，go语言没有- &gt; 结构体的方法不能写在结构体内，要写在外面 匿名字段——实现结构体的“继承” 12345678910111213141516171819//Address 地址结构体type Address struct &#123; Province string City string&#125;//User 用户结构体type User struct &#123; Name string Gender string Address //匿名字段&#125;//当需要访问User中的Address中的Province时可有两种方式var user1 User//方式1：匿名字段默认按类型名索引user1.Address.Province = Hubei//方式2：继承，直接索引，go的struct查找属性顺序：自身属性-&gt;匿名字段属性user1.Province = Hubei 一个结构体包含多个匿名字段时，若这些匿名字段包含同名属性，会导致访问报错 方法也可以被继承，包含匿名字段结构体时，可选类型为指针 123456789101112131415161718192021222324252627/Animal 动物type Animal struct &#123; name string&#125;func (a *Animal) move() &#123; fmt.Printf(&quot;%s会动！\\n&quot;, a.name)&#125;//Dog 狗type Dog struct &#123; Feet int8 *Animal //通过嵌套匿名结构体实现继承&#125;func (d *Dog) wang() &#123; fmt.Printf(&quot;%s会汪汪汪~\\n&quot;, d.name)&#125;func main() &#123; d1 := &amp;Dog&#123; Feet: 4, Animal: &amp;Animal&#123; //注意嵌套的是结构体指针 name: &quot;乐乐&quot;, &#125;, &#125; d1.wang() //乐乐会汪汪汪~ d1.move() //乐乐会动！&#125; 结构体内的标识符（变量名、函数名）首字母大写，则对外可见（别的包可以拿到），否则只能在当前包使用 对结构体中的slice赋值 1234567891011type Person struct &#123; name string age int8 act []string&#125;func main() &#123; p1 := Person&#123;name: &quot;小王子&quot;, age: 18&#125; data := []string&#123;&quot;吃饭&quot;, &quot;睡觉&quot;&#125; p1.SetAct(data)&#125; 12345//方式1：指针赋值//main中data和p.act共同变化func(p *Person)SetAct(dreams[]string)&#123; p.act = dreams&#125; 123456//方式2：拷贝赋值//改变data不会改变p.actfunc(p *Person)SetAct(dreams[]string)&#123; p.dreams = make([]string,len(dreams)) copy(p.act, dreams)&#125; 14 接口interface interface是多种结构体共性方法的集合 interface定义命名一个类型，使得不管最初是什么类型的struct，只要实现了interface中的方法，都可以被算作被interface命名的类型 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//格式/* type 接口名 interface&#123; 方法名1(参数列表1)返回值列表1 ...... &#125;*/package mainimport ( &quot;fmt&quot; &quot;math&quot;)// 定义interfacetype Shape interface &#123; area() float64&#125;//实现Circle结构体的area方法type Circle struct &#123; x, y, radius float64&#125;func (c Circle) area() float64 &#123; return math.Pi * c.radius * c.radius&#125;//实现Rectangle结构体的area方法type Rectangle struct &#123; width, height float64&#125;func (r Rectangle) area() float64 &#123; return r.width * r.height&#125;//因为实现了area方法，Rectangle和Circle都是Shape类型func getArea(s Shape) float64 &#123; return s.area()&#125;func main() &#123; circle := Circle&#123;x: 0, y: 0, radius: 5&#125; rectangle := Rectangle&#123;width: 10, height: 5&#125; fmt.Printf(&quot;Circle Area: %f\\n&quot;, getArea(circle)) fmt.Printf(&quot;Rectangle Area: %f\\n&quot;, getArea(rectangle))&#125; interface是一种类型，一种抽象的类型 利用slice和interface可以实现函数参数可变，格式：变量名…类型 12345678910111213141516171819202122//同类型可变参数func functest1(values ...int)(sum int)&#123; sum = 0 for _,i:=range values&#123; fmt.Println(i) sum += i &#125; return&#125;//参数传入方式func main()&#123; //参数可以为空 fmt.Println(functest1()) //参数可以是1个 fmt.Println(functest1(1)) //参数可以是多个 fmt.Println(functest1(1,3,4)) //参数可以是slice，必须有... var tmp []int = []int&#123;2,4,5&#125; fmt.Println(functest1(tmp...)) //**可变参函数和以slice为参数的函数不一样**&#125; 12345678910111213141516171819202122//不同类型可变参数//类型必须是空的interfacefunc functest2(values ... interface&#123;&#125;)&#123; for _,i := range values&#123; fmt.Printf(&quot;function test2:Type %T, i %v\\n&quot;,i,i) &#125; return&#125;//参数传入方式func main()&#123; //**方式1：传入interface的slice** var d[] interface&#123;&#125; d = append(d,1) d = append(d,&quot;hello&quot;) d = append(d,3.14) functest2(d...)//一定要有... //**方式2：直接传不同类型参数** functest2(&quot;hello&quot;,10)&#125; go认为，任何类型都实现了空接口，所以空接口可接受任何类型值，也可用于函数参数，接收任何类型。同时可用于map的value，扩展map功能 1234var m = make(map[string]interface&#123;&#125;)m[&#x27;name&#x27;] = &#x27;oliver&#x27;m[&#x27;age&#x27;] = agem[&#x27;hobby&#x27;] = []string&#123;&quot;篮球&quot;,&quot;羽毛球&quot;&#125; 数值接收与指针接收实现接口的区别 值接收实现的接口，即可用实现接口的结构体，也可以用该结构体的指针调用接口方法 指针接收实现的接口，只能用结构体的指针调用接口方法 123456//实现Mover接口type Mover interface &#123; move()&#125;//结构体dog，将会使用dog实现值接收接口，也将使用&amp;dog实现指针接收接口type dog struct &#123;&#125; 123456789101112131415//值实现的接口func (d dog) move() &#123; fmt.Println(&quot;狗会动&quot;)&#125;func main() &#123; var x Mover var val_rec = dog&#123;&#125; // dog类型 x = val_rec // x可以接收dog类型 var poi_rec = &amp;dog&#123;&#125;// *dog类型 x = poi_rec // x可以接收*dog类型 x.move()&#125; 123456789101112//指针实现的接口func (d *dog) move() &#123; fmt.Println(&quot;狗会动&quot;)&#125;func main() &#123; var x Mover var poi_rec = &amp;dog&#123;&#125; // *dog类型 x = poi_rec // x只能接收*dog类型 x.move()&#125; 接口类型变量 接口类型变量可以接收任何实现了该接口的类型 123456789//如果有一个Sayer接口，其内部有say方法//cat结构体和dog结构体都实现了say方法var x Sayera := cat&#123;&#125; b := dog&#123;&#125;x = a // 可以把cat实例直接赋值给xx.say() x = b // 可以把dog实例直接赋值给xx.say() 接口嵌套 123456789101112131415// Sayer 接口type Sayer interface &#123; say()&#125;// Mover 接口type Mover interface &#123; move()&#125;// 接口嵌套，生成新的animal接口type animal interface &#123; Sayer Mover&#125; 让一个结构体同时实现say()方法和move()方法，即为实现animal接口 接口类型断言 接口类型断言用于空接口存储变量时，推断出变量的类型，格式x.(T)：x是空接口变量，T是推断类型 1234567891011//x.(T)返回两个变量，第一个是x转换为T类型后的值，第二个是bool值，反映是否推断正确func main() &#123; var x interface&#123;&#125; x = &quot;Hello World&quot; v, ok := x.(string) if ok &#123; fmt.Println(v) &#125; else &#123; fmt.Println(&quot;类型断言失败&quot;) &#125;&#125; 15 反射 📌补充知识：结构体标签(tag)，只用于反射机制，格式为 key1:&quot;value1&quot; key2:&quot;value2&quot; 静态编译语言在编译时，会将变量转换成内存地址，关于变量的信息将消失不见，也无从获取； 但是go语言引入了反射机制，可以将变量的信息(变量名、变量类型等)整合到可执行文件中，从而能够实现在程序运行时对变量信息的访问。采用reflect包的API进行反射操作！ reflect.TypeOf()：获取变量类型 返回的变量是reflect.Type实例，该实例含有两个重要方法Name和Kind，前者返回类型名(包括自定义类型名)，后者是更加底层的类型，比如Name会返回结构体名，而Kind则是struct 12345678910111213141516171819202122232425type myInt int64//获取类型func reflectType(x interface&#123;&#125;) &#123; t := reflect.TypeOf(x) fmt.Printf(&quot;type:%v kind:%v\\n&quot;, t.Name(), t.Kind())&#125;func main() &#123; var a *float32 // 指针 var b myInt // 自定义类型 var c rune // 类型别名 reflectType(a) // type: kind:ptr reflectType(b) // type:myInt kind:int64 reflectType(c) // type:int32 kind:int32 type person struct &#123; name string age int &#125; var d = person&#123; name: &quot;Oliver&quot;, age: 18, &#125; reflectType(d) // type:person kind:struct&#125; 数组、切片、Map、指针等类型的变量，Name都是返回空 reflect.ValueOf()：获取值信息，即可读值，又可改值 12345678910111213141516171819202122232425//读值func reflectValue(x interface&#123;&#125;) &#123; v := reflect.ValueOf(x) k := v.Kind() switch k &#123; case reflect.Int64: // v.Int()从反射中获取整型的原始值，然后通过int64()强制类型转换 fmt.Printf(&quot;type is int64, value is %d\\n&quot;, int64(v.Int())) case reflect.Float32: // v.Float()从反射中获取浮点型的原始值，然后通过float32()强制类型转换 fmt.Printf(&quot;type is float32, value is %f\\n&quot;, float32(v.Float())) case reflect.Float64: // v.Float()从反射中获取浮点型的原始值，然后通过float64()强制类型转换 fmt.Printf(&quot;type is float64, value is %f\\n&quot;, float64(v.Float())) &#125;&#125;func main() &#123; var a float32 = 3.14 var b int64 = 100 reflectValue(a) // type is float32, value is 3.140000 reflectValue(b) // type is int64, value is 100 // 将int类型的原始值转换为reflect.Value类型 c := reflect.ValueOf(10) fmt.Printf(&quot;type c :%T\\n&quot;, c) // type c :reflect.Value&#125; reflect.Value可用转换类型方法： 方法 说明 Int() int64 将值以 int 类型返回，所有有符号整型均可以此方式返回 Uint() uint64 将值以 uint 类型返回，所有无符号整型均可以此方式返回 Float() float64 将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回 Bool() bool 将值以 bool 类型返回 Bytes() []byts 将值以字节数组 []bytes 类型返回 String() string 将值以字符串类型返回 Interface() interface{} 将值以 interface{} 类型返回，可以通过类型断言转换为指定类型 修改值的时候需要注意！ 必须用Elem才能修改地址对应的值，不用Elem最后只能修改拷贝值，会引起panic！ 1234567891011121314151617181920//改值func reflectSetValue1(x interface&#123;&#125;) &#123; v := reflect.ValueOf(x) if v.Kind() == reflect.Int64 &#123; v.SetInt(200) //修改的是副本，reflect包会引发panic &#125;&#125;func reflectSetValue2(x interface&#123;&#125;) &#123; v := reflect.ValueOf(x) // 反射中使用 Elem()方法获取指针对应的值 if v.Elem().Kind() == reflect.Int64 &#123; v.Elem().SetInt(200) &#125;&#125;func main() &#123; var a int64 = 100 // reflectSetValue1(a) //panic: reflect: reflect.Value.SetInt using unaddressable value reflectSetValue2(&amp;a) fmt.Println(a)&#125; 结构体反射 结构体反射可以用来在运行时获取结构体的属性和方法 reflect.Type可用结构体反射方法： 方法 说明 NumField() int 返回结构体成员字段数量。 FieldByName(name string) (StructField, bool) 根据给定字符串返回字符串对应的结构体字段的信息。 FieldByIndex(index []int) StructField 多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息。 FieldByNameFunc(match func(string) bool) (StructField,bool) 根据传入的匹配函数匹配需要的字段。 NumMethod() int 返回该类型的方法集中方法的数目 Method(int) Method 返回该类型方法集中的第i个方法 123456789101112//利用Field方法获取的是一个StructField实例，该结构体结构为type StructField struct &#123; // Name是字段的名字。PkgPath是非导出字段的包路径，对导出字段该字段为&quot;&quot;。 // 参见http://golang.org/ref/spec#Uniqueness_of_identifiers Name string PkgPath string Type Type // 字段的类型 Tag StructTag // 字段的标签 Offset uintptr // 字段在结构体中的字节偏移量 Index []int // 用于Type.FieldByIndex时的索引切片 Anonymous bool // 是否匿名字段&#125; 12345678910111213141516171819202122232425//获取方法type student struct &#123; Name string `json:&quot;name&quot;` Score int `json:&quot;score&quot;`&#125;func main() &#123; stu1 := student&#123; Name: &quot;小王子&quot;, Score: 90, &#125; t := reflect.TypeOf(stu1) fmt.Println(t.Name(), t.Kind()) // student struct // 通过for循环遍历结构体的所有字段信息 for i := 0; i &lt; t.NumField(); i++ &#123; field := t.Field(i) fmt.Printf(&quot;name:%s index:%d type:%v json tag:%v\\n&quot;, field.Name, field.Index, field.Type, field.Tag.Get(&quot;json&quot;)) &#125; // 通过字段名获取指定结构体字段信息 if scoreField, ok := t.FieldByName(&quot;Score&quot;); ok &#123; fmt.Printf(&quot;name:%s index:%d type:%v json tag:%v\\n&quot;, scoreField.Name, scoreField.Index, scoreField.Type, scoreField.Tag.Get(&quot;json&quot;)) &#125;&#125; 12345678910111213141516171819202122232425262728//获取方法// 给student添加两个方法 Study和Sleep(注意首字母大写)func (s student) Study() string &#123; msg := &quot;好好学习，天天向上。&quot; fmt.Println(msg) return msg&#125;func (s student) Sleep() string &#123; msg := &quot;好好睡觉，快快长大。&quot; fmt.Println(msg) return msg&#125;func printMethod(x interface&#123;&#125;) &#123; t := reflect.TypeOf(x) v := reflect.ValueOf(x) fmt.Println(t.NumMethod()) for i := 0; i &lt; v.NumMethod(); i++ &#123; methodType := v.Method(i).Type() fmt.Printf(&quot;method name:%s\\n&quot;, t.Method(i).Name) fmt.Printf(&quot;method:%s\\n&quot;, methodType) // 通过反射调用方法传递的参数必须是 []reflect.Value 类型 var args = []reflect.Value&#123;&#125; v.Method(i).Call(args) &#125;&#125; 注意上面右边的代码虽然获取了方法的信息，但也有陌生的调用方法的操作method.Call() 123456789101112131415//利用反射调用函数或方法func fn(p1, p2 int) int &#123; return p1 + p2&#125;func main() &#123; valueFunc := reflect.ValueOf(fn)//reflect.Value实例是函数，输入值和返回值都是[]reflect.Value类型 paramList := []reflect.Value&#123; reflect.ValueOf(22),//设置第一个参数 reflect.ValueOf(20),//设置第二个参数 &#125; // 反射调用函数 resultList := valueFunc.Call(paramList) // 获取第一个返回值, 取整数值 fmt.Println(resultList[0].Int()) // 42&#125; 📌反射的优劣 优点：搭配接口实现泛型，代码更灵活 缺点：性能低下，使用反射的代码通常比正常代码慢一两个数量级 代码脆弱，引起panic是真正运行时，代码写完很长时间后 16 并发 goroutine协程 go调用协程只需要在被调用的函数前加上go即可 123456789101112131415161718package mainimport&#123; &quot;fmt&quot; &quot;sync&quot;&#125;var wg sync.WaitGroup //信号量，计数器func hello(i int) &#123; fmt.Println(&quot;Hello Goroutine!&quot;, i) wg.Done() //每当一个协程执行完，需要计数器减一&#125;func main() &#123; wg.Add(10000) //因为有10000个协程，所以要给计数器加10000 for i := 0; i &lt; 10000; i++ &#123; go hello(i) //执行10000个协程 &#125; wg.Wait() // 等待所有登记的goroutine都结束&#125; goroutine调用匿名函数，需要注意闭包情形 1234567891011/*错误写法*/func main() &#123; wg.Add(10000) for i := 0; i &lt; 10000; i++ &#123; go func ()&#123;//匿名函数 fmt.Println(&quot;Hello Goroutine!&quot;,i) wg.Done() &#125;()//此时形成了闭包 &#125; wg.Wait() &#125; 1234567891011/*正确写法*/func main() &#123; wg.Add(10000) for i := 0; i &lt; 10000; i++ &#123; go func (i int)&#123;//匿名函数 fmt.Println(&quot;Hello Goroutine!&quot;,i) wg.Done() &#125;(i)//将参数直接传入线程，避免闭包 &#125; wg.Wait() &#125; 上面左边的写法构成了闭包，也就是i自增时，参数并未传入对应协程，而对应协程将要执行时 才从外部获取i的值，而此时i可能已经自增很多。所以左边的代码最后会输出大量的10000 此外，可以通过GOMAXPROCS参数设置要将协程分配给多少个OS线程，默认使用全部物理线程 1234567891011121314151617181920212223package mainimport&#123; &quot;fmt&quot; &quot;sync&quot; &quot;runtime&quot;&#125;func a() &#123; for i := 1; i &lt; 10; i++ &#123; fmt.Println(&quot;A:&quot;, i) &#125;&#125;func b() &#123; for i := 1; i &lt; 10; i++ &#123; fmt.Println(&quot;B:&quot;, i) &#125;&#125;func main() &#123; runtime.GOMAXPROCS(1)//只有一个物理核心，并行也串行 go a() go b() time.Sleep(time.Second)//等待所有线程结束&#125; channel channel就是消息队列(先入先出)，用于协程之间的通信，格式为：var 变量 chan 数据类型 或：make(chan 元素类型, [缓冲大小]) 1234567//新建channelvar ch1 chan int // 声明一个传递整型的通道var ch2 chan bool // 声明一个传递布尔型的通道var ch3 chan []int // 声明一个传递int切片的通道ch4 := make(chan int)ch5 := make(chan bool)ch6 := make(chan []int) 对于channel，有发送、接收、关闭三种操作，前两者使用&lt; - 符号传递数据 1234567//发送ch &lt;- 10 // 把10发送到ch中//接收x := &lt;- ch // 从ch中接收值并赋值给变量x&lt;-ch // 从ch中接收值，忽略结果//关闭close(ch) 需要注意的是，当channel关闭后，不可再向channel关闭值，可以接收，如果全部接收完，再接收就是该类型的零值。channel不能重复关闭。 1234567//无缓冲channelch := make(chan int)//无缓冲channel如果没有接收操作时就执行发送，最后程序会进入死锁，所以对于无缓冲必须要有接收//有缓冲channelch := make(chan int)//指定缓冲区大小为1//发送后无接收会阻塞下一次发送，直至接收完 无缓冲可以实现goroutine同步 channel被关闭后，若一直接收最后会无限接收零值，所以需要机制判断channel为空 1234567891011121314151617/*******机制1：利用接收操作时返回的布尔值*******/func main() &#123; ch1 := make(chan int) // 开启goroutine将0~100的数发送到ch1中 go func() &#123; for i := 0; i &lt; 100; i++ &#123; ch1 &lt;- i &#125; close(ch1) &#125;() for &#123; i, ok := &lt;-ch1 // 通道关闭后再取值时，ok=false if !ok &#123; break &#125; &#125;&#125; 12345678910111213141516/*******机制2：使用for range*******/// channel 练习func main() &#123; ch1 := make(chan int) // 开启goroutine将0~100的数发送到ch1中 go func() &#123; for i := 0; i &lt; 100; i++ &#123; ch1 &lt;- i &#125; close(ch1) &#125;() // 在主goroutine中从ch1中接收值打印 for i := range ch1 &#123; // 通道关闭后会退出for range循环 fmt.Println(i) &#125;&#125; 单向通道 单向通道就是只能发送或接收，只有单项操作的通道，比如 12chan&lt;- int //只写通道，只能向该通道输入int值&lt;-chan int //只读通道，只能从该通道读取int值 123456789101112131415161718192021222324252627//例程func counter(out chan&lt;- int) &#123; for i := 0; i &lt; 100; i++ &#123; out &lt;- i &#125; close(out)&#125;func squarer(out chan&lt;- int, in &lt;-chan int) &#123; for i := range in &#123; out &lt;- i * i &#125; close(out)&#125;func printer(in &lt;-chan int) &#123; for i := range in &#123; fmt.Println(i) &#125;&#125;func main() &#123; ch1 := make(chan int) ch2 := make(chan int) go counter(ch1) go squarer(ch2, ch1) printer(ch2)&#125; Select语句 select类似于switch，有很多case和一个default，用来在一个语句块对多个channel进行收发操作，每个case对应一个收和发 12345678910func main() &#123; ch := make(chan int, 1) for i := 0; i &lt; 10; i++ &#123; select &#123; case x := &lt;-ch: fmt.Println(x) case ch &lt;- i: &#125; &#125;&#125; 每次可处理一个case，若有多个case可执行操作，会随机选取一个执行 没有case的select会一直等待，阻塞程序 同步 当多个goroutine同时操作一个资源(临界区)时，就有竞态问题，此时需要利用锁实现同步 互斥锁sync.Mutex：当一个协程将资源锁住，进行操作时，其它协程必须等待解锁才能访问资源 12345678910111213141516171819var x int64var wg sync.WaitGroupvar lock sync.Mutexfunc add() &#123; for i := 0; i &lt; 5000; i++ &#123; lock.Lock() // 加锁 x = x + 1 lock.Unlock() // 解锁 &#125; wg.Done()&#125;func main() &#123; wg.Add(2) go add() go add() wg.Wait() fmt.Println(x)&#125; 读写互斥锁sync.RWMutex：资源被一个goroutine上了写锁后，其它协同都必须等待解锁才能进行读写操作；而被上了读锁时，其它要进行读操作的协同可以读，写操作的协程需要等待 123456789101112131415161718192021222324252627282930313233343536var ( x int64 wg sync.WaitGroup lock sync.Mutex rwlock sync.RWMutex)func write() &#123; rwlock.Lock() // 加写锁 x = x + 1 time.Sleep(10 * time.Millisecond) // 假设读操作耗时10毫秒 rwlock.Unlock() // 解写锁 wg.Done()&#125;func read() &#123; rwlock.RLock() // 加读锁 time.Sleep(time.Millisecond) // 假设读操作耗时1毫秒 rwlock.RUnlock() // 解读锁 wg.Done()&#125;func main() &#123; start := time.Now() for i := 0; i &lt; 10; i++ &#123; wg.Add(1) go write() &#125; for i := 0; i &lt; 1000; i++ &#123; wg.Add(1) go read() &#125; wg.Wait() end := time.Now() fmt.Println(end.Sub(start))&#125; 利用读写互斥锁执行上面代码要比用互斥锁快十倍 并发中的单例：sync.Once 针对高并发情形下只执行一次的操作，可以使用sync.Once避免一系列问题，比如下面例子 123456789101112131415161718var icons map[string]image.Imagefunc loadIcons() &#123; icons = map[string]image.Image&#123; &quot;left&quot;: loadIcon(&quot;left.png&quot;), &quot;up&quot;: loadIcon(&quot;up.png&quot;), &quot;right&quot;: loadIcon(&quot;right.png&quot;), &quot;down&quot;: loadIcon(&quot;down.png&quot;), &#125;&#125;// Icon被多个goroutine调用不是并发安全的func Icon(name string) image.Image &#123; if icons == nil &#123; loadIcons() &#125; return icons[name]&#125; 1234567func loadIcons() &#123; icons = make(map[string]image.Image) icons[&quot;left&quot;] = loadIcon(&quot;left.png&quot;) icons[&quot;up&quot;] = loadIcon(&quot;up.png&quot;) icons[&quot;right&quot;] = loadIcon(&quot;right.png&quot;) icons[&quot;down&quot;] = loadIcon(&quot;down.png&quot;)&#125; 这种情况下，可能会出现一个协程调用Icon时，写icons这个map只写到一半，还没写到right，就有另一个协程调用Icon了。 此时icons不是nil，但是要调用icons[“right”]，导致错误。 使用sync.Once的Do方法执行if里的操作可以解决这一问题 123456789101112131415161718/****************正确写法*****************/var icons map[string]image.Imagevar loadIconsOnce sync.Oncefunc loadIcons() &#123; icons = map[string]image.Image&#123; &quot;left&quot;: loadIcon(&quot;left.png&quot;), &quot;up&quot;: loadIcon(&quot;up.png&quot;), &quot;right&quot;: loadIcon(&quot;right.png&quot;), &quot;down&quot;: loadIcon(&quot;down.png&quot;), &#125;&#125;// Icon 是并发安全的func Icon(name string) image.Image &#123; loadIconsOnce.Do(loadIcons) return icons[name]&#125; sync.Once相当于有一个互斥锁和布尔值，前者上锁保护临界资源和布尔值，后者标记是否执行过 面向并发的map：sync.Map 多个协程同时写map是不被允许也是不安全的，若想不加锁的前提下使用map，可以用sync.Map 12345678910111213141516var m = sync.Map&#123;&#125;//sync.Map的读操作是Load方法，写操作是Store方法func main() &#123; wg := sync.WaitGroup&#123;&#125; for i := 0; i &lt; 20; i++ &#123; wg.Add(1) go func(n int) &#123; key := strconv.Itoa(n) m.Store(key, n) value, _ := m.Load(key)//第二个返回值是布尔类型，判断是否被找到 fmt.Printf(&quot;k=:%v,v:=%v\\n&quot;, key, value) wg.Done() &#125;(i) &#125; wg.Wait()&#125; 值得一提的是，sync.Map的键值都是空接口类型，也就是说可以在同一个sync.Map存储任意类型的键-值对，而不是像传统map要把类型写死 原子操作 原子操作操作数据时是不可被分割的，所以不会被其它协程抢占，并发安全，而且性能比互斥锁优异 123456789101112131415161718192021222324252627282930313233343536373839404142434445package mainimport ( &quot;fmt&quot; &quot;sync&quot; &quot;sync/atomic&quot; &quot;time&quot;)type Counter interface &#123; Inc() Load() int64&#125;// 原子操作版type AtomicCounter struct &#123; counter int64&#125;func (a *AtomicCounter) Inc() &#123; atomic.AddInt64(&amp;a.counter, 1)//原子方法&#125;func (a *AtomicCounter) Load() int64 &#123; return atomic.LoadInt64(&amp;a.counter)//原子方法&#125;func test(c Counter) &#123; var wg sync.WaitGroup start := time.Now() for i := 0; i &lt; 1000; i++ &#123; wg.Add(1) go func() &#123; c.Inc() wg.Done() &#125;() &#125; wg.Wait() end := time.Now() fmt.Println(c.Load(), end.Sub(start))&#125;func main() &#123; c3 := AtomicCounter&#123;&#125; // 并发安全且比互斥锁效率更高 test(&amp;c3)&#125; 17 IO编程 17.1 文件IO 文件读和写分别至少有三种方式，并且读文件和写文件时文件的打开方式也是不同的 12345678910111213141516//读---打开文件:os.Open(文件名)package mainimport ( &quot;fmt&quot; &quot;os&quot;)func main() &#123; // 只读方式打开当前目录下的main.go文件 file, err := os.Open(&quot;./main.go&quot;) if err != nil &#123; fmt.Println(&quot;open file failed!, err:&quot;, err) return &#125; // 关闭文件 defer file.Close()//用defer保证最后一定会关闭文件&#125; 12345678910111213141516171819//写---打开文件：os.OpenFile(文件名,模式,权限设置)//模式：os.O_WRONLY(只写)、os.O_CREATE(创建文件)、//os.O_RDONLY(只读)、os.O_RDWR(读写)、os.O_TRUNC(清空)、os.O_APPEND(追加)//权限：r（读）04，w（写）02，x（执行）01// owner group other//0 - rwx - rwx - rwxpackage mainimport ( &quot;fmt&quot; &quot;os&quot;)func main() &#123; file, err := os.OpenFile(&quot;xx.txt&quot;, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666) if err != nil &#123; fmt.Println(&quot;open file failed, err:&quot;, err) return &#125; defer file.Close()&#125; 读文件的三种方式 方式一：file.Read()，优势：原生读文件方式，可以精准把控读到的字节数 123456789101112131415161718192021222324//Read()函数会接收一个字节数组做参数//返回字节数和error类型func main() &#123; // 只读方式打开当前目录下的main.go文件 file, err := os.Open(&quot;./main.go&quot;) if err != nil &#123; fmt.Println(&quot;Failed!, err:&quot;, err) return &#125; defer file.Close() // 使用Read方法读取数据 var tmp = make([]byte, 128) n, err := file.Read(tmp) if err == io.EOF &#123;//读取少于128字节，读完了 fmt.Println(&quot;文件读完了&quot;) return &#125; if err != nil &#123; fmt.Println(&quot;Failed, err:&quot;, err) return &#125; fmt.Printf(&quot;读取了%d字节数据\\n&quot;, n) fmt.Println(string(tmp[:n]))&#125; 1234567891011121314151617181920212223242526//循环读取func main() &#123; // 只读方式打开当前目录下的main.go文件 file, err := os.Open(&quot;./main.go&quot;) if err != nil &#123; fmt.Println(&quot;open failed!, err:&quot;, err) return &#125; defer file.Close() // 循环读取文件 var content []byte var tmp = make([]byte, 128) for &#123; n, err := file.Read(tmp) if err == io.EOF &#123; fmt.Println(&quot;文件读完了&quot;) break &#125; if err != nil &#123; fmt.Println(&quot;read failed, err:&quot;, err) return &#125; content = append(content, tmp[:n]...) &#125; fmt.Println(string(content))&#125; 方式二：bufio读取文件，优势：提供大量函数，读文件更加灵活，而且会先从磁盘读到缓存，然后使用时可直接从缓存取数据，减少了磁盘IO带来的瓶颈效应，速度快 1234567891011121314151617181920212223242526272829303132package mainimport ( &quot;bufio&quot; &quot;fmt&quot; &quot;io&quot; &quot;os&quot;)// bufio按行读取示例func main() &#123; file, err := os.Open(&quot;./xx.txt&quot;) if err != nil &#123; fmt.Println(&quot;open file failed, err:&quot;, err) return &#125; defer file.Close() reader := bufio.NewReader(file)//需要new一个reader对象 for &#123; line, err := reader.ReadString(&#x27;\\n&#x27;) //注意是字符 if err == io.EOF &#123; if len(line) != 0 &#123; fmt.Println(line) &#125; fmt.Println(&quot;文件读完了&quot;) break &#125; if err != nil &#123; fmt.Println(&quot;read file failed, err:&quot;, err) return &#125; fmt.Print(line) &#125;&#125; 方式三：io/ioutil包的ReadFile方法，优势：可以一次读取完整文件内容，不需要Open、Close 12345678910111213141516package mainimport ( &quot;fmt&quot; &quot;io/ioutil&quot;)// ioutil.ReadFile读取整个文件func main() &#123; content, err := ioutil.ReadFile(&quot;./main.go&quot;)//返回的是字节数组 if err != nil &#123; fmt.Println(&quot;read file failed, err:&quot;, err) return &#125; fmt.Println(string(content))&#125; 写文件的三种方式 方式一：os包的write和writeString函数，前者写字节数组，后者写字符串 1234567891011func main() &#123; file, err := os.OpenFile(&quot;xx.txt&quot;, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666) if err != nil &#123; fmt.Println(&quot;open file failed, err:&quot;, err) return &#125; defer file.Close() str := &quot;hello 沙河&quot; file.Write([]byte(str)) //写入字节切片数据 file.WriteString(&quot;hello 小王子&quot;) //直接写入字符串数据&#125; 方式二：bufio的writer对象，需要注意的是，这种方式先写到缓存里，再刷新到磁盘中，所以写完后，需要执行Flush函数 12345678910111213func main() &#123; file, err := os.OpenFile(&quot;xx.txt&quot;, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666) if err != nil &#123; fmt.Println(&quot;open file failed, err:&quot;, err) return &#125; defer file.Close() writer := bufio.NewWriter(file) for i := 0; i &lt; 10; i++ &#123; writer.WriteString(&quot;hello沙河\\n&quot;) //将数据先写入缓存 &#125; writer.Flush() //将缓存中的内容写入文件&#125; 方式三：io/ioutil包的WriteFile方法，其最后一个参数与OpenFile的最后一个参数一致 123456789//不需要OpenFile、Closefunc main() &#123; str := &quot;hello 沙河&quot; err := ioutil.WriteFile(&quot;./xx.txt&quot;, []byte(str), 0666) if err != nil &#123; fmt.Println(&quot;write file failed, err:&quot;, err) return &#125;&#125; 17.2 log包输出日志 go语言中的log包与python中的logging非常相似，都有logger，可以指定输出到控制台或文件，有fomatter，不同信息有不同等级。 https://golang.org/pkg/log/ https://www.bilibili.com/video/BV1QJ411X7CN?from=search&amp;seid=2882714410354221537 17.3 fmt包 18 正则表达式 Go语言的正则表达式用到了&quot;regexp&quot;包，正则格式和python中的无异。 有两种方式进行正则表达式匹配，一种是正则字符串直接拿来匹配，另一种是将正则表达式字符串通过函数优化成go语言的regexp对象，再利用该对象的方法。后者是线程安全的！ 1234567//第一种方式：正则字符串直接匹配matched, err := regexp.MatchString(`a.b`, &quot;aaxbb&quot;)//注意需要用反引号fmt.Println(matched) // truefmt.Println(err) // nil (regexp is valid)matched, _ := regexp.MatchString(`^a.b$`, &quot;aaxbb&quot;)fmt.Println(matched) // false 12345//第二种方式：正则字符串先编译成regexp对象//两种编译方式re1, err := regexp.Compile(`regexp`) // error if regexp invalidre2 := regexp.MustCompile(`regexp`) // panic if regexp invalid//后者可直接配合defer recover Find：find有两种，一种用字符串，一种用字节数组，没有String字样的find方法都是字节数组 12345678910111213141516171819//找到第一个匹配的子串//方法的参数是待匹配的字符串re := regexp.MustCompile(`foo.?`)fmt.Printf(&quot;%q\\n&quot;, re.FindString(&quot;seafood fool&quot;)) // &quot;food&quot;fmt.Printf(&quot;%q\\n&quot;, re.FindString(&quot;meat&quot;)) // &quot;&quot;//找到第一个匹配的子串的位置re := regexp.MustCompile(`ab?`)fmt.Println(re.FindStringIndex(&quot;tablett&quot;)) // [1 3]fmt.Println(re.FindStringIndex(&quot;foo&quot;) == nil) // true//找到所有匹配的子串re := regexp.MustCompile(`a.`)fmt.Printf(&quot;%q\\n&quot;, re.FindAllString(&quot;paranormal&quot;, -1)) // [&quot;ar&quot; &quot;an&quot; &quot;al&quot;]fmt.Printf(&quot;%q\\n&quot;, re.FindAllString(&quot;paranormal&quot;, 2)) // [&quot;ar&quot; &quot;an&quot;]fmt.Printf(&quot;%q\\n&quot;, re.FindAllString(&quot;graal&quot;, -1)) // [&quot;aa&quot;]fmt.Printf(&quot;%q\\n&quot;, re.FindAllString(&quot;none&quot;, -1)) // [] (nil slice)//FindAllString方法最后一个参指定返回多少子串//小于0：返回所有；等于0：不返回；大于0：返回这个数量的子串 Replace： 12re := regexp.MustCompile(`ab*`)fmt.Printf(&quot;%q\\n&quot;, re.ReplaceAllString(&quot;-a-abb-&quot;, &quot;T&quot;)) // &quot;-T-T-&quot; Split： 12345678910111213a := regexp.MustCompile(`a`)fmt.Printf(&quot;%q\\n&quot;, a.Split(&quot;banana&quot;, -1)) // [&quot;b&quot; &quot;n&quot; &quot;n&quot; &quot;&quot;]fmt.Printf(&quot;%q\\n&quot;, a.Split(&quot;banana&quot;, 0)) // [] (nil slice)fmt.Printf(&quot;%q\\n&quot;, a.Split(&quot;banana&quot;, 1)) // [&quot;banana&quot;]fmt.Printf(&quot;%q\\n&quot;, a.Split(&quot;banana&quot;, 2)) // [&quot;b&quot; &quot;nana&quot;]zp := regexp.MustCompile(`z+`)fmt.Printf(&quot;%q\\n&quot;, zp.Split(&quot;pizza&quot;, -1)) // [&quot;pi&quot; &quot;a&quot;]fmt.Printf(&quot;%q\\n&quot;, zp.Split(&quot;pizza&quot;, 0)) // [] (nil slice)fmt.Printf(&quot;%q\\n&quot;, zp.Split(&quot;pizza&quot;, 1)) // [&quot;pizza&quot;]fmt.Printf(&quot;%q\\n&quot;, zp.Split(&quot;pizza&quot;, 2)) // [&quot;pi&quot; &quot;a&quot;]//Split方法最后一个参数指定返回多少子串//小于0：返回所有；等于0：不返回；大于0：返回这个数量的子串 19 go语言常用标准库 19.1 time 19.2 flag 19.3 strconv Go语言底层原理 《Go语言底层原理剖析》 Golang修养之路：https://www.kancloud.cn/aceld/golang GMP模型 逃逸现象 make和new 的区别 变量声明： var关键字，不指定变量默认值时，变量的默认值会是零值 12var i int //int类型的零值是0var s string //string类型的零值是&quot;&quot; 引用类型的零值是nil new内存分配 使用new时必须先分配内存 12345func main() &#123; var i *int *i=10 fmt.Println(*i)&#125; 1234567func main() &#123; var i *int i=new(int) *i=10 fmt.Println(*i)&#125; new()只接收一个参数，就是类型。返回的是类型指针，并且分配内存后会默认给指针指向的地址赋零值。 make内存分配 make只用于三种类型：chan，map，slice的内存创建。而且返回的不是指针，而就是这三种类型（不是指针，因为它们自身就是引用类型）。 1func make(t Type, size ...IntegerType) Type 123ch := make(chan int)ch := make(chan bool)ch := make(chan []int) 12/*格式：make(map[键数据类型][值数据类型])*/emails := make(map[string]string) 1234//T:切片的元素类型//size:切片中元素的数量//cap:切片的容量a := make([]int, 2, 10) make与new的异同： 相同：均为堆空间分配 不同： make：只用于slice、map和chan的初始化，无可替代； new：用于类型内存分配（初始化值为0），不常用 📌new不常用： 现实代码通常采用短语句声明以及结构体的字面量达到分配内存目的，如： i := 0 u := user{} 内存分配 垃圾回收 📌为什么需要垃圾回收？ 1. 减少错误和复杂性 手动分配、释放内存等可能会带来内存泄露、野指针等问题。虽然垃圾回收不保证完全不产生内存泄露，但其提供了重要的保障，即不再被引用的对象最终将被收集。 同时，可以避免悬空指针、多次释放等手动管理内存时会出现的问题。 垃圾回收功能屏蔽了内存管理的复杂性，开发者可更好地关注核心业务逻辑。 2. 解耦 现代软件工程崇尚模块化，而模块间只提供少量接口以交互。当多个模块同时维护一个内存时，释放内存将变得非常小心。 手动分配面临这样的问题：缺乏信息，难以在本地模块内做出全局的决定。 垃圾回收机制将此工作托管给了具有全局视野的运行时代码，从而使业务模块间真正解耦，从而有利于开发、调试，并开发出更大规模的、高并发的项目。 📌什么场景需要垃圾回收？ 垃圾回收带来了额外的成本，需要保存内存的状态信息并扫描内存，很多时候还需要中断整个程序来处理垃圾回收。 因此，垃圾回收对于要求极致的速度和内存要求极小的场景并不适用（嵌入式、系统级程序）； 却是开发大规模、分布式、微服务集群的极佳选择。 Go垃圾回收中的三色标记： Go执行垃圾回收具体流程： defer defer的执行顺序 栈：先进后出 函数的返回值初始化 只要函数返回值有名字（例子中为t），这个t会在函数起始处被初始化为对应类型的零值并且作用域为整个函数。 return和defer谁先谁后 &amp; 有名函数返回值遇见defer情况 12345678910111213package mainimport &quot;fmt&quot;func returnButDefer() (t int) &#123; //t初始化0， 并且作用域为该函数全域 defer func() &#123; t = t * 10 &#125;() return 1&#125;func main() &#123; fmt.Println(returnButDefer())&#125; 12$ go run test.go10 本应返回1，但是return后进入了defer，所以t=t*10被执行，因此最后返回给main的结果为10。 defer遇见panic defer中包含panic 12345678910111213141516171819package mainimport &quot;fmt&quot;func main() &#123; defer func() &#123; if err := recover(); err != nil&#123; fmt.Println(err) &#125;else &#123; fmt.Println(&quot;fatal&quot;) &#125; &#125;() defer func() &#123; panic(&quot;defer panic&quot;) &#125;() panic(&quot;panic&quot;)&#125; 12输出结果：defer panic 触发panic(&quot;panic&quot;)后defer顺序出栈执行，第一个被执行的defer中的panic(&quot;defer panic&quot;)异常，会覆盖掉main中的panic(&quot;panic&quot;)，最后这个异常被第二个执行的defer捕获到。 defer下的函数参数包含子函数 123456789101112package mainimport &quot;fmt&quot;func function(index int, value int) int &#123; fmt.Println(index) return index&#125;func main() &#123; defer function(1, function(3, 0)) defer function(2, function(4, 0))&#125; 12345输出结果：3421 这里有四个函数，用第一个参数的值给它们标号为1\\2\\3\\4。需要研究它们的先后执行顺序： 有两个defer，所以defer会压栈两次，先进栈1，后进栈2。压1时，由于需要连同函数地址、函数形参一同进栈，因此为了得到第二个参数的结果，需要先执行function3。同理在压2时，就需要先执行function4。 因此执行顺序为：3→4→2→1。 相关工具 gRPC gRPC允许","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://example.com/tags/golang/"}]}],"categories":[{"name":"WebRTC","slug":"WebRTC","permalink":"http://example.com/categories/WebRTC/"},{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"数学","slug":"数学","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6/"},{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"WebRTC","slug":"WebRTC","permalink":"http://example.com/tags/WebRTC/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"数学方法","slug":"数学方法","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6%E6%96%B9%E6%B3%95/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"},{"name":"golang","slug":"golang","permalink":"http://example.com/tags/golang/"}]}