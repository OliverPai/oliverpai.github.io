<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.12.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Wolai版笔记：https:&#x2F;&#x2F;www.wolai.com&#x2F;i4fuq7u3G5X9fh79fG4yqS 。学习C++98、11、14的主要语法，为看懂WebRTC等大型项目打好基础。">
<meta property="og:type" content="article">
<meta property="og:title" content="C++基础知识">
<meta property="og:url" content="http://example.com/2022/07/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/index.html">
<meta property="og:site_name" content="OliverPai">
<meta property="og:description" content="Wolai版笔记：https:&#x2F;&#x2F;www.wolai.com&#x2F;i4fuq7u3G5X9fh79fG4yqS 。学习C++98、11、14的主要语法，为看懂WebRTC等大型项目打好基础。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/cpp-basic/image_C-0mU-M0rw.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/cpp-basic/image_MHylNzhysP.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/cpp-basic/image_nuXGWwKUxa.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/cpp-basic/image_6jwbJcI4f8.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/cpp-basic/image_OQknyX-tPz.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/cpp-basic/image__v58OY9wwk.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/cpp-basic/image_M99Hn4BKd-.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/cpp-basic/image_59GclcE4Cr.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/cpp-basic/image_w9TrPipfr5.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/cpp-basic/image_pNRhIJgYeq.png">
<meta property="article:published_time" content="2022-07-01T04:33:00.000Z">
<meta property="article:modified_time" content="2022-07-23T12:46:45.851Z">
<meta property="article:author" content="OliverPai">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/cpp-basic/image_C-0mU-M0rw.png">


<link rel="canonical" href="http://example.com/2022/07/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2022/07/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","path":"2022/07/01/C++基础知识/C++基础知识/","title":"C++基础知识"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>C++基础知识 | OliverPai</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="OliverPai" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">OliverPai</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">落叶本就是假的</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#c%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-number">1.</span> <span class="nav-text"> C++基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B"><span class="nav-number">1.1.</span> <span class="nav-text"> 面向过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-number">1.1.1.</span> <span class="nav-text"> 1 基础知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.2.</span> <span class="nav-text"> 2 用户自定义类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#autodecltype"><span class="nav-number">1.1.2.1.</span> <span class="nav-text"> auto&#x2F;decltype</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%8D%E5%9F%9F"><span class="nav-number">1.1.2.2.</span> <span class="nav-text"> 位域</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="nav-number">1.1.3.</span> <span class="nav-text"> 3 模块化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-number">1.1.4.</span> <span class="nav-text"> 4 错误处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-const"><span class="nav-number">1.1.5.</span> <span class="nav-text"> 5 const</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#const%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%AE%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.5.1.</span> <span class="nav-text"> const常量与宏的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#const%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.5.2.</span> <span class="nav-text"> const修饰成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#const%E4%BF%AE%E9%A5%B0%E6%8C%87%E9%92%88"><span class="nav-number">1.1.5.3.</span> <span class="nav-text"> const修饰指针</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.1.6.</span> <span class="nav-text"> 6 匿名函数（lambda表达式）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#mutable"><span class="nav-number">1.1.6.1.</span> <span class="nav-text"> mutable</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="nav-number">1.1.7.</span> <span class="nav-text"> 7 函数指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88"><span class="nav-number">1.1.7.1.</span> <span class="nav-text"> 重载函数的指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%BD%A2%E5%8F%82"><span class="nav-number">1.1.7.2.</span> <span class="nav-text"> 函数指针形参</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88"><span class="nav-number">1.1.7.3.</span> <span class="nav-text"> 返回指向函数的指针</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.1.8.</span> <span class="nav-text"> 8 常用关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9B%E7%A7%8Dcast%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.1.8.1.</span> <span class="nav-text"> 四种cast（转换）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#static%E4%BD%9C%E7%94%A8"><span class="nav-number">1.1.8.2.</span> <span class="nav-text"> static作用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E5%86%8D%E7%9C%8B%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="nav-number">1.1.9.</span> <span class="nav-text"> 9 再看函数重载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%97%B6%E7%9A%84%E5%8C%B9%E9%85%8D%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">1.1.9.1.</span> <span class="nav-text"> 函数重载时的匹配优先级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E5%85%A5%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="nav-number">1.1.9.2.</span> <span class="nav-text"> 引入模板的重载</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.2.</span> <span class="nav-text"> 面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E7%B1%BB"><span class="nav-number">1.2.1.</span> <span class="nav-text"> 10 类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#override-final-default-delete"><span class="nav-number">1.2.1.1.</span> <span class="nav-text"> override、final、default、delete</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="nav-number">1.2.1.2.</span> <span class="nav-text"> 菱形继承与虚继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#raii%E8%B5%84%E6%BA%90%E8%8E%B7%E5%8F%96%E5%8D%B3%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.2.1.3.</span> <span class="nav-text"> RAII：资源获取即初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E9%9A%90%E5%BC%8F%E9%94%80%E6%AF%81"><span class="nav-number">1.2.1.4.</span> <span class="nav-text"> 对象隐式销毁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="nav-number">1.2.1.5.</span> <span class="nav-text"> 友元函数&amp;友元类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">1.2.1.6.</span> <span class="nav-text"> 运算符重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%89%B9%E6%AE%8A%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">1.2.1.7.</span> <span class="nav-text"> 类类型转换（特殊运算符重载）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#newdelete%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="nav-number">1.2.1.8.</span> <span class="nav-text"> new&#x2F;delete的重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E5%92%8C%E7%A7%BB%E5%8A%A8"><span class="nav-number">1.2.1.9.</span> <span class="nav-text"> 拷贝和移动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">1.2.1.10.</span> <span class="nav-text"> 智能指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9Dcow-copy-on-write"><span class="nav-number">1.2.1.11.</span> <span class="nav-text"> 写时拷贝（COW, Copy On Write）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.2.2.</span> <span class="nav-text"> 11 模板</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81crtp"><span class="nav-number">1.2.2.1.</span> <span class="nav-text"> 静态多态：CRTP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1function-objectfunctor"><span class="nav-number">1.2.2.2.</span> <span class="nav-text"> 函数对象（function object&#x2F;functor）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="nav-number">1.2.2.3.</span> <span class="nav-text"> 可变参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%AB%E5%90%8D"><span class="nav-number">1.2.2.4.</span> <span class="nav-text"> 别名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96"><span class="nav-number">1.2.2.5.</span> <span class="nav-text"> 模板特化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6%E8%AE%A1%E7%AE%97%E6%B5%85%E8%BF%B0%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B"><span class="nav-number">1.2.2.6.</span> <span class="nav-text"> 编译时计算（浅述模板元编程）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#type_traits"><span class="nav-number">1.2.2.7.</span> <span class="nav-text"> type_traits</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E6%AD%A7%E4%B9%89%E6%B6%88%E9%99%A4traits"><span class="nav-number">1.2.2.8.</span> <span class="nav-text"> 重载歧义消除（traits）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#declval"><span class="nav-number">1.2.2.9.</span> <span class="nav-text"> declval</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.3.</span> <span class="nav-text"> 正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#string%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.3.1.</span> <span class="nav-text"> string类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.3.2.</span> <span class="nav-text"> 正则表达式的模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99api"><span class="nav-number">1.3.3.</span> <span class="nav-text"> C++中的正则API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#io%E6%B5%81"><span class="nav-number">1.4.</span> <span class="nav-text"> I&#x2F;O流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#cin-cout"><span class="nav-number">1.4.1.</span> <span class="nav-text"> cin cout</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E8%81%94"><span class="nav-number">1.4.1.1.</span> <span class="nav-text"> 关联</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#io%E7%8A%B6%E6%80%81"><span class="nav-number">1.4.2.</span> <span class="nav-text"> I&#x2F;O状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">1.4.3.</span> <span class="nav-text"> 流运算符重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%B5%81"><span class="nav-number">1.4.4.</span> <span class="nav-text"> 文件流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B5%81"><span class="nav-number">1.4.5.</span> <span class="nav-text"> 字符串流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#istringstream"><span class="nav-number">1.4.5.1.</span> <span class="nav-text"> istringstream</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ostringstream"><span class="nav-number">1.4.5.2.</span> <span class="nav-text"> ostringstream</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="nav-number">1.5.</span> <span class="nav-text"> 实用工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#12-%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E7%AE%97%E6%B3%95"><span class="nav-number">1.5.1.</span> <span class="nav-text"> 12 常用内置算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-%E7%89%B9%E6%AE%8A%E5%AE%B9%E5%99%A8"><span class="nav-number">1.5.2.</span> <span class="nav-text"> 12 特殊容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#array"><span class="nav-number">1.5.2.1.</span> <span class="nav-text"> array</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bitset"><span class="nav-number">1.5.2.2.</span> <span class="nav-text"> bitset</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tuple"><span class="nav-number">1.5.2.3.</span> <span class="nav-text"> tuple</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-%E6%97%B6%E9%97%B4"><span class="nav-number">1.5.3.</span> <span class="nav-text"> 13 时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-%E5%87%BD%E6%95%B0%E9%80%82%E9%85%8D%E5%99%A8"><span class="nav-number">1.5.4.</span> <span class="nav-text"> 14 函数适配器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text"> 对象模型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text"> 并发编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#stdthread"><span class="nav-number">3.1.</span> <span class="nav-text"> std::thread</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE"><span class="nav-number">3.2.</span> <span class="nav-text"> 共享数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="nav-number">3.3.</span> <span class="nav-text"> 内存模型和原子操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7"><span class="nav-number">4.</span> <span class="nav-text"> 代码技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88webrtc"><span class="nav-number">4.1.</span> <span class="nav-text"> 引用计数智能指针（WebRTC）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pybind11"><span class="nav-number">4.2.</span> <span class="nav-text"> pybind11</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="OliverPai"
      src="/images/avatar-star.png">
  <p class="site-author-name" itemprop="name">OliverPai</p>
  <div class="site-description" itemprop="description">求索与记录</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/OliverPai" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;OliverPai" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar-star.png">
      <meta itemprop="name" content="OliverPai">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OliverPai">
      <meta itemprop="description" content="求索与记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="C++基础知识 | OliverPai">
      <meta itemprop="description" content="Wolai版笔记：https://www.wolai.com/i4fuq7u3G5X9fh79fG4yqS 。学习C++98、11、14的主要语法，为看懂WebRTC等大型项目打好基础。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++基础知识
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-01 12:33:00" itemprop="dateCreated datePublished" datetime="2022-07-01T12:33:00+08:00">2022-07-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-23 20:46:45" itemprop="dateModified" datetime="2022-07-23T20:46:45+08:00">2022-07-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">Wolai版笔记：https://www.wolai.com/i4fuq7u3G5X9fh79fG4yqS 。学习C++98、11、14的主要语法，为看懂WebRTC等大型项目打好基础。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="c基础知识"><a class="markdownIt-Anchor" href="#c基础知识"></a> C++基础知识</h1>
<blockquote>
<p>参考资料：<br />
- 《C<ins>语言导学》（第一版）<br />
- 《C</ins> primer》（第五版）<br />
- 《C<ins>新经典：对象模型》（第一版）<br />
- 《C</ins>并发编程实战》（第二版）</p>
<p>时间线：<br />
2021/10/9：开始整理笔记，以《C<ins>语言导学》为线索梳理<br />
2022/05/24：初步整理完成，汇总《C</ins>语言导学》，部分《C++ Primer》和少量《Effective Modern C++》<br />
2022/06/20：开始在笔记中加入并发（《C<ins>并发编程实战》第二版）知识<br />
2022/07/07：学习极客时间“现代C</ins>实战30讲”，添加type_traits相关内容</p>
</blockquote>
<h2 id="面向过程"><a class="markdownIt-Anchor" href="#面向过程"></a> 面向过程</h2>
<h3 id="1-基础知识"><a class="markdownIt-Anchor" href="#1-基础知识"></a> 1 基础知识</h3>
<ul>
<li>
<p><strong>程序编译：</strong></p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/cpp-basic/image_C-0mU-M0rw.png" alt="" /></p>
<p>ISO的C++标准定义了两种实体：</p>
<p>1.核心语言特性</p>
<p>比如内置类型（int, float）以及循环（for, while）；</p>
<p>2.标准库组件</p>
<p>比如容器（vector, map）以及I/O操作（&lt;&lt;, getline）。</p>
</li>
<li>
<p><strong>预处理期编程：</strong></p>
<p>预处理编程的操作目标是“源码”，各种指令控制预处理器，实际上就是让预处理器改造源码，改造成其他形式。预处理指令以“#”开头，单独的“#”也是一个预处理指令，即空指令，相当于空行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#                              <span class="comment">// 预处理空行</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __linux__                  <span class="comment">// 预处理检查宏是否存在</span></span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> HAS_LINUX    1      <span class="comment">// 宏定义，有缩进</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>                         <span class="comment">// 预处理条件语句结束</span></span></span><br><span class="line">#                              <span class="comment">// 预处理空行</span></span><br></pre></td></tr></table></figure>
<p>预处理器改造后的代码可以让gcc用-E选项来展开。</p>
<ul>
<li>
<p>包含文件（#include）：</p>
<p>#include不仅可以包含头文件，理论上，只要想，源码、普通文本、图片、音频、视频都可以引进来（虽然可能出现无法处理的错误）。比如<code>#include &quot;a.out&quot;</code>。引用头文件时常用的技巧是“Include Guard”：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _XXX_H_INCLUDE_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _XXX_H_INCLUDE_</span></span><br><span class="line">... <span class="comment">//头文件内容</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> _XXX_H_INCLUDE_</span></span><br></pre></td></tr></table></figure>
<p>还有一种常用用法，使用“ *.inc”文件存放一些代码片段。比如有一个很大的用于数值计算的数组，直接放在源码文件里很占地方，不方便对源码的逻辑部分进行梳理查看。那么，便可以把此数组放在calc_values.inc中，通过#include加载它，从而替换原来的大批数字：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//calc_values.inc文件</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span>  calc_table[] = &#123;  <span class="comment">// 非常大的一个数组，有几十行</span></span><br><span class="line">    <span class="number">0x00000000</span>, <span class="number">0x77073096</span>, <span class="number">0xee0e612c</span>, <span class="number">0x990951ba</span>,</span><br><span class="line">    <span class="number">0x076dc419</span>, <span class="number">0x706af48f</span>, <span class="number">0xe963a535</span>, <span class="number">0x9e6495a3</span>,</span><br><span class="line">    <span class="number">0x0edb8832</span>, <span class="number">0x79dcb8a4</span>, <span class="number">0xe0d5e91e</span>, <span class="number">0x97d2d988</span>,</span><br><span class="line">    <span class="number">0x09b64c2b</span>, <span class="number">0x7eb17cbd</span>, <span class="number">0xe7b82d07</span>, <span class="number">0x90bf1d91</span>,</span><br><span class="line">    ...                          </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//源码文件</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span>  calc_table[] = &#123;</span><br><span class="line"><span class="meta">#  <span class="keyword">include</span> <span class="string">&quot;calc_values.inc&quot;</span>        <span class="comment">// 非常大的一个数组，细节被隐藏</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>宏定义（#define/#undef）：</p>
<ul>
<li>
<p>宏的展开、替换发生在预处理阶段，对于一些调用频繁的小代码片段，用宏来封装的效果比inline关键字要好，因为其是源码级别的无条件内联，比如Nginx中的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ngx_tolower(c)      ((c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>) ? (c | 0x20) : c)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ngx_toupper(c)      ((c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>) ? (c &amp; ~0x20) : c)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ngx_memzero(buf, n)       (void) memset(buf, 0, n)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>宏没有作用域概念，永远生效，因此对于一些用于简化代码、起临时作用的宏，用完后尽快#undef取消定义，避免冲突：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CUBE(a) (a) * (a) * (a)  <span class="comment">// 定义一个简单的求立方的宏</span></span></span><br><span class="line">cout &lt;&lt; <span class="built_in">CUBE</span>(<span class="number">10</span>) &lt;&lt; endl;        <span class="comment">// 使用宏简化代码</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">CUBE</span>(<span class="number">15</span>) &lt;&lt; endl;        <span class="comment">// 使用宏简化代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> CUBE                      <span class="comment">// 使用完毕后立即取消定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> AUTH_PWD                  <span class="comment">// 检查是否已经有宏定义</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">undef</span> AUTH_PWD                <span class="comment">// 取消宏定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>                           <span class="comment">// 宏定义检查结束</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AUTH_PWD <span class="string">&quot;xxx&quot;</span>           <span class="comment">// 重新宏定义</span></span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>宏也被常用来做<strong>文本替换</strong>，比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BEGIN_NAMESPACE(x)  namespace x &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> END_NAMESPACE(x)    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">BEGIN_NAMESPACE</span>(my_own)</span><br><span class="line"></span><br><span class="line">...      <span class="comment">// functions and classes</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">END_NAMESPACE</span>(my_own)</span><br></pre></td></tr></table></figure>
<p>此处只是简单的文本替换，但是全大写的形式非常醒目，可以更容易识别出命名空间开始和结束的位置。</p>
</li>
</ul>
</li>
<li>
<p>条件编译（#if/#else/#endif）：</p>
<p>在预处理阶段实现分支处理，通过判断宏的数值来产生不同的源码，从而改变源文件的形态。#if后的判断依据，也就是定义好的各种宏。</p>
<ul>
<li>
<p>C++版本号宏：<code>__cplusplus</code>，利用该宏来判断当前的环境，从而使用相应的处理方式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus                      <span class="comment">// 定义了这个宏就是在用C++编译</span></span></span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;                        <span class="comment">// 函数按照C的方式去处理</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">a_c_function</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus                      <span class="comment">// 检查是否是C++编译</span></span></span><br><span class="line">    &#125;                                   <span class="comment">// extern &quot;C&quot; 结束</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus &gt;= 201402                <span class="comment">// 检查C++标准的版本号</span></span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c++14 or later&quot;</span> &lt;&lt; endl;    <span class="comment">// 201402就是C++14</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __cplusplus &gt;= 201103              <span class="comment">// 检查C++标准的版本号</span></span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c++11 or before&quot;</span> &lt;&lt; endl;   <span class="comment">// 201103是C++11</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span>   <span class="comment">// __cplusplus &lt; 201103          // 199711是C++98</span></span></span><br><span class="line"><span class="meta">#   <span class="keyword">error</span> <span class="string">&quot;c++ is too old&quot;</span>               <span class="comment">// 太低则预处理报错</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// __cplusplus &gt;= 201402         // 预处理语句结束</span></span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>C++语言特性宏：可以在预处理阶段判断系统是否支持某些语法特性，若支持就用特性，不支持就用老写法</p>
<ul>
<li>
<p>C<ins>标准提供的宏：C</ins>有很多预定义的宏，如源文件信息的“FILE”“LINE”“DATE”，以及一些测试语言特性是否被支持的宏，如“__cpp_decltype”“__cpp_decltype_auto”“__cpp_lib_make_unique”等。</p>
</li>
<li>
<p>编译器提供的宏：C++标准里很多宏未定义，但编译器提供，可用<code>g++ -E -dM - &lt; /dev/null</code>查看。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__cpp_decltype_auto)        <span class="comment">//检查是否支持decltype(auto)</span></span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;decltype(auto) enable&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;decltype(auto) disable&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">//__cpp_decltype_auto</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __GNUC__ &lt;= 4</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;gcc is too old&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span>   <span class="comment">// __GNUC__ &gt; 4</span></span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;gcc is good enough&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// __GNUC__ &lt;= 4</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__SSE4_2__) &amp;&amp; defined(__x86_64)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;we can do more optimization&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// defined(__SSE4_2__) &amp;&amp; defined(__x86_64)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>自定义的宏：可以用自定义的宏来实现条件编译，比如Nginx使用Shell脚本检测外部环境，生成一个包含若干宏的源码配置文件，再条件编译包含不同的头文件，实现操作系统定制化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> (NGX_FREEBSD)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">include</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> (NGX_LINUX)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">include</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> (NGX_SOLARIS)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">include</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> (NGX_DARWIN)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">include</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>代码禁用启用：</p>
<p>使用<code>#if 1</code>或<code>#if 0</code>来显式启用或者禁用大段代码，要比<code>/*...*/</code>的注释方式安全且清晰：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 0          <span class="comment">// 0即禁用下面的代码，1则是启用</span></span></span><br><span class="line">  ...          <span class="comment">// 任意的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>         <span class="comment">// 预处理结束</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1          <span class="comment">// 1启用代码，用来强调下面代码的必要性</span></span></span><br><span class="line">  ...          <span class="comment">// 任意的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>         <span class="comment">// 预处理结束</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>属性：编译期指令</strong></p>
<p>前面的#include、#define都是预处理指令，用于控制预处理器。类似的，还有“<strong>编译指令</strong>”来控制编译器。</p>
<p>C++11之前标准里没有编译指令，但编译器提供了，比如GCC里的<code>__attribute__</code>，VC里的<code>__declspec</code></p>
<p>C++11开始，官方将编译指令正式命名为“<strong>属性</strong>”，用两对方括号的形式<code>[[...]]</code>表示，相当于给变量、函数、类等贴上一个编译阶段的标签，让编译器识别。</p>
<p>虽然官方将属性的语法加进来了，但是标准里定义的属性还是十分有限的，最有用的当属C++14的deprecated：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">deprecated</span>(<span class="string">&quot;deadline:2020-12-31&quot;</span>)]]</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">old_func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用此函数的程序编译时会报出一条警告：</span></span><br><span class="line"><span class="comment">//warning: ‘int old_func()’ is deprecated: deadline:2020-12-31 [-Wdeprecated-declarations]</span></span><br></pre></td></tr></table></figure>
<p>属性支持非标准扩展，也就是允许使用编译器提供的非官方属性，比如GCC的属性在<code>gnu::</code>中：</p>
<ul>
<li>
<p><code>gnu::deprecated</code>：与C<ins>14的deprecated相同，但是可以用在C</ins>11里。</p>
</li>
<li>
<p><code>gnu::unused</code>：抑制对变量、类、函数的未使用警告，与&quot;(void) var&quot;效果一样。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[gnu::unused]] <span class="comment">//声明下面的变量暂不使用，不是错误，不需要warning</span></span><br><span class="line"><span class="type">int</span> nouse;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>gnu::constructor</code>：函数会在main()函数之前执行，效果类似对全局对象的构造函数</p>
</li>
<li>
<p><code>gnu::destructor</code>：函数会在main()函数结束之后执行，效果类似对全局对象的析构函数</p>
</li>
<li>
<p><code>gnu::always_inline</code>：要求编译器强制内联函数，作用比inline关键字强</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[gnu::always_inline]] <span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_num</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>gnu::hot</code>：标记热点函数，要求编译器对其进行更积极的优化</p>
</li>
</ul>
<blockquote>
<p>📌constructor和destructor必须使用C语言的语法，比如只能用printf()而不能用cout。</p>
</blockquote>
<p>下面两种写法是等价的：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((constructor)) <span class="function"><span class="type">void</span> <span class="title">load_file</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Constructor is called.\n&quot;</span>);</span><br><span class="line">    g_count = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (g_count == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Failed to malloc memory.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">__attribute__((destructor)) <span class="function"><span class="type">void</span> <span class="title">unload_file</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;destructor is called.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (g_count)</span><br><span class="line">    <span class="built_in">free</span>(g_count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[[gnu::constructor]] </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">load_file</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Constructor is called.\n&quot;</span>);</span><br><span class="line">    g_count = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (g_count == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Failed to malloc memory.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[[gnu::destructor]] </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unload_file</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;destructor is called.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (g_count)</span><br><span class="line">    <span class="built_in">free</span>(g_count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>函数：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回值类型 函数名字（函数参数）</span></span><br><span class="line"><span class="function"><span class="type">double</span>     <span class="title">sqrt</span>    <span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span>     <span class="title">sqrt</span>    <span class="params">(<span class="type">double</span> d)</span></span>;</span><br></pre></td></tr></table></figure>
<p>1.对于类成员函数来说，类名字也是函数名字的一部分<code>char&amp; String::operator[](int index);</code></p>
<p>2.编译器会检查实参的类型，并且会在必要的时候执行隐式实参类型转换 <code>sqrt(2);</code></p>
<p>3.函数重载可能会因为二义性报错：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">user</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="number">0</span>,<span class="number">0</span>); <span class="comment">//此时会报错，因为两个print都可以用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌C<ins>和C编译文件的区别：<br />
C语言不支持重载，而C</ins>支持。如一个函数声明为<code>void function(float x,float y)</code>，在C语言中，编译器进行编译之后，在库中的名字为<code>_function</code>；在C<ins>中，编译器进行编译后，在库中的名字为<code>_function_float_float</code>。<br />
编译器在链接的阶段，都是找到相应的函数名，进行链接。<br />
在C语言中，两个函数的名字一样，就会在链接时报错；<br />
在C</ins>中 ，两个函数名字不相同，就不会报错。</p>
</blockquote>
</li>
<li>
<p><strong>变量类型与算术：</strong></p>
<p>基本类型：<code>bool</code>，<code>int</code>，<code>double</code>，<code>char</code>，<code>unsigned</code>，等</p>
</li>
</ul>
<p>算术运算符</p>
<p>比较运算符</p>
<p>逻辑运算符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x+y  <span class="comment">//二元加法</span></span><br><span class="line">+x   <span class="comment">//一元正（结果没区别）</span></span><br><span class="line">x-y  <span class="comment">//二元减法</span></span><br><span class="line">-y   <span class="comment">//一元负（结果取负）</span></span><br><span class="line">x*y  <span class="comment">//乘法</span></span><br><span class="line">x/y  <span class="comment">//除法</span></span><br><span class="line">x%y  <span class="comment">//取模</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x==y</span><br><span class="line">x!=y</span><br><span class="line">x&lt;y</span><br><span class="line">x&gt;y</span><br><span class="line">x&lt;=y</span><br><span class="line">x&gt;=y</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x&amp;y  <span class="comment">//按位与</span></span><br><span class="line">x|y  <span class="comment">//按位或</span></span><br><span class="line">x^y  <span class="comment">//按位异或</span></span><br><span class="line">~x   <span class="comment">//按位求补</span></span><br><span class="line">x&amp;&amp;y <span class="comment">//逻辑与</span></span><br><span class="line">x||y <span class="comment">//逻辑或</span></span><br></pre></td></tr></table></figure>
<p><strong>初始化</strong>的两种方式：=赋值运算符 和 {}初始值列表，二者区别在于前者允许隐式类型转换，而后者不允许</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> x = <span class="number">2.4</span></span><br><span class="line">complex &lt;<span class="type">double</span>&gt; test = &#123;<span class="number">2.4</span>,<span class="number">2</span>&#125;;<span class="comment">//正确，会转换</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> x &#123;<span class="number">2.4</span>&#125;;<span class="comment">//正确</span></span><br><span class="line">complex &lt;<span class="type">double</span>&gt; test &#123;<span class="number">2.4</span>, <span class="number">2</span>&#125;<span class="comment">//错误，2是int</span></span><br></pre></td></tr></table></figure>
<p>由于不允许隐式类型转换，所以一般建议初始值列表的方式初始化变量，可以避免一些导致部分信息丢失的类型转换</p>
<ul>
<li>
<p>还可以使用auto关键字根据初始值自动推断类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">auto</span> ch = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line"><span class="keyword">auto</span> i = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">auto</span> d = <span class="number">1.2</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<!---->
<ul>
<li>
<p><strong>常量：</strong></p>
<ul>
<li>
<p>const：保证变量不变 <code>const int dmv = 17;</code></p>
</li>
<li>
<p>constexpr：编译时求值 <code>constexpr double max1=square(dmv);</code></p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>📌constexpr若要用在编译时求值场景，右式必须是常量表达式！</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常量表达式函数必须有constexpr声明</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">double</span> <span class="title">square</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;<span class="keyword">return</span> x*x;&#125;</span><br></pre></td></tr></table></figure>
<p>由constexpr声明的函数可以接受非常量实参，但此时将不再是常量表达式；若接受的是常量实参，此时是常量表达式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">constexpr</span> result1 = <span class="built_in">square</span>(var);</span><br><span class="line"><span class="comment">//报错！因为square(var)非常量表达式，不可编译时求值</span></span><br></pre></td></tr></table></figure>
<p>↑错误  →正确</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> dmv = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">constexpr</span> result2 = <span class="built_in">square</span>(dmv);</span><br><span class="line"><span class="comment">//正确！square(dmv)是常量表达式，此时编译时求值</span></span><br><span class="line"><span class="type">const</span> result3 = <span class="built_in">square</span>(var);</span><br><span class="line"><span class="comment">//正确！result3仍是常量，此为运行时求值</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>作用域与生命周期：</strong></p>
<ul>
<li>
<p>局部作用域：</p>
</li>
<li>
<p>类作用域：</p>
</li>
<li>
<p>命名空间作用域：</p>
</li>
</ul>
</li>
<li>
<p><strong>循环与条件：</strong></p>
</li>
</ul>
<!---->
<ul>
<li>[ ] 普通for</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)&#123;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>[ ] 普通while</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(i++ != <span class="number">10</span>)&#123;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for循环的执行顺序：先auto i=0，再判断i≠10，若满足，执行{ }中的内容，再进行<ins>i，然后判断i≠10，满足则执行{ }，再</ins>i，循环往复。</p>
<ul>
<li>[ ] for…range（类似于Python里的for）</li>
</ul>
<p>拷贝形式的for…range（x是v中元素的拷贝值）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> v[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x:v)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;%d&quot;</span>, x);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x:&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;%d&quot;</span>, x);</span><br></pre></td></tr></table></figure>
<p><strong>引用形式的for…range</strong>（x是v中元素的引用）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x:v)</span><br><span class="line">  ++x;</span><br></pre></td></tr></table></figure>
<ul>
<li>[ ] switch</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>switch的限制：</p>
<p>ch必须是一个整形或枚举类型，或者是一个class（class中有转换函数将其转换为整型或枚举类型）</p>
</li>
</ul>
<!---->
<ul>
<li>
<p><strong>内联函数：</strong></p>
<ul>
<li>
<p>内联函数以空间换时间，省去调用函数的额外开销。所以代码很长或有循环的时候不适合使用内联；</p>
</li>
<li>
<p>inline对编译器而言只是一个建议，如果定义的函数体内有递归/循环等，编译器优化时自动忽视内联；</p>
</li>
<li>
<p>inline必须与函数定义放在一起，仅将内联放在声明前是不起作用的；</p>
</li>
<li>
<p>定义在类内的成员函数默认为内联函数；</p>
</li>
<li>
<p>内联与宏函数的区别：</p>
<ul>
<li>
<p>宏：</p>
<ul>
<li>
<p>没有类型检测，不安全</p>
</li>
<li>
<p>不能进行调试</p>
</li>
<li>
<p>不可以访问类的成员变量</p>
</li>
</ul>
</li>
<li>
<p>内联函数：</p>
<ul>
<li>
<p>有类型检测，较安全</p>
</li>
<li>
<p>进行参数传递，可在运行时调试</p>
</li>
<li>
<p>可以访问类的成员变量</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>指针与引用：</strong></p>
<p>空指针尽量用<code>nullptr</code>，使用<code>NULL</code>可能会导致与整数0的混淆。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* p = &amp;v[<span class="number">3</span>];   <span class="comment">//p指向v数组中的第四个元素的地址</span></span><br><span class="line"><span class="type">char</span> x = *p;       <span class="comment">//v是p指向地址的变量的值</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌前置&amp;表示一个变量的地址；<br />
后置&amp;表示声明一个引用</p>
</blockquote>
<ul>
<li>
<p>将引用传入作为函数实参</p>
<p>一般来说，函数实参的传递是一个拷贝的过程，将变量的值拷贝到函数的栈中，不会带来对原变量的影响。</p>
<p>而若将引用作为参数传递<code>void sort(vector&lt;double&gt;&amp; vec);</code>，sort函数将直接操纵vec向量，没有拷贝的过程。这样可以加快速度，节省空间，但带来了操作原变量，误改动值的风险。</p>
<p>若想加快传入大数组参数的速度，又不改变值，可以加入const限定！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">sum</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">double</span>&gt;&amp; vec)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>二级指针与指针的引用</p>
<ul>
<li>
<p>二级指针</p>
<p>指针的指针，作用是改变指针本身的内容。</p>
</li>
<li>
<p>指针的引用</p>
<p>指针的引用，可以写为<code>int *&amp;i;</code>形式，本质是<code>((int*)&amp;) i;</code>，表示i是一个int型指针的引用，也可以像二级指针一样修改指针本身的内容。</p>
</li>
</ul>
<p>需要说明的是，没有指向引用的指针，因为引用不是变量，因此不存在指针。</p>
</li>
</ul>
<h3 id="2-用户自定义类型"><a class="markdownIt-Anchor" href="#2-用户自定义类型"></a> 2 用户自定义类型</h3>
<blockquote>
<p>这是C++提供的一种抽象机制，用户可以此机制定义自己想要实现某些功能的新类型</p>
</blockquote>
<ul>
<li>
<p><strong>结构体：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector</span>&#123;</span><br><span class="line">  <span class="type">int</span> sz;       <span class="comment">//元素的数量</span></span><br><span class="line">  <span class="type">double</span> * elem;<span class="comment">//指向元素的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Vector_init</span><span class="params">(Vector&amp; v, <span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">  v.elem = <span class="keyword">new</span> <span class="type">double</span>[s];</span><br><span class="line">  v.sz = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问结构体的元素有两种方式，点运算符和→运算符（指针）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vector v &#123;<span class="number">0</span>, <span class="literal">nullptr</span>&#125;;</span><br><span class="line"><span class="built_in">Vector_init</span>(v, <span class="number">3</span>);</span><br><span class="line">v.elem[<span class="number">0</span>] = <span class="number">1</span>,v.elem[<span class="number">1</span>] = <span class="number">2</span>,v.elem[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">Vector&amp; rv = v;</span><br><span class="line">Vector* pv = &amp;v; </span><br><span class="line"></span><br><span class="line">cout &lt;&lt; v.sz &lt;&lt; rv.sz &lt;&lt; pv-&gt;sz &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<ul>
<li>结构体的多种初始化方法：</li>
</ul>
<blockquote>
<p>📌结构体初始化：<br />
- {}初始化：<br />
<code>Node b = &#123;2, nullptr&#125;</code>或 <code>Node b &#123;2, nullptr&#125;;</code><br />
- 构造函数初始化：<br />
`struct Node{</p>
<pre><code> int var;                                                                             
 Node* `\*\*`next;                                                                   
 Node(int value, Node next_ty)&#123;
      this→var = value;
      this→next = next_ty;
 &#125;
 //或者： Node(int value, Node* next_ty):var(value), next(next_ty)&#123;&#125;;
</code></pre>
<p>};``Node c(3, nullptr)<code>  或 </code>Node* d = new Node(4,nullptr)`</p>
</blockquote>
</li>
<li>
<p><strong>类：</strong></p>
<p>类有一系列成员，可能是数据、函数或类型。public成员定义了该类的接口，private成员则只能从接口访问</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Vector</span>(<span class="type">int</span> s): elem&#123;<span class="keyword">new</span> <span class="type">double</span>[s]&#125;, sz&#123;&#125; &#123;&#125; <span class="comment">//构造函数的初始值列表</span></span><br><span class="line">  <span class="type">double</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> i)&#123; <span class="keyword">return</span> elem[i]; &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sz; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">double</span>* elem; <span class="comment">// 指向元素的指针</span></span><br><span class="line">  <span class="type">int</span> sz; <span class="comment">//元素的数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的一点是，虽然Vector类中elem的元素个数可能会变，但是Vector声明的对象大小是不变的。这一点也适用于所有类声明的对象。</p>
<blockquote>
<p>📌struct和class并没有太大区别，struct中也可以定义一些成员函数。唯一的区别体现在struct中的所有成员都是public的。</p>
</blockquote>
</li>
<li>
<p><strong>枚举：</strong></p>
<ul>
<li>
<p>普通枚举：<code>enum</code></p>
<p>普通枚举的枚举值都是整形，默认情况下枚举值对应的整数从0开始，依次加1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;red, green, blue&#125;;</span><br><span class="line"><span class="type">int</span> col = green; <span class="comment">//col的值变为1</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>强类型枚举：（scoped enumeration，C++11引入的特性）</p>
<p>强类型中，每个<code>enum class</code>是不同的类型，其枚举值位于指定的作用域中，不得混用，可避免对常量的意外误用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123;red, blue, green&#125;;</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Traffic_light</span> &#123;green, yellow, red&#125;;</span><br><span class="line"></span><br><span class="line">Color x = red;                <span class="comment">//报错，哪个red？</span></span><br><span class="line">Color y = Traffic_light::red; <span class="comment">//报错，这个Red不是一个Color对象</span></span><br><span class="line">Color z = Color::red;         <span class="comment">//正确 </span></span><br><span class="line"><span class="type">int</span> col = Color::red;         <span class="comment">//报错，Color::Red不是一个int</span></span><br></pre></td></tr></table></figure>
<p>强类型枚举并不和普通枚举一样，枚举值并不是int。但其作为一种用户自定义类型，也可进行运算符重载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Traffic_light&amp; <span class="keyword">operator</span>++(Traffic_light&amp; t)&#123;<span class="comment">//前置++运算符</span></span><br><span class="line">  <span class="keyword">switch</span>(t)&#123;</span><br><span class="line">    <span class="keyword">case</span> Traffic_light::green: <span class="keyword">return</span> t = Traffic_light::yellow;</span><br><span class="line">    <span class="keyword">case</span> Traffic_light::green: <span class="keyword">return</span> t = Traffic_light::yellow;</span><br><span class="line">    <span class="keyword">case</span> Traffic_light::green: <span class="keyword">return</span> t = Traffic_light::yellow;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>联合：</strong></p>
<p>union的所有成员被分配在同一片内存区域中，其实际占用的空间就是它最大的成员所占的空间。同一时刻，union中只能保存一个成员的值。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Type</span> &#123;str, num&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entry</span>&#123;</span><br><span class="line">  <span class="type">char</span>* name;</span><br><span class="line">  Type t;</span><br><span class="line">  <span class="type">char</span>* s;  <span class="comment">//如果t==str,则使用s</span></span><br><span class="line">  <span class="type">int</span> i;    <span class="comment">//如果t==num,则使用i</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Entry* p)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;t==str)</span><br><span class="line">    cout &lt;&lt; p-&gt;s;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如左边程序所示，s和i永远不会同时用到，但又同时定义了二者，所以无形中浪费了内存空间，使用联合可解决该问题。</p>
<p>命名联合和匿名联合均可！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//命名联合体</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Type</span> &#123;str,num&#125;;</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">Value</span>&#123;</span><br><span class="line">  <span class="type">char</span>* s;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entry</span>&#123;</span><br><span class="line">  <span class="type">char</span>* name;</span><br><span class="line">  Type t;</span><br><span class="line">  Value v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Entry* p)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;t==str)</span><br><span class="line">    cout&lt;&lt;p-&gt;v.s;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匿名联合体</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Type</span> &#123;str,num&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entry</span>&#123;</span><br><span class="line">  <span class="type">char</span>* name;</span><br><span class="line">  Type t;</span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="type">char</span>* s;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Entry* p)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;t==str)</span><br><span class="line">    cout&lt;&lt;p-&gt;s;<span class="comment">//匿名的优势在于，可以直接用</span></span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：初始化此结构体不能再<code>Entry test&#123;&quot;abc&quot;, num, 123&#125;</code>，{}会按{char <em>, Type, char</em>}初始化，发挥不了union优势</p>
<p>要逐个赋初值，以匿名联合体为例，要<code>Entry test;test.name=&quot;abc&quot;; test.t=str;test.s=&quot;abc&quot;;//test.t=num;test.i=123;</code></p>
<h4 id="autodecltype"><a class="markdownIt-Anchor" href="#autodecltype"></a> auto/decltype</h4>
<blockquote>
<p>auto自动类型推到，在代码里的作用像一个占位符，写上它，让编译器自动填上变量的类型。其属于编译阶段的特殊指令，因此在泛型编程和模板元编程里有比较多的使用。<br />
decltype比较像函数，来计算类型，跟auto很像。（也是编译阶段的类型推导）</p>
</blockquote>
<ul>
<li>
<p><strong>auto注意事项</strong>：</p>
<ul>
<li>
<p>auto的自动推导能力只能用在“初始化”场合</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">0L</span>;    <span class="comment">// 自动推导为long</span></span><br><span class="line"><span class="keyword">auto</span> y = &amp;x;    <span class="comment">// 自动推导为long*</span></span><br><span class="line"><span class="keyword">auto</span> z &#123;&amp;x&#125;;    <span class="comment">// 自动推导为long* </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> err;       <span class="comment">// 错误，没有赋值表达式，不知道是什么类型</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>类成员变量初始化时，不允许使用auto推导类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> <span class="keyword">final</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = <span class="number">10</span>;  <span class="comment">// 错误，类里不能使用auto推导类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>auto总是推导出“值类型”，绝不会是“引用”；但是auto可以附加上const、 *、&amp;等，得到新的类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>        x = <span class="number">10L</span>;    <span class="comment">// auto推导为long，x是long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp;       x1 = x;     <span class="comment">// auto推导为long，x1是long&amp;</span></span><br><span class="line"><span class="keyword">auto</span>*       x2 = &amp;x;    <span class="comment">// auto推导为long，x2是long*</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; x3 = x;     <span class="comment">// auto推导为long，x3是const long&amp;</span></span><br><span class="line"><span class="keyword">auto</span>        x4 = &amp;x3;   <span class="comment">// auto推导为const long*，x4是const long*</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>decltype注意事项</strong>：decltype没有auto这么多局限，<strong>前述auto的三个事项在decltype这里均不需要注意</strong>。</p>
<ul>
<li>
<p>类型推导时不需要初始化（后面无需有表达式），可以直接声明变量；</p>
</li>
<li>
<p>decltype不仅能够推导出值类型，还能推导出引用类型，即“原始类型”</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;          <span class="comment">// 整型变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(x)     x1;      <span class="comment">// 推导为int，x1是int</span></span><br><span class="line"><span class="keyword">decltype</span>(x)&amp;    x2 = x;    <span class="comment">// 推导为int，x2是int&amp;，引用必须赋值</span></span><br><span class="line"><span class="keyword">decltype</span>(x)*    x3;      <span class="comment">// 推导为int，x3是int*</span></span><br><span class="line"><span class="keyword">decltype</span>(&amp;x)    x4;      <span class="comment">// 推导为int*，x4是int*</span></span><br><span class="line"><span class="keyword">decltype</span>(&amp;x)*   x5;      <span class="comment">// 推导为int*，x5是int**</span></span><br><span class="line"><span class="keyword">decltype</span>(x2)    x6 = x2;  <span class="comment">// 推导为int&amp;，x6是int&amp;，引用必须赋值</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>C++14引入了<code>decltype(auto)</code>，既能够精确推导类型，又可以像auto一样方便（decltype里不再每次都输入特定的表达式了）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;            <span class="comment">// 整型变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>)     x1 = (x);  <span class="comment">// 推导为int&amp;，因为(expr)是引用类型</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>)     x2 = &amp;x;   <span class="comment">// 推导为int*</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>)     x3 = x1;   <span class="comment">// 推导为int&amp;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>auto和decltype的使用</strong>：</p>
<ul>
<li>
<p>auto使用场景：变量声明、range-based for：<code>for(auto&amp; i : vec)</code>、函数返回值<code>auto test()&#123;&#125;</code>（C++14）</p>
</li>
<li>
<p>decltype的使用场景：</p>
<ul>
<li>
<p>当类型非常奇怪时，给奇怪类型一个别名</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UNIX信号函数的原型，看着就让人晕，你能手写出函数指针吗？</span></span><br><span class="line"><span class="built_in">void</span> (*<span class="built_in">signal</span>(<span class="type">int</span> signo, <span class="built_in">void</span> (*func)(<span class="type">int</span>)))(<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用decltype可以轻松得到函数指针类型</span></span><br><span class="line"><span class="keyword">using</span> <span class="type">sig_func_ptr_t</span> = <span class="keyword">decltype</span>(&amp;signal) ;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>类内成员，auto被禁，decltype可以替换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DemoClass</span> <span class="keyword">final</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> set_type      = std::set;  <span class="comment">// 集合类型别名</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    set_type      m_set;                   <span class="comment">// 使用别名定义成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用decltype计算表达式的类型，定义别名</span></span><br><span class="line">    <span class="keyword">using</span> iter_type = <span class="keyword">decltype</span>(m_set.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">    iter_type     m_pos;                   <span class="comment">// 类型别名定义成员变量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="位域"><a class="markdownIt-Anchor" href="#位域"></a> 位域</h4>
<p>C++中的类和结构体可以包含比内置整形类型占用更少存储空间的成员。这些成员可以指定位数大小，叫做“位域”。</p>
<p>位域可以看做内置整形类型的子集，位域成员可以指定其在结构体中占用的位数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Date</span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> nWeekDay  : <span class="number">3</span>;  <span class="comment">//3 bits</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> nMonthDay : <span class="number">6</span>;  <span class="comment">//6 bits</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> nMonth    : <span class="number">5</span>;  <span class="comment">//5 bits</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> nYear     : <span class="number">8</span>;  <span class="comment">//8 bits</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/cpp-basic/image_MHylNzhysP.png" alt="" /></p>
<p>声明为位域的数据从低位到高位进行排序</p>
<p>假定系统中unsigned short是16位的，nYear8位，会溢出unsigned short类型的单元边界，因此它会从新的unsigned short开始。同时，还可以有匿名位域（宽度为0），匿名位域会强制下一字段与下一个类型边界对齐</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Date</span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> nWeekDay  : <span class="number">3</span>;  <span class="comment">//3 bits</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> nMonthDay : <span class="number">6</span>;  <span class="comment">//6 bits</span></span><br><span class="line">  <span class="type">unsigned</span>                 : <span class="number">0</span>;  <span class="comment">//强制对齐到下一边界</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> nMonth    : <span class="number">5</span>;  <span class="comment">//5 bits</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> nYear     : <span class="number">8</span>;  <span class="comment">//8 bits</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/cpp-basic/image_nuXGWwKUxa.png" alt="" /></p>
<p>带有零长度位域的对象布局</p>
<blockquote>
<p>📌位域字段的基础类型必须是整形类型（内置的那些）</p>
</blockquote>
<h3 id="3-模块化"><a class="markdownIt-Anchor" href="#3-模块化"></a> 3 模块化</h3>
<ul>
<li>
<p><strong>命名空间：</strong></p>
<p>一段完整的程序可能是由不同部分构成的，应对这种情况，为使结构清晰且编译加快，应该使用<strong>分离编译</strong>，即在头文件中声明，利用头文件提供接口，具体实现在不同源文件中。</p>
<p>但是若有多个开发者共同开发，把模块组装在一起构成程序并不一定是一件容易的事情，特别是当不同开发者命名了同一个函数名时。命名空间为解决此情况问题而生。</p>
<p>如要声明一个自己的complex类型，但又不想与std库中的complex类型冲突：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> My_Code&#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">complex</span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function">complex <span class="title">sort</span><span class="params">(complex)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">My_Code::complex <span class="title">My_Code::sort</span><span class="params">(My_Code::complex)</span></span>&#123;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  My_Code::complex a &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">  My_Code::complex result = My_Code::<span class="built_in">sort</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，如果不想写的像上面那样繁琐，也可以直接用using关键字<code>using namespace My_Code</code>，使得一个指定命名空间的名字在当前在当前作用域中可见。</p>
</li>
</ul>
<h3 id="4-错误处理"><a class="markdownIt-Anchor" href="#4-错误处理"></a> 4 错误处理</h3>
<ul>
<li>
<p><strong>异常&amp;不变式：</strong></p>
<p>异常负责报告<strong>运行时</strong>程序发射时能够的错误。由<code>throw</code>语句指定。例如在自定义Vector时，需要确保索引Vector对象时，不会有越界的情况发生。因此，可以在<code>operator[]()</code>中抛出异常：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span>&amp; Vector::<span class="keyword">operator</span>[](<span class="type">int</span> i)&#123;</span><br><span class="line">  <span class="keyword">if</span>(i&lt;<span class="number">0</span> || <span class="built_in">size</span>()&lt;=i)</span><br><span class="line">    <span class="keyword">throw</span> out_of_range&#123;<span class="string">&quot;Vector::operator[]&quot;</span>&#125;;</span><br><span class="line">  <span class="keyword">return</span> elem[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>throw</code>将程序的控制权从调用了Vector::operator[]()的函数转移到了out_of_range异常的异常处理代码。比如下面当try中的索引越界，抛出out_of_range异常后，会进入catch块中的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Vector&amp; v)</span></span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">try</span> &#123; <span class="comment">//可能发生越界错误的代码被放在了try块中</span></span><br><span class="line">    v[v.<span class="built_in">size</span>()] = <span class="number">7</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span> (out_of_range) &#123; <span class="comment">//捕捉到越界异常</span></span><br><span class="line">    <span class="comment">//处理越界错误</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，在调用构造函数构造Vector时，传入的参数也需要满足一些条件。将从调用构造函数，直到调用析构函数这一过程中，对象始终所满足的要求称为<strong>不变式</strong>(Invariant)。比如调用Vector构造函数指定包含多少个元素，却传进了一个负值，这时需要不变式来约束。这种情况下的不变式可以通过异常实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Vector::<span class="built_in">Vector</span>(<span class="type">int</span> s)&#123;</span><br><span class="line">  <span class="keyword">if</span> (s &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> length_error&#123;&#125;;</span><br><span class="line">  elem = <span class="keyword">new</span> <span class="type">double</span>[s];</span><br><span class="line">  sz = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="function">Vector <span class="title">v</span><span class="params">(<span class="number">-27</span>)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span> (std::length_error) &#123;</span><br><span class="line">    <span class="comment">//处理负值问题</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span> (std::bad_alloc) &#123;</span><br><span class="line">    <span class="comment">//处理内存耗尽问题</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>📌当希望一个函数永远不抛出异常，可以将其声明为noexcept。这样的话当函数抛出了异常，标准库函数terminate()会立即终止当前程序的执行，避免异常的传播和扩散。<br />
noexcept 等效于 noexcept(true)<br />
C++11后，类的析构函数默认是noexcept，也就是析构函数不允许抛出异常。但如果人为将声明改为noexcept(false)，或者其基类的析构函数是noexcept(false)，那么此时的析构函数可以抛出异常。<br />
此外，noexcept自身也可以是一个运算符，标志一个函数是否被声明成了noexcept，是否能抛出异常。 </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">noexcept</span></span>; </span><br><span class="line"><span class="comment">//函数f()不抛出异常</span></span><br><span class="line"><span class="built_in">void</span> (*fp) <span class="built_in">noexcept</span>(<span class="literal">false</span>); </span><br><span class="line"><span class="comment">//fp指向可能抛出异常的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">void</span> pfa() <span class="keyword">noexcept</span>)</span></span>; </span><br><span class="line"><span class="comment">//g接收不抛出异常的函数的指针</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">noexcept</span>(f); <span class="comment">//返回值为true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//两种noexcept可配合于函数模板</span></span><br><span class="line"><span class="comment">//以声明函数对某些类型抛异常，但不对其他类型抛出</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> <span class="title">noexcpet</span><span class="params">(<span class="keyword">noexcept</span>(T()))</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>静态断言：</strong></p>
<p>上述两种方式均为运行时报错，而静态断言可以在编译时报错，从而让开发者改进代码以规避运行时的错误。<code>static_assert(A,S)</code>机制的作用是，当A不为true时，把S作为一条编译器错误信息输出。</p>
<blockquote>
<p>📌需注意，A必须是常量表达式！</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">double</span> C = <span class="number">299792.458</span>;</span><br><span class="line"><span class="type">double</span> speed = <span class="number">100000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> local_max = <span class="number">160.0</span>/(<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line"><span class="built_in">static_assert</span>(speed&lt;C,<span class="string">&quot;can&#x27;t go that fast&quot;</span>);     <span class="comment">// 报错，speed不是常量，非常量表达式</span></span><br><span class="line"><span class="built_in">static_assert</span>(local_max&lt;C,<span class="string">&quot;can&#x27;t go that fast&quot;</span>); <span class="comment">// 正确，常量表达式</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="5-const"><a class="markdownIt-Anchor" href="#5-const"></a> 5 const</h3>
<h4 id="const常量与宏的区别"><a class="markdownIt-Anchor" href="#const常量与宏的区别"></a> const常量与宏的区别</h4>
<p><strong>const定义的常量在预处理阶段并不存在，而是直到运行阶段才出现</strong>。也就是说，const声明出来的是一种“只读变量”，可以用指针获取地址。既然可以获取指针，那么便可以利用指针再强制写入，从而“常量不常”。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要加上volatile修饰，运行时才能看到效果</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> <span class="type">int</span> MAX_LEN = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ptr = (<span class="type">int</span>*)(&amp;MAX_LEN);</span><br><span class="line">*ptr = <span class="number">2048</span>;</span><br><span class="line">cout &lt;&lt; MAX_LEN &lt;&lt; endl;<span class="comment">//输出2048</span></span><br></pre></td></tr></table></figure>
<p>修改时需要用volatile禁用优化。不加的话编译器看到const会采取优化手段，把所有const常量出现的地方替换成原值</p>
<h4 id="const修饰成员函数"><a class="markdownIt-Anchor" href="#const修饰成员函数"></a> const修饰成员函数</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">fun</span><span class="params">(<span class="type">int</span>&amp; a)</span></span>; <span class="comment">//修饰返回值</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">fun</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a)</span></span>; <span class="comment">//修饰形参</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">fun</span><span class="params">(<span class="type">int</span>&amp; a)</span> <span class="type">const</span></span>&#123;&#125; <span class="comment">//const成员函数</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>const修饰返回值</p>
<p>const修饰返回值多是在返回类型为引用的情况下，避免返回值被修改的情况。</p>
<p>因为此时这个引用比不是临时对象的引用，必然是成员变量后函数参数。不用const修饰可能会成为左值被修改，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> num):<span class="built_in">data</span>(num)&#123;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span>&amp; <span class="title">get_data</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    a.<span class="built_in">get_data</span>()=<span class="number">3</span>;</span><br><span class="line">    cout&lt;&lt;a.<span class="built_in">get_data</span>()&lt;&lt;endl; <span class="comment">//data=3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果返回值加上了const，此时试图改变返回值的操作是不允许的，编译会报错。从而规避上述情况。</p>
</li>
<li>
<p>const修饰形参</p>
<p>传引用的方式可以节省内存，提高效率。但导致了函数具备修改该值的风险。如果在引用类型的形参前加const，就可以规避此风险。</p>
</li>
<li>
<p>const修饰成员函数</p>
<p>考虑这样一种场景：一个对象被声明成const，但是其某个成员函数非const，此时通过该对象调用该成员函数，编译器会报错</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> String <span class="title">str</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line">str.<span class="built_in">print</span>(); <span class="comment">//类内的print没有被const修饰</span></span><br></pre></td></tr></table></figure>
<p>这是因为调用成员函数时，会使用this指针。但是我们定义了一个const对象，但this指针不是const类型的，所以出现参数类型不匹配，编译无法通过的情况。</p>
<p><strong>用const修饰成员函数，实质上是修饰this所指向的对象</strong>。</p>
<p>当类内没有函数重载，即只有一个版本的成员函数时，const对象只能调用const成员函数，non-const对象既可以调用const成员函数，也可以调用non-const成员函数。</p>
<p>而如果一个成员函数同时有const和non-const两个版本的话，const对象只能调用const成员函数，non-const对象只能调用non-const成员函数。</p>
</li>
</ul>
<h4 id="const修饰指针"><a class="markdownIt-Anchor" href="#const修饰指针"></a> const修饰指针</h4>
<ul>
<li>
<p>const char* ptr：* ptr是const的，即不能通过*ptr修改值，但是ptr可以修改，值也可改</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="type">char</span> ss[] = <span class="string">&quot;good game||&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* ptr = str;</span><br><span class="line"></span><br><span class="line">ptr[<span class="number">0</span>] = <span class="string">&#x27;s&#x27;</span>; <span class="comment">//报错！</span></span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;s&#x27;</span>; <span class="comment">//不报错，正常，输出会得到&quot;sello world&quot;</span></span><br><span class="line">ptr = ss;     <span class="comment">//不报错，输出*ptr会得到&quot;good game||&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>char const* ptr：与<code>const char*</code>一致。</p>
</li>
<li>
<p>char* const ptr：ptr是const的，即不能修改ptr，但可以通过*ptr改值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="type">char</span> ss[] = <span class="string">&quot;good game||&quot;</span>;</span><br><span class="line"><span class="type">char</span>* <span class="type">const</span> ptr = str;</span><br><span class="line"></span><br><span class="line">ptr[<span class="number">0</span>] = <span class="string">&#x27;s&#x27;</span>; <span class="comment">//正常</span></span><br><span class="line">ptr = ss;     <span class="comment">//报错</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>📌const在*前值不变，const在*后地址不变<br />
值得注意的是，有一种说法为const在前的属于<strong>底层const</strong>，而const在后的属于<strong>顶层const</strong><code>const int*</code>，<code>const int&amp;</code>这种属于底层const，使得值不可改；<code>int* const</code>属于顶层const，值可改</p>
</blockquote>
<h3 id="6-匿名函数lambda表达式"><a class="markdownIt-Anchor" href="#6-匿名函数lambda表达式"></a> 6 匿名函数（lambda表达式）</h3>
<p>具体形式：<code>[capture](parameters)→return-type&#123;body&#125;</code></p>
<p>如最简单的形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="type">int</span> x, <span class="type">int</span> y)-&gt;<span class="type">int</span> &#123;<span class="type">int</span> z=x+y; <span class="keyword">return</span> z;&#125;</span><br></pre></td></tr></table></figure>
<p>若想捕获外部变量，可在[ ]内输入外部参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[]        <span class="comment">//未定义变量.试图在Lambda内使用任何外部变量都是错误的.</span></span><br><span class="line">[x, &amp;y]   <span class="comment">//x 按值捕获, y 按引用捕获.</span></span><br><span class="line">[&amp;]       <span class="comment">//用到的任何外部变量都隐式按引用捕获</span></span><br><span class="line">[=]       <span class="comment">//用到的任何外部变量都隐式按值捕获</span></span><br><span class="line">[&amp;, x]    <span class="comment">//x显式地按值捕获. 其它变量按引用捕获</span></span><br><span class="line">[=, &amp;z]   <span class="comment">//z按引用捕获. 其它变量按值捕获</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; some_list;</span><br><span class="line"><span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i) some_list.<span class="built_in">push_back</span>(i);</span><br><span class="line">std::for_each(<span class="built_in">begin</span>(some_list), <span class="built_in">end</span>(some_list), [&amp;total](<span class="type">int</span> x) </span><br><span class="line">&#123;</span><br><span class="line">    total += x;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌[ ]中想捕获this时，this只能按值捕获<code>[this]</code>。</p>
</blockquote>
<p>如果用户想把lambda表达式当作一个参数来传递，可以用auto关键字（转换成<code>std::function</code>对象）帮助存储：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">eval</span><span class="params">(std::function&lt;<span class="type">double</span>(<span class="type">double</span>)&gt; f, <span class="type">double</span> x = <span class="number">2.0</span>)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">f</span>(x);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     std::function&lt;<span class="type">double</span>(<span class="type">double</span>)&gt; f0    = [](<span class="type">double</span> x)&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;;</span><br><span class="line">     <span class="keyword">auto</span>                          f1    = [](<span class="type">double</span> x)&#123;<span class="keyword">return</span> x;&#125;;</span><br><span class="line">     <span class="keyword">decltype</span>(f0)                  fa[<span class="number">3</span>] = &#123;f0,f1,[](<span class="type">double</span> x)&#123;<span class="keyword">return</span> x*x;&#125;&#125;;</span><br><span class="line">     std::vector&lt;<span class="keyword">decltype</span>(f0)&gt;     fv    = &#123;f0,f1&#125;;</span><br><span class="line">     fv.<span class="built_in">push_back</span>                  ([](<span class="type">double</span> x)&#123;<span class="keyword">return</span> x*x;&#125;);</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;fv.<span class="built_in">size</span>();i++)  std::cout &lt;&lt; fv[i](<span class="number">2.0</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)          std::cout &lt;&lt; fa[i](<span class="number">2.0</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;f : fv)             std::cout &lt;&lt; <span class="built_in">f</span>(<span class="number">2.0</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;f : fa)             std::cout &lt;&lt; <span class="built_in">f</span>(<span class="number">2.0</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">     std::cout &lt;&lt; <span class="built_in">eval</span>(f0) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">     std::cout &lt;&lt; <span class="built_in">eval</span>(f1) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌- std::function&lt;double(double)&gt;里，括号外的double是返回类型，括号里的double是参数类型<br />
- decltype()，C++11中的类型说明符，返回操作数的数据类型。</p>
</blockquote>
<blockquote>
<p>lambda表达式其实是一种闭包。</p>
</blockquote>
<h4 id="mutable"><a class="markdownIt-Anchor" href="#mutable"></a> mutable</h4>
<ul>
<li>
<p>修饰类内成员</p>
<p>前面说到，被const修饰的常成员函数，不会修改对象的任何属性。但是没有提到一种情况，那就是该属性由mutable修饰。mutable的作用是：可以在常成员函数中被修改其值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; m_data++ &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="type">int</span> m_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修饰匿名函数</p>
<p>当[]中采用值捕获时，是不允许在匿名函数内部修改捕获的变量的值的。但是如果有mutable修饰匿名函数，则在捕获时会创建该变量在匿名函数中的<strong>同名拷贝</strong>，而且该拷贝会一直存在，直到匿名函数作用域完结。此时，匿名函数内部可以对该“变量”（实质上是拷贝）进行修改，同时不必担心原变量被修改。而且每次进入相同的匿名函数时，该拷贝都会维持上一次调用该函数时的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> t = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//按值捕获</span></span><br><span class="line">  <span class="keyword">auto</span> f = [t]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ++t;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">auto</span> f2 = [t]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ++t;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="built_in">f</span>() &lt;&lt; endl;   <span class="comment">//11</span></span><br><span class="line">  cout &lt;&lt; <span class="built_in">f2</span>() &lt;&lt; endl;  <span class="comment">//11</span></span><br><span class="line">  cout &lt;&lt; <span class="built_in">f</span>() &lt;&lt; endl;   <span class="comment">//12</span></span><br><span class="line">  cout &lt;&lt; <span class="built_in">f2</span>() &lt;&lt; endl;  <span class="comment">//12</span></span><br><span class="line">  cout &lt;&lt; t &lt;&lt;endl;      <span class="comment">//10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="7-函数指针"><a class="markdownIt-Anchor" href="#7-函数指针"></a> 7 函数指针</h3>
<p>函数指针指向的是函数而非对象，其指向的函数的类型，仅由其返回值类型和形参类型决定，与函数名无关。比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>定义了一个函数<code>lengthCompare</code>，其类型为<code>bool(const string&amp;, const string&amp;)</code>。可以声明一个指针pf：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> (*pf)(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌*pf两端的括号<strong>必不可少</strong>。如果不写这对括号，表示一个函数，返回bool*类型的返回值</p>
</blockquote>
<p>这是一个指向<code>bool(const string&amp;, const string&amp;)</code>类型函数的<strong>函数指针</strong>，因此可以有</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pf = lengthCompare;                          <span class="comment">//pf指向lengthCompare函数</span></span><br><span class="line">pf = &amp;lengthCompare;                         <span class="comment">//等价的赋值语句：取地址符是可选的</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> b1 = <span class="built_in">pf</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;goodbye&quot;</span>);            <span class="comment">//调用lengthCompare函数</span></span><br><span class="line"><span class="type">bool</span> b2 = (*pf)(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;goodbye&quot;</span>);         <span class="comment">//一个等价的调用</span></span><br><span class="line"><span class="type">bool</span> b3 = <span class="built_in">lengthCompare</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;goodbye&quot;</span>); <span class="comment">//另一个等价的调用</span></span><br></pre></td></tr></table></figure>
<h4 id="重载函数的指针"><a class="markdownIt-Anchor" href="#重载函数的指针"></a> 重载函数的指针</h4>
<p>如果指针指向一个函数，这个函数的函数名被很多函数共享，即出现重载，那么编译器需要通过指针类型决定选用哪个函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">(<span class="type">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> (*pf1)(<span class="type">unsigned</span> <span class="type">int</span>) = ff; <span class="comment">//pf1指向ff(unsigned)</span></span><br><span class="line"><span class="built_in">void</span> (*pf2)(<span class="type">int</span>) = ff;          <span class="comment">//错误，没有可以匹配的重载（参数角度）</span></span><br><span class="line"><span class="built_in">double</span> (*pf3)(<span class="type">int</span>*) = ff;       <span class="comment">//错误，没有可以匹配的重载（返回类型角度）</span></span><br></pre></td></tr></table></figure>
<p>可以看出，相比于一般的重载（只看形参，不看返回值），函数指针在重载的选择上要苛刻一些，既考虑了形参，又要考虑返回值类型。</p>
<h4 id="函数指针形参"><a class="markdownIt-Anchor" href="#函数指针形参"></a> 函数指针形参</h4>
<p>C++“表面上”是可以把“函数类型”作为形参传入一个函数的，即：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第三个形参是函数类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">bool</span> pf(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;))</span></span>;</span><br></pre></td></tr></table></figure>
<p>实际上，编译器偷偷地做了一个隐式转换，将所谓的函数类型给解释成了函数指针问题，即转换成了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">bool</span> (*pf)(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;))</span></span>;</span><br></pre></td></tr></table></figure>
<p>此时可以直接把函数名作为实参传入，它会被<strong>自动转换成指针</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">useBigger</span>(s1, s2, lengthCompare);</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>利用类型别名和decltype简化函数指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ---- 函数类型别名 ---- */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="type">bool</span> <span class="title">Func</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;)</span></span>; <span class="comment">//定义Func为bool(const string&amp;, const string&amp;)类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> Func2</span>;           <span class="comment">//定义Func2为与lengthCompare类型一致的函数类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ---- 函数指针别名 ---- */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span><span class="params">(*FuncP)</span> <span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;)</span></span>; <span class="comment">//定义FuncP为函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> *FuncP2</span>;             <span class="comment">//decltype返回的是类型，所以要加上*才能使FuncP2指针</span></span><br></pre></td></tr></table></figure>
<p>那么在使用的时候，就可以使用下面这几种等价写法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;, Func)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;, Func2)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;, FuncP)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;, FuncP2)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第1、2条语句中，编译器自动将Func、Func2类型转换成函数指针</p>
</li>
</ul>
<h4 id="返回指向函数的指针"><a class="markdownIt-Anchor" href="#返回指向函数的指针"></a> 返回指向函数的指针</h4>
<p>函数不能作为另一个函数的返回值，但是函数可以返回函数指针，以达到类似效果。然而，返回值不再像形参一样，编译器不再对返回值进行自动的隐式转换，因此<strong>返回值需要显式声明为函数指针类型</strong>。而简化这种显式声明的方式仍然是别名：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> F = <span class="built_in">int</span>(<span class="type">int</span>*, <span class="type">int</span>);      <span class="comment">//F是函数类型，不是指针</span></span><br><span class="line"><span class="keyword">using</span> PF = <span class="built_in">int</span>(*)(<span class="type">int</span>*, <span class="type">int</span>);  <span class="comment">//PF是指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;                    <span class="comment">//正确：PF是指向函数的指针，f1返回指向函数的指针</span></span><br><span class="line"><span class="function">F <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;                     <span class="comment">//错误：F是函数类型，f1不能返回一个函数</span></span><br><span class="line"><span class="function">F *<span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;                    <span class="comment">//正确：显式地指定返回类型是指向F类型函数的指针</span></span><br></pre></td></tr></table></figure>
<p>此外，还有一种奇技淫巧，可以用下面的形式声明f1：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*<span class="built_in">f1</span>(<span class="type">int</span>)) (<span class="type">int</span>*, <span class="type">int</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">需要按照由内向外的顺序解读此代码：f1有形参列表，所以它是函数，f1前面有*，所以f1返回一个指针；</span></span><br><span class="line"><span class="comment">进一步观察发现，指针的类型本身也包含形参列表，因此指针指向函数，该函数的返回值类型是int</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>Modern C++中，也可以用尾置返回类型的方式，声明一个返回函数指针的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> -&gt; <span class="title">int</span><span class="params">(*)</span><span class="params">(<span class="type">int</span>*, <span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="8-常用关键字"><a class="markdownIt-Anchor" href="#8-常用关键字"></a> 8 常用关键字</h3>
<h4 id="四种cast转换"><a class="markdownIt-Anchor" href="#四种cast转换"></a> 四种cast（转换）</h4>
<ul>
<li>
<p>const_cast</p>
<p>用于将const变量转化为非const。</p>
</li>
<li>
<p>static_cast</p>
<p>用于各种<strong>隐式转换</strong>，比如非const转const，void*转指针等，<code>static_cast</code>能用于多态向上转化，如果向下转，不管是否非法，都会直接转而无视潜在的问题，因此不安全。</p>
</li>
<li>
<p>dynamic_cast</p>
<p>用于动态类型转换。<strong>只能用于含有虚函数的类</strong>，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果转化的是指针，且是非法的，返回NULL；如果转化的是引用，且是非法的，则抛出异常（相比于static_cast更安全）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我是父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tfather</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;father&#x27;s f()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我是子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tson</span> : <span class="keyword">public</span> Tfather</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;son&#x27;s f()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> data; <span class="comment">// 我是子类独有成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Tfather father;</span><br><span class="line">Tson son;</span><br><span class="line">son.data = <span class="number">123</span>;</span><br><span class="line">Tfather* pf;</span><br><span class="line">Tson* ps;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上行转换：没有问题，多态有效 */</span></span><br><span class="line">ps = &amp;son;</span><br><span class="line">pf = <span class="built_in">dynamic_cast</span>&lt;Tfather *&gt;(ps);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>reinterpret_cast</p>
<p>几乎什么都可以转，比如将int转为指针，可能会出问题，尽量少用。</p>
</li>
</ul>
<blockquote>
<p>📌为什么不使用C的强制转换？<br />
C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。</p>
</blockquote>
<blockquote>
<p><strong>隐式转换</strong>的四种方式：<br />
1. <strong>算术表达式</strong><br />
int m=10; double n=m;                            <a target="_blank" rel="noopener" href="//n=10.0">//n=10.0</a>，隐式把m转为double类型<br />
2. <strong>赋值</strong><br />
int* p = NULL;                                          //NULL(0)隐式转换为int*类型的空指针值<br />
3. <strong>函数入参</strong><br />
float add(float f); add(2);                         //2隐式转换为float类型<br />
4. <strong>函数返回值</strong><br />
double minus(int a, int b) { return a-b; } //返回值隐式转换为double类型</p>
</blockquote>
<h4 id="static作用"><a class="markdownIt-Anchor" href="#static作用"></a> static作用</h4>
<ul>
<li>
<p>static作用在全局变量</p>
<p>加了static之后，变量只在当前文件有效</p>
</li>
<li>
<p>static作用在类成员变量</p>
<p>static成员变量可以实现多个对象之间的数据共享，<strong>静态数据成员只存储一处</strong>，供所有对象共用</p>
</li>
<li>
<p>static作用在全局函数</p>
<p><strong>在定义该函数的文件内才能使用</strong>。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static</p>
<p>如果想要其他文件可以引用本地函数，则要在函数定义时使用关键字extern，表示该函数是外部函数，可供其他文件调用</p>
</li>
<li>
<p>static作用在类成员函数</p>
<p><strong>由于static修饰的类成员属于类，不属于对象</strong>，<strong>因此static类成员函数是没有this指针的</strong>，正因为没有this指针，<strong>所以static类成员函数不能访问非static的类成员，只能访问 static修饰的类成员</strong></p>
<blockquote>
<p>📌<strong>phread_create参数必须是static的，因为非static会自动加一个this指针，导致传入参数和函数不匹配</strong></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>📌C<ins>是否允许同时用const和static修饰一个成员函数呢？<br />
答案是不可以，C</ins>编译器在实现const的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数const this *。但当一个成员为static的时候，该函数是没有this指针的。也就是说此时const的用法和static是冲突的。</p>
<p>同理，virtual和static也不能一起用，virtual也有一个隐含参数this指针。</p>
</blockquote>
<h3 id="9-再看函数重载"><a class="markdownIt-Anchor" href="#9-再看函数重载"></a> 9 再看函数重载</h3>
<p>函数重载<strong>取决于参数的类型、个数，而跟返回类型无关</strong>。编译器通过在<strong>编译时对函数重新命名</strong>以解决同名冲突。</p>
<p>对于普通函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Print an integer: &quot;</span> &lt;&lt; i &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Print a string: &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>objdump -d a.out &gt;log.txt</code>反汇编，可以将编译结果打印到log.txt中进行分析。分析可知：</p>
<p><code>void print(int i)</code>→**_Z5printi**</p>
<p><code>void print(String s)</code>→**_Z5printSs**</p>
<p>其中Z5表示返回值类型，i表示int类型,Ss表示String类型（g++编译结果，vs的方案可能会有出入）</p>
<p>对于类内的函数重载：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;char&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>反汇编后，可知两个函数被映射为：</p>
<p><code>void print(int i)</code>→**_ZN4test5printEi**</p>
<p><code>void print(char c)</code>→**_ZN4test5printEc**</p>
<p>N4test表示作用域。</p>
<p>由以上可知，g++对函数重载的映射机制为：<strong>作用域 + 返回类型 + 函数名 + 参数列表</strong></p>
<p>虽然返回值类型也参与了函数重载的映射机制，但是编译器处理函数重载时并不考虑返回值类型，这样可使函数调用时独立于上下文，而且减少很多麻烦，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">sqrt</span><span class="params">(<span class="type">float</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">sqrt</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">double</span> da, <span class="type">float</span> fla)</span></span>&#123;</span><br><span class="line">  <span class="type">float</span> fl = <span class="built_in">sqrt</span>(da);   <span class="comment">// 调用sqrt(double)</span></span><br><span class="line">  <span class="type">double</span> d = <span class="built_in">sqrt</span>(da);   <span class="comment">// 调用sqrt(double)</span></span><br><span class="line"></span><br><span class="line">  fl = <span class="built_in">sqrt</span>(fla); <span class="comment">//调用sqrt(float)</span></span><br><span class="line">  d = <span class="built_in">sqrt</span>(fla);  <span class="comment">//调用sqrt(float)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="函数重载时的匹配优先级"><a class="markdownIt-Anchor" href="#函数重载时的匹配优先级"></a> 函数重载时的匹配优先级</h4>
<blockquote>
<p>C++ Primer 6.6节</p>
</blockquote>
<p>C++编译器力图找最佳匹配。为了确定最佳匹配，编译器将实参类型向形参类型的转换划分为几个等级，具体排序如下：</p>
<ol>
<li>
<p>精确匹配，包括以下情况</p>
<ul>
<li>
<p>实参类型和形参类型相同</p>
</li>
<li>
<p>实参从数组类型或函数类型转换为对应的指针类型</p>
<ul>
<li>
<p>数组类型转指针：在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span>* ip = ia;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>函数类型转指针：当把一个函数名传入函数时，编译器会隐式将其转换为函数指针类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string&amp; s1, <span class="type">const</span> string&amp; s2,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">bool</span> (*pf)(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">useBigger</span>(s1, s2, lengthCompare);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>向实参添加顶层const或从实参删除顶层const</p>
<p>可以理解为，顶层const不影响参数，因此下面的两个函数，是相同的参数类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>* <span class="type">const</span> a)</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>* b)</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当程序中有两个这样的函数，编译时会报错，因为发生了歧义，编译器不知道应该选择哪个函数。</p>
</li>
</ul>
</li>
<li>
<p>通过const转换实现的匹配</p>
<p>特指底层const转换，一般是非const转换成const形参</p>
</li>
<li>
<p>通过类型提升实现的匹配</p>
<ul>
<li>
<p>对于bool, char, signed char, unsigned char, short, unsigned short等类型，只要所有可能的值都能存在int里，它们就会被提升为int；否则，提升为unsigned int。</p>
</li>
<li>
<p>较大的char类型（wchar_t, char16_t, char32_t）提升成int, unsigned int, long, unsigned long, long long, unsigned long long中最小的一种类型，前提是转换后的类型能容纳原类型所有可能的值。</p>
</li>
</ul>
</li>
<li>
<p>通过算术类型转换和指针转换实现的匹配</p>
<ul>
<li>
<p>算术类型转换就是不同数值类型间的相互转换，如int,short,double之类，但不再局限于类型提升，double也可隐式转为int，也能匹配到。</p>
</li>
<li>
<p>指针转换：</p>
<ol>
<li>
<p>常量整数值0或者字面值nullptr能转换成任意指针类型</p>
</li>
<li>
<p>指向任意非常量的指针能转换成void*</p>
</li>
<li>
<p>指向任意对象的指针能转换成const void*</p>
</li>
<li>
<p>继承关系：编译器会隐式地执行派生类到基类的转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Bulk_quote继承自Quote</span></span><br><span class="line">Quote item;</span><br><span class="line">Bulk_quote bulk;</span><br><span class="line">Quote *p = &amp;item;</span><br><span class="line">p = &amp;bulk;</span><br><span class="line">Quote &amp;r = bulk;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li>
<p>算术类型/指针类型自动转换成bool类型</p>
<p>存在一种从算术类型或指针类型向布尔类型自动转换的机制。如果指针或算术类型的值为0，转换结果为false；否则转换结果是true。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* cp = <span class="built_in">get_string</span>();</span><br><span class="line"><span class="keyword">if</span>(cp)    <span class="comment">/*...*/</span>   <span class="comment">//如果指针cp不是0，条件为真</span></span><br><span class="line"><span class="keyword">while</span>(*cp) <span class="comment">/*...*/</span>   <span class="comment">//如果*cp不是空字符，条件为真</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>通过类类型转换实现的匹配：见“类”章。</p>
<p>类类型转换的一个例子就是，char*转换成string类型</p>
</li>
</ol>
<p>考虑这样一个场景</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Employee* <span class="title">findEmployee</span><span class="params">(<span class="type">const</span> std::string&amp; surname, <span class="type">const</span> std::string&amp; givenName, <span class="type">bool</span> retired=<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="function">Employee* <span class="title">findEmployee</span><span class="params">(<span class="type">const</span> std::string&amp; fullName, <span class="type">bool</span> retired = <span class="literal">false</span>)</span></span></span><br><span class="line"><span class="function">Employee* e </span>= <span class="built_in">findEmployee</span>(<span class="string">&quot;Chen&quot;</span>, <span class="string">&quot;Shuo&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>一般可能认为，执行第3行时，会调用第1行对应的函数。实则不然，实际情况下会调用第2行对应的函数。这就涉及上面所说的优先级问题。&quot;chen&quot;这种字符串字面量，作为参数时，是const char*类型，两种重载都没有考虑const char*，因此需要进行隐式转换。从const char*转换为string，是一个类类型转换，而从const char*转换为bool，是一个指针类型转换，后者优先级高于前者，因此会调用第2行对应的函数重载。</p>
<h4 id="引入模板的重载"><a class="markdownIt-Anchor" href="#引入模板的重载"></a> 引入模板的重载</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T a)</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="number">3</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">foo</span>(<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后会输出3，也就是使用了有模板的foo函数重载。因为编译器力图精确匹配，而T可以被推断为double/float类型，比int更精确，所以会使用有模板的foo函数重载。</p>
<h2 id="面向对象"><a class="markdownIt-Anchor" href="#面向对象"></a> 面向对象</h2>
<h3 id="10-类"><a class="markdownIt-Anchor" href="#10-类"></a> 10 类</h3>
<blockquote>
<p>C++中的类可大致分为三种：具体类、抽象类和类层次漫游中的类。大部分类可归为这三种之一，或某种的简单变形，或某几种的组合。</p>
</blockquote>
<ul>
<li>
<p><strong>具体类：</strong></p>
<p>具体类可以有与内置类型相似的行为，同时为了提高灵活性，还可以把成员变量的主体部分放在自由存储中（动态内存、堆）。一个经典的用户自定义类型是complex：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span>&#123;</span><br><span class="line">  <span class="type">double</span> re,im;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">complex</span>(<span class="type">double</span> r, <span class="type">double</span> i): re&#123;r&#125;, im&#123;i&#125;&#123;&#125;</span><br><span class="line">  <span class="built_in">complex</span>(<span class="type">double</span> r): re&#123;r&#125;, im&#123;<span class="number">0</span>&#125;&#123;&#125;</span><br><span class="line">  <span class="built_in">complex</span>(): re&#123;<span class="number">0</span>&#125;, im&#123;<span class="number">0</span>&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">real</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> re;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">real</span><span class="params">(<span class="type">double</span> d)</span> </span>&#123;re = d;&#125;</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">imag</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> im;&#125;                     <span class="comment">//const 常量函数，函数不会改变所调用的对象</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">imag</span><span class="params">(<span class="type">double</span> d)</span> </span>&#123;im = d;&#125;</span><br><span class="line"></span><br><span class="line">  complex&amp; <span class="keyword">operator</span>+=(complex z)&#123;re+=z.re, im+=z.im; <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">  complex&amp; <span class="keyword">operator</span>-=(complex z)&#123;re-=z.re, im-=z.im; <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line"></span><br><span class="line">  complex&amp; <span class="keyword">operator</span>*=(complex);<span class="comment">//在类外的某处进行定义</span></span><br><span class="line">  complex&amp; <span class="keyword">operator</span>/=(complex);<span class="comment">//在类外的某处进行定义</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//很多函数并不需要访问complex的成员变量，因此其定义可以与类的定义分离开来</span></span><br><span class="line">complex <span class="keyword">operator</span>+(complex a, complex b)&#123; <span class="keyword">return</span> a += b; &#125;</span><br><span class="line">complex <span class="keyword">operator</span>-(complex a, complex b)&#123; <span class="keyword">return</span> a -= b; &#125;</span><br><span class="line">complex <span class="keyword">operator</span>-(complex a)&#123; <span class="keyword">return</span> &#123;-a.<span class="built_in">real</span>(), -a.<span class="built_in">imag</span>()&#125;; &#125;</span><br><span class="line">complex <span class="keyword">operator</span>*(complex a, complex b)&#123; <span class="keyword">return</span> a *= b; &#125;</span><br><span class="line">complex <span class="keyword">operator</span>/(complex a, complex b)&#123; <span class="keyword">return</span> a /= b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==()&#123;</span><br><span class="line">  <span class="keyword">return</span> a.<span class="built_in">real</span>() == b.<span class="built_in">real</span>() &amp;&amp; a.<span class="built_in">imag</span>() == b.<span class="built_in">imag</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=()&#123;</span><br><span class="line">  <span class="keyword">return</span> !(a==b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>complex必须足够高效，否则专门定义一个类没有意义，因此简单的操作必须设置成内联的。</p>
<blockquote>
<p>📌定义在类里面的函数默认是内联的，也可以在声明前加上inline关键字显式指定。</p>
</blockquote>
<ul>
<li>
<p>当给自定义类型使用运算符重载时，应该尊重其常规使用习惯：</p>
<ul>
<li>
<p>比如不能定义一元运算符/，因为其语法在语言中已固定；</p>
</li>
<li>
<p>也不能改变内置类型的运算符的含义，如不能重新定义+执行int的减法</p>
</li>
</ul>
</li>
<li>
<p>数据句柄模型(handle-to-data model)：</p>
<blockquote>
<p>构造函数负责为元素分配空间并正确初始化成员，析构函数负责释放空间。</p>
</blockquote>
<p>这也是<strong>资源获取即初始化(Resource Acquisition Is Initialization, RAII)</strong> 技术，可以防止在普通代码中利用“裸new”和“裸delete”分配内存，而是将分配操作隐藏在行为良好的抽象的实现内部，规避资源泄露的潜在风险。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">double</span>* elem; <span class="comment">//elem指向含有sz个double型元素的数组</span></span><br><span class="line">  <span class="type">int</span> sz;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Vector</span>(<span class="type">int</span> s): elem&#123;<span class="keyword">new</span> <span class="type">double</span>[s]&#125;,sz&#123;s&#125; &#123;   <span class="comment">// 构造函数，获取资源</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i!=s;++i)</span><br><span class="line">      elem[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Vector</span>()&#123;<span class="keyword">delete</span>[] elem;&#125;                    <span class="comment">// 析构函数，释放资源</span></span><br><span class="line"></span><br><span class="line">  <span class="type">double</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> i);</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的构造函数，先建立了一定数目的存储，然后给存储中的各个元素赋值，用户使用时再向其中填值。这不是很好的初始化方法。更简洁的途径是;</p>
<ul>
<li>
<p>利用元素列表进行初始化：</p>
<p>先重载一个构造函数<code>Vector(std::initializer_list&lt;double&gt;)</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vector::<span class="built_in">Vector</span>(std::initializer_list&lt;<span class="type">double</span>&gt; lst):</span><br><span class="line">  elem&#123;<span class="keyword">new</span> <span class="type">double</span>[lst.<span class="built_in">size</span>()]&#125;, sz&#123;<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(lst.<span class="built_in">size</span>())&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">copy</span>(lst.<span class="built_in">begin</span>(), lst.<span class="built_in">end</span>(), elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>std::initializer_list</code>是一种标准库类型，使用{1,2,3,4}列表时，编译器会创建一个该类型的对象。</p>
<p><code>static_cast</code>负责强制类型转换，旨在避免特别严重的错误。</p>
<p>因此此时可以采用初始值列表来做初始化：<code>Vector v1 = &#123;1,2,3,4,5&#125;;</code></p>
</li>
<li>
<p>push_back()：在序列的末尾添加一个元素，容器长度加1.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>抽象类：</strong></p>
<p>抽象类的作用更类似于提供一个接口，将使用者与类的实现细节完全隔离开来。如设计一个比Vector更抽象的Container类：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> <span class="type">double</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span>) = <span class="number">0</span>;<span class="comment">//纯虚函数</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;       <span class="comment">//常量成员函数</span></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Container</span>()[]              <span class="comment">//析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">(Container&amp; c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> sz = c.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i!=sz;++i)</span><br><span class="line">    cout&lt;&lt;c[i]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>virtual</code>关键字声明虚函数（可能在派生类中被重新定义），<code>=0</code>表示虚函数是纯虚函数，即Container的派生类必须定义这个函数。抽象类中不需要自行定义构造函数，因为不需要初始化数据，而且析构函数也是虚函数。</p>
<blockquote>
<p>📌抽象类应放弃包含局部成员。</p>
</blockquote>
<p><strong>多态模型</strong>：<code>use()</code>完全忽视Container的实现细节，而使用Container接口。这种为其他类型提供接口的类，一般称为多态模型(polymorphic type)。use函数可以使用所有派生自Container的有这样接口的派生类。</p>
<ul>
<li>
<p>派生类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vector_container</span>: <span class="keyword">public</span> Container&#123;      <span class="comment">//:public表示继承关系</span></span><br><span class="line">  Vector v;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Vector_container</span>(<span class="type">int</span> s): <span class="built_in">v</span>(s) &#123;&#125;</span><br><span class="line">  ~<span class="built_in">Vector_container</span>() &#123;&#125;</span><br><span class="line">  <span class="type">double</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> i) &#123; <span class="keyword">return</span> v[i]; &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> v.<span class="built_in">size</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Vector_container vc &#123;<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="built_in">use</span>(vc);                                      <span class="comment">//使用多态模型，可以直接使用所有派生类</span></span><br></pre></td></tr></table></figure>
<p>需要注意：使用多态模型会带来灵活性，但是必须通过引用或指针操作对象！</p>
<p>这里的<code>~Vector_container()</code>隐式调用了<code>~Vector()</code></p>
</li>
<li>
<p>虚函数的编译器实现：</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/cpp-basic/image_6jwbJcI4f8.png" alt="" /></p>
<p>当使用Vector_container作为Container对象时，use将必须使用Vector_container的operator[]()，而其他派生类则会使用那些派生类实现的operator[]()。因此Container的对象必须包含一些信息，使得运行时能够选择正确的虚函数实现。</p>
<p>做法如上图，编译器将虚函数名字转换成虚函数表(virtual function table, vtbl)，每个含有虚函数的类都有自己的vtbl用于辨识虚函数，从而确保对象被正确使用。调用Container对象时只需要知道vtbl指针位置和各虚函数索引即可。</p>
<blockquote>
<p>📌这种方式，会使虚函数的调用多一些开销，如每个类都需要一个vtbl，并且保留其指针。但是函数调用的效率还是非常接近“普通函数调用”的（相差不超过25%）。</p>
</blockquote>
</li>
<li>
<p>派生类的构造函数：</p>
<p>考虑这样的基类和派生类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quote</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Quote</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">Quote</span>(<span class="type">const</span> std::string &amp;book, <span class="type">double</span> sales_price):</span><br><span class="line">    <span class="built_in">bookNo</span>(book), <span class="built_in">price</span>(sales_price) &#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string bookNo;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">double</span> price = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span> : <span class="keyword">public</span> Quote&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Bulk_quote</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">Bulk_quote</span>(<span class="type">const</span> std::string &amp;book, <span class="type">double</span> p, std::<span class="type">size_t</span> qty, <span class="type">double</span> disc);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::<span class="type">size_t</span> min_qty = <span class="number">0</span>;</span><br><span class="line">  <span class="type">double</span> discount = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>派生类对象中含有从基类继承的成员，但是派生类并不能直接初始化这些成员。<strong>派生类必须使用基类的构造函数来初始化它的基类部分</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote::<span class="built_in">Bulk_quote</span>(<span class="type">const</span> std::string&amp; book, <span class="type">double</span> p, std::<span class="type">size_t</span> qty, <span class="type">double</span> disc)</span><br><span class="line">  : <span class="built_in">Quote</span>(book, p), <span class="built_in">min_qty</span>(qty), <span class="built_in">discount</span>(disc) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这是由C++实例化对象时的内存分配导致的，一个派生类对象包含多个组成部分：一个含有派生类自己定义成员（对应minqty和discount）的子对象，以及一个基类对应的子对象（子对象中包含）。如果有多个基类，那么这样的子对象也有多个。因此在利用构造函数实例化派生类的对象时，也必须调用基类的构造函数，实例化子对象。</p>
</li>
</ul>
<!---->
<ul>
<li><strong>类层次漫游：</strong></li>
</ul>
<blockquote>
<p>类层次就是结构就是，一个子类继承一个基类，另一个子类继承相同的基类，一个子子类继承子类等等</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Point <span class="title">center</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">move</span><span class="params">(Point to)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> angle)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">shape</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>: <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Circle</span>(Point p, <span class="type">int</span> rr);</span><br><span class="line"></span><br><span class="line">  <span class="function">Point <span class="title">center</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(Point to)</span> </span>&#123; x=to; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span>)</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Point x;</span><br><span class="line">  <span class="type">int</span> r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Smiley</span>: <span class="keyword">public</span> Circle &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Smiley</span>(Point p, <span class="type">int</span> r) : Circle&#123;p,r&#125;, mouth&#123;<span class="literal">nullptr</span>&#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Smiley</span>()&#123;</span><br><span class="line">    <span class="keyword">delete</span> mouth;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p:eyes)</span><br><span class="line">      <span class="keyword">delete</span> p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(Point to)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add_eye</span><span class="params">(Shape* s)</span></span>&#123;eyes.<span class="built_in">push_back</span>(s);&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set_mouth</span><span class="params">(Shape* s)</span></span>;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  vector&lt;Shape*&gt; eyes;</span><br><span class="line">  Shape* mouth;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Smiley::draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Circle::<span class="built_in">draw</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> p:eyes)</span><br><span class="line">    p-&gt;<span class="built_in">draw</span>();</span><br><span class="line">  mouth-&gt;<span class="built_in">draw</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Smiley继承了Circle，Circle继承了Shape</p>
<ul>
<li>
<p>对于抽象类来说，其派生类的对象通常是通过抽象基类的接口操纵的，所以基类中必须有一个虚析构函数。</p>
</li>
<li>
<p><code>rotate_all</code>可以调用任何Shape的派生类，如Smiley，这体现了<strong>接口继承</strong>的益处，即：派生类可以用在任何需要基类对象的地方。</p>
</li>
<li>
<p>Smiley可以使用Circle的构造函数和<code>Circle::draw()</code>，这体现了<strong>实现继承</strong>的益处，即：基类可以提供简化派生类实现的函数或数据。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate_all</span><span class="params">(vector&lt;Shape*&gt;&amp; v, <span class="type">int</span> angle)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> p:v)</span><br><span class="line">    p-&gt;<span class="built_in">rotate</span>(angle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>     - 当某个函数需要使用特定派生类的成员函数时，可以使用<code>dynamic_cast</code>运算符询问类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Shape* <span class="title">ps</span><span class="params">(read_shape(cin))</span></span>; <span class="comment">//根据cin指定的类型生成特定派生类的Shape</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Smiley* p = <span class="built_in">dynamic_cast</span>&lt;Smiley*&gt;(ps)) &#123; <span class="comment">//或者引用: if(Smiley&amp; p = dynamic_cast&lt;Smiley&amp;&gt;(*ps))</span></span><br><span class="line">  <span class="comment">//...指针p所指的对象类型是Smiley</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">//...指针p所指的对象类型不是Smiley，执行其他操作...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>当不能直接使用候选的派生类时，可以用引用替代，用于<code>dynamic_cast</code></p>
</li>
<li>
<p>若<code>dynamic_cast</code>的参数(ps)与期望类型(Smiley)不符时，则会返回<code>nullptr</code>。</p>
</li>
</ul>
<blockquote>
<p>📌private、public、protected：<br />
- 访问范围的差异：<br />
private：只能由该类中的函数、其友元函数访问，不能被任何其他访问，该类的对象也不能访问；<br />
protected：可以被该类中的函数、子类的函数、以及其友元函数访问，但不能被该类的对象访问；<br />
public：可以被该类中的函数、子类的函数、其友元函数访问，也可以由该类的对象访问。<br />
- 继承后的方法属性变化：<br />
使用private继承，父类的所有方法在子类中变为private；<br />
使用protected继承，父类的protected和public方法在子类中变为protected，private方法不变；<br />
使用public继承，父类中的方法属性不发生改变。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关于子类访问父类的private成员：</span></span><br><span class="line"><span class="comment">//×！编译器报错</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">set_x</span><span class="params">()</span></span>&#123;x = <span class="number">10</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set_x</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;x = <span class="number">10</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关于子类访问父类的protected成员：</span></span><br><span class="line"><span class="comment">//√！编译器不报错</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">set_x</span><span class="params">()</span></span>&#123;x = <span class="number">10</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set_x</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;x = <span class="number">10</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌explicit关键字：<br />
声明为explicit的构造函数不能在隐式转换中使用。<br />
当类构造函数<strong>只有一个参数或除了第一个参数外其余参数都有默认值时</strong>，则此类有隐含的类型转换操作符（隐式转换），但有时隐式转换并不是我们想要的，可在构造函数前加上关键字explicit，来指定显式调用。<br />
class Demo{<br />
   public:<br />
       explicit Demo(double a);<br />
};<br />
由于构造函数使用了explicit关键字，因此调用它时无法进行隐式转换，即Demo test; test=12.2; 是无效的！<br />
然而，此时可以进行显式转换<br />
Demo test;<br />
test = Demo(12.2); 或者<br />
test = (Demo)12.2;</p>
</blockquote>
<h4 id="override-final-default-delete"><a class="markdownIt-Anchor" href="#override-final-default-delete"></a> override、final、default、delete</h4>
<ul>
<li>
<p>override</p>
<p>有virtual就允许多态，即允许继承基类的子类重新virtual的方法。然而存在两种情况：</p>
<ol>
<li>
<p>子类并不想重写基类的函数，只是碰巧写的新函数与基类中的某一个方法重名了；</p>
</li>
<li>
<p>子类想重写基类的函数，但是把函数名写错了，此时编译器将该函数判定为新函数，不会报错，但运行时可能会出很多问题。</p>
</li>
</ol>
<p>针对以上场景，C++11引入了<code>override</code>关键字，以起到标记作用。override表示，此成员函数就是要重写基类的同名函数，而且函数签名一致。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : A&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>而以下两种情况会导致编译器报错：原函数不存在，以及重新函数的函数签名不一致。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原函数不存在（函数名写错了）                     //函数签名不一致（返回值写错了）                   </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : A&#123;                                  <span class="keyword">class</span> <span class="title class_">B</span> : A&#123;</span><br><span class="line"><span class="keyword">protected</span>:                                    <span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">funa</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> d)</span></span>&#123;                      <span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">  &#125;                                             &#125;</span><br><span class="line">&#125;;                                            &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>final</p>
<p>有一种情况，类A继承了一个基类，但是类A不希望被其他类所继承。或者说类A重写了基类的虚函数，但当类A被继承时，不再希望这个虚函数被重写。</p>
<blockquote>
<p>值得一提的是，没有final时虚函数会传递，只要基类有virtual，即使类A重写时对这个函数不加virtual，类B继承类A时也能重写该函数，该函数仍然是一个虚函数。</p>
</blockquote>
<ul>
<li>
<p>final修饰类：不能再被继承</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> <span class="keyword">final</span>&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时不能再继承Base类，下述代码会编译期报错</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : Base&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>final修饰虚函数，虚函数不能再被重写（注：final只能修饰虚函数，不能修饰其他成员函数）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">final</span></span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : Base&#123;</span><br><span class="line">  <span class="comment">//此时不能再重写func方法，下述代码会编译期报错</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>=default</p>
<p>当手动写了一个<strong>有参数</strong>的构造/析构函数时，编译器会把默认的构造/析构函数优化掉，即<strong>不生成那些默认无参数</strong>的构造/析构函数。如果想要保留这些默认函数，使得编译器能够生成默认函数从而保留无参数时的行为，可以用<code>=default</code></p>
<ul>
<li>
<p>报错场景：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">int</span> i)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  A a;      <span class="comment">//可以编译通过，但是会运行时报错，因为已经没有无参数的构造函数了，A a这句又没传参数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>不报错场景：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">int</span> i)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  A a;      <span class="comment">//运行时不会出错，因为默认无参数的构造函数得到了保留</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>=delete</p>
<p><code>=delete</code>与<code>=default</code>的作用相反，它会禁用掉类中的某个成员函数。比如不想要默认的构造函数、析构函数、拷贝构造函数或operator=，可以用<code>=delete</code>禁用掉。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">test</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">test</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">test</span>(<span class="type">const</span> test&amp; a) = <span class="keyword">delete</span>;</span><br><span class="line">    test&amp; <span class="keyword">operator</span>=(<span class="type">const</span> test&amp; a) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="菱形继承与虚继承"><a class="markdownIt-Anchor" href="#菱形继承与虚继承"></a> 菱形继承与虚继承</h4>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/cpp-basic/image_OQknyX-tPz.png" alt="" /></p>
<p>菱形继承的情况如图所示，B和C都继承了A，也就都继承了cnt属性。而D同时继承了B和C，此时D的对象内部将会有两份cnt，存在二义性。此时若要让D的对象访问或修改cnt属性，会因二义性（编译器不知道应该使用哪个cnt）使得编译器报错。</p>
<p>D:</p>
<p>   - B: cnt</p>
<p>   - C: cnt</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;           <span class="comment">//间接基类A</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A&#123; <span class="comment">//直接基类B</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> cnt_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">public</span> A&#123; <span class="comment">//直接基类C</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> cnt_c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123; <span class="comment">//派生类D</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set_a</span><span class="params">(<span class="type">int</span> i)</span></span>&#123; cnt = i; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set_b</span><span class="params">(<span class="type">int</span> i)</span></span>&#123; cnt_b = i; &#125; </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set_c</span><span class="params">(<span class="type">int</span> i)</span></span>&#123; cnt_c = i; &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  D d;</span><br><span class="line">  d.<span class="built_in">set_a</span>(<span class="number">3</span>);  <span class="comment">//报错！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决菱形继承的二义性问题，一种方式是直接使用::B或::C，强制编译器使用来自某个基类的属性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;           <span class="comment">//间接基类A</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A&#123; <span class="comment">//直接基类B</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> cnt_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">public</span> A&#123; <span class="comment">//直接基类C</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> cnt_c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123; <span class="comment">//派生类D</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  D d;</span><br><span class="line">  d.B::cnt = <span class="number">3</span>; <span class="comment">//强制指定使用哪个基类的cnt属性，规避二义性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的方案不能根治菱形继承的问题，因为属性在类D中本就应该只有一个。更有效方案是利用<strong>虚继承</strong>。虚继承会使得派生类中只保留一份来自间接基类的属性，有效防止二义性问题。此时的间接基类A，被称为虚基类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;                     <span class="comment">//间接基类A</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;   <span class="comment">//虚继承，直接基类B</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> cnt_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;   <span class="comment">//虚继承，直接基类C</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> cnt_c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123; <span class="comment">//派生类D</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set_a</span><span class="params">(<span class="type">int</span> i)</span></span>&#123; cnt = i; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set_b</span><span class="params">(<span class="type">int</span> i)</span></span>&#123; cnt_b = i; &#125; </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set_c</span><span class="params">(<span class="type">int</span> i)</span></span>&#123; cnt_c = i; &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  D d;</span><br><span class="line">  d.<span class="built_in">set_a</span>(<span class="number">3</span>);  <span class="comment">//正确！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标准库中也有利用虚继承解决菱形继承问题的案例。如iostream类同时继承了istream类和ostream类，而istream和ostream都继承了base_ios类。此时istream和ostream必须虚继承base_ios，否则会导致iostream类中包含两份来自base_ios的属性，导致二义性。</p>
<h4 id="raii资源获取即初始化"><a class="markdownIt-Anchor" href="#raii资源获取即初始化"></a> RAII：资源获取即初始化</h4>
<blockquote>
<p>Resource Acquisition is Initialization</p>
</blockquote>
<p>RAII主要利用<strong>对象离开作用域会自动调用析构函数</strong>的特性，在设计一个类时，于构造函数申请资源，在析构函数释放资源，即可避免内存泄露问题，并将程序员从内存管理的泥潭中释放出来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CTest</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CTest</span>()&#123;</span><br><span class="line">    m_pInt = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">CTest</span>()&#123;</span><br><span class="line">    <span class="keyword">if</span>( m_pInt != <span class="literal">nullptr</span> )</span><br><span class="line">      <span class="keyword">delete</span> m_pInt;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span>* m_pInt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="对象隐式销毁"><a class="markdownIt-Anchor" href="#对象隐式销毁"></a> 对象隐式销毁</h4>
<p>考虑这样的函数，<code>user()</code>函数在退出前会delete掉所有的Shape，<code>delete</code>运算符依赖于Shape的析构函数，而该函数是虚函数，所以<code>delete</code>会调用最终的派生类的析构函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">user</span><span class="params">()</span></span>&#123;</span><br><span class="line">  std::vector&lt;Shape*&gt; v;</span><br><span class="line">  <span class="keyword">while</span>(cin)</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">read_shape</span>(cin));</span><br><span class="line">  <span class="built_in">draw_all</span>(v);</span><br><span class="line">  <span class="built_in">rotate_all</span>(v,<span class="number">45</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> p : v)    <span class="comment">//最后删除元素</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是“显式”地销毁对象。然而若对所有函数都执行这样的显式操作的话，可能总有漏网之鱼。解决方案便是“隐式”对象销毁，让编译器自己来做delete操作。</p>
<p>对象若要隐式销毁，需要避免“裸指针”，而是尽量用智能指针<code>unique_ptr</code>，此时可以修改代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Kind</span> &#123; Circle, triangle, smiley &#125;;</span><br><span class="line"><span class="function">unique_ptr&lt;Shape&gt; <span class="title">read_shape</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//...从is中读取描述信息，找到对应形状种类</span></span><br><span class="line">  <span class="keyword">switch</span>(k)&#123;</span><br><span class="line">    <span class="keyword">case</span> Kind::circle:</span><br><span class="line">      <span class="keyword">return</span> unique_ptr&lt;Shape&gt;&#123;<span class="keyword">new</span> Circle&#123;p,r&#125;&#125;;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">user</span><span class="params">()</span></span>&#123;</span><br><span class="line">  vector&lt;unique_ptr&lt;Shape&gt;&gt; v;</span><br><span class="line">  <span class="keyword">while</span>(cin)</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">read_shape</span>(cin));</span><br><span class="line">  <span class="built_in">draw_all</span>(v);</span><br><span class="line">  <span class="built_in">rotate_all</span>(v,<span class="number">45</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象由<code>unique_ptr</code>拥有，当对象离开作用域时，<code>unique_ptr</code>将释放掉所指的对象。</p>
<h4 id="友元函数友元类"><a class="markdownIt-Anchor" href="#友元函数友元类"></a> 友元函数&amp;友元类</h4>
<ul>
<li>
<p>普通友元函数</p>
<p>突破类内成员访问权限的限制，使得外部的函数仍能访问到类内的私有成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">  ~<span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>; <span class="comment">//声明foo函数是类A的好朋友</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">  A aObj;</span><br><span class="line">  aObj.m_data = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>友元成员函数</p>
<p>令类B的成员函数有权限访问类A的私有成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">B</span>()&#123;&#125;;</span><br><span class="line">  ~<span class="built_in">B</span>()&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">  ~<span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">B::foo</span><span class="params">()</span></span>; <span class="comment">//声明类B的foo成员函数是类A的好朋友</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B::foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">  A aObj;</span><br><span class="line">  aObj.m_data = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>友元类</p>
<p>若类B是类A的友元类，那么类B的所有成员函数均能访问到类A的私有成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">B</span>()&#123;&#125;;</span><br><span class="line">  ~<span class="built_in">B</span>()&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">  ~<span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">  <span class="keyword">friend</span> B;          <span class="comment">//声明类B是类A的好朋友</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B::foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">  A aObj;</span><br><span class="line">  aObj.m_data = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="运算符重载"><a class="markdownIt-Anchor" href="#运算符重载"></a> 运算符重载</h4>
<blockquote>
<p>可以重载的运算符：<br />
+   -   *   /   %   ^   &amp;   |   ~   !   =   &lt;   &gt;  +=  -=  *=  /=  %=  ^=  &amp;=  |=  &lt;&lt;  &gt;&gt;  &lt;&lt;=  &gt;&gt;=  ==  !=  &lt;=  &gt;=<br />
&amp;&amp;  ||  ++  –  []  ()  -&gt;  ,  new  new[]  delete  delete[] </p>
</blockquote>
<ul>
<li>
<p>一元运算符重载：++、–、-（负号）、!</p>
<p>一元运算符往往不需要传形参，传形参说明是后缀++或后缀–</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> i;</span><br><span class="line">    <span class="type">double</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">int</span> = <span class="number">0</span>, <span class="type">int</span> = <span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">    Complex <span class="keyword">operator</span> ++();<span class="comment">//前缀自增</span></span><br><span class="line">    Complex <span class="keyword">operator</span> ++(<span class="type">int</span>);<span class="comment">//后缀自增，参数需要加int</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex::<span class="built_in">Complex</span>(<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">    i = a;</span><br><span class="line">    j = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Complex::display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&#x27;+&#x27;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27;i&#x27;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complex Complex::<span class="keyword">operator</span> ++() &#123;</span><br><span class="line">    ++i;</span><br><span class="line">    ++j;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Complex Complex::<span class="keyword">operator</span> ++(<span class="type">int</span>) &#123;</span><br><span class="line">    Complex temp =*<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>二元运算符重载：+、-、 *、/</p>
<p>this是左值，形参是右值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test_minus</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> val1, val2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">test_minus</span>(<span class="type">int</span> a, <span class="type">int</span> b): <span class="built_in">val1</span>(a), <span class="built_in">val2</span>(b) &#123;&#125;</span><br><span class="line">  test_minus <span class="keyword">operator</span>-(<span class="type">const</span> test_minus&amp; right)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">test_minus</span>(right.val1 - val1, right.val2 - val2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; val1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; val2 &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">test_minus <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">  <span class="function">test_minus <span class="title">b</span><span class="params">(<span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  test_minus c = a - b;</span><br><span class="line">  c.<span class="built_in">Print</span>();            <span class="comment">//输出 1 -3</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>还可以友元函数的方式重载：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test_minus</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> val1, val2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">test_minus</span>(<span class="type">int</span> a, <span class="type">int</span> b): <span class="built_in">val1</span>(a), <span class="built_in">val2</span>(b) &#123;&#125;</span><br><span class="line">  <span class="keyword">friend</span> test_minus <span class="keyword">operator</span>- (<span class="type">const</span> test_minus&amp;, <span class="type">const</span> test_minus&amp;); <span class="comment">//友元函数</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; val1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; val2 &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">test_minus <span class="keyword">operator</span>-(<span class="type">const</span> test_minus&amp; left, <span class="type">const</span> test_minus&amp; right)&#123;<span class="comment">//友元函数运算符重载</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">test_minus</span>(right.val1 - left.val1, right.val2 - left.val2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">test_minus <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">  <span class="function">test_minus <span class="title">b</span><span class="params">(<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  test_minus c = a-b;</span><br><span class="line">  c.<span class="built_in">Print</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>关系运算符重载：&lt;、&gt;、&lt;=、&gt;=、==、!=</p>
<p>和二元运算符一样，this是左值，形参是右值。可以在形参加上const以规避修改</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Distance</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> feet;</span><br><span class="line">    <span class="type">int</span> inches;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> Distance&amp; d)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span>(feet &lt; d.feet)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">if</span>(feet == d.feet &amp;&amp; inches &lt; d.inches)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>流运算符重载：&lt;&lt;、&gt;&gt;</p>
<p>见“I/O流”章，需要注意区分一元运算符中的左移右移。</p>
</li>
<li>
<p>赋值运算符重载：=</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Distance</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="type">int</span> feet;             <span class="comment">// 0 到无穷</span></span><br><span class="line">      <span class="type">int</span> inches;           <span class="comment">// 0 到 12</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> Distance &amp;D )</span><br><span class="line">      &#123; </span><br><span class="line">         feet = D.feet;</span><br><span class="line">         inches = D.inches;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>函数调用运算符重载：()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Distance</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="type">int</span> feet;             <span class="comment">// 0 到无穷</span></span><br><span class="line">      <span class="type">int</span> inches;           <span class="comment">// 0 到 12</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Distance</span>(<span class="type">int</span> f, <span class="type">int</span> i)&#123;</span><br><span class="line">         feet = f;</span><br><span class="line">         inches = i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 重载函数调用运算符</span></span><br><span class="line">      <span class="function">Distance <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         Distance D;</span><br><span class="line">         <span class="comment">// 进行随机计算</span></span><br><span class="line">         D.feet = a + c + <span class="number">10</span>;</span><br><span class="line">         D.inches = b + c + <span class="number">100</span> ;</span><br><span class="line">         <span class="keyword">return</span> D;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">Distance <span class="title">D1</span><span class="params">(<span class="number">11</span>, <span class="number">10</span>)</span>, D2</span>;</span><br><span class="line"></span><br><span class="line">   D2 = <span class="built_in">D1</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>); <span class="comment">// invoke operator()</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>下标运算符重载：[]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> SIZE = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">safearay</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="type">int</span> arr[SIZE];</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">safearay</span>() </span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">register</span> <span class="type">int</span> i;</span><br><span class="line">         <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; SIZE; i++)</span><br><span class="line">         &#123;</span><br><span class="line">           arr[i] = i;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> i)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span>( i &gt;= SIZE )</span><br><span class="line">          &#123;</span><br><span class="line">              cout &lt;&lt; <span class="string">&quot;索引超过最大值&quot;</span> &lt;&lt;endl; </span><br><span class="line">              <span class="comment">// 返回第一个元素</span></span><br><span class="line">              <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> arr[i];</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   safearay A;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;A[2] 的值为 : &quot;</span> &lt;&lt; A[<span class="number">2</span>] &lt;&lt;endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;A[5] 的值为 : &quot;</span> &lt;&lt; A[<span class="number">5</span>]&lt;&lt;endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;A[12] 的值为 : &quot;</span> &lt;&lt; A[<span class="number">12</span>]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌C++的register关键字作用是，建议编译器使用CPU寄存器来存储变量，旨在提高访问变量的速度</p>
</blockquote>
</li>
<li>
<p>类成员访问运算符重载：-&gt; 和 解引用运算符：*</p>
</li>
</ul>
<p>成员访问-&gt;和解引用*的重载都只能由对象使用，而不能由指针使用，因此，出现<code>pointer-&gt;mem;</code>时，可能有两种情况：</p>
<ol>
<li>
<p>指针，原原本本的成员访问和解引用功能：mem就是指针指向的对象，所属类型的成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pointer-&gt;mem;</span><br><span class="line"><span class="comment">//等价于   (*pointer).mem;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对象，调用的重载的运算符：mem不一定是pointer所属类型的成员，可能是其它类型的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pointer.<span class="built_in">operator</span>()-&gt;mem;</span><br><span class="line"><span class="comment">//等价于   (pointer.operator*()).mem;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>重载时，一般要求解引用*重载，返回引用，要求成员访问-&gt;重载，返回指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test_arrow_1</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> val1, val2;</span><br><span class="line">  <span class="built_in">test_arrow_1</span>(<span class="type">int</span> a, <span class="type">int</span> b) : <span class="built_in">val1</span>(a), <span class="built_in">val2</span>(b) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; val1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; val2 &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test_arrow_2</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> val3, val4, val5;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  test_arrow_1* val6;</span><br><span class="line">  <span class="built_in">test_arrow_2</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d, <span class="type">int</span> e) </span><br><span class="line">    : <span class="built_in">val6</span>(<span class="keyword">new</span> <span class="built_in">test_arrow_1</span>(a,b)), <span class="built_in">val3</span>(c), <span class="built_in">val4</span>(d), <span class="built_in">val5</span>(e) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; val6-&gt;val1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; val6-&gt;val2 &lt;&lt; <span class="string">&#x27; &#x27;</span> </span><br><span class="line">         &lt;&lt; val3 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; val4 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; val5 &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  test_arrow_1&amp; <span class="keyword">operator</span>*() <span class="type">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*val6);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  test_arrow_1* <span class="keyword">operator</span>-&gt;() <span class="type">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val6;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">test_arrow_2 <span class="title">t1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">  t1-&gt;val1 = <span class="number">6</span>;</span><br><span class="line">  t1-&gt;<span class="built_in">Print1</span>();</span><br><span class="line">  t1.<span class="built_in">Print2</span>();</span><br><span class="line"></span><br><span class="line">  (*t1).val2 = <span class="number">7</span>;</span><br><span class="line">  t1.<span class="built_in">Print2</span>();</span><br><span class="line"></span><br><span class="line">  test_arrow_2* t2 = <span class="keyword">new</span> <span class="built_in">test_arrow_2</span>(<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">  t2-&gt;<span class="built_in">Print2</span>();</span><br><span class="line">  (*t2).<span class="built_in">Print2</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对象调用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">test_arrow_2 <span class="title">t1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">  t1-&gt;val1 = <span class="number">6</span>;</span><br><span class="line">  t1-&gt;<span class="built_in">Print1</span>();</span><br><span class="line">  t1.<span class="built_in">Print2</span>();</span><br><span class="line"></span><br><span class="line">  (*t1).val2 = <span class="number">7</span>;</span><br><span class="line">  t1.<span class="built_in">Print2</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>t1是重载了*和-&gt;的对象，而不是指针，因此，当t1调用*t1和t1-&gt;时，会使用重载的运算符函数。</p>
<p>因此t1-&gt;可以使用属于<code>test_arrow_1</code>类的属性和方法，</p>
<p>(*t1)也可以使用属于改类的属性和方法。而“点运算符”仍然只能使用<code>test_arrow_2</code>类的。</p>
<ul>
<li>指针调用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test_arrow_2* t2 = &amp;t1;</span><br><span class="line">t2-&gt;<span class="built_in">Print2</span>();</span><br><span class="line">(*t2).<span class="built_in">Print2</span>();</span><br></pre></td></tr></table></figure>
<p>t2是指针，因此调用*和-&gt;时，不能再调用重载的运算符函数，而是和平时的操作无异。因此t2-&gt;只能使用<code>test_arrow_2</code>的属性和方法，而且(*t2)也只能使用<code>test_arrow_2</code>的。</p>
<p>值得注意的是，解引用运算符 *，可以自定义任何逻辑，上面的代码中，也可以让解引用的重载返回一个int常数。</p>
<p>但是成员访问运算符无论怎么改，都<strong>必须保留成员访问的功能</strong>，虽然可能不再是当前类的成员了。</p>
<blockquote>
<p>📌取地址符&amp;也可以重载，但一般不需要手动重载，类会默认生成&amp;和&amp; const</p>
</blockquote>
<h4 id="类类型转换特殊运算符重载"><a class="markdownIt-Anchor" href="#类类型转换特殊运算符重载"></a> 类类型转换（特殊运算符重载）</h4>
<p><strong>类型转换运算符</strong>，负责将一个类的类型转换成其他类型：<code>operator type() const;</code>，由于其通常不应该改变待转换对象的内容，因此，一般被定义为const成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmallInt</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">SmallInt</span>(<span class="type">int</span> i = <span class="number">0</span>):<span class="built_in">val</span>(i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt; <span class="number">255</span>)</span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Bad SmallInt value&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123;&#125;;          <span class="comment">//类型转换运算符</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::<span class="type">size_t</span> val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里SmallInt类中定义了向int类型的转换符，因此，可以显式/<strong>隐式</strong>的将SmallInt对象转换成int类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SmallInt si;</span><br><span class="line">si = <span class="number">4</span>; <span class="comment">// 首先将4隐式转换成SmallInt，然后调用SmallInt operator=</span></span><br><span class="line">si + <span class="number">3</span>; <span class="comment">// 首先将si隐式转换成int，然后执行整数的加法</span></span><br></pre></td></tr></table></figure>
<p>除此之外，如果转换后的类型又有其它内置转换方案，实际情况中，也可以出现转换传递的情况。比如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SmallInt si = <span class="number">3.14</span>; <span class="comment">// 调用SmallInt(int)构造函数</span></span><br><span class="line">si + <span class="number">3.14</span>;          <span class="comment">// SmallInt类型转换成int，int又继续隐式转换成double</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌一个类型转换函数必须是类的成员函数。<br />
<strong>不能声明返回类型！</strong>（其名字就已说明返回）<br />
**形参列表必须为空！**<strong>通常应该为const！</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmallInt</span>;</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">(SmallInt&amp;)</span></span>;            <span class="comment">//错,不是成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmallInt</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span></span>;         <span class="comment">//错,有返回类型</span></span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">(<span class="type">int</span>=<span class="number">0</span>)</span> <span class="type">const</span></span>;        <span class="comment">//错,有形参</span></span><br><span class="line">  <span class="keyword">operator</span> <span class="type">int</span>*() <span class="type">const</span> &#123;<span class="keyword">return</span> <span class="number">42</span>;&#125;<span class="comment">//错,42不是一个指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>老版本C++，类型转换运算符的不足：</p>
<p>早期版本C++中，类中定义一个向bool转换的类型转换运算符，是比较普遍的。比如经常用的<code>while(cin&gt;&gt;i)</code>就是cin中内置了一个operator bool( )。然而，这样会有意想不到的效果，比如下面的语句：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line">cin &lt;&lt; i;</span><br></pre></td></tr></table></figure>
<p>流运算符&lt;&lt;是cout特有的，istream本身没有定义&lt;&lt;，所以这段代码本应报错。然而，istream内置了bool类型转换，由此将cin转换成了bool，接着bool会被提升为int，后面的&lt;&lt;成为了左移运算符。因此，这段代码不会报错，还会出现与预期大相径庭的结果。</p>
</li>
<li>
<p>C++11带来的解决方案：<strong>显式的类型转换运算符</strong></p>
<p>为了防止上面现象的发生，C++引入了解决方案：explicit operator type()，即<strong>通过explicit关键字</strong>，<strong>要求显式转换</strong></p>
<p>比如下面代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmallInt</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">SmallInt</span>(<span class="type">int</span> i = <span class="number">0</span>):<span class="built_in">val</span>(i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt; <span class="number">255</span>)</span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Bad SmallInt value&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SmallInt si = <span class="number">3</span>;        <span class="comment">//正确：SmallInt的构造函数不是显式的</span></span><br><span class="line">si + <span class="number">3</span>;                 <span class="comment">//错误：此处需要隐式的类型转换，但类的运算符不是显式的</span></span><br><span class="line"><span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(si)+<span class="number">3</span>; <span class="comment">//正确：显式地请求类型转换</span></span><br></pre></td></tr></table></figure>
<p>这种规定还是有例外的，标准规定：如果表达式被用作了条件，则编译器会<strong>自动</strong>（即“隐式”）进行显式类型转换，</p>
<p>因此istream内部的bool()成为explicit的了，但是while(cin&gt;&gt;i)依然能用，因为是条件，会自动转成bool类型。</p>
<ul>
<li>
<p>成为条件的几个位置：</p>
<p>if, while, do…while, for</p>
<p>逻辑运算符<code>!, ||, &amp;&amp;</code></p>
<p>条件运算符<code>? :</code> </p>
</li>
</ul>
</li>
<li>
<p>类类型转换带来的二义性：（这里的类型转换不再局限于类型转换运算符，还包括构造函数）</p>
<p>有几种情况可能会带来二义性，出现二义性之后会编译报错，因为编译器不知道该使用哪种实现方式。</p>
<ol>
<li>
<p>两个类提供了“互相指向”的类型转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">const</span> B&amp;);           <span class="comment">//把一个B转换为A</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">A</span><span class="params">()</span> <span class="type">const</span></span>;    <span class="comment">//把一个A转换为B</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A <span class="title">f</span><span class="params">(<span class="type">const</span> A&amp;)</span></span>;           <span class="comment">//定义一个接收A的函数</span></span><br><span class="line">B b;</span><br><span class="line">A a = <span class="built_in">f</span>(b);              <span class="comment">//二义性错误：含义是 调用B中转换为A的类型转换运算符 f(b.operator A())</span></span><br><span class="line">                         <span class="comment">//             还是调用A中可以把B类型转换为A的构造函数 f(A(b))</span></span><br></pre></td></tr></table></figure>
<p>如果想执行上面的调用，必须显式地调用类型转换运算符或转换构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a1 = <span class="built_in">f</span>(b.<span class="keyword">operator</span> <span class="built_in">A</span>()); <span class="comment">//正确：使用B的类型转换运算符</span></span><br><span class="line">A a2 = <span class="built_in">f</span>(<span class="built_in">A</span>(b));           <span class="comment">//正确：使用A的构造函数</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>类定义了多个转换规则：</p>
<p>最困扰的情况是类中定义了多个参数都是算术类型的构造函数，或者转换目标都是算术类型的类型转换运算符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">int</span> = <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">double</span> = <span class="number">0</span>);</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">long</span> <span class="type">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line"><span class="built_in">f2</span>(a);    <span class="comment">//二义性错误，不知道是 f(a.operator int()) 还是 f(a.operator double())</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> lg;</span><br><span class="line"><span class="function">A <span class="title">a2</span><span class="params">(lg)</span></span>; <span class="comment">//二义性错误，不知道是 A::A(int) 还是 A::A(double)</span></span><br></pre></td></tr></table></figure>
<p>f2的调用中，哪个类型转换都无法精确匹配long double，然而却都存在向long double的隐式转换（而且转换级别还一致）。因此出现了二义性。</p>
<blockquote>
<p>📌C++ primer中建议，<br />
最好不要创建两个转换源都是算术类型的类型转换！<br />
最好不要创建两个转换对象都是算术类型的类型转换！</p>
</blockquote>
<p>如果这种情况中，转换级别不一致，就不存在二义性问题。比如从short提升到int，级别高于long到double。</p>
</li>
<li>
<p>函数重载过程中，不同重载的形参，都定义了同一种类型转换运算符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span>&#123;</span><br><span class="line">  <span class="built_in">C</span>(<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span>&#123;</span><br><span class="line">  <span class="built_in">D</span>(<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manip</span><span class="params">(<span class="type">const</span> C&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manip</span><span class="params">(<span class="type">const</span> D&amp;)</span></span>;</span><br><span class="line"><span class="built_in">manip</span>(<span class="number">10</span>);     <span class="comment">//二义性错误：含义是 manip(C(10)) 还是 manip(D(10))</span></span><br></pre></td></tr></table></figure>
<p>可以显式调用构造函数，以消除二义性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">manip</span>(<span class="built_in">C</span>(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>
<p>但这种情况并没有结束，10可以精确匹配int，那么下面的代码是否就没有二义性了呢？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span>&#123;</span><br><span class="line">  <span class="built_in">C</span>(<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">  <span class="built_in">E</span>(<span class="type">double</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manip</span><span class="params">(<span class="type">const</span> C&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manip</span><span class="params">(<span class="type">const</span> E&amp;)</span></span>;</span><br><span class="line"><span class="built_in">manip</span>(<span class="number">10</span>);     <span class="comment">//二义性错误：含义是 manip(C(10)) 还是 manip(E(double(10)))</span></span><br></pre></td></tr></table></figure>
<p>还是会编译报错，还是会有二义性，这是因为在调用重载时，类类型转换都是最低级别的匹配度。即使int比double更能匹配10，但是现在不是int和double的比较，而是C(10)：int→C，和E(double(10))：int→E的比较，而二者是平级的。而且二者都是可行匹配。因此导致了二义性。</p>
</li>
</ol>
</li>
</ul>
<p>虽然，类型转换运算符可以在某些程度上简化操作，但还是要慎用，非常容易出现二义性问题！</p>
<h4 id="newdelete的重载"><a class="markdownIt-Anchor" href="#newdelete的重载"></a> new/delete的重载</h4>
<p>new operator/delete operator就是new和delete操作符，而operator new/operator delete是函数。 placement new是operator new的全局重载。</p>
<p>new运算分两阶段：（1）调用::operator new配置内存；（2）调用对象构造函数构造对象内容。</p>
<p>delete运算分为两个阶段：（1）调用对象析构函数；（2）调用::operator delete释放内存。</p>
<ul>
<li>
<p>operator new函数</p>
<p>默认的::operator new与malloc无明显区别。只分配所要求的空间，不调用相关对象的构造函数。当无法满足所要求分配的空间时，则：</p>
<p>→如果有<code>new_handler</code>，则调用其，否则</p>
<p>→如果允许抛出异常（即<code>nothrow</code>参数未被设置），则执行<code>bad_alloc</code>异常，否则</p>
<p>→返回0</p>
<p>需要注意的是，::operator new是可以被重载的，也就是说可以自定义operator new的行为</p>
<ul>
<li>
<p>operator new重载</p>
<p>重载时，返回类型必须声明为void*</p>
<p>重载时，第一个参数类型必须为表达要求分配空间的大小（字节），类型为size_t</p>
<p>重载时，可以带其它参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>() &#123; cout&lt;&lt;<span class="string">&quot;constructor of X&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line">    ~<span class="built_in">X</span>() &#123; cout&lt;&lt;<span class="string">&quot;destructor of X&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size,string str)</span>  <span class="comment">//重载::operator new</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;operator new size &quot;</span>&lt;&lt;size&lt;&lt;<span class="string">&quot; with string &quot;</span>&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pointee)</span>         <span class="comment">//重载::operator delete</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;operator delete&quot;</span>&lt;&lt;endl;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pointee)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X *px = <span class="built_in">new</span>(<span class="string">&quot;A new class&quot;</span>) X;</span><br><span class="line">    <span class="keyword">delete</span> px;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>缺省的operator new具有非常好的通用性，这也使得其在某些场合下牺牲了性能。针对性优化的operator new可以提升效率。</p>
</li>
<li>
<p>placement new函数</p>
<p>前面重载的operator new只能作为类内函数，无法全局使用。而placement new是一种全局的重载的operator new。</p>
<p>placement new的使用：</p>
<p>operator new会分配内存，但是placement new不分配。相反地，placement new的参数就是一个预先分配好的内存，而placement new会在其上构造对象。（placement new不接收size_t类型参数，即不接收待分配内存大小参数），函数返回值是对象的地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string* sp=<span class="built_in">static_cast</span>&lt;string*&gt;(::<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(string)));</span><br><span class="line">mystr = <span class="built_in">new</span> (sp) <span class="built_in">string</span>(<span class="string">&quot;hello world&quot;</span>); <span class="comment">//使用placement new构造对象</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>placement new的使用步骤：</p>
<ol>
<li>
<p>内存提前分配</p>
</li>
<li>
<p>调用placement new构造对象</p>
</li>
<li>
<p>使用对象<code>mystr</code></p>
</li>
<li>
<p>析构对象<code>mystr→~string();</code></p>
</li>
<li>
<p>释放内存：内存<code>sp</code>可以被反复使用，反复通过placement new分配给新的对象，但若不想使用该内存，可以用<code>delete [] buf;</code>释放它。</p>
</li>
</ol>
</li>
<li>
<p>为什么要有placement new：</p>
<ol>
<li>
<p>确实有要在预分配内存上创建对象的需求。比如硬件中有一个内存映射的IO计时器设备，想建立一个clock对象在那个内存位置，但用。</p>
</li>
<li>
<p>增大时空效率。使用new操作符需要在堆中查找足够大的剩余空间，这个操作速度较慢，而且可能出现无法分配内存的异常（空间不够）。placement new可以解决，预先分配好的内存确保不会出现内存不足的异常，同时也省下了查找可用内存的时间。</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>📌申请内存和释放内存的操作符需要配套使用，比如new和delete一起用，new[]和delete[]一起用。<br />
int* ptr = new int[10];<br />
delete [] ptr;</p>
</blockquote>
<h4 id="拷贝和移动"><a class="markdownIt-Anchor" href="#拷贝和移动"></a> 拷贝和移动</h4>
<ul>
<li><strong>拷贝构造</strong>：定义拷贝构造函数和拷贝赋值运算符 </li>
</ul>
<blockquote>
<p>📌对于大容量的容器来说，拷贝过程可能耗费巨大。举例来说，<br />
而事实上，我们并不真的想要一个副本，而是想将计算结果从函数中取出来，相比于<em>拷贝</em>，更希望的操作的<em>移动</em>。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******* 声明一个Vector类 *******/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">double</span>* elem;</span><br><span class="line">  <span class="type">int</span> sz;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Vector</span>(<span class="type">int</span> s);                          <span class="comment">//构造函数：建议不变式，获取资源</span></span><br><span class="line">  ~<span class="built_in">Vector</span>() &#123; <span class="keyword">delete</span>[] elem; &#125;            <span class="comment">//析构函数：释放资源</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">Vector</span>(<span class="type">const</span> Vector&amp; a);                <span class="comment">//拷贝构造函数</span></span><br><span class="line">  Vector&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Vector&amp; a);     <span class="comment">//拷贝赋值运算符</span></span><br><span class="line"></span><br><span class="line">  <span class="type">double</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> i);</span><br><span class="line">  <span class="type">const</span> <span class="type">double</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/****拷贝构造函数****/</span></span><br><span class="line">Vector::<span class="built_in">Vector</span>(<span class="type">const</span> Vector&amp; a)</span><br><span class="line">  :elem&#123;<span class="keyword">new</span> <span class="type">double</span>[a.sz]&#125;,     <span class="comment">//为元素分配空间</span></span><br><span class="line">   sz&#123;a.sz&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i != sz; ++i) <span class="comment">//复制元素</span></span><br><span class="line">    elem[i] = a.elem[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是<strong>深拷贝</strong>。拷贝构造函数的输入参数是被拷贝的对象，也就是a = b中右面的b。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/****拷贝赋值运算符****/</span></span><br><span class="line">Vector&amp; Vector::<span class="keyword">operator</span>=(<span class="type">const</span> Vector&amp; a)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">double</span>* p = <span class="keyword">new</span> <span class="type">double</span>[a.sz];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i != a.sz; ++i)</span><br><span class="line">    p[i]=a.elem[i];</span><br><span class="line">  <span class="keyword">delete</span>[] elem;       <span class="comment">//删除旧元素</span></span><br><span class="line">  elem = p;</span><br><span class="line">  sz = a.sz;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>深拷贝与浅拷贝：</strong></li>
</ul>
<p>如果类中的属性均为基本类型变量，全部在栈上分配，不涉及深/浅拷贝问题。深拷贝与浅拷贝仅在，类中存在需要在堆上分配内存的属性时，才需要加以区分。考虑上面的Vector类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拷贝构造函数：深拷贝</span></span><br><span class="line">Vector::<span class="built_in">Vector</span>(<span class="type">const</span> Vector&amp; a)</span><br><span class="line">  :elem&#123;<span class="keyword">new</span> <span class="type">double</span>[a.sz]&#125;,     <span class="comment">//为元素分配空间</span></span><br><span class="line">   sz&#123;a.sz&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i != sz; ++i) <span class="comment">//复制元素</span></span><br><span class="line">    elem[i] = a.elem[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拷贝构造函数：浅拷贝</span></span><br><span class="line">Vector::<span class="built_in">Vector</span>(<span class="type">const</span> Vector&amp; a)</span><br><span class="line">  :elem&#123;a.elem&#125;,     <span class="comment">//不分配空间，直接赋值</span></span><br><span class="line">   sz&#123;a.sz&#125;</span><br><span class="line">&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>也就是构造的Vector对象的elem指针，直接指向=右边的Vector对象的elem数组。</p>
<p>可以看出，深拷贝会重新开辟一片内存，并且对内存中的值逐个拷贝。而浅拷贝的话，不会开辟内存，对象的指针直接等于右值对象内的指针。换言之，深拷贝过程中，左值的堆内存和右值的堆内存是两片内存，而浅拷贝的话共同使用一片内存。</p>
<img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/cpp-basic/image__v58OY9wwk.png" title="" alt="" width="420">
<p>C++的默认拷贝构造函数<code>=default</code>采用的是<strong>浅拷贝</strong>方式。</p>
<p>但是，<strong>一般遇到有属性需要从堆内存分配时，应该自己手写深拷贝方式的拷贝构造函数</strong>。浅拷贝涉及这样多次析构的问题，考虑上面的Vector类，如果采用了浅拷贝的拷贝构造函数，禁用operator=，main函数进行最基本的赋值操作时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Vector <span class="title">lv</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    Vector rv = lv;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时程序会在运行时崩溃，崩溃在析构函数上。在执行return 0之前，作用域内有两个Vector变量：lv和rv，二者的elem指向了同一片内存elem。然而，执行return 0，离开作用域时，会调用两个变量的析构函数。假设先调用了lv的析构函数，那么lv的elem会在析构时释放内存，此时的elem成为了野指针。而在调用rv的析构函数时，还会delete [] elem，此时要delete一个野指针，就会导致程序崩溃。</p>
<p>由此可见，对象中涉及堆时，应该尽量手写深拷贝形式的拷贝构造函数。</p>
<blockquote>
<p>📌在C++标准中，NULL和nullptr都被认为是0，尤其nullptr指向的是0x0地址，可以重复delete。<br />
因此，当一个对象被delete了，指针未归为nullptr，再调用该指针时会因野指针而使得程序崩溃。但如果delete后归为nullptr，再delete并不会出现问题。</p>
</blockquote>
<ul>
<li>
<p><strong>右值引用：</strong></p>
<p>通常写的引用<code>int a=0; int &amp;b=a;</code>，b是一个左值引用，它引用了一个左值a，但它不能引用右值，即<code>int &amp;b=0;</code>会报错。C++11之前，强行通过左值引用，引用一个右值的方式，只有一个，那就是常引用<code>const int&amp;b=0;</code>，但是如此并不能修改右值的值。</p>
<p>前面提到，浅拷贝比深拷贝效率更高（不用开辟新空间），但是存在重复析构的问题，那么是否可以通过下面的代码解决析构野指针的问题呢？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">demo</span>(demo &amp;d):<span class="built_in">num</span>(d.num)&#123;        <span class="comment">//拷贝构造函数，入参去掉const，让d可修改</span></span><br><span class="line">    d.num = <span class="literal">nullptr</span>;             <span class="comment">//修改原对象对应指针为空指针</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;copy construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不可以的，运行会报错。因为<code>num=d.num</code>表示<code>d.num</code>是右值，右值不可修改，但<code>d.num=nullptr</code>又让其成为可修改的左值，发生了冲突。</p>
<p>解决这个问题的方法，就是希望函数参数d是一个右值引用，右值引用的特定在于，既反映右值，又可以修改右值。</p>
<p>C<ins>定义了<code>T&amp;&amp; param</code>这样语法，表示<code>param</code>是一个右值引用，其可以引用一个右值，那么<code>int &amp;&amp;b=0;</code>就可行了，而且可以通过b来修改右值。与此同时，C</ins>11引入了<code>std::move()</code>函数，作用在于，不管输入的是左值还是右值，move出来的都是右值。</p>
<p>然而这样的语法，也不一定能保证引用到的必然是右值，以一个函数传参的例子进行说明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span>&amp; lvalue)</span>          <span class="comment">// 接收左值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;lvalue = &quot;</span> &lt;&lt; lvalue &lt;&lt; std::endl; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span>&amp;&amp; rvalue)</span>         <span class="comment">// 接收右值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rvalue = &quot;</span> &lt;&lt; rvalue &lt;&lt; std::endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(T&amp;&amp; param)</span>       <span class="comment">// 不能确保是右值引用，但是是万能引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>(param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">function</span>(x);               <span class="comment">// 左值</span></span><br><span class="line">    <span class="built_in">function</span>(std::<span class="built_in">move</span>(x));    <span class="comment">// 右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先看function函数，其明明标明入参应该是右值引用，为何还能通过<code>function(x)</code>传一个左值引用进去呢？</p>
<p>这是<strong>引用折叠</strong>的原因导致的：</p>
<p>虽然是<code>T&amp;&amp; param</code>，但若传进去一个<code>int&amp;</code>，实际相当于传入的类型为<code>int&amp; &amp;&amp;</code>，等价于<code>int&amp;</code>，即左值引用。《Effective Modern C++》的作者将这种，由引用折叠导致的，<strong>既可以表示右值引用，又可以表示左值引用的语法称为万能引用</strong>。</p>
<ul>
<li>
<p>引用折叠的规则：</p>
<table>
<thead>
<tr>
<th>first</th>
<th>second</th>
<th>result</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;</td>
<td>&amp;</td>
<td>左值引用</td>
</tr>
<tr>
<td>&amp;</td>
<td>&amp;&amp;</td>
<td>左值引用</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>&amp;</td>
<td>左值引用</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>&amp;&amp;</td>
<td>右值引用</td>
</tr>
</tbody>
</table>
<p>即，只有两个引用均为右值引用时，才会折叠成右值引用。</p>
</li>
<li>
<p>万能引用的规律：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp;&amp; var1 = <span class="built_in">Widget</span>();       <span class="comment">// rvalue reference</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = var1;             <span class="comment">// universal reference</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::vector&lt;T&gt;&amp;&amp; param)</span></span>; <span class="comment">// rvalue reference</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;              <span class="comment">// universal reference</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(T&amp;&amp; x)</span></span>;      <span class="comment">// rvalue reference</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>如果<code>T</code>不是模板参数，而是具体的类型，如上面的第一个例子Widget，<code>T&amp;&amp;</code>一定是右值引用。</p>
</li>
<li>
<p>如果<code>T</code>是模板参数，<code>T&amp;&amp;</code>一般情况下是通用引用。除了下面两种例外情况：</p>
</li>
<li>
<p>如果<code>T</code>是模板参数，但<code>param</code>的类型不直接是<code>T</code>，比如<code>std::vector&lt;T&gt;&amp;&amp;</code>，那么<code>std::vector&lt;T&gt;&amp;&amp;</code>是右值引用。</p>
</li>
<li>
<p>如果<code>T</code>是模板参数，但不需要自动推导，比如已经在类实例化的时候手动指定过了，那么<code>T&amp;&amp;</code>是右值引用。</p>
</li>
</ul>
</li>
</ul>
<p>但是，如果执行上面的代码，会发现输出结果为：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lvalue = 10</span><br><span class="line">lvalue = 10</span><br></pre></td></tr></table></figure>
<p>也就是，左值和右值都被判定为左值。这是因为右值引用接收的值既可以是左值，也可以是右值，存在这样一个对应关系：</p>
<table>
<thead>
<tr>
<th></th>
<th>左值引用</th>
<th>右值引用</th>
<th>非引用</th>
</tr>
</thead>
<tbody>
<tr>
<td>什么时候是左值</td>
<td>always</td>
<td>显式声明为变量时</td>
<td>显式声明为变量时</td>
</tr>
<tr>
<td>什么时候是右值</td>
<td>never</td>
<td>作为临时变量时</td>
<td>作为临时变量时</td>
</tr>
</tbody>
</table>
<p>虽然move函数强行使得第二个function函数传入右值，但是，function函数内部调用fun函数时，涉及传参，又把param显式化了。这样就使得param变为一个左值。</p>
<p>那么如何保留右值的特点，使得调用fun函数也传入右值呢，C++11同时提供了<strong>完美转发</strong><code>std::forward</code>特性。</p>
<p><code>std::forward</code>的返回值既可能是左值，也可能是右值，当传入参数是右值引用时，返回右值，否则就返回左值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收左值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span>&amp; lvalue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;lvalue = &quot;</span> &lt;&lt; lvalue &lt;&lt; std::endl; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接收右值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span>&amp;&amp; rvalue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rvalue = &quot;</span> &lt;&lt; rvalue &lt;&lt; std::endl; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 万能引用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(T&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//fun(param);</span></span><br><span class="line">    <span class="built_in">fun</span>(std::forward&lt;T&gt;(param)); <span class="comment">// 使用std::forward进行完美转发</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">function</span>(x);     <span class="comment">// 左值</span></span><br><span class="line">    <span class="built_in">function</span>(std::<span class="built_in">move</span>(x));    <span class="comment">// 右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再执行通过完美转发改进的程序，可以得到这样的输出结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lvalue = 10</span><br><span class="line">rvalue = 10</span><br></pre></td></tr></table></figure>
<p>也就是，左值是左值的行为，右值是右值的行为，不再混乱，泾渭分明。</p>
<p>事实上，使用<code>std::forward</code>处理万能引用，也是官方推荐的开发方式！</p>
</li>
</ul>
<p>合理运用右值引用，达到提速效果的案例：</p>
<p>在做矩阵加法时，可以这样写，即入参是两个左值引用以避免拷贝</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Matrix <span class="keyword">operator</span>+(<span class="type">const</span> Matrix&amp; lhs, <span class="type">const</span> Matrix&amp; rhs) &#123;</span><br><span class="line">    Matrix sum = ...        <span class="comment">// Sum all elements in lhs and rhs here.</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这么做美中不足的地方在于，需要创建一个额外的Matrix对象。如果说，lhs和rhs有一个操作数可以是右值，也就是算完之后调用者不会再使用它，那便可以复用它的内存空间，不必创建新的Matrix对象，达到提高效率的目的。假设这个右值是lhs，那么便可以设置它为右值引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Matrix <span class="keyword">operator</span>+(Matrix&amp;&amp; lhs, <span class="type">const</span> Matrix&amp; rhs) &#123;</span><br><span class="line">    lhs = ...               <span class="comment">// Sum all elements in lhs and rhs and assign to lhs.</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(lhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要用<code>std::move</code>返回值，避免让lhs成为显式变量，成为左值（成为左值的话，会返回对象的拷贝构造）。此时的返回值变成了右值引用，编译器自动为右值调用移动构造函数。</p>
<p>那么进行矩阵加法便可以：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Matrix sum1 = m1 + m2;                  <span class="comment">// 调用第一种实现</span></span><br><span class="line">Matrix sum3 = std::<span class="built_in">move</span>(m1) + m2;       <span class="comment">// 调用第二种实现</span></span><br></pre></td></tr></table></figure>
<p><strong>一般不建议函数返回右值引用！</strong></p>
<blockquote>
<p>C++中的左右值：<br />
- lvalue：通常可以放在等号左边的表达式，左值<br />
- rvalue：通常只能放在等号右边的表达式，右值<br />
- glvalue：generalized lvalue，广义左值<br />
- xvalue：expiring lvalue，将亡值，也就是std::move(ptr1)的值<br />
- prvalue：pure rvalue，纯右值<br />
对于包含右值的内存位置来说，其本质就是：它虽然没有名称，但是可以从程序的其他部分访问到它。<br />
而右值引用便可以用来表示这个本应没有名称的临时对象。</p>
<p>C++11之后编译器开始支持RVO(Return Value Optimization)技术，RVO可以把函数返回时创建的临时对象优化掉，达到少调用拷贝构造函数的目标。如果函数返回一个仅在函数内的局部变量，而且变量类型支持移动构造函数，比如：<br />
std::vector&lt;int&gt; return_vector(void){<br />
   std::vector&lt;int&gt; tmp {1,2,3,4,5};<br />
   return tmp;<br />
}<br />
std::vector&lt;int&gt; rval_ref = return_vector();<br />
那么编译器发现tmp是局部变量，离开return_vector函数后就会死亡时，会把tmp当做将亡值（xvalue），编译器会为将亡值调用移动构造函数。</p>
</blockquote>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/cpp-basic/image_M99Hn4BKd-.png" alt="" /></p>
<ul>
<li>
<p><strong>移动构造：</strong></p>
<p>虽然深拷贝很稳定，使得出错的风险降低，但是带来了效率的牺牲。考虑下面的深拷贝构造函数代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">demo</span>():<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>))&#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">demo</span>(<span class="type">const</span> demo &amp;d):<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*(d.num)))&#123;  <span class="comment">//拷贝构造函数</span></span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;copy construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br><span class="line">   ~<span class="built_in">demo</span>()&#123;</span><br><span class="line">      <span class="keyword">delete</span> num;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;class destruct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="type">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">demo <span class="title">get_demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">demo</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    demo a = <span class="built_in">get_demo</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>g++ demo.cpp -o demo.exe -std=c++0x -fno-elide-constructors</code>命令禁用优化，看最原始情况的输出，有：</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/cpp-basic/image_59GclcE4Cr.png" alt="" /></p>
<ol>
<li>
<p>首先在get_demo里调用了构造函数</p>
</li>
<li>
<p>离开get_demo时，return语句对函数内创建的对象进行拷贝，从而提供返回值</p>
</li>
<li>
<p>执行完return后，离开作用域，之前函数内创建的对象销毁，但是拷贝的作为返回值来到了main</p>
</li>
<li>
<p>返回值被=赋给了a，执行了拷贝构造（深拷贝，此时有两个demo对象）</p>
</li>
<li>
<p>return 0之后，离开作用域，调用析构函数销毁对象，由于两个对象都要销毁，因此调用了两次析构函数</p>
</li>
</ol>
<p>可以看出来，在第2步和第4步时执行了两次深拷贝，对于仅申请少量堆空间的临时对象来说，深拷贝的执行效率依旧可以接受，但如果临时对象中的指针成员申请了大量的堆空间，那么 2 次深拷贝操作势必会影响 a 对象初始化的执行效率。针对此，C++11引入了移动构造函数方案以避免深拷贝导致的效率问题。</p>
<p>移动构造函数与浅拷贝类似，但是区别在于：1. 参数要求是右值引用，而非左值引用；2. 函数内将原指针置为0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加移动构造函数</span></span><br><span class="line"><span class="built_in">demo</span>(demo &amp;&amp;d):<span class="built_in">num</span>(d.num)&#123;</span><br><span class="line">    d.num = <span class="literal">NULL</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;move construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来，上面的main在执行过程中，return返回和=赋值，都是将右值赋给左值，因此对应上了移动构造函数中的右值引用。所以再执行代码时，将会通过两次移动替代两次拷贝：</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/cpp-basic/image_w9TrPipfr5.png" alt="" /></p>
<p>实际开发中，通常在类中自定义移动构造函数的同时，会再为其自定义一个适当的拷贝构造函数，由此当用户利用右值初始化类对象时，会调用移动构造函数；使用左值（非右值）初始化类对象时，会调用拷贝构造函数。</p>
<p><strong>但是</strong>，也可以完全用移动构造函数，也就是完全用右值引用，方法是采用<code>std::move()</code>函数，强行将左值转为右值。</p>
</li>
</ul>
<blockquote>
<p>📌C<ins>定义类class A，类内包含的默认8个成员函数：<br />
- 默认构造函数：                                   A();<br />
- 默认拷贝构造函数：                            A(const A&amp;);<br />
- 默认析构函数：                                   ~A();<br />
- 默认重载赋值运算符：                         A&amp; operator = (const A&amp;);<br />
- 默认重载取址运算符：                         A* operator &amp; ();<br />
- 默认const修饰的重载取址运算符：     const A* operator &amp; () const;<br />
- （C</ins>11）默认移动构造函数：          A(A&amp;&amp;);<br />
- （C++11）默认重载移动赋值运算符：A&amp; operator = (const A&amp;&amp;);</p>
<p>unique_ptr就是通过移动构造函数实现的所有权转移。unique_ptr类中只有移动构造函数，禁用拷贝构造。<br />
移动构造函数还有一个典型案例就是，vector容器中的emplace_back函数采用移动构造，push_back函数采用拷贝构造，前者比后者高效很多。</p>
</blockquote>
<h4 id="智能指针"><a class="markdownIt-Anchor" href="#智能指针"></a> 智能指针</h4>
<p>智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，智能指针是一个类，当超出类的作用域时，会自动调用析构函数，析构函数会自动释放资源。因此<strong>智能指针在函数结束时自动释放内存空间，不需要手动释放</strong>（严格践行RAII）。而且智能指针重载了*和→操作符，使用起来和原始指针一样。不要试图delete智能指针。</p>
<ul>
<li>
<p>auto_ptr（已被C++11弃用）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">p1</span> <span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;I reigned lonely as a cloud&quot;</span>))</span></span>;</span><br><span class="line">auto_ptr&lt;string&gt; p2;</span><br><span class="line">p2 = p1; <span class="comment">//auto_ptr不会报错</span></span><br></pre></td></tr></table></figure>
<p>auto_ptr采用所用权模式。上述代码执行时不会报错，但p2剥夺了p1的所有权，当程序访问p1时将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃风险。</p>
</li>
<li>
<p>unique_ptr</p>
<p>unique_ptr实现独占式拥有，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露（如“new创建对象后因异常而忘记调用delete”）特别有用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> string (<span class="string">&quot;auto&quot;</span>))</span></span>;</span><br><span class="line">unique_ptr&lt;string&gt; p4;</span><br><span class="line">p4 = p3; <span class="comment">//报错！</span></span><br></pre></td></tr></table></figure>
<p>编译器认为p4=p3非法，因此避免了p3不再指向有效数据，成为野指针的问题。因此unique_ptr比auto_ptr更为安全。</p>
<p>智能指针没有定义加减运算，<strong>不能随意移动指针地址</strong>，从而<strong>避免指针越界</strong>等危险操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ptr1++;   <span class="comment">//导致编译错误</span></span><br><span class="line">ptr2+=<span class="number">2</span>;  <span class="comment">//导致编译错误</span></span><br></pre></td></tr></table></figure>
<p>需要注意，使用智能指针也要避免未初始化的空指针问题。比如下面的代码会导致core dump：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr ptr3;  <span class="comment">//未初始化智能指针</span></span><br><span class="line">*ptr3 = <span class="number">42</span>;       <span class="comment">//错误！操作了空指针</span></span><br></pre></td></tr></table></figure>
<p>为了避免这种低级错误，可以调用工厂函数<strong>make_unique()</strong>，强制要求创建指针的时候必须初始化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;string&gt; ptr5;</span><br><span class="line">ptr5 = <span class="built_in">unique_ptr</span>&lt;string&gt;(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">&quot;You&quot;</span>)); <span class="comment">//不用工厂函数，而是构造函数，临时右值初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ptr3 = <span class="built_in">make_unique</span>(<span class="number">42</span>);                   <span class="comment">//工厂函数创建智能指针</span></span><br><span class="line"><span class="built_in">assert</span>(ptr3 &amp;&amp; *ptr3 == <span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ptr4 = <span class="built_in">make_unique</span>(<span class="string">&quot;god of war&quot;</span>);         <span class="comment">//工厂函数创建智能指针</span></span><br><span class="line"><span class="built_in">assert</span>(!ptr4-&gt;<span class="built_in">empty</span>());</span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌make_unique()要求C<ins>14，但是如果使用C</ins>11，可以自己实现一个简化版的make_unqiue()</p>
<p>template&lt;typename T, typename… Ts&gt;                                                //可变参数模板     <br />
std::unique_ptr&lt;T&gt; make_unique(Ts&amp;&amp;… params)                             //返回智能指针，入口参数<br />
{<br />
    return std::unique_ptr&lt;T&gt;(new T(std::foward&lt;Ts&gt;(params)…));   //构造智能指针，完美转发<br />
}</p>
<p>（标准库的工厂函数内部是有优化的，会比手写类型构造的效率更高）</p>
</blockquote>
<p>前面提到unique_ptr不允许直接进行“所有权”转移，这是因为其禁用了拷贝赋值，仅保留了移动构造和移动赋值。因此，若想要进行所有权转移，必须用<code>std::move</code>函数显式地声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr1 = <span class="built_in">make_unique</span>(<span class="number">42</span>);   <span class="comment">//工厂函数创建智能指针</span></span><br><span class="line"><span class="built_in">assert</span>(ptr1 &amp;&amp; *ptr1 ==<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ptr2 = std::<span class="built_in">move</span>(ptr1);   <span class="comment">//使用move()转移所有权</span></span><br><span class="line"><span class="built_in">assert</span>(!ptr1 &amp;&amp; ptr2);</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>get()和release()：</p>
<p>bar是一个智能指针，p是一个普通指针，<code>p=bar.get()</code>，bar并未被释放，此时相当于指针p和智能指针bar共同管理一个对象。也就是说，*p=做的事情，会反映到bar指向的对象。</p>
<p>release()会释放当前指针对对象的所有权，其返回值用于新的指针（普通指针或智能指针）接管对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">                                           <span class="comment">// foo   bar    p</span></span><br><span class="line">                                           <span class="comment">// ---   ---   ---</span></span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; foo;                  <span class="comment">// null</span></span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; bar;                  <span class="comment">// null  null</span></span><br><span class="line"><span class="type">int</span>* p = <span class="literal">nullptr</span>;                          <span class="comment">// null  null  null</span></span><br><span class="line"></span><br><span class="line">foo = std::<span class="built_in">unique_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>));   <span class="comment">//  10   null  null</span></span><br><span class="line">bar = std::<span class="built_in">move</span>(foo);                      <span class="comment">// null   10   null</span></span><br><span class="line">p = bar.<span class="built_in">get</span>();                             <span class="comment">// null   10    10</span></span><br><span class="line">*p = <span class="number">20</span>;                                   <span class="comment">// null   20    20</span></span><br><span class="line">p = <span class="literal">nullptr</span>;                               <span class="comment">// null   20   null</span></span><br><span class="line"></span><br><span class="line">foo = std::<span class="built_in">unique_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">30</span>));   <span class="comment">//  30    20   null</span></span><br><span class="line">p = foo.<span class="built_in">release</span>();                         <span class="comment">// null   20    30</span></span><br><span class="line">*p = <span class="number">40</span>;                                   <span class="comment">// null   20    40</span></span><br></pre></td></tr></table></figure>
<p>此外还有reset()方法，不仅会释放所有权，还会释放对象，即释放内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> std::string(<span class="string">&quot;1&quot;</span>))</span></span>;</span><br><span class="line"><span class="function">std::unique_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(p1.release())</span></span>;    <span class="comment">//p1置空,p2接管</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;string&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> std::string(<span class="string">&quot;3&quot;</span>))</span></span>;</span><br><span class="line">p2.<span class="built_in">reset</span>(p3.<span class="built_in">release</span>());                      <span class="comment">//p2会释放原来指向的对象，接管p3原来的对象</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>shared_ptr</p>
<p>shared_ptr实现共享式拥有概念。多个智能指针指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时释放。采用计数机制表明资源被几个指针共享，可通过成员函数<code>use_count()</code>查看资源所得者个数。</p>
<ul>
<li>
<p>构造方式：</p>
<p>可通过new来构造，也可通过传入<code>auto_ptr</code>，<code>unique_ptr</code>，<code>weak_ptr</code>来构造，还可通过<code>std::make_shared</code>函数构造，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sptr3</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sptr4 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>由于所有权是可以被安全共享的，所以允许拷贝赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">auto</span> ptr2 = ptr1;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>销毁方式：</p>
<p>对某个指针调用release()时，当前指针会释放资源所有权，计数减1。当计数等于0，资源被释放</p>
</li>
<li>
<p>关键成员函数：</p>
<p>use_count：返回引用计数的个数</p>
<p>unique：返回是否是独占所有权（use_count为1）</p>
<p>swap：交换两个shared_ptr对象</p>
<p>reset：放弃内部对象的所有权或拥有对象的变更，会引起原有对象的引用计数的减少</p>
<p>get：返回内部对象（指针），如<code>shared_ptr&lt;int&gt;sp (new int(1))</code>后，<code>sp</code>与<code>sp.get()</code>是等价的</p>
</li>
</ul>
</li>
<li>
<p>weak_ptr</p>
<p>weak_ptr指向由shared_ptr管理的对象，但不控制对象的生命周期。考虑这样一种情况，两个shared_ptr相互引用，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  shared_ptr&lt;B&gt; pb_;</span><br><span class="line">  ~<span class="built_in">A</span>()&#123; cout&lt;&lt;<span class="string">&quot;A delete\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  shared_ptr&lt;A&gt; pa_;</span><br><span class="line">  ~<span class="built_in">B</span>()&#123; cout&lt;&lt;<span class="string">&quot;B delete\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">shared_ptr&lt;B&gt; <span class="title">pb</span> <span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line"><span class="function">shared_ptr&lt;A&gt; <span class="title">pa</span> <span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">pb-&gt;pa_ = pa;</span><br><span class="line">pa-&gt;pb_ = pb;</span><br><span class="line">cout &lt;&lt; pb.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; pa.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>此时两个指针互相引用，形成了死锁，计数不可能下降为0（两个的计数都为2），资源永远不会释放。而weak_ptr旨在解决这一问题，weak_ptr不会引起计数的增加或减少，但可指向shared_ptr管理的对象，因此在例子中，两shared_ptr中的一个降级为weak_ptr即可解决死锁问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  weak_ptr&lt;B&gt; pb_;</span><br><span class="line">  ~<span class="built_in">A</span>()&#123; cout&lt;&lt;<span class="string">&quot;A delete\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>weak_ptr基本用法：</p>
<p> 如果要使用weak_ptr指向的对象，首先要用expired成员函数检查对象是否存在且是否能引用，之后再用lock成员函数升格为shared_ptr，才能使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">3</span>))</span></span>;  <span class="comment">//strong ref = 1</span></span><br><span class="line">  std::shared_ptr&lt;<span class="type">int</span>&gt; sptr2 = sptr;      <span class="comment">//strong ref = 2</span></span><br><span class="line"></span><br><span class="line">  std::weak_ptr&lt;<span class="type">int</span>&gt; wptr = sptr;         <span class="comment">//strong ref = 2, weak ref = 1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!wptr.<span class="built_in">expired</span>())&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; sptr3 = wptr.<span class="built_in">lock</span>();<span class="comment">//strong ref = 3, weak ref = 1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，使用weak_ptr是有强弱引用计数的</p>
</li>
</ul>
</li>
<li>
<p>智能指针是否会有内存泄漏</p>
<p>当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，退出作用域时未能释放内存，从而导致内存泄露。</p>
</li>
<li>
<p>智能指针的内存泄露如何处理</p>
<p>为了解决循环引用导致的内存泄漏，引入了weak_ptr弱指针，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。</p>
</li>
</ul>
<h4 id="写时拷贝cow-copy-on-write"><a class="markdownIt-Anchor" href="#写时拷贝cow-copy-on-write"></a> 写时拷贝（COW, Copy On Write）</h4>
<p> 深拷贝和浅拷贝各有优劣，前者可以避免重复析构的问题，后者可以提高代码效率。写时拷贝即是融合了二者优点的改良方案，类似于shared_ptr。</p>
<p>其特点为：<strong>写之前→浅拷贝</strong>，多个对象可以指向一片内存；<strong>修改时→深拷贝</strong>，哪个对象要修改内存的值，就为其新开辟一块空间。当要释放掉某片内存时，只在<strong>最后一个对象销毁时</strong>释放该内存。</p>
<ul>
<li>
<p>如何知道当前析构的是否是最后一个对象？</p>
<p>利用计数器（<strong>引用计数</strong>），当新增了一个指向这片内存的对象时，该计数器加1，当销毁了一个指向这片内存的对象时，计数器减1。减到0时，说明在销毁最右一个对象，此时可以释放内存。</p>
<p>计数器位置的选取是此方案最重要的问题。</p>
<ul>
<li>
<p>引用计数作为成员变量？</p>
<p>难以做到多个对象之间的同步。</p>
</li>
<li>
<p>引用计数作为静态变量？</p>
<p>所有对象共享该引用计数，如果都指向了相同内存，可以达到计数目的。然而，如果出现了写操作，会导致问题。举例说明，类中有一个string指针属性，实例化对象时需要开辟内存。当前三个对象都指向&quot;hello&quot;字符串时，计数器会加到3，但是如果第四个对象指向了&quot;world&quot;字符串，那么第四个对象会将计数器置1。那么前三个对象的计数器也会被修改为1，从而无法释放掉&quot;hello&quot;字符串。</p>
</li>
<li>
<p><strong>引用计数放在堆内存中</strong>：</p>
<p>将引用计数变量放在堆内存中，是写时拷贝的惯用方案。当开辟内存时，多留4字节的裕量，将引用计数放在堆内存起始位置。之后再将类的属性（指针）指向堆内存起始位置+4。</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/cpp-basic/image_pNRhIJgYeq.png" alt="" /></p>
</li>
</ul>
</li>
</ul>
<p>以自定义一个CString类型为例：</p>
<ol>
<li>
<p>查看引用计数函数：</p>
<p>引用计数在堆内存中，需要查看或修改时，返回该内存的引用。因为堆内存开辟时是char类型，指针需强制转为int*</p>
<p>不应暴露出可以外部修改引用计数的接口，所以引用计数和查看函数均应是私有的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mptr是类CString中，指向堆内存的指针成员</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">getRefCount</span><span class="params">(<span class="type">char</span>* ptr)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">int</span>*)(ptr<span class="number">-4</span>);         <span class="comment">//ptr指向的是字符串，想查看引用计数需地址回退四个字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>释放内存函数：</p>
<p>释放内存涉及的问题是判断是否销毁到了指向这片内存的最后一个对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Release</span><span class="params">(<span class="type">char</span>* ptr)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(--<span class="built_in">getRefCount</span>(mptr) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] (mptr<span class="number">-4</span>);                <span class="comment">//释放内存的时候还要释放保存引用计数的四个字节</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>构造函数：</p>
<p>构造函数需从一个字符串常量构造，由于事先并无开辟的堆内存，所以需要开辟新内存，并将引用计数置1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CString</span>(<span class="type">char</span>* ptr=<span class="literal">NULL</span>) : <span class="built_in">mptr</span>(<span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(ptr) + <span class="number">1</span> + <span class="number">4</span>])&#123;     <span class="comment">//从字符串常量构造CString对象</span></span><br><span class="line">  mptr += <span class="number">4</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(mptr, ptr);</span><br><span class="line">  <span class="built_in">getRefCount</span>(mptr) = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>拷贝构造函数和重载赋值运算符：</p>
<p>拷贝构造函数用浅拷贝，同时给引用计数加1。</p>
<p>而赋值运算符需要注意的是，如果左值是原内存的最后一个对象，则需要销毁原内存（或者不是最后一个对象，要引用计数减1），再进行浅拷贝。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CString</span>(<span class="type">const</span> CString&amp; rhs):<span class="built_in">mptr</span>(rhs.mptr)&#123;</span><br><span class="line">  ++<span class="built_in">getRefCount</span>(mptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CString&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CString&amp; rhs)&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;rhs)&#123;</span><br><span class="line">    <span class="built_in">Release</span>(mptr);</span><br><span class="line">    mptr = rhs.mptr;</span><br><span class="line">    ++<span class="built_in">getRefCount</span>(mptr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>重载[]运算符函数：</p>
<p>[ ]运算符涉及的问题是，CSting定义的对象str，往往是通过[ ]来修改值的，比如str[1]=‘a’。所以这里不应采用浅拷贝，而应是深拷贝。这也对应了<strong>写时拷贝</strong>的概念，即只有发生修改时，才用深拷贝。</p>
<p>但也不是所有情况下都必须用深拷贝，如果引用计数为1，说明只有一个对象独占资源，那么可以直接在原内存上进行修改，不需要深拷贝。如果引用计数大于1，说明多个对象共享堆内存，那么一个对象动了堆，其他对象也会跟着改变，但是其他对象本来的堆内存的值本就不应改变，这时需要采用深拷贝。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index)&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">getRefCount</span>(mptr) &gt; <span class="number">1</span>)&#123;                   <span class="comment">//判断引用计数是否大于1</span></span><br><span class="line">    <span class="type">char</span>* ptr = mptr;</span><br><span class="line">    mptr = <span class="keyword">new</span> <span class="built_in">char</span>(<span class="built_in">strlen</span>(mptr) + <span class="number">1</span> + <span class="number">4</span>);     <span class="comment">//深拷贝</span></span><br><span class="line">    --<span class="built_in">getRefCount</span>(ptr);</span><br><span class="line">    mptr += <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(mptr, ptr);</span><br><span class="line">    <span class="built_in">getRefCount</span>(mptr) = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mptr[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样写也存在问题，很多时候调用[ ]只希望访问值，而非修改，但访问时也采用了深拷贝，导致了效率的损失。<strong>这也是写时拷贝的缺点所在</strong>。</p>
</li>
</ol>
<ul>
<li>
<p>整体代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CString</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CString</span>(<span class="type">char</span>* ptr=<span class="literal">NULL</span>) : <span class="built_in">mptr</span>(<span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(ptr) + <span class="number">1</span> + <span class="number">4</span>])&#123;</span><br><span class="line">    mptr += <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(mptr, ptr);</span><br><span class="line">    <span class="built_in">getRefCount</span>(mptr) = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">CString</span>(<span class="type">const</span> CString&amp; rhs):<span class="built_in">mptr</span>(rhs.mptr)&#123;</span><br><span class="line">    ++<span class="built_in">getRefCount</span>(mptr);</span><br><span class="line">  &#125;</span><br><span class="line">  CString&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CString&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;rhs)&#123;</span><br><span class="line">      <span class="built_in">Release</span>(mptr);</span><br><span class="line">      mptr = rhs.mptr;</span><br><span class="line">      ++<span class="built_in">getRefCount</span>(mptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">getRefCount</span>(mptr) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">      <span class="type">char</span>* ptr = mptr;</span><br><span class="line">      mptr = <span class="keyword">new</span> <span class="built_in">char</span>(<span class="built_in">strlen</span>(mptr) + <span class="number">1</span> + <span class="number">4</span>);</span><br><span class="line">      --<span class="built_in">getRefCount</span>(ptr);</span><br><span class="line">      mptr += <span class="number">4</span>;</span><br><span class="line">      <span class="built_in">strcpy</span>(mptr, ptr);</span><br><span class="line">      <span class="built_in">getRefCount</span>(mptr) = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mptr[index];</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">CString</span>()&#123;</span><br><span class="line">    <span class="built_in">Release</span>(mptr);                      <span class="comment">//析构时调用释放内存函数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; mptr &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">char</span>* mptr;</span><br><span class="line">  <span class="function"><span class="type">int</span>&amp; <span class="title">getRefCount</span><span class="params">(<span class="type">char</span>* ptr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">int</span>*)(ptr<span class="number">-4</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Release</span><span class="params">(<span class="type">char</span>* ptr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(--<span class="built_in">getRefCount</span>(mptr) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">delete</span>[] (mptr<span class="number">-4</span>);                <span class="comment">//释放内存的时候还要释放保存引用计数的四个字节</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">CString <span class="title">str1</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;<span class="comment">//构造</span></span><br><span class="line">  <span class="function">Cstring <span class="title">str2</span><span class="params">(str1)</span></span>;<span class="comment">//拷贝构造</span></span><br><span class="line">  <span class="function">CString <span class="title">str3</span><span class="params">(<span class="string">&quot;world&quot;</span>)</span></span>;<span class="comment">//构造</span></span><br><span class="line">  str1 = str3;</span><br><span class="line">  str1[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  str1.<span class="built_in">Print</span>();</span><br><span class="line">  str2.<span class="built_in">Print</span>();</span><br><span class="line">  str3.<span class="built_in">Print</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p>aorld</p>
<p>hellow</p>
<p>world</p>
</li>
</ul>
<h3 id="11-模板"><a class="markdownIt-Anchor" href="#11-模板"></a> 11 模板</h3>
<blockquote>
<p>更高深的模板知识移步《泛型编程》笔记，泛型编程本身就是C++几大编程风格之一，可以说非常复杂</p>
</blockquote>
<ul>
<li>
<p>类模板</p>
<p>编译时的机制，并不会产生额外的运行时开销</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T* elem;</span><br><span class="line">  <span class="type">int</span> sz;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Vector</span><span class="params">(<span class="type">int</span> s)</span></span>;</span><br><span class="line">  ~<span class="built_in">Vector</span>() &#123;<span class="keyword">delete</span>[] elem;&#125;</span><br><span class="line"></span><br><span class="line">  T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> i);</span><br><span class="line">  <span class="type">const</span> T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> sz;&#125;</span><br><span class="line">  <span class="function">T* <span class="title">begin</span><span class="params">(Vector&lt;T&gt;&amp; x)</span></span>;</span><br><span class="line">  <span class="function">T* <span class="title">end</span><span class="params">(Vector&lt;T&gt;&amp; x)</span></span></span><br><span class="line"><span class="function">&#125;</span>;</span><br></pre></td></tr></table></figure>
<p>成员函数的定义方式与之类似</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Vector&lt;T&gt;::<span class="built_in">Vector</span>(<span class="type">int</span> s)&#123;</span><br><span class="line">  <span class="keyword">if</span>(s &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> Negative_size&#123;&#125;;</span><br><span class="line">  elem = <span class="keyword">new</span> T[s];</span><br><span class="line">  sz = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> T&amp; Vector&lt;T&gt;::<span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i&lt;<span class="number">0</span> || <span class="built_in">size</span>()&lt;=i)</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;Vector::operator[]&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> elem[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T* <span class="title">begin</span><span class="params">(Vector&lt;T&gt;&amp; x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x.<span class="built_in">size</span>() ? &amp;x[<span class="number">0</span>] : <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T* <span class="title">end</span><span class="params">(Vector&lt;T&gt;&amp; x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">begin</span>(x) + x.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义了begin 和end就可以使用for循环了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(Vector&lt;string&gt;&amp; vs)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; s : vs)</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了类型参数外，还接受普通的值参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Buffer</span>&#123;</span><br><span class="line">  <span class="keyword">using</span> value_type = T;</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> N;&#125;</span><br><span class="line">  T[N];</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>函数模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Value&gt;</span></span><br><span class="line"><span class="function">Value <span class="title">sum</span><span class="params">(<span class="type">const</span> Container&amp; c, Value v)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> x : c)</span><br><span class="line">    v += x;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的函数相当于针对不同的类型实现了一个累加器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">user</span><span class="params">(Vector&lt;<span class="type">int</span>&gt;&amp; vi, std::list)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="built_in">sum</span>(vi, <span class="number">0</span>);</span><br><span class="line">  <span class="type">double</span> d = <span class="built_in">sum</span>(vi, <span class="number">0.0</span>);</span><br><span class="line">  <span class="type">double</span> dd = <span class="built_in">sum</span>(ld, <span class="number">0.0</span>);</span><br><span class="line">  <span class="keyword">auto</span> z = <span class="built_in">sum</span>(vc, complex&lt;<span class="type">double</span>&gt;&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>📌模板也可以跟函数参数一样，有默认值。<br />
template &lt;typename ty=string&gt;<br />
int test(ty x) {<br />
 //…<br />
}<br />
如果没有显式说明ty的类型，也没有自动推断，那么编译时就会让ty成为默认类型string。</p>
</blockquote>
<h4 id="静态多态crtp"><a class="markdownIt-Anchor" href="#静态多态crtp"></a> 静态多态：CRTP</h4>
<blockquote>
<p><strong>C</strong>uriously <strong>R</strong>ecurring <strong>T</strong>emplate <strong>P</strong>attern</p>
</blockquote>
<p>一般意义上的使用virtual实现的多态均为动态多态，在运行时实现多态。在C++中也可以使用<strong>静态多态</strong>，在编译时实现多态。动态多态由于存储虚表指针和虚表，以及有查询虚函数地址的一系列操作，会带来较大的开销。静态多态可以<strong>提升效率（降低开销）</strong>，就像内联函数一样。</p>
<ul>
<li>
<p>动态多态：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;unset&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Dog&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Cat&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">My_Print</span><span class="params">(<span class="type">const</span> Animal&amp; animal)</span></span>&#123;</span><br><span class="line">  animal.<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Dog d;</span><br><span class="line">  <span class="built_in">My_Print</span>(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<!---->
<ul>
<li>
<p>最简单的静态多态：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Animal_Type</span>&#123;</span><br><span class="line">  unset, Dog, Cat,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Animal</span>(Animal_Type animal_type) </span><br><span class="line">    : <span class="built_in">animal_type</span>(animal_type) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(animal_type)&#123;</span><br><span class="line">      <span class="keyword">case</span> unset:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;unset&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Dog:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Dog&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Cat:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Cat&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Animal_Type animal_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">My_Print</span><span class="params">(<span class="type">const</span> Animal&amp; animal)</span></span>&#123;</span><br><span class="line">  animal.<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">Animal <span class="title">dog</span><span class="params">(Animal_Type::Dog)</span></span>;</span><br><span class="line">  <span class="built_in">My_Print</span>(dog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>然而这种最简单的静态多态方法导致的问题是明显的，Animal类非常难以维护，要加一个新类别或新动作，要直接修改Animal类和Animal_Type类的源码。于是可以采用模板来进行改进（需要说明的是，既不用virtual，也不用模板，达不到多态的目的）：</p>
<ul>
<li>
<p>不用virtual和模板无法实现多态：</p>
<p>打印的结果是unset，因为调用My_Print时会把Dog类隐式转换为Animal类（因为My_Print函数接收的参数要求是Animal类）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;unset&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="comment">//覆盖原Print</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Dog&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="comment">//覆盖原Print</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Cat&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">My_Print</span><span class="params">(<span class="type">const</span> Animal&amp; animal)</span></span>&#123;</span><br><span class="line">  animal.<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Dog d;</span><br><span class="line">  <span class="built_in">My_Print</span>(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<!---->
<ul>
<li>
<p>利用模板改进的静态多态：</p>
<p>打印Dog，My_Print是模板函数，自动推断类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;unset&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Dog&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Cat&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A_T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">My_Print</span><span class="params">(<span class="type">const</span> A_T&amp; animal)</span></span>&#123;</span><br><span class="line">  animal.<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Dog d;</span><br><span class="line">  <span class="built_in">My_Print</span>(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可以在上面的静态多态实现方案的基础上，进一步改良。现在是有三个Print函数，可以进一步降到只有两个函数以降低开销。改良的方案是CRTP。</p>
<p>CRTP一般的套路如下，在基类上用模板，基类只保留接口，子类负责接口的具体实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Derived</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Interface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="built_in">static_cast</span>&lt;Derived*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">Implementation</span>();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base&lt;Derived&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Implementation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>针对上面的例子，则可以改写为CRTP实现的静态多态：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Derived&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="built_in">static_cast</span>&lt;Derived*&gt;(<span class="keyword">this</span>) -&gt; <span class="built_in">Print</span>(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal&lt;Dog&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Dog&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal&lt;Cat&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Cat&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A_T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">My_Print</span><span class="params">(<span class="type">const</span> A_T&amp; animal)</span></span>&#123;</span><br><span class="line">  animal.<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Dog d;</span><br><span class="line">  <span class="built_in">My_Print</span>(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，表面上Dog和Cat类都在继承Animal，但事实上它们继承的类是不同的，Dog继承的是Animal&lt;Dog&gt;类，Cat继承的是Animal&lt;Cat&gt;类。因此即使基类中有static变量，它们是不共享的。除此之外，由于继承的不是同一个基类，Dog和Cat的对象也无法放在同一个STL容器中，这也给CRTP的使用带来了局限。</p>
<h4 id="函数对象function-objectfunctor"><a class="markdownIt-Anchor" href="#函数对象function-objectfunctor"></a> 函数对象（function object/functor）</h4>
<p>函数对象，顾名思义，就是将函数视作一个类的对象。调用函数对象时与调用函数无异，而函数对象的一个好处就是比较灵活，可以作为其他函数的参数被调用。</p>
<p>模板的一个特殊用途就是泛化函数对象，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Less_than</span>&#123;</span><br><span class="line">  <span class="type">const</span> T val; <span class="comment">//待比较的值</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Less_than</span>(<span class="type">const</span> T&amp; v) : <span class="built_in">val</span>(v) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x &lt; val; &#125; <span class="comment">//调用运算符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此时，可以像调用函数一样调用函数对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Less_than&lt;<span class="type">int</span>&gt; LT_i &#123;<span class="number">42</span>&#125;;</span><br><span class="line">Less_than&lt;string&gt; LT_s &#123;<span class="string">&quot;Backus&quot;</span>&#125;;</span><br><span class="line"><span class="type">bool</span> b1 = <span class="built_in">LT_i</span>(n);  <span class="comment">//如果n&lt;42则为真</span></span><br><span class="line"><span class="type">bool</span> b2 = <span class="built_in">LT_s</span>(s);  <span class="comment">//如果s&lt;&quot;Backus&quot;则为真</span></span><br></pre></td></tr></table></figure>
<p>函数对象经常作为算法的参数出现，例如下面例子中pred就是函数对象作为的参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//统计容器中有多少个小于某数的值</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> P&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">const</span> C&amp; c, P pred)</span></span>&#123;    <span class="comment">//C假定为容器类型，P为函数对象类型</span></span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; x : c)</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pred</span>(x))</span><br><span class="line">      ++cnt;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> Vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">count</span>(vec, Less_than&lt;<span class="type">int</span>&gt;&#123;x&#125;) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了用类和模板定义函数对象，还<strong>可以用匿名函数(lambda表达式)定义函数对象</strong>。</p>
<h4 id="可变参数"><a class="markdownIt-Anchor" href="#可变参数"></a> 可变参数</h4>
<ul>
<li>
<p>省略符形参：</p>
<p>省略符形参应该仅仅用于C和C++通用的类型。特别应该注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> count, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//为了实现可变参数列表，首先需要声明一个va_list类型的指针</span></span><br><span class="line">  <span class="comment">//va_list类型是在cstdarg头文件里面定义的，该指针用来依次指向各个参数</span></span><br><span class="line">  <span class="comment">//va_start是一个宏，用来初始化arg_ptr，使其指向列表的第一个参数</span></span><br><span class="line">  <span class="comment">//这个宏的第二个参数是sum函数参数列表省略号前得固定参数的名称，用来确定第一个参数的位置 </span></span><br><span class="line">  va_list arg_ptr;</span><br><span class="line">  <span class="built_in">va_start</span>(arg_ptr, count);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> CountSum = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//va_arg是一个宏，返回arg_ptr指向的参数位置，并使arg_ptr递增来指向下一个参数值</span></span><br><span class="line">  <span class="comment">//va_arg宏的第二个参数是需要统计的第一个参数的类型，</span></span><br><span class="line">  <span class="comment">//如果类型不正确，程序也可能会执行，但得到的是无用的数据，arg_ptr将被错误地递增</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    CountSum += <span class="built_in">va_arg</span>(arg_ptr, <span class="type">int</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将va_list类型的指针复位成空值</span></span><br><span class="line">  <span class="comment">//就是清空可变参数列表</span></span><br><span class="line">  <span class="built_in">va_end</span>(arg_ptr);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> CountSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sum</span>(<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);<span class="comment">//return 15</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>可变参数模板</strong>（实用）：</p>
<p>实现可变参数模板的关键是：当你传给它多个参数时，谨记把第一个参数和其他参数<strong>区分对待</strong>。此处，首先处理第一个参数head，然后使用剩余参数<strong>递归</strong>地调用f()。省略号…表示列表地“剩余部分”。最终，tail将为空。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">//不执行任何操作</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Tail&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T head, Tail... tail)</span></span>&#123;          <span class="comment">//f()类似于printf()的简单变形</span></span><br><span class="line">  <span class="built_in">g</span>(head);                             <span class="comment">//对head做某些操作</span></span><br><span class="line">  <span class="built_in">f</span>(tail...);                          <span class="comment">//再次处理tail</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;first: &quot;</span>;</span><br><span class="line">  <span class="built_in">f</span>(<span class="number">1</span>,<span class="number">2.2</span>,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;\n second: &quot;</span>;</span><br><span class="line">  <span class="built_in">f</span>(<span class="number">0.2</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&quot;yuck!&quot;</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//first: 1 2.2 hello</span></span><br><span class="line"><span class="comment">//second: 0.2 c yuck! 0 1 2</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>可变参数initializer_list：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//initializer_list相对vector更轻量化 而且元素是常量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_msg</span><span class="params">(initializer_list&lt;string&gt; il)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> beg = il.<span class="built_in">begin</span>(); beg != il.<span class="built_in">end</span>(); ++beg)</span><br><span class="line">    cout &lt;&lt; *beg &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">error_msg</span>(&#123;<span class="string">&quot;im&quot;</span>,<span class="string">&quot;da&quot;</span>,<span class="string">&quot;gong&quot;</span>&#125;);<span class="comment">//&quot;im da gong&quot;</span></span><br></pre></td></tr></table></figure>
<p>这种方式局限性很大，列表里只能同类型，而且元素是常量。</p>
<p>这种方式的一个典型例子就是vector初始化赋值，可用下面代码模拟：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyNumber</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">MyNumber</span>(<span class="type">const</span> std::initializer_list&lt;<span class="type">int</span>&gt;&amp; v)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> itm : v)</span><br><span class="line">      mVec.<span class="built_in">push_back</span>(itm);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> itm : mVec)</span><br><span class="line">      std::cout &lt;&lt; itm &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; mVec;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  MyNumber m = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">  m.<span class="built_in">print</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>宏：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> debug(...) print(cout,__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug2(os, ...) print(os, __VA_ARGS__)</span></span><br><span class="line"><span class="comment">//#define debug2(format, args...) print(format, ##args)//win32不支持</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">debug2</span>(cout,<span class="string">&quot;this &quot;</span>, <span class="string">&quot; year&quot;</span>);<span class="comment">//&quot;this  year&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>__VA_ARGS__</code>表示可变参数列表。</p>
</li>
</ul>
<h4 id="别名"><a class="markdownIt-Anchor" href="#别名"></a> 别名</h4>
<p>泛型编程中的别名可以有很多用途，</p>
<ul>
<li>
<p>写出通用代码：</p>
<p>比如，每个标准库容器都提供了value_type作为其值类型的名字（如vector&lt;int&gt;::value_type为int），因此可以利用这点写出代码，使代码能够在任何一个服从这种规范的容器上工作，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="keyword">using</span> Element_type = <span class="keyword">typename</span> C::value_type; <span class="comment">//C的元素类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">algo</span><span class="params">(Container&amp; c)</span></span>&#123;</span><br><span class="line">  Vector&lt;Element_type&lt;Container&gt;&gt; vec; <span class="comment">//保存结果</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现algo函数，就可以将如stack&lt;int&gt;的变量转换成vector&lt;int&gt;，Element_type&lt;Container&gt;会等于int。</p>
</li>
<li>
<p>绑定某些模板实参，定义新的模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Map</span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value&gt;</span><br><span class="line"><span class="keyword">using</span> String_map = Map&lt;string, Value&gt;;</span><br><span class="line"></span><br><span class="line">String_map&lt;<span class="type">int</span>&gt; m; <span class="comment">//m是一个Map&lt;string, int&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>📌typedef 和using 的区别：typedef 只能针对特定的类型，而using 可以生成别名模板。<br />
比如可以<code>template&lt;class T&gt; using remove_const_t = typename remove_const&lt;T&gt;::type</code>，而typedef则不行。</p>
</blockquote>
<h4 id="模板特化"><a class="markdownIt-Anchor" href="#模板特化"></a> 模板特化</h4>
<p>当定义一个类模板或函数模板时，往往希望所有会用到的模板参数类型，都能够满足类模板或函数模板对其功能的要求，举例来说，函数模板template&lt;typename T&gt; …希望所有可能实例化的T，都能够实现取模运算<code>%</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function">E <span class="title">my_gcd</span><span class="params">(E a, E b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(b != <span class="built_in">E</span>(<span class="number">0</span>))&#123;</span><br><span class="line">    E r = a % b;</span><br><span class="line">    a = b;</span><br><span class="line">    b = r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，并不是所有的类型都有取模函数，比如一些第三方库的高精度数字库（如CLN的<code>cl_I</code>高精度整数类型就不支持），那么实例化会失败，编译出错。</p>
<p>针对这种情况，有三种解决方案，其中后面两种最常用，即<strong>重载</strong>和<strong>特化</strong>。1</p>
<ol>
<li>
<p>方案1：添加代码，让类型支持所需要的操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cln::cl_I</span><br><span class="line"><span class="keyword">operator</span>%(<span class="type">const</span> cln::cl_I&amp; lhs,</span><br><span class="line">          <span class="type">const</span> cln::cl_I&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">mod</span>(lhs, rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>方案2：<strong>函数重载</strong>，不直接使用%运算符，替换成my_mod函数，再重载cl_I类型的my_mod函数</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//%替换成my_mod</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function">E <span class="title">my_gcd</span><span class="params">(E a, E b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (b != <span class="built_in">E</span>(<span class="number">0</span>)) &#123;</span><br><span class="line">    E r = <span class="built_in">my_mod</span>(a, b);</span><br><span class="line">    a = b;</span><br><span class="line">    b = r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般情况下的my_mod函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function">E <span class="title">my_mod</span><span class="params">(<span class="type">const</span> E&amp; lhs,</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="type">const</span> E&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> lhs % rhs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//针对cl_I类重载的my_mod函数</span></span><br><span class="line"><span class="function">cln::cl_I</span></span><br><span class="line"><span class="function"><span class="title">my_mod</span><span class="params">(<span class="type">const</span> cln::cl_I&amp; lhs,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="type">const</span> cln::cl_I&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">mod</span>(lhs, rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   3. 方案3：<strong>模板特化</strong>，同方案2类似，但是my_mod不针对cl_I类型重载，而是特化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line">cln::cl_I <span class="built_in">my_mod</span>&lt;cln::cl_I&gt;(<span class="type">const</span> cln::cl_I&amp; lhs, <span class="type">const</span> cln::cl_I&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">mod</span>(lhs, rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌特化是一种更加通用的技巧，因为特化既可以用在类模板也可以用在函数模板，而重载只能用于函数。<br />
然而，一般的建议是：对函数模板使用重载，对类模板进行特化。</p>
</blockquote>
<ul>
<li>
<p>特化的经典例子：static_assert</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">compile_time_error</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">compile_time_error</span>&lt;<span class="literal">true</span>&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STATIC_ASSERT(Expr, Msg)   \</span></span><br><span class="line"><span class="meta">  &#123;                                \</span></span><br><span class="line"><span class="meta">    compile_time_error<span class="string">&lt;bool(Expr)&gt;</span> \</span></span><br><span class="line"><span class="meta">      ERROR_##_Msg;                \</span></span><br><span class="line"><span class="meta">    (void)ERROR_##_Msg;            \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码声明了一个struct模板，但仅对true的情况进行了特化，产生了compile_tme_error&lt;true&gt;的定义。这样，如果Expr是错的（比如3&gt;5），此时就遇到了compile_time_error&lt;false&gt;的情况，缺少定义编译不出来，所以就会编译报错，起到编译期检查的作用。<code>(void)ERROR_##_Msg</code>是在抑制编译器unused警告（当成功编译时）。</p>
</li>
<li>
<p><strong>为什么遇到类型不满足条件时，对函数模板更倾向于重载</strong>？</p>
<blockquote>
<p>资料：<a target="_blank" rel="noopener" href="http://www.gotw.ca/publications/mill17.htm" title="Why not specialize Function Templates?">Why not specialize Function Templates?</a></p>
</blockquote>
<blockquote>
<p>偏特化：多个模板参数，仅特化其中的一部分</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="编译时计算浅述模板元编程"><a class="markdownIt-Anchor" href="#编译时计算浅述模板元编程"></a> 编译时计算（浅述模板元编程）</h4>
<ul>
<li>最大公约数（辗转相除gcd）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> n&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">factorial</span>&#123;</span><br><span class="line">  <span class="built_in">static_assert</span>( n &gt;= <span class="number">0</span>, <span class="string">&quot;Arg must be non-negative&quot;</span>);</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = n * factorial&lt;n<span class="number">-1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">factorial</span>&lt;<span class="number">0</span>&gt;&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; factorial&lt;<span class="number">10</span>&gt;::value &lt;&lt; std::endl; </span><br><span class="line">    <span class="comment">//3628800</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的代码进行反汇编，可以看到3628800直接出现了，中间的递归、计算过程完全没有。这便体现了编译期计算，即计算步骤完全由编译器完成了，而不在运行时进行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.LC0:</span><br><span class="line">        .string <span class="string">&quot;%d\n&quot;</span></span><br><span class="line">main:</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        mov     esi, <span class="number">3628800</span></span><br><span class="line">        mov     edi, OFFSET FLAT:.LC0</span><br><span class="line">        mov     eax, <span class="number">0</span></span><br><span class="line">        call    printf</span><br><span class="line">        mov     eax, <span class="number">0</span></span><br><span class="line">        pop     rbp</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>
<p>从中可以一窥编译期计算的核心：<strong>将计算转变成类型推导</strong>。</p>
<ul>
<li>条件语句（C++98）：右边两种写法是等价的</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> cond, <span class="keyword">typename</span> Then, <span class="keyword">typename</span> Else&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">If</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Then, <span class="keyword">typename</span> Else&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">If</span>&lt;<span class="literal">true</span>, Then, Else&gt;&#123;</span><br><span class="line">  <span class="keyword">typedef</span> Then type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Then, <span class="keyword">typename</span> Else&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">If</span>&lt;<span class="literal">false</span>, Then, Else&gt;&#123;</span><br><span class="line">  <span class="keyword">typedef</span> Else type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, T v&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">integral_constant</span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> T value = v;</span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> integral_constant type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>( n==<span class="number">2</span> || n==<span class="number">3</span> || n==<span class="number">5</span> ) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> n&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> If&lt;</span><br><span class="line">    ( n==<span class="number">2</span> || n==<span class="number">3</span> || n==<span class="number">5</span>),</span><br><span class="line">    integral_constant&lt;<span class="type">int</span>, <span class="number">1</span>&gt;,</span><br><span class="line">    integral_constant&lt;<span class="type">int</span>, <span class="number">2</span>&gt;&gt;::type</span><br><span class="line">  type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用<code>::</code>取一个成员类型，且<code>::</code>左边有模板参数的话，得额外加上typename关键字来标明结果是一个类型。使用如下：</p>
<p><code>std::cout&lt;&lt;Foo&lt;1&gt;::type::value&lt;&lt;std::endl</code></p>
<p>定义两项分支Then和Else，用类型来代表执行状态。</p>
<p>cond：条件（真或假）</p>
<p>Then：条件为真时的状态</p>
<p>Else：条件为假时的状态</p>
<ul>
<li>循环语句（C++98）：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> condition, <span class="keyword">typename</span> body&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WhileLoop</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Body&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WhileLoop</span>&lt;<span class="literal">true</span>, Body&gt;&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> WhileLoop&lt;</span><br><span class="line">    Body::cond_value,</span><br><span class="line">    <span class="keyword">typename</span> Body::next_type&gt;::type</span><br><span class="line">  type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Body&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WhileLoop</span>&lt;<span class="literal">false</span>, Body&gt;&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Body::res_type type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Body&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">While</span> &#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> WhileLoop&lt;</span><br><span class="line">    Body::cond_value, Body&gt;::type</span><br><span class="line">  type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, T v&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">integral_constant</span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> T value = v;</span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> integral_constant type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">  result = result + n;</span><br><span class="line">  n = n<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> result, <span class="type">int</span> n&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SumLoop</span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">bool</span> cond_value = n!=<span class="number">0</span>;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> res_value = result;</span><br><span class="line">  <span class="keyword">typedef</span> integral_constant&lt;<span class="type">int</span>, res_value&gt; res_type;</span><br><span class="line">  <span class="keyword">typedef</span> SumLoop&lt;result + n, n <span class="number">-1</span>&gt; next_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> n&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sum</span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> SumLoop&lt;<span class="number">0</span>,n&gt; type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>↑上面两种写法的效果是等价的。使用时执行：</p>
<p><code>While&lt;Sum&lt;10&gt;::type&gt;::type::value</code></p>
<p>可得到1~10累加结果</p>
<p>前面说到，编译期计算用类型推导表示分支状态。因此需要三个成员：cond_value表示循环判断的条件（真假）、res_type表示退出循环时的状态、next_type表示下面循环执行一次的状态。</p>
<p>这样的循环过程可以通过展开来理解，以累加到2为例：</p>
<p>While&lt; Sum&lt;2&gt;::type &gt;::type::value 实例化(instantiation)过程<br />
--&gt; While&lt; SumLoop&lt;0, 2&gt; &gt;::type::value<br />
--&gt; WhileLoop&lt;SumLoop&lt;0, 2&gt;::cond_value, SumLoop&lt;0, 2&gt;&gt;::type::value<br />
--&gt; WhileLoop&lt;true, SumLoop&lt;0, 2&gt;&gt;::type::value</p>
<p>--&gt; WhileLoop&lt;SumLoop&lt;0, 2&gt;::cond_value, SumLoop&lt;0, 2&gt;::next_type&gt;::type::value<br />
--&gt; WhileLoop&lt;true, SumLoop&lt;2, 1&gt;&gt;::type::value</p>
<p>--&gt; WhileLoop&lt;SumLoop&lt;2, 1&gt;::cond_value, SumLoop&lt;2, 1&gt;::next_type&gt;::type::value<br />
--&gt; WhileLoop&lt;true, SumLoop&lt;3, 0&gt;&gt;::type::value</p>
<p>--&gt; WhileLoop&lt;SumLoop&lt;3, 0&gt;::cond_value, SumLoop&lt;3, 0&gt;::next_type&gt;::type::value<br />
--&gt; WhileLoop&lt;false, SumLoop&lt;3, -1&gt;&gt;::type::value</p>
<p>--&gt; SumLoop&lt;3, -1&gt;::res_type::value</p>
<p>--&gt;integral_constant&lt;int, 3&gt;::value<br />
--&gt;3</p>
<h4 id="type_traits"><a class="markdownIt-Anchor" href="#type_traits"></a> type_traits</h4>
<p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/header/type_traits">https://en.cppreference.com/w/cpp/header/type_traits</a></p>
<p>顾名思义，&lt;type_traits&gt;头文件定义了一些工具类模板，用来提取某个类型（type）在某方面的特点（trait）。它可以实现在编译期的判断、转换、查询等功能，并且提供了编译期的true和false。比如上面提到的integral_constant类，就被定义在了type_traits中，它可以称作type_traits的基石。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// integral_constant</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, _Tp __v&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">integral_constant</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> _Tp                  value = __v;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp                           value_type;</span><br><span class="line">    <span class="keyword">typedef</span> integral_constant&lt;_Tp, __v&gt;   type;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">operator</span> <span class="title">value_type</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus &gt; 201103L</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __cpp_lib_integral_constant_callable 201304</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> value_type <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, _Tp __v&gt;</span><br><span class="line"><span class="keyword">constexpr</span> _Tp integral_constant&lt;_Tp, __v&gt;::value;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::integral_constant&lt;</span><br><span class="line">  <span class="type">bool</span>, <span class="literal">true</span>&gt; true_type;</span><br><span class="line"><span class="keyword">typedef</span> std::integral_constant&lt;</span><br><span class="line">  <span class="type">bool</span>, <span class="literal">false</span>&gt; false_type;</span><br></pre></td></tr></table></figure>
<p>为方便使用，type_traits还针对布尔值有两个额外的类型定义。于是调用<code>std::true_type::value</code>可以得到<code>true</code></p>
<p>type_traits头文件中凡是带前缀<code>is_*</code>类的偏特化或特化均继承自<code>true_type</code>和<code>false_type</code>，比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__is_pointer_helper</span> : \</span><br><span class="line">  <span class="keyword">public</span> false_type &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__is_pointer_helper</span> &lt;_Tp*&gt; : \</span><br><span class="line">  <span class="keyword">public</span> true_type &#123; &#125;;</span><br></pre></td></tr></table></figure>
<p>而这些<code>is_*</code>前缀的便是<strong>用来标注某类型是否有某特点</strong>的模板元。比如<code>is_trivially_destructible</code>模板可用于判断类是否可平凡析构（即，不调用析构函数，不会造成任何资源泄露问题）。模板返回的要么是<code>true_type</code>要么是<code>false_type</code>。使用operator()重载或::value都可以得到背后的true或false。因此，可以在删除某对象前，用它来判断是否需要析构函数，这样在优化编译时，编译器可以把不需要的析构操作全部删除。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeContainer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(T* ptr)</span></span>&#123;</span><br><span class="line">    _destroy(ptr, <span class="built_in">is_trivially_destructible</span>&lt;T&gt;());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">void</span> _destroy(T* ptr, true_type) &#123;&#125;</span><br><span class="line">  <span class="type">static</span> <span class="type">void</span> _destroy(T* ptr, false_type) &#123;</span><br><span class="line">    ptr-&gt;~<span class="built_in">T</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的代码便是很多容器类都会有的destroy函数，通过<code>is_trivially_destructible</code>来最大程度优化。类似的<code>is_*</code>还有：（具体可查看cppreference官网）</p>
<p><code>is_void, is_null_pointer, is_integral, is_class, is_function, is_pointer, is_lvalue_reference, is_rvalue_reference, is_const, is_move_constructble, is_copy_constructible, has_virtual_destructor</code>等等</p>
<hr />
<p>同时，type_traits还可以做类型转换，以<code>std::remove_const</code>为例，来去除类型里的const修饰。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">remove_const</span> &#123;</span><br><span class="line">  <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">remove_const</span>&lt;<span class="type">const</span> T&gt;&#123;</span><br><span class="line">  <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remove_const&lt;<span class="type">const</span> string&gt;::type str;<span class="comment">//string类型</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌如果对const char* 应用remove_const的话，结果还是const char <em>。因为const char</em> 是指向const chat的指针，而不是指向char的const指针。如果对char * const应用remove_const的话，可得到char*</p>
</blockquote>
<p>&lt;type_traits&gt;中类似的类型转换元还有：（具体可查看cppreference官网）</p>
<p><code>remove_cv</code>（同时去除const和volatile）、<code>remove_volatile</code>、<code>remove_pointer</code>、<code>add_const</code>、<code>remove_extent</code>、<code>make_signed</code>等等。</p>
<p>C<ins>14和C</ins>17还针对&lt;type_traits&gt;提供了一些简易写法，比如写<code>is_trivially_destructible&lt;T&gt;::value</code>和<code>is_trivially_destructible&lt;T&gt;::type</code>会比较啰嗦，那么可以简化写成_v（C<ins>17）和_t（C</ins>14）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="type">bool</span></span><br><span class="line">  is_trivially_destructible_v =</span><br><span class="line">    is_trivially_destructible&lt;</span><br><span class="line">      T&gt;::value;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">remove_const_t</span> =</span><br><span class="line">  <span class="keyword">typename</span> remove_const&lt;T&gt;::type;</span><br></pre></td></tr></table></figure>
<p>类型转换模板元中，最重要的模板元是<code>std::decay</code>，decay可以对于普通类型移除引用和cv符（const和volatile）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::decay&lt;<span class="type">int</span>&gt;::type Normal;      <span class="comment">//int</span></span><br><span class="line"><span class="keyword">typedef</span> std::decay&lt;<span class="type">int</span>&amp;&gt;::type Ref;        <span class="comment">//int</span></span><br><span class="line"><span class="keyword">typedef</span> std::decay&lt;<span class="type">int</span>&amp;&amp;&gt;::type RefRef;    <span class="comment">//int</span></span><br><span class="line"><span class="keyword">typedef</span> std::decay&lt;<span class="type">const</span> <span class="type">int</span>&amp;&gt;::type cnst; <span class="comment">//int</span></span><br><span class="line"><span class="keyword">typedef</span> std::decay&lt;<span class="type">int</span>[<span class="number">2</span>]&gt;::type Array;    <span class="comment">//int*，数组类型变成指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----decay一般会和decltype搭配-----*/</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">typedef</span> std::decay&lt;<span class="keyword">decltype</span>(arr)&gt;::type myArray;</span><br></pre></td></tr></table></figure>
<p>decay比较常用的一点在于其可以方便地获得函数指针，即其可以实现从函数对象提取出函数指针类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add_2</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add_3</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(add_2)&gt; add_ptr = add_3;   <span class="comment">//add_ptr是函数指针</span></span><br><span class="line"><span class="keyword">decltype</span>&lt;add_2&gt; * add_func = add2_3;             <span class="comment">//直接使用decltype推断不出函数指针</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">add_ptr</span>(<span class="number">7</span>) &lt;&lt; endl;                      <span class="comment">//10</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">add_func</span>(<span class="number">7</span>) &lt;&lt; endl;                     <span class="comment">//10</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>decay本意就是退化，移除引用和cv，从函数对象到函数指针，都可以看做是一种退化行为。</p>
</blockquote>
<p>但是需要注意，decay_t&lt;decltype&lt;func&gt;&gt;和decay_t&lt;decltype&lt;func()&gt;&gt;是不同的，看上去后者只是加了一个括号。但是后者是将func的返回类型退化，而前者是与func一致入参返回值的函数指针。比如下面的例子，进行map-reduce中的map操作，就是进行返回类型退化decay_t&lt;decltype&lt;func()&gt;&gt;。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>&gt;<span class="keyword">class</span> <span class="title class_">OutContainer</span> = vector, <span class="keyword">typename</span> F, <span class="keyword">class</span> R&gt;</span><br><span class="line">        <span class="keyword">auto</span> <span class="built_in">fmap</span>(F&amp;&amp; f, R&amp;&amp; inputs)&#123;</span><br><span class="line">            <span class="keyword">typedef</span> <span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(<span class="built_in">f</span>(*inputs.<span class="built_in">begin</span>()))&gt; result_type;</span><br><span class="line">            OutContainer&lt;result_type, allocator&lt;result_type&gt;&gt; result;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; item : inputs)&#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(<span class="built_in">f</span>(item));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> add_1 = [](<span class="type">int</span> x)&#123;</span><br><span class="line">        <span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> result = <span class="built_in">fmap</span>(add_1, v);   <span class="comment">//v变成：2,3,4,5,6</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<p>其他的&lt;type_traits&gt;中常用模板元有：<code>std::conditional, std::enable_if, std::void_t</code>等。</p>
<ul>
<li>
<p><code>std::conditional</code>：在编译期根据一个判断式选择两个类型中的一个，类似三元表达式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> B, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">F</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">conditional</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> std::conditional&lt;<span class="literal">true</span>, <span class="type">int</span>, <span class="type">char</span>&gt;::type A;</span><br><span class="line">  <span class="keyword">typedef</span> std::conditional&lt;<span class="literal">false</span>, <span class="type">int</span>, <span class="type">char</span>&gt;::type B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>type_traits最常用的<code>std::enable_if</code>会在下一小节阐述。</p>
</li>
</ul>
<hr />
<h4 id="重载歧义消除traits"><a class="markdownIt-Anchor" href="#重载歧义消除traits"></a> 重载歧义消除（traits）</h4>
<p>多个同名函数做重载时，偶尔会发生歧义的情况。即调用函数时的参数，同时满足两个及以上的重载函数，那么编译器无从选择，就会出现编译报错。因此需要歧义消除机制，有两种常用方案，SFINAE和type_traits。</p>
<blockquote>
<p>SFINAE其实是C++中的一种机制，即“如果模板实例化发生了失败，没有理由让编译就此出错终止，因为还可能有其他可用的函数重载”，标准库通过这种机制提出了歧义消除的解决方案。</p>
</blockquote>
<ul>
<li>
<p>SFINAE（Substitution Failure Is Not An Error）</p>
<p>考虑要实现一个Buffer类，希望在Buffer中添加元素，可以有三种形式：</p>
<ul>
<li>
<p>第一种重载：传入一个字符，和一个size_t，向Buffer中添加n个相同的c</p>
</li>
<li>
<p>第二种重载：直接传入一个字符串，并传入字符串大小</p>
</li>
<li>
<p>第三种重载：STL风格添加，即可以<code>buf.append(str.begin(), str.end());</code>和<code>buf.append(str.rbegin(),str.rend());</code>，需要注意前者的参数类型是string::iterator，后者的参数类型是string::reverse_iterator。想用一个函数接受两类迭代器，需要用到模板。</p>
</li>
</ul>
<p>因此，Buffer类可以设计成下面的形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">char</span> c, <span class="type">size_t</span> n = <span class="number">1</span>)</span></span>;    <span class="comment">//第一种重载</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> n)</span></span>; <span class="comment">//第二种重载</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iter&gt;</span></span><br><span class="line"><span class="function">  <span class="type">void</span> <span class="title">append</span><span class="params">(Iter bp, Iter ep)</span></span>;        <span class="comment">//第三种重载</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Buffer buf;</span><br><span class="line"></span><br><span class="line">  buf.<span class="built_in">append</span>(<span class="string">&#x27;a&#x27;</span>);                     <span class="comment">//[1]</span></span><br><span class="line">  buf.<span class="built_in">append</span>(<span class="string">&#x27;b&#x27;</span>,<span class="number">10</span>);                  <span class="comment">//[1]</span></span><br><span class="line"></span><br><span class="line">  <span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">  buf.<span class="built_in">append</span>(str.<span class="built_in">data</span>(), str.<span class="built_in">size</span>());  <span class="comment">//[2]</span></span><br><span class="line"></span><br><span class="line">  buf.<span class="built_in">append</span>(str.<span class="built_in">rbegin</span>(), str.<span class="built_in">rend</span>());<span class="comment">//[3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样的写法是有错误的，考虑下面的情况</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  Buffer buf;</span><br><span class="line">  buf.<span class="built_in">append</span>(ch, <span class="number">10</span>);  <span class="comment">//int,int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法下，按理说是想用第一种重载方式，然而由于两个类型都是int，所以会调用原本为迭代器设计的模板重载，即调用了第三种方式的重载，那么就会导致运行时的错误。</p>
<p>SFINAE可用于解决这种问题，它的思路是<strong>对模板参数T的类型加以限制</strong>，从而避免所有情况下模板都能精准匹配。</p>
<p>SFINAE的关键在于std::enable_if。<code>std::enable_if&lt;BOOL,??&gt;::type</code>的使用方式：第一个模板参数接收一个bool类型，第二个模板参数接收一个任意类型，当前面的bool条件为true时，enable_if的成员变量type就会是第二个模板参数??的类型。而enable_if&lt;BOOL,void&gt;默认第二个模板参数是void。bool条件为false时，表达式解析失败，即不会编译false对应的内容。</p>
<p>用SFINAE，规避Iter为int类型：</p>
<ul>
<li>
<p>写法：(可以写的形式有很多，跟这种写法都是一个思想)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">char</span> c, <span class="type">size_t</span> n = <span class="number">1</span>)</span></span>;    <span class="comment">//第一种重载</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> n)</span></span>; <span class="comment">//第二种重载</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> = </span><br><span class="line">      std::enable_if&lt;!std::is_integral&lt;Iter&gt;::value&gt;::type&gt;</span><br><span class="line">  <span class="type">void</span> <span class="built_in">append</span>(Iter bp, Iter ep);        <span class="comment">//第三种重载</span></span><br><span class="line">  <span class="comment">//当非整数时就相当于template&lt;typename Iter, typename = void&gt; void append(...)</span></span><br><span class="line">  <span class="comment">//整数时就会解析失败，SFINAE机制此时会选择其他函数重载</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>上面的写法是针对函数重载歧义消除时的enable_if用法，事实上enable_if还可以有别的用法：</p>
<ol>
<li>
<p>模板偏特化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Enable=<span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> check;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">check</span>&lt;T, <span class="keyword">typename</span> std::enable_if&lt;T::value&gt;::type&gt; &#123;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = T::value;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>check只选择<code>value==true</code>的T，否则就报编译错误（因为没有其他重载的定义了）。</p>
<blockquote>
<p>📌只有类模板是可以偏特化的，函数模板不可以偏特化。</p>
</blockquote>
</li>
<li>
<p>控制函数返回类型：典型的例子就是C++的tuple中，获取k个元素的get方法的实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;std::<span class="type">size_t</span> k, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span>... Ts&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;k==<span class="number">0</span>, <span class="keyword">typename</span> element_type_holder&lt;<span class="number">0</span>, T, Ts...&gt;::type&amp;&gt;::type</span><br><span class="line"><span class="built_in">get</span>(tuple&lt;T, Ts...&gt; &amp;t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t.tail; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::<span class="type">size_t</span> k, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span>... Ts&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;k!=<span class="number">0</span>, <span class="keyword">typename</span> element_type_holder&lt;k, T, Ts...&gt;::type&amp;&gt;::type</span><br><span class="line"><span class="built_in">get</span>(tuple&lt;T, Ts...&gt; &amp;t) &#123;</span><br><span class="line">  tuple&lt;Ts...&gt; &amp;base = t;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">get</span>&lt;k<span class="number">-1</span>&gt;(base); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过enable_if可以根据不同k的值选择调用哪个get，实现函数模板的多态。这个例子也体现了“编译时计算”思想。进行了一个编译期的递归。</p>
</li>
<li>
<p>在进行歧义消除的同时，控制返回类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_integral&lt;T&gt;::value, <span class="type">bool</span>&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">is_odd</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">bool</span>(t % <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>除了利用enable_if关键字和SFINAE机制，还有另一种更有效的歧义消除方案。</p>
<ul>
<li>
<p>添加参数（标签分发，tag dispatch）</p>
<p>现在希望实现一个to_string函数，把数值（整数、浮点数）转换为标准库string类型变量，可以先这么写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">long</span> <span class="type">long</span> value)</span></span>&#123;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">64</span>];</span><br><span class="line">  <span class="type">int</span> len = <span class="built_in">sprintf</span>(str, <span class="string">&quot;%lld&quot;</span>, value);</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">string</span>(str, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> value)</span></span>&#123;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">64</span>];</span><br><span class="line">  <span class="type">int</span> len = <span class="built_in">sprintf</span>(str, <span class="string">&quot;%llu&quot;</span>, value);</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">string</span>(str, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">long</span> <span class="type">double</span> value)</span></span>&#123;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">64</span>];</span><br><span class="line">  <span class="type">int</span> len = <span class="built_in">sprintf</span>(str, <span class="string">&quot;%Lg&quot;</span>, value);</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">string</span>(str, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  std::string str;</span><br><span class="line"></span><br><span class="line">  str = <span class="built_in">to_string</span>(<span class="number">1234</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str = %s\n&quot;</span>, str.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">  str = <span class="built_in">to_string</span>(<span class="number">-1234</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str = %s\n&quot;</span>, str.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">  str = <span class="built_in">to_string</span>(<span class="number">56.789</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str = %s\n&quot;</span>, str.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此代码考虑了long long 类型整数和非负整数，以及double浮点类型。然而，<strong>编译会报错</strong>。因为传1234这个字面量时，1234会作为一个整数变量进入函数栈，然而重载的函数中没一个是精确匹配int类型的，因此编译器会找类型提升，即隐式转换。然而，int对于long long , unsigned long long, long double都存在隐式转换，由此产生歧义，编译器不知道该选择哪个函数重载，所以会有编译报错。</p>
<ul>
<li>
<p>解决方案一：把所有类型的参数，都写一遍，即列举所有可能的函数重载</p>
<p>缺点：写太多了，费时费力</p>
</li>
<li>
<p>解决方案二：用SFINAE</p>
<p>缺点：当前的重载主要判断两个条件，一个是“参数是否为整数”，另一个是“参数是否为有符号数”。当重载的判断条件大于等于2时，使用SFINAE会将代码写得较乱，难以维护和拓展。</p>
</li>
<li>
<p><strong>解决方案三</strong>：添加参数，确保所有情况都有重载可以匹配，而且至多有一个匹配。</p>
<p>实现方式类似于，<strong>通过函数参数，实现if语句</strong>。当前函数重载主要判断两个条件：参数是否为整数，参数是否为有符号数。因为浮点数不存在有无符号的问题，所以类型总共可以分为三个分支：</p>
<ol>
<li>
<p>整数，有符号数</p>
</li>
<li>
<p>整数，无符号数</p>
</li>
<li>
<p>浮点数</p>
</li>
</ol>
<p>因此，可以加上模板，利用std::is_integral&lt;T&gt;判断参数类型是否为整数，利用std::is_signed&lt;T&gt;判断类型是否为有符号数。</p>
<p>is_integral&lt;T&gt;事实上是C<ins>标准库中的一个类，继承自integral_constant&lt;bool, true&gt;，该基类是一个bool类型常量。而bool类型在C</ins>标准库中存在两个别名，分别对应true和false：<code>std::true_type</code>和<code>std::false_type</code>，因此可以将函数重载调整为以下代码，即利用重载实现对类型和符号的if判断。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span> <span class="comment">//is_integral, is_signed都归属于type_traits头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//既是整数，又是有符号数的情况</span></span><br><span class="line"><span class="function">std::string <span class="title">do_to_string</span><span class="params">(std::true_type,   <span class="comment">//integral</span></span></span></span><br><span class="line"><span class="params"><span class="function">                         std::true_type,   <span class="comment">//signed</span></span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">long</span> <span class="type">long</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">64</span>];</span><br><span class="line">  <span class="type">int</span> len = <span class="built_in">sprintf</span>(str, <span class="string">&quot;%lld&quot;</span>, value);</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">string</span>(str, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是整数，但不是有符号数的情况</span></span><br><span class="line"><span class="function">std::string <span class="title">do_to_string</span><span class="params">(std::true_type,   <span class="comment">//integral</span></span></span></span><br><span class="line"><span class="params"><span class="function">                         std::false_type,   <span class="comment">//!signed</span></span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">64</span>];</span><br><span class="line">  <span class="type">int</span> len = <span class="built_in">sprintf</span>(str, <span class="string">&quot;%llu&quot;</span>, value);</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">string</span>(str, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不是整数，但是是有符号数</span></span><br><span class="line"><span class="function">std::string <span class="title">do_to_string</span><span class="params">(std::false_type,  <span class="comment">//!integral</span></span></span></span><br><span class="line"><span class="params"><span class="function">                         std::true_type,   <span class="comment">//signed</span></span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">long</span> <span class="type">double</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">64</span>];</span><br><span class="line">  <span class="type">int</span> len = <span class="built_in">sprintf</span>(str, <span class="string">&quot;%Lg&quot;</span>, value);</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">string</span>(str, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">const</span> T&amp; t)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">do_to_string</span>(std::<span class="built_in">is_integral</span>&lt;T&gt;(),</span><br><span class="line">                      std::<span class="built_in">is_signed</span>&lt;T&gt;(),</span><br><span class="line">                      t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="declval"><a class="markdownIt-Anchor" href="#declval"></a> declval</h4>
<p>declval是C++11引入的一种<strong>函数模板</strong>，其作用在于为一些类型返回它的右值引用类型。官方代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>,</span><br><span class="line">    <span class="keyword">class</span> = <span class="type">void</span>&gt;</span><br><span class="line">    <span class="keyword">struct</span> _Add_reference</span><br><span class="line">    &#123;   <span class="comment">// add reference</span></span><br><span class="line">    <span class="keyword">using</span> _Lvalue = _Ty;</span><br><span class="line">    <span class="keyword">using</span> _Rvalue = _Ty;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">add_rvalue_reference</span></span><br><span class="line">    &#123;   <span class="comment">// add rvalue reference</span></span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> _Add_reference&lt;_Ty&gt;::_Rvalue;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line">    <span class="keyword">using</span> <span class="type">add_rvalue_reference_t</span> = <span class="keyword">typename</span> _Add_reference&lt;_Ty&gt;::_Rvalue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// FUNCTION TEMPLATE declval</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> _Ty&gt;</span></span><br><span class="line"><span class="function">    <span class="type">add_rvalue_reference_t</span>&lt;_Ty&gt; <span class="title">declval</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>
<p>std::declval&lt;T&gt;，传入的T为int时返回int&amp;&amp;，T为int&amp;时返回int&amp;（引用折叠），T为int&amp;&amp;时返回int&amp;&amp;。declval返回右值引用的操作均在编译期完成，不管T类型是否有public的默认构造函数，都能造出右值引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> YT = <span class="keyword">decltype</span>(std::<span class="built_in">declval</span>&lt;A&gt;());<span class="comment">//不要丢到declval&lt;A&gt;() 后的括号，因为是函数，否则代码含义发生变化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;YT = &quot;</span> &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;YT&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; endl;<span class="comment">//显示YT类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：YT = class A &amp;&amp;</span></span><br></pre></td></tr></table></figure>
<p>declval和decltype经常配合在一块，用于进行函数指针、成员方法返回类型的推导。</p>
<ul>
<li><strong>成员方法返回值类型推导</strong>：</li>
</ul>
<p>传统方案：必须构造对象，才能用decltype</p>
<blockquote>
<p>📌decltype()中出现的是 变量、对象、表达式、函数名、函数指针等，而不可以出现类型名</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//想获得普通函数 myfunc的返回值类型</span></span><br><span class="line">    <span class="function">A <span class="title">myobj</span><span class="params">(<span class="number">1</span>)</span></span>;<span class="comment">//创建对象</span></span><br><span class="line">    <span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;返回值类型:= &quot;</span> &lt;&lt;</span><br><span class="line">    <span class="built_in">type_id_with_cvr</span>&lt;</span><br><span class="line">    <span class="keyword">decltype</span>(myobj.<span class="built_in">myfunc</span>())&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">     &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现代方法：decltype配合declval，无需创建对象</p>
<blockquote>
<p>📌declval()获得右值引用，可以“骗过”编译器，相当于创建了一个假的对象，从而直接使用该类型的成员函数</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;返回值类型:= &quot;</span> &lt;&lt;</span><br><span class="line">    type_id_with_cvr&lt;</span><br><span class="line">    <span class="keyword">decltype</span>(std::<span class="built_in">declval</span>&lt;A&gt;().<span class="built_in">myfunc</span>())&gt;()</span><br><span class="line">    .<span class="built_in">pretty_name</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>函数指针推导</strong>：刚刚的成员方法返回类型推导比较简单，考虑这样一种情况，函数模板内使用了一个函数指针，返回的就是函数指针的返回值。但是这个函数模板是通用的，也就是各种各样的函数指针它都能接收，那么这个时候返回值类型是不确定的，此时的函数模板该如何定义呢？</p>
<p>解决方案就是，推导函数指针的返回值类型，推导出的类型来作为函数模板的返回类型。</p>
<p>有两种方式实现这一思路，其中一个就是decltype搭配declval。</p>
</li>
</ul>
<p>方式一：decltype + declval</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">myfunc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T_F, <span class="keyword">typename</span>... U_Args&gt;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">declval</span>&lt;T_F&gt;()  (<span class="built_in">declval</span>&lt;U_Args&gt;()...))</span><br><span class="line"><span class="built_in">TestFnRtnTmp1</span>(T_F func, U_Args... args) &#123;</span><br><span class="line">    <span class="keyword">auto</span> rtnvalue = <span class="built_in">func</span>(args...);</span><br><span class="line">    <span class="keyword">return</span> rtnvalue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> result = <span class="built_in">TestFnRtnTmp1</span>(myfunc, <span class="number">5</span>, <span class="number">8</span>);</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方式二：尾置返回类型 + auto关键字</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">myfunc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T_F, <span class="keyword">typename</span>... U_Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">TestFnRtnTmp2</span><span class="params">(T_F func, U_Args... args)</span></span></span><br><span class="line"><span class="function"> -&gt; <span class="title">decltype</span><span class="params">(func(args...))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> rtnvalue = <span class="built_in">func</span>(args...);</span><br><span class="line">    <span class="keyword">return</span> rtnvalue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> result = <span class="built_in">TestFnRtnTmp2</span>(myfunc, <span class="number">5</span>, <span class="number">8</span>);</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处主要解释方式一。<code>declval&lt;T_F&gt;()</code>：T_F是函数指针<code>int(*)(int, int)</code>类型，那么在编译期declval可以推断出其是函数指针并返回<code>int(*&amp;&amp;)(int,int)</code>，即函数指针的右值类型，相当于实例化了一个假的函数指针对象，可以输入参数。所以在<code>decltype(函数指针右值引用())</code>，就可以得到返回值类型。也就是</p>
<p><code>decltype(declval&lt;T_F&gt;() (declval&lt;U_Args&gt;()...))</code></p>
<p>而直接用<code>decltype(T_F(U_Args)...)</code>是不行的，会报错，因为decltype()只能接收实例，不能接收类型。</p>
<h2 id="正则表达式"><a class="markdownIt-Anchor" href="#正则表达式"></a> 正则表达式</h2>
<h3 id="string类型"><a class="markdownIt-Anchor" href="#string类型"></a> string类型</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用加号+进行字符串拼接</span></span><br><span class="line"><span class="function">string <span class="title">compose</span><span class="params">(<span class="type">const</span> string&amp;name, <span class="type">const</span> string&amp; domain)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> name + <span class="string">&#x27;@&#x27;</span> + domain;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//常用操作</span></span><br><span class="line">string name = <span class="string">&quot;Niels Stroustrup&quot;</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">m3</span>()&#123;</span><br><span class="line">  string s = name.<span class="built_in">substr</span>(<span class="number">6</span>,<span class="number">10</span>);   <span class="comment">//s=&quot;Stroustrup&quot;                   取子串，从索引6开始的10个字符</span></span><br><span class="line">  name.<span class="built_in">replace</span>(<span class="number">0</span>,<span class="number">5</span>,<span class="string">&quot;nicholas&quot;</span>);   <span class="comment">//name变为&quot;nicholas Stroustrup&quot;     替换，从索引0开始的5个字符</span></span><br><span class="line">  name[<span class="number">0</span>] = <span class="built_in">toupper</span>(name[<span class="number">0</span>]);     <span class="comment">//name变为&quot;Nicholas Stroustrup&quot;     大写</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//string与字符串字面值的比较</span></span><br><span class="line">string incantation;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">respond</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(answer == incantation)&#123;</span><br><span class="line">    <span class="comment">//执行一些操作</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (answer == <span class="string">&quot;yes&quot;</span>)&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只读形式的C风格字符串</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">print</span>(<span class="type">const</span> string&amp; s)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;For people who like printf: %s\n&quot;</span>, s.<span class="built_in">c_str</span>());</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;For people who like streams: &quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌标准库string定义了一个移动构造函数，因此，即使是以传值方式而不是传引用方式返回一个很长的string也会很高效。</p>
</blockquote>
<p>string对象除了有begin()和end()之外，还有rbegin()，rend()。同时还有cbegin()，cend()，表示的是const iterator。相应的，crbegin()，crend()表示const reverse iterator。</p>
<ul>
<li>
<p>短字符串优化(short-string optimization)技术：</p>
<blockquote>
<p>短字符串直接保存在string对象内部，而长字符串则保存在自由存储区中。</p>
</blockquote>
<p>因此对于这样的两个字符串</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s1 &#123;<span class="string">&quot;Annemarie&quot;</span>&#125;;             <span class="comment">//短字符串</span></span><br><span class="line">string s2 &#123;<span class="string">&quot;Annemarie Stroustrup&quot;</span>&#125;;  <span class="comment">//长字符串</span></span><br></pre></td></tr></table></figure>
<p>s1对象内部直接存在该字符串，而s2对象内部仅存储该字符串的地址，需要用到时则根据地址取值。</p>
<p>之所以采用这种实现方式，是因为运行时环境中内存分配代价较高，而大量长度不一的字符串会产生堆的内存碎片。</p>
<p>短字符串优化可以让栈承担短字符串，加快运行，同时规避长度过于分散的状况。</p>
</li>
<li>
<p>basic_string：</p>
<p>C++标准库中定义了通用字符串模板<code>basic_string</code>，string实际上是此模板用char类型实例化的一个别名</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Char&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">basic_string</span>&#123;</span><br><span class="line">  <span class="comment">//...类的功能实现</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> string = basic_string&lt;<span class="type">char</span>&gt;;</span><br></pre></td></tr></table></figure>
<p>用户可以不局限于ascii码，利用basic_string定义任意字符类型的字符串。例如，我们有一个日文字符类型Jchar，则可以定义为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Jstring = basic_string&lt;Jchar&gt;;</span><br></pre></td></tr></table></figure>
<p>现在，就可以在Jstring——日文字符串上执行常见的字符串操作。</p>
</li>
<li>
<p>字符串转换函数</p>
<p>C函数atoi()、atol()面向的是C字符串，而不是C<ins>的string类型。C</ins>11增加了几个新的转换函数：</p>
<ul>
<li>
<p>stoi()、stol()、stoll()等把string转换成整数；</p>
</li>
<li>
<p>stof()、stod()等把string转换成浮点数；</p>
</li>
<li>
<p>to_string()把整数、浮点数转换成字符串。</p>
</li>
</ul>
</li>
</ul>
<h3 id="正则表达式的模式"><a class="markdownIt-Anchor" href="#正则表达式的模式"></a> 正则表达式的模式</h3>
<ul>
<li>
<p>正则表达式的特殊字符</p>
<table>
<thead>
<tr>
<th>.</th>
<th>任意单个字符（“通配符”）</th>
</tr>
</thead>
<tbody>
<tr>
<td>[</td>
<td>字符集开始</td>
</tr>
<tr>
<td>]</td>
<td>字符集结束</td>
</tr>
<tr>
<td>{</td>
<td>指定重复次数开始</td>
</tr>
<tr>
<td>}</td>
<td>指定重复次数结束</td>
</tr>
<tr>
<td>(</td>
<td>分组开始</td>
</tr>
<tr>
<td>)</td>
<td>分组结束</td>
</tr>
<tr>
<td>\</td>
<td>下一个字符有特殊含义</td>
</tr>
<tr>
<td>*</td>
<td>零或多次重复（后缀操作）</td>
</tr>
<tr>
<td>+</td>
<td>一或多次重复（后缀操作）</td>
</tr>
<tr>
<td>?</td>
<td>零或一次（后缀操作）</td>
</tr>
<tr>
<td>|</td>
<td>或</td>
</tr>
<tr>
<td>^</td>
<td>行开始；非</td>
</tr>
<tr>
<td>$</td>
<td>行结束</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>重复</p>
<table>
<thead>
<tr>
<th>{n}</th>
<th>严格重复n次</th>
</tr>
</thead>
<tbody>
<tr>
<td>{n,}</td>
<td>重复n次或更多次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>至少重复n次，最多m次</td>
</tr>
<tr>
<td>*</td>
<td>零次或多次，即{0,}</td>
</tr>
<tr>
<td>+</td>
<td>一次或多次，即{1,}</td>
</tr>
<tr>
<td>?</td>
<td>零次或一次，即{0,1}</td>
</tr>
</tbody>
</table>
<p>模式匹配在遇见重复字符串时，还涉及贪心匹配和懒惰匹配。</p>
<ul>
<li>
<p>贪心匹配：默认情况下就是贪心匹配</p>
<p>原字符串：ababab，现在用模式(ab)*来匹配，模式匹配器总是查找最长匹配，会匹配到整个字符串ababab</p>
</li>
<li>
<p>懒惰匹配：在任何重复符号（?、 *、+及{ }）之后放一个后缀?，会使模式匹配器进入懒惰状态。</p>
<p>原字符串：ababab，现在用模式(ab) *?来匹配，模式匹配器会查找最短匹配，匹配到字符串中第一个ab</p>
</li>
</ul>
</li>
<li>
<p>字符集与字符集简写</p>
<p>正则表达式中，字符集必须用[: :]包围起来。例如[:digit:]匹配一个十进制数字。同时，如果是定义一个字符集，外边必须再包围一对方括号[ ]，比如，[^[:digit:]]匹配一个非十进制数字。</p>
<table>
<thead>
<tr>
<th>字符集</th>
<th>简写</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>alnum</td>
<td></td>
<td>任意字符数字字符</td>
</tr>
<tr>
<td>alpha</td>
<td></td>
<td>任意字母</td>
</tr>
<tr>
<td>blank</td>
<td></td>
<td>任意空白符，但不能是行分隔符</td>
</tr>
<tr>
<td>cntrl</td>
<td></td>
<td>任意控制字符</td>
</tr>
<tr>
<td>d</td>
<td>\d=[[:d:]]</td>
<td>任意十进制数字</td>
</tr>
<tr>
<td>digit</td>
<td>\d=[[:digit:]], \D=[^[:digit:]]非十进制数字</td>
<td>任意十进制数字</td>
</tr>
<tr>
<td>graph</td>
<td></td>
<td>任意图形字符</td>
</tr>
<tr>
<td>lower</td>
<td>\l=[[:lower:]]，\L=[^[:lower:]]非大写字符，均非标准但常见</td>
<td>任意小写字符</td>
</tr>
<tr>
<td>print</td>
<td></td>
<td>任意可打印字符</td>
</tr>
<tr>
<td>punct</td>
<td></td>
<td>任意标点</td>
</tr>
<tr>
<td>s</td>
<td>\s=[[😒:]]</td>
<td>任意空白符（空格、制表符等等）</td>
</tr>
<tr>
<td>space</td>
<td>\s=[[:space:]], \S=[^[:space:]]非空白符</td>
<td>任意空白符</td>
</tr>
<tr>
<td>upper</td>
<td>\u=[[:upper:]]，\U=[^[:upper:]]非大写字符，均非标准但常见</td>
<td>任意大写字符</td>
</tr>
<tr>
<td>w</td>
<td>\w=[[:w:]]，</td>
<td>任意单词字符（字母、数字字符再加下划线）</td>
</tr>
<tr>
<td>xdigit</td>
<td></td>
<td>任意十六进制数字字符</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>正则表达式分组</p>
<p>( )引发了分组的概念，也就是正则表达式中被( )包起来的内容构成了一个group，匹配时作为一个子模式匹配。</p>
<p>比如想匹配XML语言，模式可以设计为<code>&lt;(.*?)&gt;(.*?)&lt;/\1&gt;</code>，这里有三个分组，其中\1是第三个，含义为“与分组1一样”。而且使用了懒惰匹配<code>.*?</code>，这样，当面临下面的输入：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Always look for the &lt;b&gt;bright&lt;/b&gt; side of &lt;b&gt;life&lt;/b&gt;.</span><br></pre></td></tr></table></figure>
<p>不使用 <em>?，而是单独</em>的话，贪心匹配会将第一个&lt;和最后一个&gt;配对。</p>
<p>但懒惰匹配的结果将是&lt;b&gt;bright&lt;/b&gt;和&lt;b&gt;life&lt;/b&gt;这两个符合程序员预期的结果。</p>
<p>然而，如果<strong>想要括号，但是不需要完全匹配到括号中的内容</strong>，可以用<code>(?</code></p>
<ul>
<li>
<p>(?:pattern)：匹配pattern但不获取结果，即非获取匹配。例如“industr(?:y|ies)”可以用来替代&quot;industry|industries&quot;。</p>
</li>
<li>
<p>(?=pattern)：正向肯定预查，例如&quot;Windows(?=95|98|NT|2000)&quot;能匹配&quot;Windows2000&quot;中的Windows，但不能匹配&quot;Windows3.1&quot;中的Windows。</p>
</li>
<li>
<p>(?!pattern)：正向否定预查，例如&quot;Windows(?!95|98|NT|2000)&quot;能匹配&quot;Windows3.1&quot;中的Windows，但不能匹配&quot;Windows2000&quot;中的Windows。</p>
</li>
<li>
<p>(?&lt;=pattern)：反向肯定预查，与正向肯定预查类似，但方向相反，例如“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”</p>
</li>
<li>
<p>(?&lt;!pattern)：反向否定预查，与正向否定预查类似，但方向相反，例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”</p>
</li>
</ul>
</li>
</ul>
<h3 id="c中的正则api"><a class="markdownIt-Anchor" href="#c中的正则api"></a> C++中的正则API</h3>
<p>标准库提供了&lt;regex&gt;类，从而支持正则表达式。比如可以用下面代码定义一个正则表达式模式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">regex <span class="title">pat</span> <span class="params">(<span class="string">R&quot;(\w&#123;2&#125;\s*\d&#123;5&#125;(-\d&#123;4&#125;)?)&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>上面代码定义了一个美国邮政编码模式：XXddddd-dddd。其中后面的-dddd是可有可无的。以两个字母开始<code>\w&#123;2&#125;</code>，后面是任意个空白符<code>\s*</code>，再接下来是5个数字<code>\d&#123;5&#125;</code>，然后是可选的破折号加四位数字<code>-\d&#123;4&#125;</code>。</p>
<ul>
<li>
<p>常用正则匹配函数</p>
<ul>
<li>
<p>regex_match( )：将正则表达式与一个（已知长度的）字符串进行匹配，判断是否完全匹配。如果完全匹配则返回true，否则false。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;twinkle1993&quot;</span>;</span><br><span class="line"><span class="function">regex <span class="title">r</span><span class="params">(<span class="string">&quot;[a-z0-9]+&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> is_match = <span class="built_in">regex_match</span>(str, r); <span class="comment">//true</span></span><br><span class="line">is_match = <span class="built_in">regex_match</span>(str.<span class="built_in">begin</span>()+<span class="number">7</span>, str.<span class="built_in">end</span>(), <span class="built_in">regex</span>(<span class="string">&quot;\\d+&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">smatch sm;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">regex_match</span>(str.<span class="built_in">cbegin</span>()+<span class="number">5</span>, str.<span class="built_in">cend</span>(), sm, <span class="built_in">regex</span>(<span class="string">&quot;([a-z]+)(\\d+)&quot;</span>)))</span><br><span class="line">&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;字符串: &quot;</span> &lt;&lt; &amp;str[<span class="number">5</span>] &lt;&lt; <span class="string">&quot; 匹配成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;匹配字符串个数: &quot;</span> &lt;&lt; sm.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;分别为: &quot;</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> aa : sm)</span><br><span class="line">    cout &lt;&lt; aa.<span class="built_in">str</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  cout &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出结果：</span></span><br><span class="line"><span class="comment">    字符串: le1993匹配成功</span></span><br><span class="line"><span class="comment">    匹配字符串个数：3</span></span><br><span class="line"><span class="comment">    分别为：le1993 le 1993</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">cmatch cm;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">regex_match</span>(str.<span class="built_in">c_str</span>(), cm, <span class="built_in">regex</span>(<span class="string">&quot;([a-z]+)(\\d+)&quot;</span>))) </span><br><span class="line">&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;字符串：&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot; 匹配成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;匹配字符串个数：&quot;</span> &lt;&lt; cm.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;分别为：&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> aa : cm)</span><br><span class="line">    cout &lt;&lt; aa.<span class="built_in">str</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出结果：</span></span><br><span class="line"><span class="comment">    字符串：twinkle1993 匹配成功！</span></span><br><span class="line"><span class="comment">    匹配字符串个数：3</span></span><br><span class="line"><span class="comment">    分别为：twinkle1993 twinkle 1993</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>其中，smatch相当于vector&lt;string&gt;，其中存储所有匹配的结果。而cmatch则是C风格的smatch。</p>
<p>sm中的第一个元素sm[0]，是贪心的最长匹配（即输入字符串），之后的则是字符串中依据正则表达式group的分组。</p>
<p>smatch对象除了有size()，能索引之外，还有两个比较重要的成员函数：</p>
<p><code>::prefix()</code>：用于获取输入目标字符串中，匹配字符串之前的字符串</p>
<p><code>::suffix()</code>：用于获取输入目标字符串中，匹配字符串之后的字符串</p>
</li>
<li>
<p>regex_search( )：在一个（任意长）数据流中搜索与正则表达式匹配的字符串</p>
<p>匹配到一个子字符串即返回。sm中第一个元素sm[0]，是匹配到的子字符串，之后的元素则是子字符串中，依据正则表达式group的分组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  string str = <span class="string">&quot;twinkle1993winkle1993inkle1993&quot;</span>;</span><br><span class="line">  smatch sm;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = str.<span class="built_in">cbegin</span>(); <span class="built_in">regex_search</span>(it, str.<span class="built_in">cend</span>(), sm, <span class="built_in">regex</span>(<span class="string">&quot;([a-z]+)1&quot;</span>)); it = sm.<span class="built_in">suffix</span>().first) </span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;字符串：&quot;</span> &lt;&lt; &amp;*it &lt;&lt; <span class="string">&quot; 匹配成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;匹配字符子串个数：&quot;</span> &lt;&lt; sm.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;分别为：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> aa : sm)</span><br><span class="line">      cout &lt;&lt; aa.<span class="built_in">str</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;字符串 &quot;</span> &lt;&lt; sm.<span class="built_in">str</span>() &lt;&lt; <span class="string">&quot; 前的字符串为：&quot;</span> &lt;&lt; sm.<span class="built_in">prefix</span>().<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;字符串 &quot;</span> &lt;&lt; sm.<span class="built_in">str</span>() &lt;&lt; <span class="string">&quot; 后的字符串为：&quot;</span> &lt;&lt; sm.<span class="built_in">suffix</span>().<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">字符串：twinkle1993winkle1993inkle1993 匹配成功！</span></span><br><span class="line"><span class="comment">匹配字符子串个数：2</span></span><br><span class="line"><span class="comment">分别为：twinkle1 twinkle</span></span><br><span class="line"><span class="comment">字符串 twinkle1 前的字符串为：</span></span><br><span class="line"><span class="comment">字符串 twinkle1 后的字符串为：993winkle1993inkle1993</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">字符串：993winkle1993inkle1993 匹配成功！</span></span><br><span class="line"><span class="comment">匹配字符子串个数：2</span></span><br><span class="line"><span class="comment">分别为：winkle1 winkle</span></span><br><span class="line"><span class="comment">字符串 winkle1 前的字符串为：993</span></span><br><span class="line"><span class="comment">字符串 winkle1 后的字符串为：993inkle1993</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">字符串：993inkle1993 匹配成功！</span></span><br><span class="line"><span class="comment">匹配字符子串个数：2</span></span><br><span class="line"><span class="comment">分别为：inkle1 inkle</span></span><br><span class="line"><span class="comment">字符串 inkle1 前的字符串为：993</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>当regex_search返回后，借助sm中的sm[0]].first和sm[0].second迭代器可以得到这个字符串在源字符串中出现的准确位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  string str = <span class="string">&quot;twinkle1993winkle1993inkle1993&quot;</span>;</span><br><span class="line">  smatch sm;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;正则表达式：([a-z]+)1&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = str.<span class="built_in">cbegin</span>(); <span class="built_in">regex_search</span>(it, str.<span class="built_in">cend</span>(), sm, <span class="built_in">regex</span>(<span class="string">&quot;([a-z]+)1&quot;</span>)); it = sm.<span class="built_in">suffix</span>().first) </span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;匹配字符子串：&quot;</span> &lt;&lt; sm[<span class="number">0</span>].<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;在源串对应索引：[&quot;</span> &lt;&lt; sm[<span class="number">0</span>].first-str.<span class="built_in">begin</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; sm[<span class="number">0</span>].second-str.<span class="built_in">begin</span>() &lt;&lt; <span class="string">&#x27;)&#x27;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">匹配字符子串：twinkle1</span></span><br><span class="line"><span class="comment">在源串对应索引：[0 8)</span></span><br><span class="line"><span class="comment">匹配字符子串：winkle1</span></span><br><span class="line"><span class="comment">在源串对应索引：[11 18)</span></span><br><span class="line"><span class="comment">匹配字符子串：inkle1</span></span><br><span class="line"><span class="comment">在源串对应索引：[21 27)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>regex_replace( )：在一个（任意长）数据流中搜索与正则表达式匹配的字符串并将其替换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> data[] = <span class="string">&quot;he...ll..o, worl..d!&quot;</span>;</span><br><span class="line"><span class="function">std::regex <span class="title">reg</span><span class="params">(<span class="string">&quot;\\.&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// output: hello, world!</span></span><br><span class="line">std::cout &lt;&lt; std::<span class="built_in">regex_replace</span>(data, reg, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> data[] = <span class="string">&quot;001-Neo,002-Lucia&quot;</span>;</span><br><span class="line"><span class="function">std::regex <span class="title">reg</span><span class="params">(<span class="string">&quot;(\\d+)-(\\w+)&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// output: 001 name=Neo,002 name=Lucia</span></span><br><span class="line">std::cout &lt;&lt; std::<span class="built_in">regex_replace</span>(data, reg, <span class="string">&quot;$1 name=$2&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>regex_iterator：遍历匹配结果和子匹配</p>
<p>上面的regex_search()函数可以让我们逐一迭代正则查找的所有匹配结果，而regex_iterator是达到相同目的的另一种方式。</p>
<p>regex_iterator不同于其它容器的迭代器，不需要.begin()，.end()来进行迭代。regex_iterator只有一个end值，只需要用默认的构造函数声明一个regex_iterator，就可以获得这个尾迭代器：尾迭代器会被隐式地初始化为end值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  string str = <span class="string">&quot;twinkle1993twink1993le1993&quot;</span>;</span><br><span class="line">  <span class="function">regex <span class="title">reg</span><span class="params">(<span class="string">&quot;([a-z]+)1&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (sregex_iterator <span class="built_in">it</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>(), reg), end; it != end; it++) </span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;匹配字符子串：&quot;</span> &lt;&lt; (*it)[<span class="number">0</span>].<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;在源串对应索引：[&quot;</span> &lt;&lt; (*it)[<span class="number">0</span>].first-str.<span class="built_in">begin</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; (*it)[<span class="number">0</span>].second-str.<span class="built_in">begin</span>() &lt;&lt; <span class="string">&#x27;)&#x27;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果：</span></span><br><span class="line"><span class="comment">    匹配字符子串：twinkle1</span></span><br><span class="line"><span class="comment">    在源串对应索引：[0 8)</span></span><br><span class="line"><span class="comment">    匹配字符子串：twink1</span></span><br><span class="line"><span class="comment">    在源串对应索引：[11 17)</span></span><br><span class="line"><span class="comment">    匹配字符子串：le1</span></span><br><span class="line"><span class="comment">    在源串对应索引：[20 23)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>regex_token_iterator：遍历未遍历部分</p>
<p>相比于regex_iterator，regex_token_iterator还可用于迭代正则表达式中的每个group。这里将这种正则中的子序列称为token。regex_token_iterator在有参数构造时比regex_iterator多一个参数，此参数用于指示要匹配哪个group。</p>
<ul>
<li>
<p>如果该参数为-1，表示感兴趣的是能够匹配正则表达式的子字符串之间的字符串。</p>
</li>
<li>
<p>如果该参数为0，表示还是要完整匹配整个正则表达式（该参数默认值为0，因此可以构造时不赋值）。</p>
</li>
<li>
<p>如果该参数为其它数字，则表示要匹配的是正则表达式中的第几个组，如1就是匹配第一个group。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  string str = <span class="string">&quot;11twinkle1993teink1992le1994&quot;</span>;</span><br><span class="line">  <span class="function">regex <span class="title">reg</span><span class="params">(<span class="string">&quot;([a-z]+)1&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (sregex_token_iterator <span class="built_in">it</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>(), reg), end; it != end; it++) <span class="comment">//default=0</span></span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;匹配到的字符串为：&quot;</span> &lt;&lt; it-&gt;<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (sregex_token_iterator <span class="built_in">it</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>(), reg, <span class="number">1</span>), end; it != end; it++) </span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;匹配到的字符串为：&quot;</span> &lt;&lt; it-&gt;<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (sregex_token_iterator <span class="built_in">it</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>(), reg, <span class="number">-1</span>), end; it != end; it++) </span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;匹配到的字符串为：&quot;</span> &lt;&lt; it-&gt;<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果：</span></span><br><span class="line"><span class="comment">    匹配到的字符串为：twinkle1</span></span><br><span class="line"><span class="comment">    匹配到的字符串为：teink1</span></span><br><span class="line"><span class="comment">    匹配到的字符串为：le1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    匹配到的字符串为：twinkle</span></span><br><span class="line"><span class="comment">    匹配到的字符串为：teink</span></span><br><span class="line"><span class="comment">    匹配到的字符串为：le</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    匹配到的字符串为：11</span></span><br><span class="line"><span class="comment">    匹配到的字符串为：993</span></span><br><span class="line"><span class="comment">    匹配到的字符串为：992</span></span><br><span class="line"><span class="comment">    匹配到的字符串为：994</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="io流"><a class="markdownIt-Anchor" href="#io流"></a> I/O流</h2>
<ul>
<li>
<p>ostream对象将有类型的对象转换为一个字符（字节）流</p>
<p>cout是ostream类的一个对象，ofstream，ostringstream均继承自ostream类型</p>
</li>
<li>
<p>istream对象将一个字符（字节）流转换为有类型的对象</p>
<p>cin是istream类的一个对象，ifstream，istringstream均继承自istream类型</p>
</li>
</ul>
<p>所以，ifstream, istringstream和cin的用法区别不大，ofstream，ostringstream和cout的用法也区别不大。</p>
<blockquote>
<p>📌IO对象是不能进行拷贝和赋值的。<br />
ofstream out1,ou2;<br />
out1 = out2;                        //错误：不能对流对象赋值<br />
ofstream print(ofstream);    //错误：不能初始化ofstream参数<br />
out2 = print(out2);              //错误：不能拷贝流对象<br />
由于不能拷贝IO对象，因此<strong>不能把函数参数和返回类型设置为流类型</strong>，通常以引用方式传递和返回。同时，读写一个IO对象会改变其状态，因此<strong>传递和返回的引用不能是const的</strong>。</p>
</blockquote>
<h3 id="cin-cout"><a class="markdownIt-Anchor" href="#cin-cout"></a> cin cout</h3>
<ul>
<li>
<p>cout标准输出流</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">7000</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;the value is &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cout也可以格式化输出</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">double</span> d = <span class="number">123.456</span>;</span><br><span class="line">cout &lt;&lt; d &lt;&lt; <span class="string">&quot;;&quot;</span>                     <span class="comment">//默认格式</span></span><br><span class="line">     &lt;&lt; scientific &lt;&lt; d &lt;&lt; <span class="string">&quot;;&quot;</span>       <span class="comment">//1.23e2，科学计数法风格</span></span><br><span class="line">     &lt;&lt; hexfloat &lt;&lt; d &lt;&lt; <span class="string">&quot;;&quot;</span>         <span class="comment">//十六进制</span></span><br><span class="line">     &lt;&lt; fixed &lt;&lt; d &lt;&lt; <span class="string">&quot;;&quot;</span>            <span class="comment">//定点数</span></span><br><span class="line">     &lt;&lt; defaultfloat &lt;&lt; d &lt;&lt; <span class="string">&quot;\n&quot;</span>;   <span class="comment">//默认float格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//想让浮点数截断输出，可以用precision()，会自动四舍五入</span></span><br><span class="line">cout.<span class="built_in">precision</span>(<span class="number">8</span>);<span class="comment">//一个数最多显示8个数字，如果整数部分超过8个，就仅保留整数</span></span><br><span class="line">cout &lt;&lt; <span class="number">1234.56789</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">123456</span> &lt;&lt; endl; <span class="comment">//输出结果：1234.5679 123456</span></span><br><span class="line"></span><br><span class="line">cout.<span class="built_in">precision</span>(<span class="number">8</span>);<span class="comment">//一个数最多显示8个数字，如果整数部分超过8个，就仅保留整数</span></span><br><span class="line">cout &lt;&lt; <span class="number">1234.56789</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">123456</span> &lt;&lt; endl; <span class="comment">//输出结果：1235 123456</span></span><br></pre></td></tr></table></figure>
<p>需要小心这样一种可能不符合预期的情况</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">k</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> b = <span class="string">&#x27;b&#x27;</span>;           <span class="comment">//此处char被隐式转换成了int，&#x27;b&#x27;的ASCII码值为98</span></span><br><span class="line">  <span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&#x27;a&#x27;</span> &lt;&lt; b &lt;&lt; c; <span class="comment">//输出结果：a98c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>cin标准输入流</p>
<p>cin将字符串读为特定类型的值，并会忽略起始的空白符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello_line</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Please enter your name\n&quot;</span>;</span><br><span class="line">  string str;</span><br><span class="line">  cin &gt;&gt; str;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Hello,&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入Eric</span></span><br><span class="line"><span class="comment">//输出Hello, Eric!</span></span><br></pre></td></tr></table></figure>
<p>但是，默认情况下，空白符（如空格或换行）会终止输入。因此输入Eric Bloodaxe，仍然只会回应Hello, Eric！</p>
<p>这种情况下，可以用函数getline()来读取一整行（包括结束的换行符），例如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello_line</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Please enter your name\n&quot;</span>;</span><br><span class="line">  string str;</span><br><span class="line">  <span class="built_in">getline</span>(cin, str);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Hello,&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入Eric Bloodaxe</span></span><br><span class="line"><span class="comment">//输出Hello, Eric Bloodaxe!</span></span><br></pre></td></tr></table></figure>
<p>行尾的换行符被丢掉了，因此接下来cin会从下一行开始。</p>
</li>
</ul>
<h4 id="关联"><a class="markdownIt-Anchor" href="#关联"></a> 关联</h4>
<p>ostream对象可以通过tie( )函数关联在一个istream对象上。关联的作用在于缓冲区的实时刷新。考虑这样的场景，通过一个istream获取一些字符，之后想将其放入ostream对象中。而且在这个过程中，希望做到每通过istream接收一个字符，就会让ostream对象输出一个字符，也就是实时刷新。</p>
<p>如果不用关联的话，由于一级二级缓存的存在，istream接收的字符不会实时出现在ostream对象中，而是程序结束时一股脑放入其中。但如果用tie关联，可以实时刷新缓冲区。ostream对象能够在istream对象有动作之前刷新缓冲区。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有关联版本代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  std::ofstream ofs;</span><br><span class="line">  ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(&amp;ofs);</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="keyword">while</span>(cin &gt;&gt; c)&#123;</span><br><span class="line">    ofs &lt;&lt; c;</span><br><span class="line">  &#125;</span><br><span class="line">  ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无关联版本代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  std::ofstream ofs;</span><br><span class="line">  ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="keyword">while</span>(cin &gt;&gt; c)&#123;</span><br><span class="line">    ofs &lt;&lt; c;</span><br><span class="line">  &#125;</span><br><span class="line">  ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tie()的两个重载：<br />
ostream* tie ( ) const;                //返回指向绑定的输出流的指针。<br />
ostream* tie ( ostream* tiestr ); //将tiestr指向的输出流绑定到该对象上，并返回一个绑定的输出流指针。</p>
</blockquote>
<p>无参形态的关联：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*cin.<span class="built_in">tie</span>() &lt;&lt; <span class="string">&quot;There will be some new words&quot;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="io状态"><a class="markdownIt-Anchor" href="#io状态"></a> I/O状态</h3>
<p>IO操作可能发生错误。而条件状态可以帮助我们访问当前流的状态，以及发生了何种错误，是否可修正。</p>
<table>
<thead>
<tr>
<th><code>::iostate</code></th>
<th>iostate是表示当前流状态的类型，下面的badbit,failbit,eofbit,goodbit都属于iostate</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>::badbit</code></td>
<td>指出流已崩溃，是四种状态中唯一不可恢复的错误</td>
</tr>
<tr>
<td><code>::failbit</code></td>
<td>指出IO操作失败了，如期望读取数值却读出一个字符这样的错误</td>
</tr>
<tr>
<td><code>::eofbit</code></td>
<td>指出流到达了文件结束，如果到达文件结束位置，eofbit和failbit都会被置位</td>
</tr>
<tr>
<td><code>::goodbit</code></td>
<td>指出流未处于错误状态。值为0.</td>
</tr>
<tr>
<td><code>s.eof()</code></td>
<td>若流s的eofbit置位，则返回true</td>
</tr>
<tr>
<td><code>s.fail()</code></td>
<td>若流s的failbit置位，则返回true</td>
</tr>
<tr>
<td><code>s.bad()</code></td>
<td>若流s的badbit置位，则返回true</td>
</tr>
<tr>
<td><code>s.good()</code></td>
<td>若流s处于有效状态，则返回true</td>
</tr>
<tr>
<td><code>s.clear()</code></td>
<td>将流s中所有条件状态位复位，则流的状态设置为有效，返回void</td>
</tr>
<tr>
<td><code>s.clear(flags)</code></td>
<td>根据flags标志位，将流s中对应条件状态位复位。flags类型为<code>::iostate</code>，返回void</td>
</tr>
<tr>
<td><code>s.setstate(flags)</code></td>
<td>根据flags标志位，将流s中对应条件状态位置位。flags类型为<code>::iostate</code>，返回void</td>
</tr>
<tr>
<td><code>s.rdstate()</code></td>
<td>返回流s的当前条件状态，返回类型为<code>::iostate</code></td>
</tr>
<tr>
<td><code>cin.sync()</code></td>
<td>清除输入缓冲区，成功时返回0，失败时barbit置位，函数返回-1</td>
</tr>
<tr>
<td><code>cin.ignore(numeric_limits&lt;std::streamsize&gt;::max(), '\n')</code></td>
<td>清除输入缓冲区的当前行。其中<code>cin.ignore()</code>不输入参数，会清楚一个字符，<code>numeric_limits&lt;std::streamsize&gt;::max()</code>是climits头文件定义的流规格最大值，也可以用一个足够大的整数代替它。</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>判断流是否发生错误</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  cin &gt;&gt; a;</span><br><span class="line">  <span class="keyword">if</span>(cin.<span class="built_in">rdstate</span>() == ios::goodbit)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入数据的类型正确&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(cin.<span class="built_in">rdstate</span>() == ios_base::failbit)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入数据的类型错误，非致命错误，可清除输入缓冲区挽回&quot;</span> &lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而如果不判断出错类型，只想判断这个流是否处于良好状态，可以直接将其用作条件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(cin &gt;&gt; word)&#123;</span><br><span class="line">  <span class="comment">// ok: 读操作成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>管理条件状态</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> old_state = cin.<span class="built_in">rdstate</span>();  <span class="comment">//记住cin的当前状态</span></span><br><span class="line">cin.<span class="built_in">clear</span>();                     <span class="comment">//使cin有效</span></span><br><span class="line"><span class="built_in">process_input</span>(cin);              <span class="comment">//使用cin</span></span><br><span class="line">cin.<span class="built_in">setstate</span>(old_state);         <span class="comment">//将cin置为原有状态</span></span><br></pre></td></tr></table></figure>
<p>为了复位单一的条件状态位，首先用rdstate读出当前状态，然后用位操作将所需位复位，来生成新的状态。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将failbit和badbit复位，但保持eofbit不变</span></span><br><span class="line">cin.<span class="built_in">clear</span>(cin.<span class="built_in">rdstate</span>() &amp; ~cin.failbit &amp; ~cin.badbit);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="流运算符重载"><a class="markdownIt-Anchor" href="#流运算符重载"></a> 流运算符重载</h3>
<p>类型可以自定义输入流和输出流操作。比如自己写了一个Entry类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line">  string name;</span><br><span class="line">  <span class="type">int</span> number;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>&lt;&lt;仅对应ostream</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> Entry&amp; e)&#123;</span><br><span class="line">  <span class="keyword">return</span> os &lt;&lt; <span class="string">&quot;&#123;\&quot;&quot;</span> &lt;&lt; e.name &lt;&lt; <span class="string">&quot;\&quot;,&quot;</span> &lt;&lt; e.number &lt;&lt; <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出运算符重载接受一个输出流（引用）作为第一个参数，输出完毕后，返回此流的引用</strong>。</p>
</li>
<li>
<p>&gt;&gt;仅对应istream</p>
<p>输入运算符要复杂的多，因为必须检查格式是否正确。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入了&#123;&quot;name&quot;, number&#125;，希望把“name”赋值给name，number赋值给number</span></span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; is, Entry&amp; e)</span><br><span class="line">  <span class="comment">//读取&#123;&quot;name&quot;,number&#125;，注意，正确格式包含&#123;&quot; &quot;, 和&#125;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> c,c2;</span><br><span class="line">  <span class="keyword">if</span>(is&gt;&gt;c &amp;&amp; c==<span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; is&gt;&gt;c2 &amp;&amp; c2==<span class="string">&#x27;&quot;&#x27;</span>)<span class="comment">//以一个&#123;&quot;开始</span></span><br><span class="line">  &#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">while</span>(is.<span class="built_in">get</span>(c) &amp;&amp; c!=<span class="string">&#x27;&quot;&#x27;</span>)            <span class="comment">//is&gt;&gt;c默认跳过空白字符，但是get()不会</span></span><br><span class="line">      name+=c;</span><br><span class="line">    <span class="keyword">if</span>(is&gt;&gt;c &amp;&amp; c==<span class="string">&#x27;,&#x27;</span>)&#123;</span><br><span class="line">      <span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(is&gt;&gt;number&gt;&gt;c &amp;&amp; c==<span class="string">&#x27;&#125;&#x27;</span>)         <span class="comment">//读取数和一个&#125;</span></span><br><span class="line">      &#123;</span><br><span class="line">        e = &#123;name, number&#125;;               <span class="comment">//读入的值赋予Entry对象</span></span><br><span class="line">        <span class="keyword">return</span> is;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  is.<span class="built_in">setstate</span>(ios_base::failbit);         <span class="comment">//格式不对，将流状态置为fail</span></span><br><span class="line">  <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输入运算符重载接受一个输入流（引用）作为第一个参数，输入完毕后，返回此流的引用</strong>。</p>
</li>
</ul>
<h3 id="文件流"><a class="markdownIt-Anchor" href="#文件流"></a> 文件流</h3>
<p>在&lt;fstream&gt;中，标准库提供了读写文件数据的流：</p>
<ol>
<li>
<p>ifstream用于从文件中读取数据</p>
</li>
<li>
<p>ofstream用于向文件写入数据</p>
</li>
<li>
<p>fstream用于读写文件</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>fstream fstrm;</th>
<th>创建一个未绑定的文件流</th>
</tr>
</thead>
<tbody>
<tr>
<td>fstream fstrm(s);</td>
<td>创建一个fstream，并打开名为s的文件。构造函数是explicit的，s可以是string类型或指向C风格字符串的指针。</td>
</tr>
<tr>
<td>fstream fstrm(s, mode);</td>
<td>与上面的构造函数类似，但按指定mode打开文件</td>
</tr>
<tr>
<td>fstrm.open(s)</td>
<td>打开名为s的文件，并将文件与fstrm绑定。构造函数是explicit的，s可以是string类型或指向C风格字符串的指针。如果调用open失败，会导致failbit被置位</td>
</tr>
<tr>
<td>fstrm.close( )</td>
<td>关闭fstrm绑定的文件。返回void。关闭完，fstrm就可以去打开其它文件了</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://fstrm.is">fstrm.is</a>_open( )</td>
<td>返回bool类型，指出与fstrm关联的文件是否成功打开，且是否尚未关闭</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>自动构造和析构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对每个传递给程序的文件执行循环操作</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p = argv+<span class="number">1</span>; p != argv + argc; ++p)&#123;</span><br><span class="line">  <span class="function">ifstream <span class="title">input</span><span class="params">(*p)</span></span>;       <span class="comment">//创建输入流并打开文件</span></span><br><span class="line">  <span class="keyword">if</span>(input) &#123;</span><br><span class="line">    <span class="built_in">process</span>(input);         <span class="comment">//如果文件打开成功，“处理”此文件</span></span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;couldn&#x27;t open: &quot;</span> + <span class="built_in">string</span>(*p);</span><br><span class="line">&#125; <span class="comment">//每个循环步input都会离开作用域，因此会被销毁</span></span><br></pre></td></tr></table></figure>
<p>因为input是while循环的局部变量，它在每个循环步中都要创建和销毁一次。当一个fstream对象离开作用域时，与之关联的文件会自动关闭。</p>
</li>
<li>
<p>文件模式：打开文件时指定的mode</p>
<table>
<thead>
<tr>
<th>in</th>
<th>以读方式打开。只可以对ifstream或fstream对象设定。</th>
</tr>
</thead>
<tbody>
<tr>
<td>out</td>
<td>以写方式打开。只可以对ofstream或fstream对象设定。</td>
</tr>
<tr>
<td>trunc</td>
<td>截断文件。只有当out被设定时，才能设定trunc。此模式打开文件，文件的原内容会被丢弃</td>
</tr>
<tr>
<td>app</td>
<td>每次写操作前均定位到文件末尾。与trunc相悖</td>
</tr>
<tr>
<td>ate</td>
<td>打开文件后立即定位到文件末尾。可用于任何文件流对象。</td>
</tr>
<tr>
<td>binary</td>
<td>以二进制方式进行IO。可用于任何文件流对象。</td>
</tr>
</tbody>
</table>
<p>默认情况下，用out模式打开会自动trunc（即使没有显式写），所以会丢弃文件的原始内容。阻止一个ofstream清空文件内容的方法是out模式下指定app模式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在这几条语句中，file1都被截断</span></span><br><span class="line"><span class="function">ofstream <span class="title">out</span> <span class="params">(<span class="string">&quot;file1&quot;</span>)</span></span>; <span class="comment">//隐含以输出模式打开文件并截断文件</span></span><br><span class="line"><span class="function">ofstream <span class="title">out2</span> <span class="params">(<span class="string">&quot;file1&quot;</span>, ofstream::out)</span></span>; <span class="comment">//隐含地截断文件</span></span><br><span class="line"><span class="function">ofstream <span class="title">out3</span> <span class="params">(<span class="string">&quot;file1&quot;</span>, ofstream::out | ofstream::trunc)</span></span>;</span><br><span class="line"><span class="comment">//为了保留文件内容，必须显式指定app模式</span></span><br><span class="line"><span class="function">ofstream <span class="title">app</span><span class="params">(<span class="string">&quot;file2&quot;</span>, ofstream::app)</span></span>; <span class="comment">//隐含为输出模式</span></span><br><span class="line"><span class="function">ofstream <span class="title">app2</span><span class="params">(<span class="string">&quot;file2&quot;</span>, ofstream::out | ofstream::app)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="字符串流"><a class="markdownIt-Anchor" href="#字符串流"></a> 字符串流</h3>
<p>在sstream中，标准库提供了从string读取数据以及向string写入数据的流：</p>
<ul>
<li>
<p>istringstream用于从string中读取数据</p>
</li>
<li>
<p>ostringstream用于向string写入数据</p>
</li>
<li>
<p>stringstream用于读写string</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>sstream strm;</th>
<th>strm是一个未绑定的stringstream对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>sstream strm(s);</td>
<td>strm是一个stringstream对象，保存string s的一个拷贝，此构造函数是explicit的</td>
</tr>
<tr>
<td>strm.str();</td>
<td>返回strm所保存的string的拷贝</td>
</tr>
<tr>
<td>strm.str(s);</td>
<td>将string s拷贝到strm中。返回void</td>
</tr>
</tbody>
</table>
<h4 id="istringstream"><a class="markdownIt-Anchor" href="#istringstream"></a> istringstream</h4>
<p>考虑有这样一个文件，内容记录着一些人和他们的若干电话号码</p>
<blockquote>
<p>morgan 2015552368 8625550123<br />
drew 9735550130<br />
lee 6095550132 2015550175 8005550000</p>
</blockquote>
<p>现在希望提取这个文件，提取出每个人的人名和相应的电话号码。可以先每次第一行的字符串，之后将字符串交由istringstream，通过istringstream逐元素提取。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PersonInfo</span> &#123;</span><br><span class="line">  string name;</span><br><span class="line">  vector&lt;string&gt; phones;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">string line, word;</span><br><span class="line">vector&lt;PersonInfo&gt; people;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(cin, line))&#123;</span><br><span class="line">  PersonInfo info;</span><br><span class="line">  <span class="function">istringstream <span class="title">record</span><span class="params">(line)</span></span>;</span><br><span class="line">  record &gt;&gt; info.name;</span><br><span class="line">  <span class="keyword">while</span>(record &gt;&gt; word)</span><br><span class="line">    info.phones.<span class="built_in">push_back</span>(word);</span><br><span class="line">  people.<span class="built_in">push_back</span>(info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ostringstream"><a class="markdownIt-Anchor" href="#ostringstream"></a> ostringstream</h4>
<p>ostringstream可应用于想逐步构造输出，最后一起打印的场景。比如上面的例子，想要验证电话号码并改变其格式，并输出到一个新文件。其中，新文件只包含有效电话，无效的电话会被打印到错误信息中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设事先已经有了valid和format函数，valid验证电话号码，format改变其格式</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;entry : people) &#123;</span><br><span class="line">  ostringstream formatted, badNums;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;nums : entry.phones)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">valid</span>(nums))&#123;</span><br><span class="line">      badNums &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; nums;</span><br><span class="line">    &#125; <span class="keyword">else</span>  </span><br><span class="line">      formatted &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; format(nums);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (badNums.<span class="built_in">str</span>().<span class="built_in">empty</span>())</span><br><span class="line">    os &lt;&lt; entry.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; formatted.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;input error: &quot;</span> &lt;&lt; entry.name &lt;&lt; <span class="string">&quot; invalid number(s) &quot;</span> &lt;&lt; badNums.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实用工具"><a class="markdownIt-Anchor" href="#实用工具"></a> 实用工具</h2>
<h3 id="12-常用内置算法"><a class="markdownIt-Anchor" href="#12-常用内置算法"></a> 12 常用内置算法</h3>
<h3 id="12-特殊容器"><a class="markdownIt-Anchor" href="#12-特殊容器"></a> 12 特殊容器</h3>
<p>C++标准库中提供了若干种容器，它们与STL框架并非完全契合，比如</p>
<table>
<thead>
<tr>
<th>array&lt;T,N&gt;</th>
<th>是一段固定尺寸且连续分配的序列，包含N个T类型的元素；隐式地转换成T*</th>
</tr>
</thead>
<tbody>
<tr>
<td>pair&lt;T,U&gt;</td>
<td>两个元素，类型分别是T和U</td>
</tr>
<tr>
<td>tuple&lt;T…&gt;</td>
<td>是一段序列，存放着任意类型地任意个元素</td>
</tr>
<tr>
<td>basic_string&lt;C&gt;</td>
<td>是一段字符的序列，字符的类型是C；提供字符串操作</td>
</tr>
<tr>
<td>valarray&lt;T&gt;</td>
<td>是一个数组，包含T类型的数值；提供数值操作</td>
</tr>
</tbody>
</table>
<h4 id="array"><a class="markdownIt-Anchor" href="#array"></a> array</h4>
<p>array可以理解为一个<strong>增强版的内置数组</strong>，元素数量在编译期指定，位于栈中或者对象内，也可以位于静态存储空间中。因此，使用array的时空代价并不比使用内置数组大。</p>
<p>增强的体现在于：1. 不会隐式地转换成指针（因为很多时候开发者并不希望自动转换）；2. 提供了一些便于操作的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>,3&gt; a1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; <span class="comment">//初始值的数量不能多于array指定的元素数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//编译器不允许省略array的元素数量</span></span><br><span class="line">array&lt;<span class="type">int</span>&gt; ax = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;   <span class="comment">//错误！没有指定元素的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//元素的数量必须是一个常量表达式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  array&lt;string, n&gt; aa = &#123;<span class="string">&quot;John&#x27;s&quot;</span>, <span class="string">&quot;Queens&#x27;&quot;</span>&#125;;<span class="comment">//错误！array的元素数量必须是常量表达式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>避免隐式转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Circle a1[<span class="number">10</span>];</span><br><span class="line">  array&lt;Circle, 10&gt; a2;</span><br><span class="line"></span><br><span class="line">  Shape* p1 = a1; <span class="comment">// 语法上正确，但是存在严重的隐患</span></span><br><span class="line">  Shape* p2 = a2; <span class="comment">// 报告语法错误；禁止&lt;Circle,10&gt;自动转换成Shape*类型，从而避免了风险</span></span><br><span class="line">  p1[<span class="number">3</span>].draw;     <span class="comment">// 程序极易发生错误，如果sizeof(Shape)&lt;sizeof(Circle)，</span></span><br><span class="line">                  <span class="comment">// 则通过Shape*指针调用Circle[]的下标运算会导致访问内存时产生错误的偏移量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>传递给需要指针的C风格函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>* p, <span class="type">int</span> sz)</span></span>;                    <span class="comment">// C风格的接口</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">  array&lt;<span class="type">int</span>,10&gt; a;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">f</span>(a, a.<span class="built_in">size</span>());                          <span class="comment">// 错误：此处不存在期望的隐式类型转换</span></span><br><span class="line">  <span class="built_in">f</span>(&amp;a[<span class="number">0</span>], a.<span class="built_in">size</span>());                      <span class="comment">// C风格的写法</span></span><br><span class="line">  <span class="built_in">f</span>(a.<span class="built_in">data</span>(), a.<span class="built_in">size</span>());                   <span class="comment">// C风格的写法</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> p = <span class="built_in">find</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">777</span>);  <span class="comment">// C++ STL风格德写法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="bitset"><a class="markdownIt-Anchor" href="#bitset"></a> bitset</h4>
<p>二进制位的数组，提高存储效率。</p>
<ul>
<li>
<p>可以用整数或者字符串来初始化bitset</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bitset&lt;9&gt; bs1 &#123;<span class="string">&quot;110001111&quot;</span>&#125;;</span><br><span class="line">bitset&lt;9&gt; bs2 &#123;<span class="number">399</span>&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>各种位运算可以用在bitset上</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bitset&lt;9&gt; bs3 = ~bs1;       <span class="comment">//求反：bs3 == &quot;001110000&quot;</span></span><br><span class="line">bitset&lt;9&gt; bs4 = bs1 &amp; bs3;  <span class="comment">//所有位都为0</span></span><br><span class="line">bitset&lt;9&gt; bs5 = bs3 &lt;&lt; <span class="number">2</span>;   <span class="comment">//左移：bs5 == &quot;111000000&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>反其道而行，可用成员函数<code>to_ullong()</code>或<code>to_string()</code>将bitset转为整数或者字符串</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">binary</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">  bitset&lt;8*<span class="keyword">sizeof</span>(<span class="type">int</span>)&gt; b = i; <span class="comment">//一个字节8位，int占sizeof(int)个字节</span></span><br><span class="line">  cout &lt;&lt; b.<span class="built_in">to_string</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者也可以直接使用bitset的流运算符重载：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">binary2</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">  bitset&lt;8*<span class="keyword">sizeof</span>(<span class="type">int</span>)&gt; b = i;</span><br><span class="line">  cout &lt;&lt; b &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="tuple"><a class="markdownIt-Anchor" href="#tuple"></a> tuple</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;string,<span class="type">int</span>,<span class="type">double</span>&gt; t2 &#123;<span class="string">&quot;Sild&quot;</span>, <span class="number">123</span>, <span class="number">3.14</span>&#125;;  <span class="comment">// 显式地指定了类型</span></span><br><span class="line"><span class="keyword">auto</span> t = <span class="built_in">make_tuple</span>(string&#123;<span class="string">&quot;Herring&quot;</span>&#125;, <span class="number">10</span>, <span class="number">1.23</span>); <span class="comment">// 隐式地推断出类型是 tuple&lt;string, int, double&gt;</span></span><br><span class="line"></span><br><span class="line">string s = <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(t); <span class="comment">// 获取tuple的第一个元素：&quot;Herring&quot;</span></span><br><span class="line"><span class="type">int</span> x = <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(t);    <span class="comment">// 获取tuple的第二个元素：10</span></span><br><span class="line"><span class="type">double</span> d = <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(t); <span class="comment">// 获取tuple的第三个元素：1.23</span></span><br></pre></td></tr></table></figure>
<p>tuple的每一个元素对应一个编号，从0开始依次排列。要想<strong>在编译时从tuple中选取元素，只能使用get&lt;1&gt;(t)的方式，而不能写成get(t,1)或t[1]</strong>。</p>
<h3 id="13-时间"><a class="markdownIt-Anchor" href="#13-时间"></a> 13 时间</h3>
<p>标准库提供了chrono，负责处理时间，可以完成一些与时间有关的任务，比如可以用下面的程序完成最基本的计时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> t0 = high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="built_in">do_work</span>();</span><br><span class="line"><span class="keyword">auto</span> t1 = high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">cout &lt;&lt; <span class="built_in">duration_cast</span>&lt;milliseconds&gt;(t1-t0).<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;msec\n&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>duration_cast将C++的time_point类型转换为公认的单位。</p>
<h3 id="14-函数适配器"><a class="markdownIt-Anchor" href="#14-函数适配器"></a> 14 函数适配器</h3>
<blockquote>
<p>函数适配器接受一个函数作为它的参数，返回的结果是一个函数对象，可以通过这个函数对象调用原来的函数</p>
</blockquote>
<ul>
<li>
<p>bind( )：</p>
<p>顾名思义，此函数要将一些参数，绑定在函数上，以构造一个函数对象。可以通过bind实现偏函数，如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">cube</span><span class="params">(<span class="type">double</span>)</span></span>;          <span class="comment">//cube是一个函数</span></span><br><span class="line"><span class="keyword">auto</span> cube2 = <span class="built_in">bind</span>(cube, <span class="number">2</span>);   <span class="comment">//通过bind创建函数对象cube2</span></span><br><span class="line"><span class="comment">//因此，调用cube2()时，相当于调用了cube(2)</span></span><br></pre></td></tr></table></figure>
<p>而且，不必每次都绑定函数的全部参数，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> placeholds;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> string&amp;)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> g = <span class="built_in">bind</span>(f, <span class="number">2</span>, _1);    <span class="comment">//把f的第一个参数绑定为2</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">2</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="built_in">g</span>(<span class="string">&quot;hello&quot;</span>);                 <span class="comment">//等同于调用f(2, &quot;hello&quot;);</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>_1</code>表示一个占位符，其在<code>std::placeholds</code>命名空间中。占位符指定了调用函数对象时的参数，对应了原函数的哪几个位置的参数。</p>
<ul>
<li>
<p>为重载函数绑定参数，<strong>必须显式</strong>地指定被绑定的是重载函数的哪个版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pow</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">pow</span><span class="params">(<span class="type">double</span>, <span class="type">double</span>)</span></span>;    <span class="comment">//重载了函数pow</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pow2 = <span class="built_in">bind</span>(pow, _1, <span class="number">2</span>);  <span class="comment">//错误：绑定的是哪个pow()?</span></span><br><span class="line"><span class="keyword">auto</span> pow2 = <span class="built_in">bind</span>((<span class="built_in">double</span>(*)(<span class="type">double</span>,<span class="type">double</span>))pow, _1, <span class="number">2</span>);<span class="comment">//正确，确切地指定了选用第二个pow</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>mem_fn( )：</p>
<p>将名字拉长，就是member function。这个函数的目的在于，将类中的成员函数提取出来，构造出一个函数对象。通过调用普通函数的方式，调用此函数对象，可以达到调用类成员函数的效果。换言之，<code>mem_fn()</code>可以被看作是一种从面向对象的调用到面向函数的调用的映射。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">user</span><span class="params">(Shape* p)</span></span>&#123;</span><br><span class="line">  p-&gt;<span class="built_in">draw</span>();</span><br><span class="line">  <span class="keyword">auto</span> draw = <span class="built_in">mem_fn</span>(&amp;Shape::draw);</span><br><span class="line">  <span class="built_in">draw</span>(p); <span class="comment">//等价于p-&gt;draw()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>某些算法需要它的操作以非成员函数的方式调用，mem_fn()通常用在这些算法中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">draw_all</span><span class="params">(vector&lt;Shape*&gt;&amp; v)</span></span>&#123;</span><br><span class="line">  for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">mem_fn</span>(&amp;Shape::draw));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，lambda表达式出现后，可以替代这样的绑定方式（因为匿名函数本质是函数对象），而且更为简单直观：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">draw_all</span><span class="params">(vector&lt;Shape*&gt;&amp; v)</span></span>&#123;</span><br><span class="line">  for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](Shape* p)&#123;p-&gt;<span class="built_in">draw</span>();&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>function：</p>
<p>前面的代码中，函数对象都被用auto关键字声明，也就是让编译器自己去推断函数对象的类型。实际上，标准库中是有办法手动制定函数对象的准确类型的，那就是使用<code>function</code>。要通过指定返回类型和参数类型，来确定一个function：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f1</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">double</span>)&gt; fct &#123;f1&#125;;<span class="comment">//初始化为f1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f2</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">user</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fct = [](<span class="type">double</span> d)&#123;<span class="keyword">return</span> <span class="built_in">round</span>(d);&#125;;</span><br><span class="line">  fct = f1;</span><br><span class="line">  fct = f2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="对象模型"><a class="markdownIt-Anchor" href="#对象模型"></a> 对象模型</h1>
<h1 id="并发编程"><a class="markdownIt-Anchor" href="#并发编程"></a> 并发编程</h1>
<h2 id="stdthread"><a class="markdownIt-Anchor" href="#stdthread"></a> std::thread</h2>
<p>线程在<code>std::thread</code>对象创建时启动，对象里面的函数执行完毕后，线程也随之结束。使用C++线程库启动线程，就是构造<code>std::thread</code>对象。创建thread对象时需要传入有函数操作符（也就是括号运算符）的类型实例（即函数对象）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">background_task</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="built_in">do_something</span>();</span><br><span class="line">    <span class="built_in">do_something_else</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">background_task f;</span><br><span class="line"><span class="function">std::thread <span class="title">my_thread</span><span class="params">(f)</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数对象会被复制到新线程的存储空间中，函数对象的执行和调用都在线程的内存空间中进行</p>
<h2 id="共享数据"><a class="markdownIt-Anchor" href="#共享数据"></a> 共享数据</h2>
<h2 id="内存模型和原子操作"><a class="markdownIt-Anchor" href="#内存模型和原子操作"></a> 内存模型和原子操作</h2>
<h1 id="代码技巧"><a class="markdownIt-Anchor" href="#代码技巧"></a> 代码技巧</h1>
<h2 id="引用计数智能指针webrtc"><a class="markdownIt-Anchor" href="#引用计数智能指针webrtc"></a> 引用计数智能指针（WebRTC）</h2>
<blockquote>
<p>WebRTC内实现了与shared_ptr相似的，支持引用计数的智能指针scoped_refptr。与shared_ptr不同之处在于，其把引用计数留给了资源对象来实现，因此更加灵活。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ice_ly000/article/details/105629297">https://blog.csdn.net/ice_ly000/article/details/105629297</a></p>
<h2 id="pybind11"><a class="markdownIt-Anchor" href="#pybind11"></a> pybind11</h2>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/06/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/" rel="prev" title="设计模式（C++）">
                  <i class="fa fa-chevron-left"></i> 设计模式（C++）
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/07/09/WebRTC%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AD%96%E7%95%A5%E6%94%B9%E8%BF%9B%E8%B0%83%E7%A0%94/" rel="next" title="WebRTC拥塞控制策略改进调研">
                  WebRTC拥塞控制策略改进调研 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">OliverPai</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.2.8/pdfobject.min.js","integrity":"sha256-tu9j5pBilBQrWSDePOOajCUdz6hWsid/lBNzK4KgEPM="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>




  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.0/katex.min.css" integrity="sha256-uik/hNqHWZldXh/0K35nqOSCff9F61/ZOFReqNOBgB0=" crossorigin="anonymous">



</body>
</html>
