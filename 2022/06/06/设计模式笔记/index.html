<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.12.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Wolai版笔记：https:&#x2F;&#x2F;www.wolai.com&#x2F;vKvsLtKSQ2EDi2QDfPCfyp。记录UML图的案例和使用方法，利用UML图解释23种设计模式的应用场景和实现方式，同时附上C++实现代码">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式（C++）">
<meta property="og:url" content="http://example.com/2022/06/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="OliverPai">
<meta property="og:description" content="Wolai版笔记：https:&#x2F;&#x2F;www.wolai.com&#x2F;vKvsLtKSQ2EDi2QDfPCfyp。记录UML图的案例和使用方法，利用UML图解释23种设计模式的应用场景和实现方式，同时附上C++实现代码">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_LDUVW8iNHp.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_CYbCbwv9cS.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_XUXXAJ9ezw.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_XWGnxcAC0A.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_Ya565F9o_R.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image__mx-L3DfW4.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_EChel9f6VJ.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/class_test_y7PGig-rKD.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_KyqJhsbeTU.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_JkMI5Bfiix.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_4PEEOGeed7.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_NcXLfHbvGQ.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_pKnmoRy7CD.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image__0BMljJHon.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_0KgZ9eRCub.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_vAbbVjx40d.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_ibUD6jaxfN.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_0y67h-mcvx.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_f8r81cnzno.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_ZR-aggSc9b.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_J6ROHGk-HQ.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_UX7gfhHr6j.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/use_case_TSxykT_OIm.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_trdsYDdxEi.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_W5xw_j8CIc.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_-cM53juFhs.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_LTFo_mo471.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_kP5-Yda8Cq.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/sequence_test.drawio_PZeOtyidOi.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_ETQzqXUn8L.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_VVVa9OaJk4.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image__fRxSpewKb.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_wZCYDEcI8Y.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_pIG1eoG7w-.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_psTux_rw_R.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_aZYjDQ9kcg.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_YPbrcpWDP5.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_vGYSLsjdRm.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_LaOkWgxP2d.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_Bl0RbJxcRV.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_mczjtZsYoT.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_KLc8axDXNy.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_-s6OMPY2i6.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_NoWKqwuRPL.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_Qpd2kj70i2.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_zETtFplPnQ.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_wg36lPjQXx.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_6PaWAnTsVZ.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_OPxig-n88x.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_764XUH49fC.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_XcWdMEsFCy.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_hN2yH2ASOc.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_LPlCPfrZ0o.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_MkjMugjdg_.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_E09UNJ-ffJ.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_FzbBrhJfAw.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_Vfisq6ZU80.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_vFZ9_EcmBy.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_BJw7swbIke.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_bWnBly4dT4.jpg">
<meta property="article:published_time" content="2022-06-06T15:34:57.000Z">
<meta property="article:modified_time" content="2022-07-23T13:01:10.966Z">
<meta property="article:author" content="OliverPai">
<meta property="article:tag" content="设计模式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_LDUVW8iNHp.png">


<link rel="canonical" href="http://example.com/2022/06/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2022/06/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/","path":"2022/06/06/设计模式笔记/","title":"设计模式（C++）"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>设计模式（C++） | OliverPai</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="OliverPai" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">OliverPai</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">落叶本就是假的</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.</span> <span class="nav-text"> 设计模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#uml"><span class="nav-number">2.</span> <span class="nav-text"> UML</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9B%BE"><span class="nav-number">2.1.</span> <span class="nav-text"> 类图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E4%BE%8B%E5%9B%BE"><span class="nav-number">2.2.</span> <span class="nav-text"> 用例图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E5%BA%8F%E5%BA%8F%E5%88%97%E5%9B%BE"><span class="nav-number">2.3.</span> <span class="nav-text"> 时序&#x2F;序列图</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.</span> <span class="nav-text"> 面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-number">3.1.</span> <span class="nav-text"> 四大特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E8%80%8C%E9%9D%9E%E5%AE%9E%E7%8E%B0%E7%BC%96%E7%A8%8B"><span class="nav-number">3.2.</span> <span class="nav-text"> 基于接口而非实现编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%94%A8%E7%BB%84%E5%90%88%E5%B0%91%E7%94%A8%E7%BB%A7%E6%89%BF"><span class="nav-number">3.3.</span> <span class="nav-text"> 多用组合少用继承</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">4.</span> <span class="nav-text"> 设计原则</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99single-responsibility-principle-srp"><span class="nav-number">4.1.</span> <span class="nav-text"> 单一职责原则（Single Responsibility Principle, SRP）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99%E5%AF%B9%E6%89%A9%E5%B1%95%E5%BC%80%E6%94%BE-%E4%BF%AE%E6%94%B9%E5%85%B3%E9%97%ADopen-closed-principle"><span class="nav-number">4.2.</span> <span class="nav-text"> 开闭原则：对扩展开放、修改关闭（Open Closed Principle）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8C%E5%BC%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99liskov-substitution-principle"><span class="nav-number">4.3.</span> <span class="nav-text"> 里式替换原则（Liskov Substitution Principle）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99interface-segregation-principle"><span class="nav-number">4.4.</span> <span class="nav-text"> 接口隔离原则（Interface Segregation Principle）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99dependency-inversoin-principle"><span class="nav-number">4.5.</span> <span class="nav-text"> 依赖反转原则（Dependency Inversoin Principle）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC"><span class="nav-number">4.5.1.</span> <span class="nav-text"> 依赖反转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC"><span class="nav-number">4.5.2.</span> <span class="nav-text"> 控制反转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="nav-number">4.5.3.</span> <span class="nav-text"> 依赖注入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#kiss%E5%8E%9F%E5%88%99"><span class="nav-number">4.6.</span> <span class="nav-text"> KISS原则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#yagni%E5%8E%9F%E5%88%99"><span class="nav-number">4.6.1.</span> <span class="nav-text"> YAGNI原则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dry%E5%8E%9F%E5%88%99dont-repeat-yourself"><span class="nav-number">4.7.</span> <span class="nav-text"> DRY原则（Don’t Repeat Yourself）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99law-of-demeter"><span class="nav-number">4.8.</span> <span class="nav-text"> 迪米特法则（Law of Demeter）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83"><span class="nav-number">5.</span> <span class="nav-text"> 编程规范</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%91%BD%E5%90%8D%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="nav-number">5.0.1.</span> <span class="nav-text"> 1. 命名的长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%88%A9%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%80%E5%8C%96%E5%91%BD%E5%90%8D"><span class="nav-number">5.0.2.</span> <span class="nav-text"> 2. 利用上下文简化命名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%91%BD%E5%90%8D%E8%A6%81%E5%8F%AF%E8%AF%BB-%E5%8F%AF%E6%90%9C%E7%B4%A2"><span class="nav-number">5.0.3.</span> <span class="nav-text"> 3. 命名要可读、可搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%91%BD%E5%90%8D%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">5.0.4.</span> <span class="nav-text"> 4. 命名接口和抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%B3%A8%E9%87%8A%E5%86%99%E4%BB%80%E4%B9%88"><span class="nav-number">5.0.5.</span> <span class="nav-text"> 5. 注释写什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%B3%A8%E9%87%8A%E7%9A%84%E5%A4%9A%E5%B0%91"><span class="nav-number">5.0.6.</span> <span class="nav-text"> 6. 注释的多少</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E7%B1%BB-%E5%87%BD%E6%95%B0%E5%A4%9A%E5%A4%A7%E6%89%8D%E5%90%88%E9%80%82"><span class="nav-number">5.0.7.</span> <span class="nav-text"> 7. 类、函数多大才合适</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%A4%9A%E9%95%BF%E6%9C%80%E5%90%88%E9%80%82"><span class="nav-number">5.0.8.</span> <span class="nav-text"> 8. 一行代码多长最合适</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E5%96%84%E7%94%A8%E7%A9%BA%E8%A1%8C%E5%88%86%E5%89%B2%E5%8D%95%E5%85%83%E5%9D%97"><span class="nav-number">5.0.9.</span> <span class="nav-text"> 9. 善用空行分割单元块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E5%9B%9B%E6%A0%BC%E7%BC%A9%E8%BF%9B%E8%BF%98%E6%98%AF%E4%B8%A4%E6%A0%BC%E7%BC%A9%E8%BF%9B"><span class="nav-number">5.0.10.</span> <span class="nav-text"> 10. 四格缩进还是两格缩进</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E5%A4%A7%E6%8B%AC%E5%8F%B7%E6%98%AF%E5%90%A6%E8%A6%81%E5%8F%A6%E8%B5%B7%E4%B8%80%E8%A1%8C"><span class="nav-number">5.0.11.</span> <span class="nav-text"> 11. 大括号是否要另起一行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-%E6%8A%8A%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2%E6%88%90%E6%9B%B4%E5%B0%8F%E7%9A%84%E5%8D%95%E5%85%83%E5%9D%97"><span class="nav-number">5.0.12.</span> <span class="nav-text"> 12. 把代码分割成更小的单元块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-%E9%81%BF%E5%85%8D%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%BF%87%E5%A4%9A"><span class="nav-number">5.0.13.</span> <span class="nav-text"> 13. 避免函数参数过多</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-%E5%8B%BF%E7%94%A8%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E6%9D%A5%E6%8E%A7%E5%88%B6%E9%80%BB%E8%BE%91"><span class="nav-number">5.0.14.</span> <span class="nav-text"> 14. 勿用函数参数来控制逻辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-%E5%87%BD%E6%95%B0%E8%AE%BE%E8%AE%A1%E8%A6%81%E8%81%8C%E8%B4%A3%E5%8D%95%E4%B8%80"><span class="nav-number">5.0.15.</span> <span class="nav-text"> 15. 函数设计要职责单一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-%E7%A7%BB%E9%99%A4%E8%BF%87%E6%B7%B1%E7%9A%84%E5%B5%8C%E5%A5%97%E5%B1%82%E6%AC%A1"><span class="nav-number">5.0.16.</span> <span class="nav-text"> 16. 移除过深的嵌套层次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-%E5%AD%A6%E4%BC%9A%E4%BD%BF%E7%94%A8%E8%A7%A3%E9%87%8A%E6%80%A7%E5%8F%98%E9%87%8F"><span class="nav-number">5.0.17.</span> <span class="nav-text"> 17. 学会使用解释性变量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#gof23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.</span> <span class="nav-text"> GoF——23种设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%9E%8B"><span class="nav-number">6.1.</span> <span class="nav-text"> 创建型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8Fsingleton"><span class="nav-number">6.1.1.</span> <span class="nav-text"> 1 单例模式（Singleton）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88%E4%B8%8A%E5%8D%95%E4%BE%8B%E6%87%92%E6%B1%89%E5%BC%8F"><span class="nav-number">6.1.1.1.</span> <span class="nav-text"> 栈上单例（懒汉式）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86%E4%B8%8A%E5%8D%95%E4%BE%8B%E6%87%92%E6%B1%89%E5%BC%8F"><span class="nav-number">6.1.1.2.</span> <span class="nav-text"> 堆上单例（懒汉式）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86%E4%B8%8A%E5%8D%95%E4%BE%8B%E9%A5%BF%E6%B1%89%E5%BC%8F"><span class="nav-number">6.1.1.3.</span> <span class="nav-text"> 堆上单例（饿汉式）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8Ffactory"><span class="nav-number">6.1.2.</span> <span class="nav-text"> 2 工厂模式（Factory）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#21-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82"><span class="nav-number">6.1.2.1.</span> <span class="nav-text"> 2.1 简单工厂</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="nav-number">6.1.2.2.</span> <span class="nav-text"> 2.2 工厂方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#23-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82"><span class="nav-number">6.1.2.3.</span> <span class="nav-text"> 2.3 抽象工厂</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#24-%E6%A8%A1%E6%9D%BF%E5%B7%A5%E5%8E%82c"><span class="nav-number">6.1.2.4.</span> <span class="nav-text"> 2.4 模板工厂（C++）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8Fbuilder"><span class="nav-number">6.1.3.</span> <span class="nav-text"> 3 建造者模式（Builder）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8Fprototype"><span class="nav-number">6.1.4.</span> <span class="nav-text"> 4 原型模式（Prototype）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B"><span class="nav-number">6.2.</span> <span class="nav-text"> 结构型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8Fproxy"><span class="nav-number">6.2.1.</span> <span class="nav-text"> 5 代理模式（Proxy）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8Fbridge"><span class="nav-number">6.2.2.</span> <span class="nav-text"> 6 桥接模式（Bridge）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E6%8A%BD%E8%B1%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%9B%B8%E5%88%86%E7%A6%BB"><span class="nav-number">6.2.2.1.</span> <span class="nav-text"> 简单的抽象与实现相分离</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E7%9A%84%E6%8A%BD%E8%B1%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%9B%B8%E5%88%86%E7%A6%BB"><span class="nav-number">6.2.2.2.</span> <span class="nav-text"> 复杂的抽象与实现相分离</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8Fdecorator"><span class="nav-number">6.2.3.</span> <span class="nav-text"> 7 装饰器模式（Decorator）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8Fadapter"><span class="nav-number">6.2.4.</span> <span class="nav-text"> 8 适配器模式（Adapter）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E9%97%A8%E9%9D%A2%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8Ffacade"><span class="nav-number">6.2.5.</span> <span class="nav-text"> 9 门面&#x2F;外观模式（Facade）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8Fcomposite"><span class="nav-number">6.2.6.</span> <span class="nav-text"> 10 组合模式（Composite）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%8F%E6%98%8E%E5%BC%8F"><span class="nav-number">6.2.6.1.</span> <span class="nav-text"> 透明式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E5%BC%8F"><span class="nav-number">6.2.6.2.</span> <span class="nav-text"> 安全式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8Fflyweight"><span class="nav-number">6.2.7.</span> <span class="nav-text"> 11 享元模式（Flyweight）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B"><span class="nav-number">6.3.</span> <span class="nav-text"> 行为型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#12-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8Fobserver"><span class="nav-number">6.3.1.</span> <span class="nav-text"> 12 观察者模式（Observer）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95template"><span class="nav-number">6.3.2.</span> <span class="nav-text"> 13 模板方法（Template）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8Fstrategypolicy"><span class="nav-number">6.3.3.</span> <span class="nav-text"> 14 策略模式（Strategy&#x2F;Policy）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8Fchain-of-responsibility"><span class="nav-number">6.3.4.</span> <span class="nav-text"> 15 职责链模式（Chain of Responsibility）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8Fstate"><span class="nav-number">6.3.5.</span> <span class="nav-text"> 16 状态模式（State）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8Fiterator"><span class="nav-number">6.3.6.</span> <span class="nav-text"> 17 迭代器模式（Iterator）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8Fvisitor"><span class="nav-number">6.3.7.</span> <span class="nav-text"> 18 访问者模式（Visitor）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8Fmemento"><span class="nav-number">6.3.8.</span> <span class="nav-text"> 19 备忘录模式（Memento）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8Fcommand"><span class="nav-number">6.3.9.</span> <span class="nav-text"> 20 命令模式（Command）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8F%E5%91%BD%E4%BB%A4"><span class="nav-number">6.3.9.1.</span> <span class="nav-text"> 宏命令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8Finterpreter"><span class="nav-number">6.3.10.</span> <span class="nav-text"> 21 解释器模式（Interpreter）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-%E4%B8%AD%E4%BB%8B%E6%A8%A1%E5%BC%8Fmediator"><span class="nav-number">6.3.11.</span> <span class="nav-text"> 22 中介模式（Mediator）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE"><span class="nav-number">6.4.</span> <span class="nav-text"> 设计模式思维导图</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="OliverPai"
      src="/images/avatar-star.png">
  <p class="site-author-name" itemprop="name">OliverPai</p>
  <div class="site-description" itemprop="description">求索与记录</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/OliverPai" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;OliverPai" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar-star.png">
      <meta itemprop="name" content="OliverPai">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OliverPai">
      <meta itemprop="description" content="求索与记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="设计模式（C++） | OliverPai">
      <meta itemprop="description" content="Wolai版笔记：https://www.wolai.com/vKvsLtKSQ2EDi2QDfPCfyp。记录UML图的案例和使用方法，利用UML图解释23种设计模式的应用场景和实现方式，同时附上C++实现代码">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          设计模式（C++）
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-06 23:34:57" itemprop="dateCreated datePublished" datetime="2022-06-06T23:34:57+08:00">2022-06-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-23 21:01:10" itemprop="dateModified" datetime="2022-07-23T21:01:10+08:00">2022-07-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">计算机基础知识</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">Wolai版笔记：https://www.wolai.com/vKvsLtKSQ2EDi2QDfPCfyp。记录UML图的案例和使用方法，利用UML图解释23种设计模式的应用场景和实现方式，同时附上C++实现代码</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="设计模式"><a class="markdownIt-Anchor" href="#设计模式"></a> 设计模式</h1>
<blockquote>
<p>参考资料：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/liu-jianhao/Cpp-Design-Patterns">https://github.com/liu-jianhao/Cpp-Design-Patterns</a></p>
<p><a target="_blank" rel="noopener" href="http://service.qbjavawa.top/time/beautyOfDesignPatterns.html" title="极客时间《设计模式之美》">极客时间《设计模式之美》</a></p>
<p><a target="_blank" rel="noopener" href="https://zhulao.gitee.io/blog/2019/03/31/23%E7%A7%8D%E7%BB%8F%E5%85%B8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E9%99%84c++%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81)/index.html">https://zhulao.gitee.io/blog/2019/03/31/23种经典设计模式(附c++实现代码)/index.html</a></p>
<p><a target="_blank" rel="noopener" href="https://design-patterns.readthedocs.io/zh_CN/latest/index.html">https://design-patterns.readthedocs.io/zh_CN/latest/index.html</a></p>
</blockquote>
<p><strong>面向对象、设计原则、设计模式、编程规范、代码重构五者之间的关系：</strong></p>
<ul>
<li>
<p>面向对象：因其丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式等编码实现的基础。</p>
</li>
<li>
<p>设计原则：代码设计的经验总结，指导对于某些场景下，是否应该使用某种设计模式。（比如，“开闭原则”是如策略、模板等设计模式的指导原则）</p>
</li>
<li>
<p>设计模式：针对软件开发中遇到的设计问题，而总结出来的一套解决方案或者设计思路。主要目的是提高代码的可扩展性。</p>
</li>
<li>
<p>编程规范：<br />
解决代码可读性问题。相比于设计原则、设计模式，更加具体、更偏重代码细节。</p>
</li>
<li>
<p>重构技巧：<br />
是保持代码质量不下降的有效手段，利用的就是面向对象、设计原则、设计模式、编码规范这些理论。</p>
</li>
</ul>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_LDUVW8iNHp.png" alt="" /></p>
<h1 id="uml"><a class="markdownIt-Anchor" href="#uml"></a> UML</h1>
<blockquote>
<p>画图工具：draw.io</p>
</blockquote>
<h2 id="类图"><a class="markdownIt-Anchor" href="#类图"></a> 类图</h2>
<p>考虑给动物园建一个模。动物园里有很多动物，均可以属于动物类型，因此可以建立一个比较大的Animal类。每个该类的实例就是一个特定动物。可以通过属性以区分不同实例，因此加上name、id、age属性。属性名后面可以接上期望的基础类型，比如是整数，还是字符。同时加上方法来设置这些属性，或者描述实例的动作。比如添加<code>setName()</code>方法，（也可以给方法加上参数和返回类型<code>setName(var1, var2):string</code>）</p>
<p>UML类图中对可见性的表达与C++中一致：减号表示private，加号表示public，#表示protected。此外，还有一个波浪线~表示package/default，其含义是可以被同一package内的任何类所访问。</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_CYbCbwv9cS.png" alt="" /></p>
<ul>
<li>
<p>继承关系（Inheritance）：</p>
<p>现在Animal类中的方法和属性都是private的。动物也是有具体类型的，比如乌龟、水獭和懒猴。因此，再为这三个类型制定新的class，他们继承自Animal类，有动物的共有属性方法，又有自己的独特行为。同时，Animal类还需要是一个抽象类。抽象类可以用：加尖括号&lt;&lt;Animal&gt;&gt;或者斜体<em>Animal</em>来表示。<strong>继承用空心箭头来表示</strong>。</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_XUXXAJ9ezw.png" alt="" /></p>
</li>
<li>
<p>关联关系（Association）：</p>
<p>比如水獭和海胆都属于动物，而水獭吃海胆，因此这两个类型之间出现了关联关系，关联行为就是eat。关联关系用一条普通直线就可以表示。</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_XWGnxcAC0A.png" alt="" /></p>
<p>除了这样的普通直线表示，还可以用带箭头的直线来表示。</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_Ya565F9o_R.png" alt="" /></p>
<p>比如图中表示，A知道B，但B不知道A。</p>
</li>
<li>
<p>聚合关系（Aggregation）：</p>
<p>聚合关系比较抽象，其描述整体与部分的关系。部分归属于整体，但二者并非强依赖，整体没了，部分依然可以在。</p>
<p>动物除却具体类型外，也可以按纲目划分。比如可以有一个水生动物类，而乌龟也可以属于水生动物。但是二者的关系并非那么强烈，即使水生动物类在代码中没有了，乌龟类依然可以存在。因此二者属于聚合关系，可用<strong>空心菱形直线</strong>表示。</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image__mx-L3DfW4.png" alt="" /></p>
</li>
<li>
<p>组合关系（Composition）：</p>
<p> 组合关系不同于聚合，其描述了比较强的依赖关系。比如有一个类A和类B，前者与后者强关联，有前者就会有后者，而且类A没了，类B也不复存在。此为组合关系，组合关系使用<strong>实心菱形直线</strong>表示。而且可以用数字表示，在这样的依赖关系中，每个类可以有几个实例。</p>
<p>当是1对1的关系时，也可以注解当前为has a还是is a关系。</p>
<p>比如在动物园中，每个懒猴都需要制定窝，一个猴可以有一个窝也可以有多个窝，当猴子不在了，与其绑定的窝也就拆毁了。</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_EChel9f6VJ.png" alt="" /></p>
</li>
</ul>
<p>因此，整体的类图如下所示：</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/class_test_y7PGig-rKD.png" alt="" /></p>
<ul>
<li>
<p>依赖关系：</p>
<p>上面的例子中没有提到依赖关系。依赖关系用一套带箭头的虚线表示，用于描述一个对象在运行期间会用到另一个对象的关系。</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_KyqJhsbeTU.png" alt="" /></p>
<p>如图表示A依赖于B。依赖有方向，而双向依赖是一种非常糟糕的结构，应总是保持单向依赖，杜绝双向依赖的产生。</p>
</li>
</ul>
<h2 id="用例图"><a class="markdownIt-Anchor" href="#用例图"></a> 用例图</h2>
<p>用例图可以分为四个主体：Systems、Actors、Use Cases、Relationships</p>
<ul>
<li>
<p>Systems：系统就是正在开发的东西，可以是app，可以是软件组件、网站等等。用一个长方形表示。比如下面的例子中，要开发一个银行应用，那么就画一个长方形，命名为Banking app</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_JkMI5Bfiix.png" alt="" /></p>
</li>
<li>
<p>Actors：用户就是使用系统来达成目标的人或物（比如一个组织、或外部设备）。</p>
<p>Actor在实际代码中要被视为类型。</p>
<p>在此例子中，可以分析出有两个Actor。首先是顾客，其下载App并进行现金存取。而另一个则是银行自己，银行向app提供信息，比如交易流水或账户余额。</p>
<blockquote>
<p>📌需要注意的是：<br />
1. Actor永远是外部对象，也就是说要始终置于描述System的方框外。<br />
2. Actor的定义不要太具体，比如不要把Bank这个Actor命名为建行。</p>
</blockquote>
<p>既然存在多个Actor，那么就引申出了Primary Actors和Secondary Actors的概念。前者主动启用系统，而后者则较为被动。在本例中，顾客为Primary Actor，他们会拿出手机，打开app再进行相关操作。而银行则是Secondary Actor，银行只会在顾客采取行动之后再行动。比如顾客在app上查询账户余额，此事银行才会参与系统提供信息。</p>
<p>Primary Actor放在System的左边，而Secondary Actor放在System的右边。</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_4PEEOGeed7.png" alt="" /></p>
</li>
<li>
<p>Use Cases：</p>
<p>用例用于描述系统的若干功能，用椭圆表示。它们被放在System中，因为用例是系统内部的动作。本例中，银行app有这么几项功能：顾客登录、查账、转账、付款。</p>
<blockquote>
<p>📌不同于Actor，Use Case需要具体。比如转账写成了Transfer Funds，但如果仅写Transfer，就会让人摸不着头脑。</p>
</blockquote>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_NcXLfHbvGQ.png" alt="" /></p>
</li>
<li>
<p>Relationships：</p>
<p>Relationship反映了actor与use case之间，以及use case与use case之间的关系、交流或互动。</p>
<ol>
<li>
<p>关联（Association）：用于描述Actor与Use Case之间的交互</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_pKnmoRy7CD.png" alt="" /></p>
</li>
<li>
<p>包含（Include）与扩展（Extend）：</p>
<ul>
<li>
<p>包含：包含关系显示了基本用例和包含用例之间的<strong>依赖关系</strong>。</p>
<p>每次执行基本用例（Base Use Case）时，包含用例（Included Use Case）也会被执行。为了表示包含关系，需要由基本用例向包含用例拉一条&lt;&lt;include&gt;&gt;的线。</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image__0BMljJHon.png" alt="" /></p>
</li>
<li>
<p>扩展：基本用例和扩展用例之间没有太严格的依赖关系。只有在执行基本用例，满足某些条件时，扩展用例才会被执行。因此可以理解为，<strong>扩展用例用于扩展基本用例的行为</strong>。为了表示扩展关系，需要由扩展用例向基本用例拉一条&lt;&lt;extend&gt;&gt;的线。</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_0KgZ9eRCub.png" alt="" /></p>
</li>
</ul>
<p>当顾客要登录app时，系统会验证顾客输入的密码，密码正确则登录成功，不正确则返回一条登录失败的信息。因此可以在系统中加上两个use case：验证密码、和打印登录错误信息。</p>
<p>每次执行Log in用例，都必须执行Verify Password用例，因此，二者间存在包含关系，前者包含后者。</p>
<p>而且，当执行Log in用例时，Display Login Error用例并不会总是执行，只有一种情况：密码错误时，才会得以执行。因此，二者间存在扩展关系。</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_vAbbVjx40d.png" alt="" /></p>
<blockquote>
<p>📌多个基本用例可以同时与某一个用例，产生包含或扩展关系。</p>
</blockquote>
<p>当顾客要转账时，系统也需要首先查看账户是否有足够的余额。因此还需要添加验证余额是否充足的用例。同时，用户要付款时（make payment），也需要用到查询余额是否充足的用例。因此可以让这两个基本用例，同时指向一个包含用例。</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_ibUD6jaxfN.png" alt="" /></p>
</li>
<li>
<p>泛化（Generalization）：</p>
<p>泛化，也可称为继承（inheritance），与面向对象中类的继承很相似。子用例（Specialized Use Cases）继承父用例（General Use Cases）的行为，但同时又可以添加自身的独特行为。从子用例向父用例拉一个下面这样的箭头表示继承关系。</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_0y67h-mcvx.png" alt="" /></p>
<p>比如本例中，付款可以分为从支票账户付款，也可以从储蓄账户付款。二者属于付款的子用例。</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_f8r81cnzno.png" alt="" /></p>
<p>除了对Use Case进行继承外，还可以让Actor之间有继承关系。比如顾客中可以分为老顾客和新顾客。而不管新老，它们都是顾客，但是可能具备独特的行为和属性，如果设计成类，可以有这样的继承关系：</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_ZR-aggSc9b.png" alt="" /></p>
</li>
<li>
<p>带扩展点的用例（Use Cases with extension points）</p>
<p>一个带扩展点的用例如下图所示，上面是用例名，下面是扩展点。扩展点详细描述了扩展关系。</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_J6ROHGk-HQ.png" alt="" /></p>
<p>比如用户可以在app中设置配置文件，因此可以有Set up Profile用例，而拓展点表示，当用户进入Set up Profile时，可以导航到几个不同的界面。如果顾客不知道该如何导航，可以访问配置文件帮助，如果顾客需要询问私人信息，可以去隐私信息界面去查看。扩展点指向对应的扩展用例。同时还可以设置<strong>注释</strong>，注明当满足什么条件时会引导到相应的扩展点。</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_UX7gfhHr6j.png" alt="" /></p>
</li>
</ol>
</li>
</ul>
<p>最终就得到了这样一个银行app的用例图示例：</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/use_case_TSxykT_OIm.png" alt="" /></p>
<h2 id="时序序列图"><a class="markdownIt-Anchor" href="#时序序列图"></a> 时序/序列图</h2>
<blockquote>
<p>时序图显示了代码中的类/对象在其执行顺序过程中的相互作用，换言之，其显示了序列事件。</p>
</blockquote>
<p>下面以一个ATM机存取，导致的银行系统执行流程来理解时序图。</p>
<ul>
<li>
<p>objects（对象）&amp; actor（参与者）：</p>
<p>一个人去ATM机取钱，ATM机将于银行服务器通信，之后那个人的账户就会被存取。ATM机、银行服务器和银行账户，三者均属于银行系统。因此这三项可以算作objects。而那个人不属于银行系统，而且他来引发的事件，因此他是一名actor。</p>
<p>画图时actor放在系统左边，在其右陆续画对象，按照与actor的远近画（比如ATM机与人的关系最近，因此右边的第一个对象是ATM机）</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_trdsYDdxEi.png" alt="" /></p>
</li>
<li>
<p>lifelines（生命线）</p>
<p>生命线是位于对象下方垂直的虚线，显示着一个对象或者参与者存在的时间。沿着生命线向下代表着时间的流逝。</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_W5xw_j8CIc.png" alt="" /></p>
</li>
<li>
<p>messages（信息）</p>
<p>messages在对象之间传递，以表示相互作用时的动作或信息。各对象的message沿着生命线向下挪动，表示事件的前后发生关系。</p>
<p>考虑整个系统的执行顺序，actor来到ATM机前的第一件事就是插入银行卡；接着ATM机与银行服务器通信来核对此卡是否有效；银行服务器将查询并向ATM机返回核对结果。</p>
<p>插入卡片，通信要求核对，均属于信息，由实线箭头表示。而返回核对结果，则属于<strong>返回信息</strong>（return/reply message），由虚线箭头表示。</p>
<blockquote>
<p>📌需注意，返回信息并没有明确的方向，可以从右指向左，也可以从左指向右，需要视具体情况而定。</p>
</blockquote>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_-cM53juFhs.png" alt="" /></p>
<p>但是在返回信息的时候，问题出现了。有两种可能的回复信息，卡可用，或者不可用。那么如何在同一张图描述两种可能情况的发生呢，UML的解决方案是alternative frame。</p>
</li>
<li>
<p>Alternative Frame（选项）</p>
<p>当银行服务器反馈，此时卡有效时，ATM机就会要求actor输入卡密码；而当反馈卡无效时，就会将卡弹出。</p>
<p>由于要求输入密码这一事件，并不是在回应，因此不归属于返回信息，要用实线箭头画。Alternative frame中，左边写条件，并用虚线划分两个条件对应的行为。</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_LTFo_mo471.png" alt="" /></p>
<p>剩下的操作就是顺理成章的银行取钱操作。卡有效后，用户会输入密码，银行服务器反馈密码是否正确。密码正确后，用户输入需要取钱的金额，银行服务器会向银行账户核实是否有足够多的钱。</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_kP5-Yda8Cq.png" alt="" /></p>
</li>
<li>
<p>Activation Boxes（激活框）：</p>
<p>Activation boxes显示对象进程的开始时间和结束时间。通过激活框可以轻松看到对象何时处于活动状态，何时处于空闲状态。下面根据messages来给各个对象加上激活框。</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/sequence_test.drawio_PZeOtyidOi.png" alt="" /></p>
<p>通过激活框可以看出，银行账户对象显然比另外两个对象更不活跃。</p>
<blockquote>
<p>📌激活框只能作用于objects，不能作用于actors。</p>
</blockquote>
</li>
</ul>
<h1 id="面向对象"><a class="markdownIt-Anchor" href="#面向对象"></a> 面向对象</h1>
<ul>
<li>
<p>相比于面向过程，为什么项目开发使用面向对象？</p>
<p>古早的程序需求足够简单，整个程序的处理流程只有一条主线，很容易被划分成顺序执行的几个步骤，很适合面向过程风格。</p>
<p>但对于大规模复杂程序的开发来说，整个程序的处理流程错综复杂，画出来的话会是一个网状结构，再用面向过程来思考会比较吃力，此时面向对象的思维将更具优势。即，将需求翻译为类，并且在类之间建立交互关系。</p>
<p>除此之外，面向对象也强制程序员将代码的组织方式更清晰、更模块化。</p>
</li>
</ul>
<h2 id="四大特性"><a class="markdownIt-Anchor" href="#四大特性"></a> 四大特性</h2>
<blockquote>
<p>四大特性：封装、抽象、继承、多态。这四大特性使得程序相比于面向过程风格的代码，更加易扩展、易复用、易维护。</p>
</blockquote>
<ol>
<li>
<p>封装：信息隐藏/数据访问保护，类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（比如方法）来访问内部信息或者数据。</p>
<p>如果对类中的属性不做限制，任何代码都能访问、修改的话，意味着不可控。即属性可能被随意地以各种方式修改，而且修改逻辑可能散落在代码中的各个角落，影响代码的可读性、可维护性。</p>
<p>另一方面，仅暴露必要的操作，也能提高类的易用性。调用者只需使用api就好，不必过于细致的了解业务逻辑，减少心智负担。而且用错的概率会减少。</p>
</li>
<li>
<p>抽象：抽象通常由接口、抽象类来实现。其隐藏方法的具体实现，让调用者只需关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。</p>
<p>通过抽象，一方面降低调用者的操作难度，另一方面可以保持兼容能力，即使具体类的具体实现更改了，也不会影响到上层代码。</p>
</li>
<li>
<p>继承：继承表示类之间的is-a关系，比如猫是一种哺乳动物。</p>
<p>继承的主要作用在于代码复用，可以避免代码重复写很多遍。但是继承层次过深也会导致代码可读性差、可维护性变差。</p>
</li>
<li>
<p>多态：子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。</p>
<p>多态代码的作用在于提高代码的可扩展性和复用性。比如一个<code>print(Animal var)</code>就可以打印所有类型动物的信息。多态是众多设计模式实现的基石。</p>
</li>
</ol>
<h2 id="基于接口而非实现编程"><a class="markdownIt-Anchor" href="#基于接口而非实现编程"></a> 基于接口而非实现编程</h2>
<blockquote>
<p>Program to an interface, not an implementation</p>
</blockquote>
<p>从本质上来看，“接口”就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”。这条原则希望，实际代码中，上层代码多用抽象出来的接口，而非具体实现了功能的类。这样可以带来好处：</p>
<ul>
<li>
<p><strong>接口与实现相分离</strong>。封装不稳定的实现，暴露稳定的接口。这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此降低耦合性，提高扩展性。</p>
<p><strong>好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对</strong>。</p>
</li>
</ul>
<h2 id="多用组合少用继承"><a class="markdownIt-Anchor" href="#多用组合少用继承"></a> 多用组合少用继承</h2>
<p>继承的弊端不仅局限于简单继承的层次过深问题。考虑“鸟”这个类：</p>
<ol>
<li>
<p>方法选择受限：</p>
<p>大部分鸟都会飞，那么可不可以在AbstractBird抽象类中，定义一个fly方法呢？</p>
<ul>
<li>
<p>如果定义了，依然有一些鸟是不会飞的，比如鸵鸟，但是鸵鸟类中却仍然有fly方法，即使将鸵鸟类中的fly内部写抛出异常的代码，也不会强制程序员在写代码时避免让 鸵鸟等鸟类fly，在后续扩展中难免有漏网之鱼，导致错误。</p>
</li>
<li>
<p>如果不定义，那么当会飞的鸟类想fly时，就要多写很多实现他们fly方法的代码，有悖于“继承提高代码复用”的目的。</p>
</li>
</ul>
</li>
<li>
<p>派生关系复杂：</p>
<p>那么是否可以给AbstractBird派生两个类，一个会飞鸟类，一个不会飞鸟类，再在会飞类里派生具体的鸟类，不会飞鸟类里派生鸵鸟类。</p>
<p>表面上这样可以解决问题，但是在后面的扩展中，这样的设计可能会带来更为严重的问题。比如此时需求变更，还想加上Tweet方法，即让鸟儿叫出来。沿袭刚才的思路，AbstractBird派生出来了四个类：会飞会叫、会飞不会叫、不会飞会叫、不会飞不会叫。两个功能衍生出了四种组合。也就是n个功能会有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>种组合，呈指数形式变化。</p>
<p>那么后面还要加下蛋（判断是否会下蛋）等功能，将会组合爆炸。这样继承的关系越来越复杂，可读性极差，而且极难维护。</p>
</li>
</ol>
<blockquote>
<p>📌继承主要有三个作用：表示is-a关系，支持多态特性，代码复用。而这三个作用都可以通过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题。</p>
</blockquote>
<ul>
<li>
<p>组合、接口、委托的实现方案：</p>
<p>针对不同需求，定义不同的接口，之后每个鸟类将这些接口组合在一起。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Tweetable</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">tweet</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EggLayable</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">layEgg</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ostrich</span> <span class="keyword">implements</span> <span class="title class_">Tweetable</span>, EggLayable &#123;<span class="comment">//鸵鸟</span></span><br><span class="line">  <span class="comment">//... 省略其他属性和方法...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tweet</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">layEgg</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sparrow</span> impelents Flayable, Tweetable, EggLayable &#123;<span class="comment">//麻雀</span></span><br><span class="line">  <span class="comment">//... 省略其他属性和方法...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tweet</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">layEgg</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口只声明方法，不定义实现。也就是说，每个会下蛋的鸟都要实现一遍layEgg()方法，并且实现逻辑是一样的，这就会导致代码重复的问题。可以通过组合+委托的方式来消除代码重复。针对三个接口再定义三个实现类，它们分别是：实现了fly()方法的FlyAbility类、实现了tweet()方法的TweetAbility类、实现了layEgg()方法的EggLayAbility类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlyAbility</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//省略Tweetable/TweetAbility/EggLayable/EggLayAbility</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ostrich</span> <span class="keyword">implements</span> <span class="title class_">Tweetable</span>, EggLayable &#123;<span class="comment">//鸵鸟</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">TweetAbility</span> <span class="variable">tweetAbility</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TweetAbility</span>(); <span class="comment">//组合</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">EggLayAbility</span> <span class="variable">eggLayAbility</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EggLayAbility</span>(); <span class="comment">//组合</span></span><br><span class="line">  <span class="comment">//... 省略其他属性和方法...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tweet</span><span class="params">()</span> &#123;</span><br><span class="line">    tweetAbility.tweet(); <span class="comment">// 委托</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">layEgg</span><span class="params">()</span> &#123;</span><br><span class="line">    eggLayAbility.layEgg(); <span class="comment">// 委托</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是组合+接口+委托，达成了代码重复少、也不必再有复杂继承关系的目的。</p>
</li>
</ul>
<h1 id="设计原则"><a class="markdownIt-Anchor" href="#设计原则"></a> 设计原则</h1>
<blockquote>
<p>SOLID原则：由5个设计原则组成，分别是，单一职责原则、开闭原则、里氏替换原则、接口隔离原则和依赖反转原则，对应S、O、L、I、D 5个英文字母</p>
</blockquote>
<h2 id="单一职责原则single-responsibility-principle-srp"><a class="markdownIt-Anchor" href="#单一职责原则single-responsibility-principle-srp"></a> 单一职责原则（Single Responsibility Principle, SRP）</h2>
<blockquote>
<p>一个类/模块只负责完成一个职责（或者功能）</p>
</blockquote>
<p>一个类只负责完成一个职责或者功能。也就是说，不要设计大而全的类，要设计粒度小、功能单一的类。换个角度就是，一个类包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一，应该将它拆分成多个功能更加单一、粒度更细的类。</p>
<p> 以下几点可以辅助判断类的职责是否足够单一：</p>
<ul>
<li>
<p>类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分；</p>
</li>
<li>
<p>类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分；</p>
</li>
<li>
<p>私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为public方法，供更多的类使用，从而提高代码的复用性；</p>
</li>
<li>
<p>比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的Manager、Context之类的词语来命名，这就说明类的职责定义得可能不够清晰；</p>
</li>
<li>
<p>类中大量的方法都是集中操作类中的某几个属性，比如，在UserInfo例子中，如果一半的方法都是在操作address信息，那就可以考虑将这几个属性和对应的方法拆分出来。</p>
</li>
</ul>
<h2 id="开闭原则对扩展开放-修改关闭open-closed-principle"><a class="markdownIt-Anchor" href="#开闭原则对扩展开放-修改关闭open-closed-principle"></a> 开闭原则：对扩展开放、修改关闭（Open Closed Principle）</h2>
<p>添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。</p>
<p>体现在C++代码的话，用父类指针去指向子类，体现了这样的开闭原则：</p>
<p>比如定义一个Calculator抽象类，通过子类继承的方式扩展出加减乘除的功能：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算器类  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//抽象接口类，子类实现</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">getompute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">getParam</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//除</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Division</span> : <span class="keyword">public</span> Calculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">getompute</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mA / mB;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">getParam</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    mA = a;</span><br><span class="line">    mB = b;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">double</span> mA;</span><br><span class="line">  <span class="type">double</span> mB;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//乘</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Multiplication</span> : <span class="keyword">public</span> Calculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">getompute</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mA * mB;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">getParam</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    mA = a;</span><br><span class="line">    mB = b;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">double</span> mA;</span><br><span class="line">  <span class="type">double</span> mB;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//减</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subtraction</span> : <span class="keyword">public</span> Calculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">getompute</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mA - mB;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">getParam</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    mA = a;</span><br><span class="line">    mB = b;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">double</span> mA;</span><br><span class="line">  <span class="type">double</span> mB;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//加</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Addition</span> : <span class="keyword">public</span> Calculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">getompute</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mA + mB;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">getParam</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    mA = a;</span><br><span class="line">    mB = b;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">double</span> mA;</span><br><span class="line">  <span class="type">double</span> mB;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Calculator* Add = <span class="keyword">new</span> Addition;</span><br><span class="line">  Add-&gt;<span class="built_in">getParam</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">  <span class="type">double</span> c = Add-&gt;<span class="built_in">getompute</span>();</span><br><span class="line">  cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么此时，还想添加一个求根的功能，就只需再添加一个求根运算的子类即可。</p>
<h2 id="里式替换原则liskov-substitution-principle"><a class="markdownIt-Anchor" href="#里式替换原则liskov-substitution-principle"></a> 里式替换原则（Liskov Substitution Principle）</h2>
<p>子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。也就是子类对象替换了父类对象的内在实现，但是对外的接口保持与父类对象一致。</p>
<p>明显违背LSP的代码：</p>
<ul>
<li>
<p>子类违背父类声明要实现的功能</p>
<p>比如父类中提供的sortByAmount()函数，是按照类中的金额属性进行从小到大的排序，而子类重写此函数时，是按照日期属性进行排序的。那么子类的设计就违背了里式替换原则。</p>
</li>
<li>
<p>子类违背父类对输入、输出、异常的约定</p>
<p>比如父类中的某个函数约定了：</p>
<ol>
<li>
<p>运行出错时返回null；获取数据为空时返回空集合。而子类重载函数之后，实现变了，运行出错返回异常，获取不到数据返回null；</p>
</li>
<li>
<p>输入数据可以是任意整数，但子类实现的时候，只允许输入数据是正整数，负数就抛出；</p>
</li>
<li>
<p>约定只会抛出A异常，子类实现时却只允许抛出B异常</p>
</li>
</ol>
<p>这些都导致子类违背里式替换原则。</p>
</li>
<li>
<p>子类违背父类注释中所罗列的任何特殊说明</p>
</li>
</ul>
<blockquote>
<p>📌理解LSP，最核心就是理解“按照协议设计”，即父类定义了函数的“协议”，那么子类可以改变函数的内部实现逻辑，但不能改变函数原有的“协议”。</p>
</blockquote>
<h2 id="接口隔离原则interface-segregation-principle"><a class="markdownIt-Anchor" href="#接口隔离原则interface-segregation-principle"></a> 接口隔离原则（Interface Segregation Principle）</h2>
<p>接口的调用者/使用者，不应该被强迫去依赖它不需要的接口。</p>
<p>这里的接口Interface不局限于编程语言里的类似于抽象类的接口，而是可理解为：</p>
<ol>
<li>
<p>一组API接口集合</p>
<p>如果部分接口只被部分调用者使用，就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。</p>
</li>
<li>
<p>单个API接口或函数</p>
<p>部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。</p>
</li>
<li>
<p>OOP中的接口概念</p>
<p>接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。</p>
</li>
</ol>
<blockquote>
<p>📌单一职责原则针对的是模块、类、接口的设计。接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面也是为单一职责的判定提供了一种新思路。<br />
可以通过调用者如何使用接口来间接判定设计是否够职责单一。</p>
</blockquote>
<h2 id="依赖反转原则dependency-inversoin-principle"><a class="markdownIt-Anchor" href="#依赖反转原则dependency-inversoin-principle"></a> 依赖反转原则（Dependency Inversoin Principle）</h2>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yyxt/p/5141577.html">https://www.cnblogs.com/yyxt/p/5141577.html</a></p>
<h3 id="依赖反转"><a class="markdownIt-Anchor" href="#依赖反转"></a> 依赖反转</h3>
<p>应用程序依赖于类库，那么一旦类库发生变化，应用程序也要相应改变。为了破除这种依赖关系，可以使用依赖反转。</p>
<p>在类库中抽象出一个接口，具体的实现类派生自接口，应用程序也调用接口，这样做：</p>
<ol>
<li>
<p>应用程序调用类库的抽象接口，依赖于类库的抽象接口；具体的实现类派生自类库的抽象接口，也依赖于类库的抽象接口。</p>
</li>
<li>
<p>应用程序和具体的类库实现完全独立，相互之间没有直接的依赖关系，只要保持接口类的稳定，应用程序和类库的具体实现都可以独立地发生变化。</p>
</li>
<li>
<p>类库完全可以独立重用，应用程序可以和任何一个实现了相同抽象接口的类库协同工作。</p>
</li>
</ol>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_ETQzqXUn8L.png" alt="" /></p>
<h3 id="控制反转"><a class="markdownIt-Anchor" href="#控制反转"></a> 控制反转</h3>
<p>框架系统与类库：</p>
<ul>
<li>
<p>框架是一个“半成品”的应用程序，而类库只包含一系列可被应用程序调用的类。</p>
</li>
<li>
<p>类库给用户提供了一系列可复用的类，用户使用时，可以创建这些类的实例，或者从这些类中继承出新的派生类，然后调用类中相应的功能。在这过程中，类库总是被动地响应用户的调用请求。</p>
</li>
<li>
<p>框架则会为某一特定目的实现一个基本的、可执行的架构。框架中已经包含了应用程序从启动到运行的主要流程，流程中那些无法预先确定的步骤留给用户来实现。程序运行时框架系统会自动调用用户实现的功能组件。这个过程中，框架的行为是主动的。</p>
</li>
</ul>
<p>设计框架是控制反转的典型应用场景。以一个GUI框架为例，最简单的方式如左图，应用程序通过框架中的CreateWindow函数创建窗口，但是GUI框架并不知道窗口接收到消息以后该如何处理，所以接收到消息时会调用应用程序中的窗口函数。而这形成了双向依赖关系。</p>
<p>这种双向依赖关系缺陷较严重：换一个新的应用程序，甚至可能需要修改GUI框架。</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_VVVa9OaJk4.png" alt="" /></p>
<p>使用<strong>控制反转</strong>可以消除这样的依赖，也就是将主控权从应用程序转移到框架。在调用CreateWindow时，其接收一个函数指针参数，该函数指针指向用户实现的消息处理函数。因此，当GUI框架接收到消息时，通过该指针自动处理消息。这就是<strong>动态调用机制</strong>，也被称为<strong>回调函数</strong>。此时改变应用程序，只会改变自定义行为，GUI框架无需更改。</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image__fRxSpewKb.png" alt="" /></p>
<h3 id="依赖注入"><a class="markdownIt-Anchor" href="#依赖注入"></a> 依赖注入</h3>
<p>不通过new()的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。</p>
<p>比如上面实现控制反转的方式：向CreateWindow中注入消息处理的函数指针，就可以理解为一种特殊的，面向过程的依赖注入。</p>
<blockquote>
<p>📌<strong>控制反转</strong>是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导框架层面的设计。<br />
<strong>依赖注入</strong>是实现控制反转的一种具体的编码技巧。<br />
<strong>依赖反转</strong>也是一种设计思想，指导框架层面的设计。高层模块不依赖低层模块，而是二者共同依赖同一个抽象。</p>
</blockquote>
<h2 id="kiss原则"><a class="markdownIt-Anchor" href="#kiss原则"></a> KISS原则</h2>
<blockquote>
<p>Keep It Simple and Stupid<br />
Keep It Short and Simple<br />
Keep It Simple and Straightforward</p>
</blockquote>
<p>尽量把代码写得简单，虽然“简单”的定义很模糊。</p>
<ul>
<li>
<p>不要使用同事可能不懂的技术来实现代码。</p>
</li>
<li>
<p>不要重复造轮子，要善于使用已经有的工具类库。</p>
</li>
<li>
<p>不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。</p>
</li>
</ul>
<h3 id="yagni原则"><a class="markdownIt-Anchor" href="#yagni原则"></a> YAGNI原则</h3>
<blockquote>
<p>You Ain’t Gonna Need It</p>
</blockquote>
<p>不要去设计当前用不到的功能；不要去编写当前用不到的代码——不要做过度设计。</p>
<p>比如，系统暂时只用Redis存储配置信息，以后可能会用到zookeeper。根据YAGNI原则，在未用到ZooKeeper之前，没必要提前编写这部分代码。</p>
<p>再比如，不要在项目中提前引入不需要依赖的开发包。</p>
<h2 id="dry原则dont-repeat-yourself"><a class="markdownIt-Anchor" href="#dry原则dont-repeat-yourself"></a> DRY原则（Don’t Repeat Yourself）</h2>
<blockquote>
<p>不要写重复的代码</p>
</blockquote>
<p>有三种代码重复的情况：实现逻辑重复、功能语义重复、代码执行重复。出现这三种情况后，需要去进一步优化。</p>
<p>但是“实现逻辑重复，功能语义不重复的代码”并不违反DRY原则。</p>
<h2 id="迪米特法则law-of-demeter"><a class="markdownIt-Anchor" href="#迪米特法则law-of-demeter"></a> 迪米特法则（Law of Demeter）</h2>
<blockquote>
<p>别名：最小知识原则（The Least Knowlwdge Principle）</p>
</blockquote>
<ul>
<li>
<p>何为“高内聚、松耦合”？</p>
<ul>
<li>
<p>高内聚：</p>
<p>相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护。单一职责原则是实现代码高内聚非常有效的设计原则。</p>
</li>
<li>
<p>松耦合：</p>
<p>在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动。</p>
<p>依赖注入、接口隔离、基于接口而非实现编程，以及迪米特法则，都是为了实现代码的松耦合。</p>
</li>
</ul>
</li>
<li>
<p>最小知识：</p>
<p>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。</p>
</li>
</ul>
<h1 id="编程规范"><a class="markdownIt-Anchor" href="#编程规范"></a> 编程规范</h1>
<h3 id="1-命名的长度"><a class="markdownIt-Anchor" href="#1-命名的长度"></a> 1. 命名的长度</h3>
<p>命名一定要准确达意。对于一些默认的、大家都比较熟知的词，比较推荐用缩写。这样一方面能让命名短一些，另一方面又不影响阅读理解，比如，sec表示second、str表示string、num表示number、doc表示document。除此之外，对于作用域比较小的变量，可以使用相对短的命名，比如一些函数内的临时变量。相反，对于类名这种作用域比较大的，更推荐用长的命名方式。</p>
<h3 id="2-利用上下文简化命名"><a class="markdownIt-Anchor" href="#2-利用上下文简化命名"></a> 2. 利用上下文简化命名</h3>
<p>比如下面的代码，成员变量和成员方法都借助了User这样的类名上下文，省去了命名时重复添加前缀“user”的麻烦。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  string name;       <span class="comment">//string userName;借助User类这个上下文</span></span><br><span class="line">  string password;   <span class="comment">//string userPassword;</span></span><br><span class="line">  string avatarUrl;  <span class="comment">//string userAvatarUrl;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">string <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">string <span class="title">getPassword</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">string <span class="title">getAvatarUrl</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  User user = <span class="keyword">new</span> <span class="built_in">User</span>();</span><br><span class="line">  user.<span class="built_in">getName</span>();   <span class="comment">//借助user对象这个上下文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-命名要可读-可搜索"><a class="markdownIt-Anchor" href="#3-命名要可读-可搜索"></a> 3. 命名要可读、可搜索</h3>
<h3 id="4-命名接口和抽象类"><a class="markdownIt-Anchor" href="#4-命名接口和抽象类"></a> 4. 命名接口和抽象类</h3>
<ul>
<li>
<p>接口：有两种常见的方式</p>
<ul>
<li>
<p>加前缀“I”表示一个Interface，比如IUserService，对应的实现类命名为UserService。</p>
</li>
<li>
<p>不加前缀，比如UserService，对应的实现类加后缀“Impl”，比如UserServiceImpl。</p>
</li>
</ul>
</li>
<li>
<p>抽象类：有两种常见的方式</p>
<ul>
<li>
<p>加前缀“Abstract”，比如AbstractConfiguration。</p>
</li>
<li>
<p>不带前缀，让对应类加后缀“Impl”或者其他与功能相关的命名。</p>
</li>
</ul>
</li>
</ul>
<h3 id="5-注释写什么"><a class="markdownIt-Anchor" href="#5-注释写什么"></a> 5. 注释写什么</h3>
<p>注释的内容主要需要包含三方面：做什么、为什么、怎么做。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* (what) Bean factory to create beans. </span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* (why) The class likes Spring IOC framework, but is more lightweight. </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* (how) Create objects from different sources sequentially:</span></span><br><span class="line"><span class="comment">* user specified object &gt; SPI &gt; configuration &gt; default object.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BeansFactory</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-注释的多少"><a class="markdownIt-Anchor" href="#6-注释的多少"></a> 6. 注释的多少</h3>
<p>类和函数一定要写注释，而且要写得尽可能全面、详细，而函数内部的注释要相对少一些。一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码的可读性。</p>
<h3 id="7-类-函数多大才合适"><a class="markdownIt-Anchor" href="#7-类-函数多大才合适"></a> 7. 类、函数多大才合适</h3>
<p>事实上很难界定，太多或太少都不合适。</p>
<ul>
<li>
<p>函数：有一种说法是函数代码的行数，最好不要超过一个显示屏的垂直高度。</p>
</li>
<li>
<p>类：主要主观来判断，当一个类的代码读起来让你感觉头大了，实现某个功能时不知道该用哪个函数了，想用哪个函数翻半天都找不到了，只用到一个小功能要引入整个类（类中包含很多无关此功能实现的函数）的时候，这就说明类的行数过多了</p>
</li>
</ul>
<h3 id="8-一行代码多长最合适"><a class="markdownIt-Anchor" href="#8-一行代码多长最合适"></a> 8. 一行代码多长最合适</h3>
<p>Google Java Style Guide文档中，一行代码最长限制为100个字符。遵循的原则是：最长最好不要超过IDE显示的宽度。</p>
<h3 id="9-善用空行分割单元块"><a class="markdownIt-Anchor" href="#9-善用空行分割单元块"></a> 9. 善用空行分割单元块</h3>
<p>对于比较长的函数，如果逻辑上可以分为几个独立的代码块，在不方便将这些独立的代码块抽取成小函数的情况下，使得逻辑更加清晰。</p>
<p>除此之外，在类的成员变量与函数之间、静态成员变量与普通成员变量之间、各函数之间、甚至各成员变量之间，我们都可以通过添加空行的方式，让这些不同模块的代码之间，界限更加明确。</p>
<h3 id="10-四格缩进还是两格缩进"><a class="markdownIt-Anchor" href="#10-四格缩进还是两格缩进"></a> 10. 四格缩进还是两格缩进</h3>
<p>不固定，最好和业内推荐的风格统一、跟著名开源项目统一。</p>
<p>缩进时尽量别用tab键。因为在不同的IDE下，tab键的显示宽度不同，有的显示为四格缩进，有的显示为两格缩进。如果在同一个项目中，不同的同事使用不同的缩进方式（空格缩进或tab键缩进），有可能会导致有的代码显示为两格缩进、有的代码显示为四格缩进。</p>
<h3 id="11-大括号是否要另起一行"><a class="markdownIt-Anchor" href="#11-大括号是否要另起一行"></a> 11. 大括号是否要另起一行</h3>
<p>只要团队统一、业内统一、跟开源项目看齐就好了，没有绝对的优劣之分。</p>
<h3 id="12-把代码分割成更小的单元块"><a class="markdownIt-Anchor" href="#12-把代码分割成更小的单元块"></a> 12. 把代码分割成更小的单元块</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重构前的代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invest</span><span class="params">(<span class="type">long</span> userId, <span class="type">long</span> financialProductId)</span> &#123;</span><br><span class="line">  <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">  calendar.setTime(date);</span><br><span class="line">  calendar.set(Calendar.DATE, (calendar.get(Calendar.DATE) + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span> (calendar.get(Calendar.DAY_OF_MONTH) == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重构后的代码：提炼函数之后逻辑更加清晰</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invest</span><span class="params">(<span class="type">long</span> userId, <span class="type">long</span> financialProductId)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (isLastDayOfMonth(<span class="keyword">new</span> <span class="title class_">Date</span>())) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLastDayOfMonth</span><span class="params">(Date date)</span> &#123;</span><br><span class="line">  <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">  calendar.setTime(date);</span><br><span class="line">  calendar.set(Calendar.DATE, (calendar.get(Calendar.DATE) + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span> (calendar.get(Calendar.DAY_OF_MONTH) == <span class="number">1</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-避免函数参数过多"><a class="markdownIt-Anchor" href="#13-避免函数参数过多"></a> 13. 避免函数参数过多</h3>
<p>函数包含3、4个参数的时候还是能接受的，大于等于5个的时候，会认为参数有点多了，影响代码的可读性，使用起来也不方便。针对参数过多，一般有2种处理方法：</p>
<ul>
<li>
<p>考虑函数是否职责单一，是否能通过拆分成多个函数的方式来减少参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">User <span class="title">getUser</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拆分成多个函数</span></span><br><span class="line"><span class="function">User <span class="title">getUserByUsername</span><span class="params">(string username)</span></span>;</span><br><span class="line"><span class="function">User <span class="title">getUserByTelephone</span><span class="params">(string telephone)</span></span>;</span><br><span class="line"><span class="function">User <span class="title">getUserByEmail</span><span class="params">(string email)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>将函数的参数封装成对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postBlog</span><span class="params">(string title, string summary, string keywords, string content, string category, <span class="type">long</span> authorId)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将参数封装成对象</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Blog</span>&#123;</span><br><span class="line">  string title;</span><br><span class="line">  string summary;</span><br><span class="line">  string keywords;</span><br><span class="line">  string content;</span><br><span class="line">  string category;</span><br><span class="line">  <span class="type">long</span> authorId;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postBlog</span><span class="params">(Blog blog)</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数参数封装成对象还可以带来一个好处：如果函数是对外暴露的抽象接口，将参数封装成对象，可以提高接口的兼容性。当有需要往接口中添加新的参数时，老的接口调用者就不需要修改代码来兼容新的接口了。</p>
</li>
</ul>
<h3 id="14-勿用函数参数来控制逻辑"><a class="markdownIt-Anchor" href="#14-勿用函数参数来控制逻辑"></a> 14. 勿用函数参数来控制逻辑</h3>
<ul>
<li>
<p>函数参数为布尔类型，控制了内部逻辑，true的时候走这块逻辑，false的时候走另一块逻辑。这违背了单一职责原则和接口隔离原则，因此建议拆分成两个函数，可读性上也要更好。</p>
</li>
<li>
<p>上面这条并不是必须要遵守的。如果函数是private私有函数，影响范围有限，或者拆分后的两函数经常被同时调用，可以酌情考虑保留该标识参数。</p>
</li>
<li>
<p>有一种“根据参数是否为null”来控制逻辑的情况。和布尔类型类似，有该参数的函数也可以通过判断条件进行函数拆分。</p>
</li>
</ul>
<h3 id="15-函数设计要职责单一"><a class="markdownIt-Anchor" href="#15-函数设计要职责单一"></a> 15. 函数设计要职责单一</h3>
<p>函数和类的设计均要满足单一职责原则。</p>
<h3 id="16-移除过深的嵌套层次"><a class="markdownIt-Anchor" href="#16-移除过深的嵌套层次"></a> 16. 移除过深的嵌套层次</h3>
<p>代码嵌套层次过深往往是因为if-else、switch-case、for循环过度嵌套导致的，建议嵌套不超过两层。</p>
<p>有下面4种常见的解决嵌套过深的思路：</p>
<ul>
<li>
<p>去掉多余的if或else语句</p>
</li>
<li>
<p>使用continue、break、return关键字，提前退出嵌套</p>
</li>
<li>
<p>调整执行顺序来减少嵌套</p>
</li>
<li>
<p>将部分嵌套逻辑封装成函数调用，以此来减少嵌套</p>
</li>
</ul>
<h3 id="17-学会使用解释性变量"><a class="markdownIt-Anchor" href="#17-学会使用解释性变量"></a> 17. 学会使用解释性变量</h3>
<p>常用的用解释性变量来提高代码可读性的情况有下面 2种：</p>
<ul>
<li>
<p>常量取代魔法数字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">CalculateCircularArea</span><span class="params">(<span class="type">double</span> radius)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">3.1415</span>) * radius * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>解释性变量来解释复杂表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.1415</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">CalculateCircularArea</span><span class="params">(<span class="type">double</span> radius)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> PI * radius * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="gof23种设计模式"><a class="markdownIt-Anchor" href="#gof23种设计模式"></a> GoF——23种设计模式</h1>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_wZCYDEcI8Y.png" alt="" /></p>
<ul>
<li>
<p>创建型模式：用于描述“怎样创建对象”，其主要特点是“将对象的创建与使用分离”。</p>
</li>
<li>
<p>结构型模式：用于描述如何将类或对象按某种布局组成更大的结构。</p>
</li>
<li>
<p>行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。</p>
</li>
</ul>
<h2 id="创建型"><a class="markdownIt-Anchor" href="#创建型"></a> 创建型</h2>
<blockquote>
<p>📌工厂(5) &gt; 单例(4) &gt; 原型(3) &gt; 建造者(2)</p>
</blockquote>
<h3 id="1-单例模式singleton"><a class="markdownIt-Anchor" href="#1-单例模式singleton"></a> 1 单例模式（Singleton）</h3>
<p>单例模式表示一个类只会有一个对象，当程序想创建新的对象时，创建的新对象其实和之前创建的对象在一个地址，即名义上的多个对象实际只有一个。单例模式分为懒汉式和饿汉式两种：</p>
<ul>
<li>
<p>懒汉式：类加载时没有生成单例。第一次调用getInstance方法时才去创建；</p>
</li>
<li>
<p>饿汉式：类一旦加载就创建一个单例，相比于懒汉式更加线程安全，但是也会丢失延迟实例化所带来的节约资源的好处。</p>
</li>
</ul>
<h4 id="栈上单例懒汉式"><a class="markdownIt-Anchor" href="#栈上单例懒汉式"></a> 栈上单例（懒汉式）</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ~<span class="built_in">Singleton</span>()&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;~Singleton() destruct&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">CreateObject</span><span class="params">()</span></span>&#123; <span class="comment">//用户只能通过此函数构造对象</span></span><br><span class="line">    <span class="type">static</span> Singleton obj;           <span class="comment">//静态以单例</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Singleton</span>(Singleton&amp; obj) = <span class="keyword">delete</span>;             <span class="comment">//禁用拷贝构造函数</span></span><br><span class="line">  Singleton* <span class="keyword">operator</span>= (Singleton&amp; obj) = <span class="keyword">delete</span>; <span class="comment">//禁用拷贝构造函数，与上一行二者择一</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">Singleton</span>() &#123;                     <span class="comment">//封闭构造函数，不让用户有接触到构造函数的机会</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Singleton() construct&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Singleton&amp; pObj1 = Singleton::<span class="built_in">CreateObject</span>();</span><br><span class="line">  Singleton&amp; pObj2 = Singleton::<span class="built_in">CreateObject</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>CreateObject是static函数：</p>
<p>避开无对象时没法调用构造函数创建对象的死结，直接用静态函数构造对象</p>
</li>
<li>
<p>CreateObject返回的是引用而不是指针：</p>
<p>虽说也可以用指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> Singleton* m_pObject = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function"><span class="type">static</span> Singleton* <span class="title">CreateObject</span><span class="params">()</span></span>&#123; <span class="comment">//用户只能通过此函数构造对象</span></span><br><span class="line">    <span class="keyword">if</span>(m_pObject == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">      m_pObject = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_pObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这么写存在的问题是，因为是指针，因为用了new，所以可能存在内存泄露问题。即使用户可以在main函数里<code>delete pObj1</code>，而且编译不会报错，但此时Singleton不再是线程安全的了。</p>
</li>
<li>
<p>禁用拷贝构造函数：</p>
<p>传回的是引用，但若允许拷贝构造函数，这么写时仍不会报错</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Singleton pObj2 = Singleton::<span class="built_in">CreateObject</span>();</span><br></pre></td></tr></table></figure>
<p>此时的pObj2是通过拷贝构造函数，新创建的Singleton对象，并把obj的内容拷贝了过来。那么此时pObj2和pObj1的地址不再相同，二者成为了两个对象，打破了单例模式。</p>
<p>因此，此处禁用拷贝构造，强迫用户必须用引用来接对象。</p>
</li>
</ul>
<h4 id="堆上单例懒汉式"><a class="markdownIt-Anchor" href="#堆上单例懒汉式"></a> 堆上单例（懒汉式）</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>();</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; other);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="type">static</span> Singleton* m_instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::m_instance=<span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程非安全版本</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        m_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程安全版本，但锁的代价过高</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Lock lock;</span><br><span class="line">    <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        m_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双检查锁，但由于内存读写reorder不安全（编译器优化时可能把第二个检查优化掉）</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_instance==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        Lock lock;</span><br><span class="line">        <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            m_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++ 11版本之后的跨平台实现 (volatile)</span></span><br><span class="line">std::atomic&lt;Singleton*&gt; Singleton::m_instance;</span><br><span class="line">std::mutex Singleton::m_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Singleton* tmp = m_instance.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_acquire);<span class="comment">//获取内存fence</span></span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        tmp = m_instance.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            tmp = <span class="keyword">new</span> Singleton;</span><br><span class="line">            std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_release);<span class="comment">//释放内存fence</span></span><br><span class="line">            m_instance.<span class="built_in">store</span>(tmp, std::memory_order_relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="堆上单例饿汉式"><a class="markdownIt-Anchor" href="#堆上单例饿汉式"></a> 堆上单例（饿汉式）</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> singleton &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">HungrySingleton</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function">HungrySingleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> instance_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="built_in">HungrySingleton</span>() &#123;&#125;</span><br><span class="line">      <span class="type">static</span> HungrySingleton* instance_;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  HungrySingleton* HungrySingleton::instance_ = <span class="keyword">new</span> <span class="built_in">HungrySingleton</span>();</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace singleton</span></span><br></pre></td></tr></table></figure>
<h3 id="2-工厂模式factory"><a class="markdownIt-Anchor" href="#2-工厂模式factory"></a> 2 工厂模式（Factory）</h3>
<blockquote>
<p>工厂模式中，创建对象时不会对客户端暴露创建逻辑，而是通过使用一个共同的接口来指向新创建的对象</p>
</blockquote>
<h4 id="21-简单工厂"><a class="markdownIt-Anchor" href="#21-简单工厂"></a> 2.1 简单工厂</h4>
<p>以炒鞋为例。鞋厂可以指定生产耐克、阿迪达斯和李宁牌子的鞋。</p>
<ul>
<li>
<p>工厂类：工厂模式的核心类，会定义一个用于创建指定的具体实例对象的接口。</p>
</li>
<li>
<p>抽象产品类：是具体产品类的继承的父类或实现的接口。</p>
</li>
<li>
<p>具体产品类：工厂类所创建的对象就是此具体产品实例。</p>
</li>
</ul>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_pIG1eoG7w-.png" alt="" /></p>
<p>特点在于封装了创建具体产品对象的函数。</p>
<p>缺点在于扩展性非常差，新增产品的时候，需要去修改工厂类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 鞋子抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shoes</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shoes</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耐克鞋子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NiKeShoes</span> : <span class="keyword">public</span> Shoes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是耐克球鞋，我的广告语：Just do it&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阿迪达斯鞋子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AdidasShoes</span> : <span class="keyword">public</span> Shoes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是阿迪达斯球鞋，我的广告语:Impossible is nothing&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 李宁鞋子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LiNingShoes</span> : <span class="keyword">public</span> Shoes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是李宁球鞋，我的广告语：Everything is possible&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SHOES_TYPE</span></span><br><span class="line">&#123;</span><br><span class="line">    NIKE,</span><br><span class="line">    LINING,</span><br><span class="line">    ADIDAS</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总鞋厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShoesFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 根据鞋子类型创建对应的鞋子对象</span></span><br><span class="line">    <span class="function">Shoes *<span class="title">CreateShoes</span><span class="params">(SHOES_TYPE type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> NIKE:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">NiKeShoes</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LINING:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">LiNingShoes</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ADIDAS:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">AdidasShoes</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>main函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 构造工厂对象</span></span><br><span class="line">    ShoesFactory shoesFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从鞋工厂对象创建阿迪达斯鞋对象</span></span><br><span class="line">    Shoes *pNikeShoes = shoesFactory.<span class="built_in">CreateShoes</span>(NIKE);</span><br><span class="line">    <span class="keyword">if</span> (pNikeShoes != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 耐克球鞋广告喊起</span></span><br><span class="line">        pNikeShoes-&gt;<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="keyword">delete</span> pNikeShoes;</span><br><span class="line">        pNikeShoes = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从鞋工厂对象创建阿迪达斯鞋对象</span></span><br><span class="line">    Shoes *pLiNingShoes = shoesFactory.<span class="built_in">CreateShoes</span>(LINING);</span><br><span class="line">    <span class="keyword">if</span> (pLiNingShoes != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 李宁球鞋广告喊起</span></span><br><span class="line">        pLiNingShoes-&gt;<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="keyword">delete</span> pLiNingShoes;</span><br><span class="line">        pLiNingShoes = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从鞋工厂对象创建阿迪达斯鞋对象</span></span><br><span class="line">    Shoes *pAdidasShoes = shoesFactory.<span class="built_in">CreateShoes</span>(ADIDAS);</span><br><span class="line">    <span class="keyword">if</span> (pAdidasShoes != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 阿迪达斯球鞋广告喊起</span></span><br><span class="line">        pAdidasShoes-&gt;<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="keyword">delete</span> pAdidasShoes;</span><br><span class="line">        pAdidasShoes = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="22-工厂方法"><a class="markdownIt-Anchor" href="#22-工厂方法"></a> 2.2 工厂方法</h4>
<p>简单工厂的缺点在于，调用工厂来创建对象时，是传入产品类别的。每当增加一个类别时，就需要修改一次工厂类。这违反了开闭原则，而工厂方法是对这种行为的补救。使用工厂方法，每次需要增加一个类别时，只需要再实现两个具体类就行，不必再去修改工厂类的内容。</p>
<p>工厂方法相比于简单工厂，添加了一个具体工厂类，每一个具体工厂类和相应的具体产品类是一一对应的，由具体工厂类来生产（创建）相应的具体产品类对象。</p>
<ul>
<li>
<p>抽象工厂类：工厂方法模式的核心类，提供创建具体产品的接口，由具体工厂类实现。</p>
</li>
<li>
<p>具体工厂类：继承于抽象工厂，实现创建对应具体产品对象的方式。</p>
</li>
<li>
<p>抽象产品类：它是具体产品继承的父类（基类）。</p>
</li>
<li>
<p>具体产品类：具体工厂所创建的对象，就是此类。</p>
</li>
</ul>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_psTux_rw_R.png" alt="" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 总鞋厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShoesFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Shoes *<span class="title">CreateShoes</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ShoesFactory</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耐克生产者/生产链</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NiKeProducer</span> : <span class="keyword">public</span> ShoesFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Shoes *<span class="title">CreateShoes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">NiKeShoes</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阿迪达斯生产者/生产链</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AdidasProducer</span> : <span class="keyword">public</span> ShoesFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Shoes *<span class="title">CreateShoes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">AdidasShoes</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 李宁生产者/生产链</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LiNingProducer</span> : <span class="keyword">public</span> ShoesFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Shoes *<span class="title">CreateShoes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">LiNingShoes</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>main函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ================ 生产耐克流程 ==================== //</span></span><br><span class="line">    <span class="comment">// 鞋厂开设耐克生产线</span></span><br><span class="line">    ShoesFactory *niKeProducer = <span class="keyword">new</span> <span class="built_in">NiKeProducer</span>();</span><br><span class="line">    <span class="comment">// 耐克生产线产出球鞋</span></span><br><span class="line">    Shoes *nikeShoes = niKeProducer-&gt;<span class="built_in">CreateShoes</span>();</span><br><span class="line">    <span class="comment">// 耐克球鞋广告喊起</span></span><br><span class="line">    nikeShoes-&gt;<span class="built_in">Show</span>();</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">delete</span> nikeShoes;</span><br><span class="line">    <span class="keyword">delete</span> niKeProducer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ================ 生产阿迪达斯流程 ==================== //</span></span><br><span class="line">    <span class="comment">// 鞋厂开设阿迪达斯生产者</span></span><br><span class="line">    ShoesFactory *adidasProducer = <span class="keyword">new</span> <span class="built_in">AdidasProducer</span>();</span><br><span class="line">    <span class="comment">// 阿迪达斯生产线产出球鞋</span></span><br><span class="line">    Shoes *adidasShoes = adidasProducer-&gt;<span class="built_in">CreateShoes</span>();</span><br><span class="line">    <span class="comment">// 阿迪达斯球鞋广喊起</span></span><br><span class="line">    adidasShoes-&gt;<span class="built_in">Show</span>();</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">delete</span> adidasShoes;</span><br><span class="line">    <span class="keyword">delete</span> adidasProducer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="23-抽象工厂"><a class="markdownIt-Anchor" href="#23-抽象工厂"></a> 2.3 抽象工厂</h4>
<ul>
<li>
<p>与工厂方法的不同：具体工厂类不再生产唯一的产品，而是生产多个产品。也就是抽象工厂类将不仅仅提供对某一种产品的创建方法，还提供多种产品的创建方法。</p>
</li>
<li>
<p>应用场景：当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的具体产品时需要使用抽象工厂模式。</p>
<p>遇到此类场景时，抽象工厂模式比工厂方法模式更为简单、有效率。</p>
</li>
</ul>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_aZYjDQ9kcg.png" alt="" /></p>
<p>考虑上面的例子。此时厂家不再局限于生产鞋子，还想生产耐克、阿迪达斯、李宁的衣服。那么就可以应用抽象工厂来替代工厂方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类 衣服</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clothe</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Clothe</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耐克衣服</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NiKeClothe</span> : <span class="keyword">public</span> Clothe</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是耐克衣服，时尚我最在行！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 鞋子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shoes</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shoes</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耐克鞋子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NiKeShoes</span> : <span class="keyword">public</span> Shoes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是耐克球鞋，让你酷起来！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 总厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Shoes *<span class="title">CreateShoes</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Clothe *<span class="title">CreateClothe</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Factory</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耐克生产者/生产链</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NiKeProducer</span> : <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Shoes *<span class="title">CreateShoes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">NiKeShoes</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Clothe *<span class="title">CreateClothe</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">NiKeClothe</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>main函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ================ 生产耐克流程 ==================== //</span></span><br><span class="line">    <span class="comment">// 鞋厂开设耐克生产线</span></span><br><span class="line">    Factory *niKeProducer = <span class="keyword">new</span> <span class="built_in">NiKeProducer</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 耐克生产线产出球鞋</span></span><br><span class="line">    Shoes *nikeShoes = niKeProducer-&gt;<span class="built_in">CreateShoes</span>();</span><br><span class="line">  <span class="comment">// 耐克生产线产出衣服</span></span><br><span class="line">    Clothe *nikeClothe = niKeProducer-&gt;<span class="built_in">CreateClothe</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 耐克球鞋广告喊起</span></span><br><span class="line">    nikeShoes-&gt;<span class="built_in">Show</span>();</span><br><span class="line">  <span class="comment">// 耐克衣服广告喊起</span></span><br><span class="line">    nikeClothe-&gt;<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">delete</span> nikeShoes;</span><br><span class="line">  <span class="keyword">delete</span> nikeClothe;</span><br><span class="line">    <span class="keyword">delete</span> niKeProducer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="24-模板工厂c"><a class="markdownIt-Anchor" href="#24-模板工厂c"></a> 2.4 模板工厂（C++）</h4>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/83537599">https://zhuanlan.zhihu.com/p/83537599</a></p>
<p>模板工厂相当于在工厂方法的基础上进行优化，使其能够获得抽象工厂的效果。而且比起抽象工厂来，当需要新添加类别时（比如在鞋和衣服的基础上，还要添加裤子），扩展性更强，符合开闭原则。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类 鞋子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shoes</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shoes</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耐克鞋子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NiKeShoes</span> : <span class="keyword">public</span> Shoes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是耐克球鞋，我的广告语：Just do it&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 衣服</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clothe</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Clothe</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优衣库衣服</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UniqloClothe</span> : <span class="keyword">public</span> Clothe</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是优衣库衣服，我的广告语：I am Uniqlo&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象模板工厂类</span></span><br><span class="line"><span class="comment">// 模板参数：AbstractProduct_t 产品抽象类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">AbstractProduct_t</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> AbstractProduct_t *<span class="title">CreateProduct</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractFactory</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体模板工厂类</span></span><br><span class="line"><span class="comment">// 模板参数：AbstractProduct_t 产品抽象类，ConcreteProduct_t 产品具体类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">AbstractProduct_t</span>, <span class="keyword">class</span> <span class="title class_">ConcreteProduct_t</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory</span> : <span class="keyword">public</span> AbstractFactory&lt;AbstractProduct_t&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">AbstractProduct_t *<span class="title">CreateProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteProduct_t</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>main函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 构造耐克鞋的工厂对象</span></span><br><span class="line">    ConcreteFactory&lt;Shoes, NiKeShoes&gt; nikeFactory;</span><br><span class="line">    <span class="comment">// 创建耐克鞋对象</span></span><br><span class="line">    Shoes *pNiKeShoes = nikeFactory.<span class="built_in">CreateProduct</span>();</span><br><span class="line">    <span class="comment">// 打印耐克鞋广告语</span></span><br><span class="line">    pNiKeShoes-&gt;<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造优衣库衣服的工厂对象</span></span><br><span class="line">    ConcreteFactory&lt;Clothe, UniqloClothe&gt; uniqloFactory;</span><br><span class="line">    <span class="comment">// 创建优衣库衣服对象</span></span><br><span class="line">    Clothe *pUniqloClothe = uniqloFactory.<span class="built_in">CreateProduct</span>();</span><br><span class="line">    <span class="comment">// 打印优衣库广告语</span></span><br><span class="line">    pUniqloClothe-&gt;<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">delete</span> pNiKeShoes;</span><br><span class="line">    pNiKeShoes = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pUniqloClothe;</span><br><span class="line">    pUniqloClothe = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-建造者模式builder"><a class="markdownIt-Anchor" href="#3-建造者模式builder"></a> 3 建造者模式（Builder）</h3>
<blockquote>
<p>将一个<strong>复杂对象</strong>分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。<br />
Builder侧重“零部件的组装过程”。</p>
</blockquote>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_YPbrcpWDP5.png" alt="" /></p>
<ul>
<li>
<p>应用场景：建造者模式主要用于“分步骤构建一个复杂的对象”。在这其中“分步骤”是一个稳定的算法，而复杂对象的各个部分经常变化。</p>
</li>
<li>
<p>缺点：这里的“组装过程”，或者说“步骤”，是固定的，无法修改。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">House</span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HouseBuilder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">House* <span class="title">GetResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> pHouse;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">HouseBuilder</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  House* pHouse;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart1</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart2</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart3</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart4</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart5</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StoneHouse</span>: <span class="keyword">public</span> House&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StoneHouseBuilder</span>: <span class="keyword">public</span> HouseBuilder&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart1</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//pHouse-&gt;Part1 = ...;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart3</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart4</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart5</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">///@brief：Director，组装各个part，“步骤”是由它制定并实现的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HouseDirector</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  HouseBuilder* pHouseBuilder;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">HouseDirector</span>(HouseBuilder* pHouseBuilder)&#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;pHouseBuilder=pHouseBuilder;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">House* <span class="title">Construct</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    pHouseBuilder-&gt;<span class="built_in">BuildPart1</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">        pHouseBuilder-&gt;<span class="built_in">BuildPart2</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> flag=pHouseBuilder-&gt;<span class="built_in">BuildPart3</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        pHouseBuilder-&gt;<span class="built_in">BuildPart4</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pHouseBuilder-&gt;<span class="built_in">BuildPart5</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pHouseBuilder-&gt;<span class="built_in">GetResult</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-原型模式prototype"><a class="markdownIt-Anchor" href="#4-原型模式prototype"></a> 4 原型模式（Prototype）</h3>
<blockquote>
<p>将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</p>
</blockquote>
<ul>
<li>
<p>应用场景：</p>
<p>针对<strong>结构复杂的对象结构</strong>，由于需求变化，对象内部也会发生变化，但是对外暴露的接口仍然是稳定的。原型模式负责应对这种变化，从客户程序隔离出易变对象，从而使得依赖这些对象的客户程序不必随着需求改变而改变。</p>
</li>
<li>
<p>实现方式：</p>
<p>定义抽象类，原型为派生出来的具体类的一个实例，需要其他（发生了变化的）实例时，从原型拷贝。</p>
</li>
</ul>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_vGYSLsjdRm.png" alt="" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 抽象原型类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractPrototype</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">AbstractPrototype</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">AbstractPrototype</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> AbstractPrototype* <span class="title">clone</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 具体原型类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcretePrototype</span> : <span class="keyword">public</span> AbstractPrototype &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ConcretePrototype</span>() = <span class="keyword">default</span>;</span><br><span class="line">  ~<span class="built_in">ConcretePrototype</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">AbstractPrototype* <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcretePrototype</span>(*<span class="keyword">this</span>);<span class="comment">//调用拷贝构造</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">ConcretePrototype</span>(<span class="type">const</span> ConcretePrototype&amp; other) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;ConcretePrototype copy construct!\n&quot;</span>);</span><br><span class="line">        <span class="comment">// ......拷贝操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test_02_prototype_impl_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-------------------- %s --------------------\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    prototype::AbstractPrototype* ptr_a = <span class="keyword">new</span> prototype::<span class="built_in">ConcretePrototype</span>();</span><br><span class="line">    prototype::AbstractPrototype* ptr_b = ptr_a-&gt;<span class="built_in">clone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> ptr_a;</span><br><span class="line">    <span class="keyword">delete</span> ptr_b; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结构型"><a class="markdownIt-Anchor" href="#结构型"></a> 结构型</h2>
<blockquote>
<p>📌门面(5) &gt; 适配器(4) = 组合(4) = 代理(4) &gt; 桥接(3) = 装饰(3) &gt; 享元(1)</p>
</blockquote>
<h3 id="5-代理模式proxy"><a class="markdownIt-Anchor" href="#5-代理模式proxy"></a> 5 代理模式（Proxy）</h3>
<p>在某些情况下，一个客户不想或者不能直接引用一个对象，此时可以通过一个称之为“代理”的第三方来实现 间接引用。代理对象可以在客户端和目标对象之间起到“中介”的作用，并且可以通过代理对象去掉客户不允许看到的内容，或者添加客户需要的额外服务。</p>
<blockquote>
<p>事实上，代理模式和科学上网时所配置的代理是异曲同工的。无法直接访问到海外的机器，此时可以使用一个代理来访问海外，而客户端调用代理即可。</p>
</blockquote>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_LaOkWgxP2d.png" alt="" /></p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_Bl0RbJxcRV.png" alt="" /></p>
<ul>
<li>
<p>subject：抽象角色</p>
</li>
<li>
<p>Proxy：代理角色</p>
</li>
<li>
<p>RealSubject：真实角色</p>
</li>
</ul>
<!---->
<ul>
<li>
<p>应用场景：</p>
<ol>
<li>
<p>远程代理：为一个处于不同地址空间的对象提供一个本地的代理，这个不同地址空间可以在同一台主机中，也可在另一台主机中，远程代理又叫做大使。</p>
</li>
<li>
<p>虚拟代理：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。</p>
</li>
<li>
<p>写时拷贝代理：虚拟代理的一种，把复制（克隆）操作延迟到只有在客户端真正需要时才执行。</p>
</li>
<li>
<p>保护代理：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</p>
</li>
<li>
<p>缓冲代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</p>
</li>
<li>
<p>防火墙代理：保护目标不让恶意用户接近。</p>
</li>
<li>
<p>同步化代理：使几个用户能够同时使用一个对象而没有冲突。</p>
</li>
<li>
<p>智能引用代理：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来等。</p>
</li>
</ol>
</li>
<li>
<p>优点：</p>
<ol>
<li>
<p>代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。</p>
</li>
<li>
<p>远程代理使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。</p>
</li>
<li>
<p>虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度。</p>
</li>
<li>
<p>保护代理可以控制对真实对象的使用权限。</p>
</li>
</ol>
</li>
<li>
<p>缺点：</p>
<p>客户端和真实对象之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，而且增加了系统实现的复杂度。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Proxy</span> : <span class="keyword">public</span> Subject&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Proxy</span>()&#123;</span><br><span class="line">    m_pRealSubject = <span class="keyword">new</span> <span class="built_in">RealSubject</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Proxy</span>()&#123;</span><br><span class="line">    <span class="keyword">delete</span> m_pReakSubject;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">request</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">preRequest</span>();</span><br><span class="line">    m_pRealSubject-&gt;<span class="built_in">request</span>();</span><br><span class="line">    <span class="built_in">afterRequest</span>();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">afterRequest</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">preRequest</span><span class="params">()</span></span>;  </span><br><span class="line">  RealSubject *m_pRealSubject;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int main()&#123;</span></span><br><span class="line"><span class="comment">  Proxy proxy;</span></span><br><span class="line"><span class="comment">  proxy.request();</span></span><br><span class="line"><span class="comment">  return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="6-桥接模式bridge"><a class="markdownIt-Anchor" href="#6-桥接模式bridge"></a> 6 桥接模式（Bridge）</h3>
<p>桥接模式同时使用了“<strong>接口与实现相分离</strong>”和“<strong>组合代替继承</strong>”的思想。</p>
<ul>
<li>
<p>应用场景：</p>
<p>某些类型的固有实现逻辑，使得它们具有两个变化的维度，甚至多个变化的维度。比如说图形既可按形状分，又可按颜色分。而Photoshop这样的软件，能画不同形状和不同颜色的图形，该如何实现呢？<br />
此时可以使用桥接模式，可以参考前文“组合代替继承”中鸟类的例子。</p>
</li>
<li>
<p>桥接模式结构：</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_mczjtZsYoT.png" alt="" /></p>
<p>Abstraction：抽象类</p>
<p>RefinedAbstraction：扩充抽象类，即扩充Abstraction所定义的接口，他同时连接Abstraction和Implementor，是“桥接”中的那座桥。</p>
<p>Implementor：实现类接口</p>
<p>ConcreteImplementor：具体实现类</p>
<p>扩充抽象类构造时接收具体实现类为参数，从而让扩充抽象类组合了若干具体实现类的功能。</p>
</li>
</ul>
<p>当然，扩充抽象类不一定是必需的，由此衍生出两种桥接模式的实现方式。</p>
<h4 id="简单的抽象与实现相分离"><a class="markdownIt-Anchor" href="#简单的抽象与实现相分离"></a> 简单的抽象与实现相分离</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 抽象类接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractInterface</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AbstractInterface</span>();</span><br><span class="line">    ~<span class="built_in">AbstractInterface</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Request</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Impl</span>;</span><br><span class="line">    Impl* impl_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 实现类接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractInterface</span>::Impl &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is AbstractInterface::Impl::Request!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 抽象类接口的实现 - 调用实现类接口</span></span><br><span class="line">AbstractInterface::<span class="built_in">AbstractInterface</span>() &#123;</span><br><span class="line">    impl_ = <span class="keyword">new</span> <span class="built_in">Impl</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AbstractInterface::~<span class="built_in">AbstractInterface</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span> impl_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AbstractInterface::Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    impl_-&gt;<span class="built_in">Request</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="复杂的抽象与实现相分离"><a class="markdownIt-Anchor" href="#复杂的抽象与实现相分离"></a> 复杂的抽象与实现相分离</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 实现化角色, 定义实现化角色的接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractImplementor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractImplementor</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Request</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 具体实现化角色, 给出实现化角色接口的具体实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteImplementorA</span> : <span class="keyword">public</span> AbstractImplementor &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this ConcreteImplementorA::Request!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteImplementorB</span> : <span class="keyword">public</span> AbstractImplementor &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this ConcreteImplementorB::Request!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 抽象类角色, 对实现化对象的引用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractRole</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AbstractRole</span>(AbstractImplementor* impl) : <span class="built_in">impl_</span>(impl) &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractRole</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Request</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    AbstractImplementor* impl_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 扩展抽象化角色, 实现父类中的业务方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExtendRole</span> : <span class="keyword">public</span> AbstractRole &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ExtendRole</span>(AbstractImplementor* impl) : <span class="built_in">AbstractRole</span>(impl) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        impl_-&gt;<span class="built_in">Request</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test_08_bridge_impl_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AbstractImplementor* ptr_implA = <span class="keyword">new</span> <span class="built_in">ConcreteImplementorA</span>();</span><br><span class="line">    AbstractImplementor* ptr_implB = <span class="keyword">new</span> <span class="built_in">ConcreteImplementorB</span>();</span><br><span class="line"></span><br><span class="line">    AbstractRole* ptr_role_1 = <span class="keyword">new</span> <span class="built_in">ExtendRole</span>(ptr_implA);</span><br><span class="line">    ptr_role_1-&gt;<span class="built_in">Request</span>();</span><br><span class="line"></span><br><span class="line">    AbstractRole* ptr_role_2 = <span class="keyword">new</span> <span class="built_in">ExtendRole</span>(ptr_implB);</span><br><span class="line">    ptr_role_2-&gt;<span class="built_in">Request</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> ptr_role_1, ptr_role_2;</span><br><span class="line">    <span class="keyword">delete</span> ptr_implA, ptr_implB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌桥接模式的“桥”体现在什么地方？<br />
比如说Photoshop的例子，颜色和形状被组合在了一起。再比如鸟的例子，飞属性和叫属性也被组合在了一起。<strong>桥接就像架起了一座桥一样，连接了两个不同的类型，从而进行组合</strong>。<br />
体现在代码上的话，就是RefineAbstraction的构造函数中，传入了不同Implementor类型的指针，于是在RefineAbstraction对象内部，就可以组合不同类型的对象。<br />
同时，用户仅需要调用抽象接口Abstraction即可。</p>
</blockquote>
<h3 id="7-装饰器模式decorator"><a class="markdownIt-Anchor" href="#7-装饰器模式decorator"></a> 7 装饰器模式（Decorator）</h3>
<p>装饰器动态的给对象增加一些职责，即增加额外的功能。采用了“<strong>组合代替继承</strong>”的原则，用组合关系创建一个包装对象来包裹真实对象，并在保持真实对象的类结构不变的前提下，提供额外的功能。</p>
<ul>
<li>
<p>应用场景：</p>
</li>
<li>
<p>优点：</p>
<ol>
<li>
<p>装饰模式可以提供比继承更多的灵活性。</p>
</li>
<li>
<p>可以通过动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的装饰器，从而实现不同的行为。</p>
</li>
<li>
<p>通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。</p>
</li>
<li>
<p>使用时进行组合即可，原有代码无须改变，符合“开闭原则”。</p>
</li>
</ol>
</li>
<li>
<p>缺点：</p>
<ol>
<li>
<p>装饰类和小对象的产生将增加系统的复杂度，加大学习与理解的难度。</p>
</li>
<li>
<p>装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。</p>
</li>
</ol>
</li>
</ul>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_KLc8axDXNy.png" alt="" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 抽象组件 - 被装饰的接口基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractComponent</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractComponent</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Request</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 具体组件 - 被装饰的接口派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteComponent</span> : <span class="keyword">public</span> AbstractComponent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is ConcreteComponent::Request!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 抽象装饰</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractDecorator</span> : <span class="keyword">public</span> AbstractComponent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AbstractDecorator</span>(AbstractComponent* comp) : <span class="built_in">comp_</span>(comp) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (comp_) comp_-&gt;<span class="built_in">Request</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    AbstractComponent* comp_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 具体装饰</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteDecoratorA</span> : <span class="keyword">public</span> AbstractDecorator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteDecoratorA</span>(AbstractComponent* comp) : <span class="built_in">AbstractDecorator</span>(comp) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">PreRequest</span>();</span><br><span class="line">        AbstractDecorator::<span class="built_in">Request</span>();</span><br><span class="line">        <span class="built_in">PostRequest</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PreRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ConcreteDecoratorA::PreRequest!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PostRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ConcreteDecoratorA::PostRequest!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌代码中的这行操作<code>ConcreteDecoratorA(AbstractComponent* comp):AbstractDecorator(comp)</code>是C++11的新特性：委托构造函数(delegating constructor)，即一个构造函数可以在初始化成员列表中，调用另一个构造函数。<br />
委托构造函数的成员初始值列表<strong>只能有唯一的参数，就是构造函数</strong>。<br />
上面的例子中，就是创建ConcreteDecoratorA对象时，会先将被对象创建为AbstractDecorator对象的内容，如果{ }中有内容，就继续执行{ }中的内容。<br />
但是委托构造函数易发生死锁的问题，考虑下面代码：<br />
class B{<br />
private:<br />
int *a;<br />
std::string *s;<br />
public:<br />
B(int a) : B(“Test”) {<br />
_*a = a;<br />
}<br />
B(std::string s) : B(100){<br />
*_s = “Test”;<br />
}<br />
};<br />
这一份代码可以编译，但是却无法运行。因为一旦初始化，无论执行哪一个函数，一定会陷入无穷无尽的循环调用中。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  AbstractComponent* ptr_comp = <span class="keyword">new</span> <span class="built_in">ConcreteComponent</span>();</span><br><span class="line">  ptr_comp-&gt;<span class="built_in">Request</span>(); <span class="comment">//原有组件该有的功能不变</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//对现有组件的功能进行扩展</span></span><br><span class="line">  AbstractDecorator* ptr_decorator = <span class="keyword">new</span> <span class="built_in">ConcreteDecoratorA</span>(ptr_comp);</span><br><span class="line">  ptr_decorator-&gt;<span class="built_in">Request</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-适配器模式adapter"><a class="markdownIt-Anchor" href="#8-适配器模式adapter"></a> 8 适配器模式（Adapter）</h3>
<ul>
<li>
<p>适配器模式中的角色：</p>
<p>Target（目标接口）、Adapter（适配器类）、Adaptee（适配者类）、Client（客户类）。</p>
</li>
<li>
<p>应用场景：</p>
<p>现有的类可以满足客户类的功能需要，但是它所提供的接口不一定是客户类所期望的。适配器模式就是在二者之间添加一个类进行接口的转化。而添加的用于转化接口的类就是适配器类，被包装的类即适配者类。</p>
<p>适配器模式，通过适配器类，在适配者类外部包装，包装成目标接口。</p>
</li>
</ul>
<p>适配器模式有两种实现方式：</p>
<ol>
<li>
<p>对象适配器</p>
<p>Adapter只继承Target以提供接口的实现，接收Adaptee的对象作为参数。</p>
</li>
<li>
<p>类适配器</p>
<p>多重继承，Adapter类同时继承Target和Adaptee。</p>
</li>
</ol>
<p>二者均能获得Adaptee功能的同时向客户提供目标接口。两种实现方式的类图如下：</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_-s6OMPY2i6.png" alt="" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目标接口（新接口）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ITarget</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遗留接口（老接口）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IAdaptee</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> data)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">bar</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遗留类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OldClass</span>: <span class="keyword">public</span> IAdaptee&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象适配器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adapter</span>: <span class="keyword">public</span> ITarget&#123; <span class="comment">//继承</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    IAdaptee* pAdaptee;<span class="comment">//组合</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Adapter</span>(IAdaptee* pAdaptee)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pAdaptee=pAdaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> data=pAdaptee-&gt;<span class="built_in">bar</span>();</span><br><span class="line">        pAdaptee-&gt;<span class="built_in">foo</span>(data);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//类适配器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adapter</span>: <span class="keyword">public</span> ITarget,</span><br><span class="line">               <span class="keyword">protected</span> OldClass&#123; <span class="comment">//多继承</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> data = <span class="keyword">this</span>-&gt;<span class="built_in">bar</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">foo</span>(data);</span><br><span class="line">  &#125;            </span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IAdaptee* pAdaptee=<span class="keyword">new</span> <span class="built_in">OldClass</span>();</span><br><span class="line"></span><br><span class="line">    ITarget* pTarget=<span class="keyword">new</span> <span class="built_in">Adapter</span>(pAdaptee);<span class="comment">//使用对象适配器</span></span><br><span class="line"></span><br><span class="line">    ITarget* pTarget=<span class="keyword">new</span> <span class="built_in">Adapter</span>();<span class="comment">//使用类适配器</span></span><br><span class="line"></span><br><span class="line">    pTarget-&gt;<span class="built_in">process</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-门面外观模式facade"><a class="markdownIt-Anchor" href="#9-门面外观模式facade"></a> 9 门面/外观模式（Facade）</h3>
<p>客户端想同时调用多个复杂的子系统，而外观模式为这些子系统提供一个一致的接口，使它们更容易被访问。</p>
<blockquote>
<p>现实生活的类比：如办房产证或注册一家公司，有时要同多个部门联系，这时要是有一个综合部门能解决一切手续问题就好了。外观模式就是在软件层面做这样的事</p>
</blockquote>
<ul>
<li>
<p>优点：</p>
<ol>
<li>
<p>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类</p>
</li>
<li>
<p>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易</p>
</li>
<li>
<p>降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象</p>
</li>
</ol>
</li>
<li>
<p>缺点：</p>
<p>增加新的子系统可能需要修改外观类或客户端的代码，违背了“开闭原则”。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 具体实现子模块</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubModuleImplementorA</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PreRequest</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SubModuleImplementorA::PreRequest!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubModuleImplementorB</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RealRequest</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SubModuleImplementorB::RealRequest!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubModuleImplementorC</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PostRequest</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SubModuleImplementorC::PostRequest!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 外观角色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Facade</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Facade</span>() &#123;</span><br><span class="line">        implA_.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">SubModuleImplementorA</span>());<span class="comment">//reset会使引用计数-1</span></span><br><span class="line">        implB_.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">SubModuleImplementorB</span>());</span><br><span class="line">        implC_.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">SubModuleImplementorC</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        implA_-&gt;<span class="built_in">PreRequest</span>();</span><br><span class="line">        implB_-&gt;<span class="built_in">RealRequest</span>();</span><br><span class="line">        implC_-&gt;<span class="built_in">PostRequest</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;SubModuleImplementorA&gt; implA_;</span><br><span class="line">    std::shared_ptr&lt;SubModuleImplementorB&gt; implB_;</span><br><span class="line">    std::shared_ptr&lt;SubModuleImplementorC&gt; implC_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test_10_facade_impl_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-------------------- %s --------------------\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Facade&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> Facade())</span></span>;</span><br><span class="line">    ptr-&gt;<span class="built_in">Request</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌shared_ptr的reset(new class())用法，先new出来对象，再将shared_ptr引用计数-1。因此，若之前指针只指向一个对象，-1后为0，自动析构，指针悬空，就可以指向新new出来的对象。</p>
</blockquote>
<h3 id="10-组合模式composite"><a class="markdownIt-Anchor" href="#10-组合模式composite"></a> 10 组合模式（Composite）</h3>
<p>组合模式将对象<strong>组合成树状层次结构</strong>，使用户<strong>对单个对象和组合对象具有一致的访问性</strong>。</p>
<ul>
<li>
<p>应用场景：</p>
<p>软件开发中存在很多“部分-整体”的关系，如文件系统中的文件与文件夹等等。对这些简单对象与复合对象的处理，用组合模式来实现会比较方便。</p>
</li>
<li>
<p>优点：</p>
<ul>
<li>
<p>客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的单个对象还是组合对象，简化了客户端代码的设计；</p>
</li>
<li>
<p>更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源码，满足“开闭原则”。</p>
</li>
</ul>
</li>
<li>
<p>缺点：</p>
<ul>
<li>
<p>设计较复杂，客户端需要花更多时间理清类之间的层次关系；</p>
</li>
<li>
<p>不容易用继承的方法增加功能。</p>
</li>
</ul>
</li>
</ul>
<h4 id="透明式"><a class="markdownIt-Anchor" href="#透明式"></a> 透明式</h4>
<p>抽象组件声明子类中的全部方法，所以客户端无需区别叶子对象和中间的树枝对象，对客户端透明。</p>
<blockquote>
<p>缺点在于，叶子类本不必有Add()、Remove()这样的方法，却要实现它们，从而有安全问题。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Component</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树枝节点 &amp; 叶子节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Composite</span> : <span class="keyword">public</span> Component&#123;</span><br><span class="line"></span><br><span class="line">    string name;</span><br><span class="line">    list&lt;Component*&gt; elements;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Composite</span>(<span class="type">const</span> string &amp; s) : <span class="built_in">name</span>(s) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(Component* element)</span> </span>&#123;</span><br><span class="line">        elements.<span class="built_in">push_back</span>(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(Component* element)</span></span>&#123;</span><br><span class="line">        elements.<span class="built_in">remove</span>(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. process current node</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. process leaf nodes</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : elements)</span><br><span class="line">            e-&gt;<span class="built_in">process</span>(); <span class="comment">//多态调用</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对组合对象和单个对象执行一致处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Invoke</span><span class="params">(Component &amp; c)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    c.<span class="built_in">process</span>();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="安全式"><a class="markdownIt-Anchor" href="#安全式"></a> 安全式</h4>
<p>将管理子component的方法移到树枝component中，抽象component和叶子component没有对子component的管理方法，从而避免上一种方式的安全性问题。</p>
<blockquote>
<p>由于叶子和分支有不同的接口，因此客户端在调用时要知道叶子对象和树枝对象的存在，不再严格透明。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Component</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Composite</span> : <span class="keyword">public</span> Component&#123;</span><br><span class="line"></span><br><span class="line">    string name;</span><br><span class="line">    list&lt;Component*&gt; elements;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Composite</span>(<span class="type">const</span> string &amp; s) : <span class="built_in">name</span>(s) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(Component* element)</span> </span>&#123;</span><br><span class="line">        elements.<span class="built_in">push_back</span>(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(Component* element)</span></span>&#123;</span><br><span class="line">        elements.<span class="built_in">remove</span>(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. process current node</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. process leaf nodes</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : elements)</span><br><span class="line">            e-&gt;<span class="built_in">process</span>(); <span class="comment">//多态调用</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//叶子节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Leaf</span> : <span class="keyword">public</span> Component&#123;</span><br><span class="line">    string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Leaf</span>(string s) : <span class="built_in">name</span>(s) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//process current node</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对组合对象和单个对象执行一致处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Invoke</span><span class="params">(Component &amp; c)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    c.<span class="built_in">process</span>();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Composite <span class="title">root</span><span class="params">(<span class="string">&quot;root&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Composite <span class="title">treeNode1</span><span class="params">(<span class="string">&quot;treeNode1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Composite <span class="title">treeNode2</span><span class="params">(<span class="string">&quot;treeNode2&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Leaf <span class="title">leat1</span><span class="params">(<span class="string">&quot;left1&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    root.<span class="built_in">add</span>(&amp;treeNode1);</span><br><span class="line">    treeNode1.<span class="built_in">add</span>(&amp;treeNode2);</span><br><span class="line">    treeNode2.<span class="built_in">add</span>(&amp;leaf1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">process</span>(root);</span><br><span class="line">    <span class="built_in">process</span>(leaf1);</span><br><span class="line">    <span class="built_in">process</span>(treeNode2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-享元模式flyweight"><a class="markdownIt-Anchor" href="#11-享元模式flyweight"></a> 11 享元模式（Flyweight）</h3>
<p>很多情况下，需要在系统中增加类和对象的个数，当对象数量太多时，将导致运行代价过高，带来性能下降等问题。享元模式针对此问题诞生，其使得相同或相似对象在重用时，共享某一个对象的内容。</p>
<p>在享元模式中可以共享的相同内容称为内部状态，而那些需要外部环境来设置的不能共享的内容称为外部状态。享元模式中通常会出现工厂模式，需创建一个享元工厂来维护一个享元池，用于存储具有相同内部状态的享元对象。</p>
<p>享元模式的优点在于，<strong>可以极大减少内存中对象的数量</strong>，使得相同对象或相似对象在内存中只保存一份</p>
<p>（Flyweight其实就是轻量级）</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_NoWKqwuRPL.png" alt="" /></p>
<ul>
<li>
<p>Flyweight：抽象享元类，描述一个接口，通过这个接口Flyweight可以接受并作用于外部状态</p>
</li>
<li>
<p>ConcreteFlyweight：具体享元类，定义了一些内部状态。ConcreteFlyweight对象必须是可共享的</p>
</li>
<li>
<p>UnsharedConcreteFlyweight：非共享具体享元类</p>
</li>
<li>
<p>FlyweightFactory：享元工厂类，创建并管理FlyWeight。当用户请求一个Flyweight时，FlyweightFactory对象提供一个已创建的实例，如果请求的实例不存在，就新创建一个实例。</p>
</li>
</ul>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_Qpd2kj70i2.png" alt="" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 非享元类, 以参数的形式注入具体享元的相关方法中</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnsharableConcreteFlyweight</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnsharableConcreteFlyweight</span>(<span class="type">const</span> std::string&amp; content) : <span class="built_in">content_</span>(content) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">GetContent</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> content_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string content_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 抽象享元类, 为具体享元规范需要实现的公共接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFlyweight</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractFlyweight</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Run</span><span class="params">(UnsharableConcreteFlyweight* unsharable_content_ptr)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 具体享元类, 实现抽象享元角色中所规定的接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFlyweightA</span> : <span class="keyword">public</span> AbstractFlyweight &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Run</span><span class="params">(UnsharableConcreteFlyweight* unsharable_content_ptr)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteFlyweightA::Run!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; unsharable_content_ptr-&gt;<span class="built_in">GetContent</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFlyweightB</span> : <span class="keyword">public</span> AbstractFlyweight &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Run</span><span class="params">(UnsharableConcreteFlyweight* unsharable_content_ptr)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteFlyweightB::Run!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; unsharable_content_ptr-&gt;<span class="built_in">GetContent</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 享元工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyweightFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">FlyweightType</span> &#123;</span><br><span class="line">        ConcreteA = <span class="number">0</span>,</span><br><span class="line">        ConcreteB,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">FlyweightFactory</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = fly_weights_.<span class="built_in">begin</span>(); it != fly_weights_.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (it-&gt;second) <span class="keyword">delete</span> it-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">        fly_weights_.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">AbstractFlyweight* <span class="title">GetFlyweight</span><span class="params">(<span class="type">const</span> std::string&amp; key, <span class="type">const</span> FlyweightType&amp; type = ConcreteA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = fly_weights_.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (fly_weights_.<span class="built_in">end</span>() == it) &#123;</span><br><span class="line">            AbstractFlyweight* ptr = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span> (ConcreteA == type) &#123;</span><br><span class="line">                ptr = <span class="keyword">new</span> <span class="built_in">ConcreteFlyweightA</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ConcreteB == type) &#123;</span><br><span class="line">                ptr = <span class="keyword">new</span> <span class="built_in">ConcreteFlyweightB</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            fly_weights_[key] = ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fly_weights_[key];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::map&lt;std::string, AbstractFlyweight*&gt; fly_weights_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>main函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;UnsharableConcreteFlyweight&gt; <span class="title">unsharable_content_ptr_1</span><span class="params">(<span class="keyword">new</span> UnsharableConcreteFlyweight(<span class="string">&quot;unsharable_content_ptr_1&quot;</span>))</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;UnsharableConcreteFlyweight&gt; <span class="title">unsharable_content_ptr_2</span><span class="params">(<span class="keyword">new</span> UnsharableConcreteFlyweight(<span class="string">&quot;unsharable_content_ptr_2&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;FlyweightFactory&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> FlyweightFactory())</span></span>;</span><br><span class="line">    AbstractFlyweight* flyweight_ptr_A_red = ptr-&gt;<span class="built_in">GetFlyweight</span>(<span class="string">&quot;Red&quot;</span>);</span><br><span class="line">    AbstractFlyweight* flyweight_ptr_A_point = ptr-&gt;<span class="built_in">GetFlyweight</span>(<span class="string">&quot;Point&quot;</span>);</span><br><span class="line"></span><br><span class="line">    flyweight_ptr_A_red-&gt;<span class="built_in">Run</span>(unsharable_content_ptr_1.<span class="built_in">get</span>());</span><br><span class="line">    flyweight_ptr_A_point-&gt;<span class="built_in">Run</span>(unsharable_content_ptr_2.<span class="built_in">get</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ConcreteFlyweightA::Run!</span></span><br><span class="line"><span class="comment">// unsharable_content_ptr_1</span></span><br><span class="line"><span class="comment">// ConcreteFlyweightA::Run!</span></span><br><span class="line"><span class="comment">// unsharable_content_ptr_2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌享元模式在编辑器软件中大量使用，如在一个文档中多次出现相同的图片，则只需要创建一个图片对象，通过在应用程序中设置该图片出现的位置，可以实现该图片在不同地方多次重复显示。</p>
</blockquote>
<h2 id="行为型"><a class="markdownIt-Anchor" href="#行为型"></a> 行为型</h2>
<blockquote>
<p>📌迭代器(5) = 观察者(5) &gt; 命令(4) = 策略(4) &gt; 职责链(3) = 状态(3) = 模板(3) &gt; 中介(2) = 备忘录(2) &gt; 访问者(1) = 解释器(1) </p>
</blockquote>
<h3 id="12-观察者模式observer"><a class="markdownIt-Anchor" href="#12-观察者模式observer"></a> 12 观察者模式（Observer）</h3>
<p>观察者模式建立对象与对象之间的一对多依赖关系。一个对象发生改变时，将自动通知其他对象，其他对象会做出相应的反应（如被自动更新）。</p>
<p>发生改变的对象称为观察目标，而被通知的对象称为观察者。</p>
<blockquote>
<p>观察者模式又被称作发布-订阅模式(Publish/Subscribe)、模型-视图模式(Model/View)、源-监听器模式(Source/Listener)、从属者模式(Dependents)。</p>
</blockquote>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_zETtFplPnQ.png" alt="" /></p>
<ul>
<li>
<p>优点：支持广播通信，符合开闭原则。可以实现表示层和数据逻辑层的分离，在观察目标和观察者之间建立一个抽象的耦合。</p>
</li>
<li>
<p>缺点：</p>
<ul>
<li>
<p>如果一个观察目标对象有很多直接和间接的观察者的话，将所有观察者都通知到会花费很多时间</p>
</li>
<li>
<p>如果观察者和观察目标之间有循环依赖，观察目标会触发它们之间循环调用，可能系统崩溃</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 抽象观察者, 包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractObserver</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">AbstractObserver</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被告知时做出响应</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Response</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 具体观察者, 实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteObserverA</span> : <span class="keyword">public</span> AbstractObserver &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Response</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is ConcreteObserverA::Response!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteObserverB</span> : <span class="keyword">public</span> AbstractObserver &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Response</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is ConcreteObserverB::Response!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 抽象主题类, 它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractSubject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractSubject</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">NotifyObserver</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddObserver</span><span class="params">(AbstractObserver* observer)</span> </span>&#123;</span><br><span class="line">        observers_.<span class="built_in">emplace_back</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RemoveObserver</span><span class="params">(AbstractObserver* observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = observers_.<span class="built_in">begin</span>(); it != observers_.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it) == observer) &#123;</span><br><span class="line">                observers_.<span class="built_in">erase</span>(it++);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::vector&lt;AbstractObserver*&gt; observers_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 具体主题类, 它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> : <span class="keyword">public</span> AbstractSubject &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">NotifyObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>* observer : observers_) &#123;</span><br><span class="line">            observer-&gt;<span class="built_in">Response</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;-------------------- %s --------------------\n&quot;</span>, __FUNCTION__);</span><br><span class="line">  <span class="function">std::shared_ptr&lt;AbstractSubject&gt; <span class="title">ptr_subject</span><span class="params">(<span class="keyword">new</span> ConcreteSubject())</span></span>;</span><br><span class="line">  <span class="function">std::shared_ptr&lt;AbstractObserver&gt; <span class="title">ptr_observer_A</span><span class="params">(<span class="keyword">new</span> ConcreteObserverA())</span></span>;</span><br><span class="line">  <span class="function">std::shared_ptr&lt;AbstractObserver&gt; <span class="title">ptr_observer_B</span><span class="params">(<span class="keyword">new</span> ConcreteObserverB())</span></span>;</span><br><span class="line"></span><br><span class="line">  ptr_subject-&gt;<span class="built_in">AddObserver</span>(ptr_observer_A.<span class="built_in">get</span>());</span><br><span class="line">  ptr_subject-&gt;<span class="built_in">AddObserver</span>(ptr_observer_B.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">  ptr_subject-&gt;<span class="built_in">NotifyObserver</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-模板方法template"><a class="markdownIt-Anchor" href="#13-模板方法template"></a> 13 模板方法（Template）</h3>
<blockquote>
<p>定义一个操作中的算法的骨架（稳定），而将一些步骤延迟（变化）到子类中</p>
</blockquote>
<p>其实模板方法顾名思义，就是定义一个抽象类，在该类中将一个算法的大致框架写好，而细节则由其派生的具体类来实现。</p>
<ul>
<li>
<p>应用场景：</p>
<p>在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。</p>
<p>对应于生活中的例子，可以类比写论文的过程。写论文需要提前写出提纲，确定各段的标题和整体结构，但是每小段的文字可以后面再具体写。</p>
</li>
<li>
<p>实现方式：</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_wg36lPjQXx.png" alt="" /></p>
<p>抽象类负责给出一个算法的轮廓和骨架，定义两种类型的方法</p>
<ol>
<li>
<p>模板方法：定义在抽象类中的，把基本操作方法组合在一起形成总算法或总行为的方法。</p>
<p>子类会不加修改地完全继承这个方法。</p>
</li>
<li>
<p>基本方法：</p>
<ul>
<li>
<p>抽象方法（延迟的内容）：在抽象类中声明，由具体子类实现</p>
</li>
<li>
<p>具体方法（骨架）：在抽象类中已实现，具体子类中可以继承或重写它</p>
</li>
<li>
<p>钩子方法：抽象类中已实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> template_method &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 抽象类, 给出一个算法的轮廓和骨架</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractClass</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// @brief 模板方法, 定义了算法的骨架，按某种顺序调用其包含的基本方法</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">TemplateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">SpecificMethodA</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">HookMethodB</span>()) &#123;</span><br><span class="line">            <span class="built_in">HookMethodA</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">AbstractMethod</span>();</span><br><span class="line">        <span class="built_in">SpecificMethodB</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">/// @brief 基本方法, 可以有三种</span></span><br><span class="line">    <span class="comment">///             - 抽象方法：在抽象类中申明，由具体子类实现</span></span><br><span class="line">    <span class="comment">///             - 具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它</span></span><br><span class="line">    <span class="comment">///             - 钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AbstractMethod</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SpecificMethodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is AbstractClass::SpecificMethodA!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SpecificMethodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is AbstractClass::SpecificMethodB!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">HookMethodA</span><span class="params">()</span> </span>&#123;    <span class="comment">// 通常为空实现</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is AbstractClass::HookMethodA!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">HookMethodB</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 具体类, 实现抽象类中所定义的抽象方法和钩子方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteClass</span> : <span class="keyword">public</span> AbstractClass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AbstractMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is ConcreteClass::AbstractMethod!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SpecificMethodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is ConcreteClass::SpecificMethodB!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">HookMethodA</span><span class="params">()</span> </span>&#123;    <span class="comment">// 通常为空实现</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is ConcreteClass::HookMethodA!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">HookMethodB</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace template_method</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test_13_composite_impl_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-------------------- %s --------------------\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    template_method::AbstractClass* ptr = <span class="keyword">new</span> template_method::<span class="built_in">ConcreteClass</span>();</span><br><span class="line">    ptr-&gt;<span class="built_in">TemplateMethod</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>优点：</p>
<ol>
<li>
<p><strong>封装了不变部分，扩展可变部分</strong>。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。</p>
</li>
<li>
<p>在父类中提取了公共的部分代码，便于代码复用。</p>
</li>
<li>
<p>部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，<strong>符合开闭原则</strong>。</p>
</li>
</ol>
</li>
<li>
<p>缺点：</p>
<ol>
<li>对每个不同的实现都需要定义一个子类，这会导致<strong>类的个数增加</strong>，系统更加庞大，设计也更加抽象</li>
</ol>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>📌一般推荐将三种基本方法设置为protected<br />
模板方法中，存在由子类影响父类的反向控制，是“控制反转”的典型应用</p>
</blockquote>
<h3 id="14-策略模式strategypolicy"><a class="markdownIt-Anchor" href="#14-策略模式strategypolicy"></a> 14 策略模式（Strategy/Policy）</h3>
<p>软件开发中往往会遇到这样的情况：实现某一个功能有多个途径。而这些不同的方式均被称为策略，每一种方式就是一个策略。</p>
<p>比如实现一个负责查找任务的类，而查找有若干种算法，在类中每一个方法对应着一种算法。或者将所有的算法都封装进一个方法中，通过输入参数和if…else…来判定具体使用何种查找算法。这两种方式都属于硬编码（hard coding），是不推荐的。</p>
<p>原因在于，每增加一种新的查找算法，就需要修改封装算法类的源代码；而且更换查找算法时，也需要修改客户端的调用代码。如果算法类中封装了大量算法，那么该类的代码会比较复杂，维护较为困难。</p>
<p>策略模式旨在解决这样的问题（可以记忆为，解决代码中的大量if…else…），其将众多策略都写成一个类，利用抽象策略类为用户提供接口。同时，让一个Context类（环境类）来耦合客户端和算法类，提供setStrategy用于更换算法，并进行统一语义的执行</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_6PaWAnTsVZ.png" alt="" /></p>
<ul>
<li>
<p>Context：环境类</p>
</li>
<li>
<p>Strategy：抽象策略类</p>
</li>
<li>
<p>ConcreteStrategy：具体策略类</p>
</li>
</ul>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_OPxig-n88x.png" alt="" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 抽象策略类, 定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractStrategy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractStrategy</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">StrategyMethod</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 具体策略类, 实现了抽象策略定义的接口，提供具体的算法实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span> : <span class="keyword">public</span> AbstractStrategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">StrategyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is ConcreteStrategyA::StrategyMethod!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyB</span> : <span class="keyword">public</span> AbstractStrategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">StrategyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is ConcreteStrategyB::StrategyMethod!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 环境类, 持有一个策略类的引用，最终给客户端调用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetStrategy</span><span class="params">(AbstractStrategy* strategy)</span> </span>&#123;</span><br><span class="line">        strategy_ = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">StrategyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strategy_) strategy_-&gt;<span class="built_in">StrategyMethod</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    AbstractStrategy* strategy_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    AbstractStrategy* ptr_strategy_A = <span class="keyword">new</span> <span class="built_in">ConcreteStrategyA</span>();</span><br><span class="line">    AbstractStrategy* ptr_strategy_B = <span class="keyword">new</span> <span class="built_in">ConcreteStrategyB</span>();</span><br><span class="line"></span><br><span class="line">    Context env_;</span><br><span class="line">    env_.<span class="built_in">SetStrategy</span>(ptr_strategy_A);</span><br><span class="line">    env_.<span class="built_in">StrategyMethod</span>();</span><br><span class="line"></span><br><span class="line">    env_.<span class="built_in">SetStrategy</span>(ptr_strategy_B);</span><br><span class="line">    env_.<span class="built_in">StrategyMethod</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> ptr_strategy_A;</span><br><span class="line">    <span class="keyword">delete</span> ptr_strategy_B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>优点：</p>
<ul>
<li>
<p>符合开闭原则，用户可以在不修改原有系统的基础上选择算法行为，也可以灵活地增加新的算法或行为</p>
</li>
<li>
<p>避免多重条件语句</p>
</li>
<li>
<p>提供了管理相关的算法族的办法</p>
</li>
</ul>
</li>
<li>
<p>缺点：</p>
<p>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</p>
</li>
</ul>
<h3 id="15-职责链模式chain-of-responsibility"><a class="markdownIt-Anchor" href="#15-职责链模式chain-of-responsibility"></a> 15 职责链模式（Chain of Responsibility）</h3>
<p>考虑这样的例子：企业的采购审批是一般是分级进行的，即根据采购金额的不同由不同层次的主管人员来审批。主任可以审批5万元以下的采购单，副董事长可以审批5万元至10万元的采购单，董事长可以审批10万元至50万元的采购单，50万元及以上的采购单就需要开董事会讨论决定。</p>
<p>那么一个自动化的审批类可以写成如下形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PurchaseRequestHandler</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handlePurchaseRequest</span><span class="params">(<span class="type">const</span> PurchaseRequest&amp; request)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> amount = request.<span class="built_in">getAmount</span>();</span><br><span class="line">        <span class="keyword">if</span>(amount &lt; <span class="number">50000</span>) &#123; <span class="keyword">this</span>-&gt;<span class="built_in">handleByDirector</span>(request); &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(amount &lt; <span class="number">100000</span>) &#123; <span class="keyword">this</span>-&gt;<span class="built_in">handleByVicePresident</span>(request); &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(amount &lt; <span class="number">500000</span>) &#123; <span class="keyword">this</span>-&gt;<span class="built_in">handleByPresident</span>(request); &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="keyword">this</span>-&gt;<span class="built_in">handleByCongress</span>(request); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 主任审批采购单</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleByDirector</span><span class="params">(<span class="type">const</span> PurchaseRequest&amp; request)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 副董事长审批采购单</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleByVicePresident</span><span class="params">(<span class="type">const</span> PurchaseRequest&amp; request)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 董事长审批采购单</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleByPresident</span><span class="params">(<span class="type">const</span> PurchaseRequest&amp; request)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 董事会审批采购单</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleByCongress</span><span class="params">(<span class="type">const</span> PurchaseRequest&amp; request)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是仔细审视这段代码的话，首先，它违反了单一职责原则，各个级别的审批方法都集中在一个类中，测试和维护难度大。同时不够灵活，现有审批流程从“主任→副董→董事长→董事会”改为“主任→董事长→董事会”，就必须修改类的源代码。</p>
<blockquote>
<p>职责链模式面向的场景：一个请求有多个对象可以处理，但是每个对象的处理条件或权限不同。</p>
</blockquote>
<p>职责链负责解决这样的问题，将每一级写成对象后，排成一个链表。而每一级的执行顺序，交由客户端来管理。</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_764XUH49fC.png" alt="" /></p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_XcWdMEsFCy.png" alt="" /></p>
<ul>
<li>
<p>Handler：抽象处理者，successor负责对下一级的引用，通过successor，处理者们可以连成一条链</p>
</li>
<li>
<p>ConcreteHandler：具体处理者，继承抽象处理者，负责具体实现对请求的响应。</p>
</li>
</ul>
<p>职责链模式代码模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象处理者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSuccessor</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;Handler&gt;&amp; successor)</span> </span>&#123;</span><br><span class="line">        successor_ = successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handleRequest</span><span class="params">(<span class="type">const</span> Request&amp; request)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::shared_ptr&lt;Handler&gt; successor_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体处理者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteHandler</span> : <span class="keyword">public</span> Handler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleRequest</span><span class="params">(<span class="type">const</span> Request&amp; request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="comment">/*满足某个条件*/</span>) &#123; </span><br><span class="line">            <span class="comment">// TO DO </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; successor_-&gt;<span class="built_in">handleRequest</span>(request); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌职责链模式更细分的话也有两种：纯职责链和非纯职责链<br />
纯职责链中，每一级直接完全承担对请求的响应；<br />
非纯职责链中，每一级承担部分响应工作。</p>
</blockquote>
<p>针对上面的例子，使用职责链模式修改的结果如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采购请求处理类：抽象处理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PurchaseRequestHandler</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSuccessor</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;PurchaseRequestHandler&gt;&amp; successor)</span> </span>&#123;</span><br><span class="line">        successor_ = successor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handlePurchaseRequest</span><span class="params">(<span class="type">const</span> PurchaseRequest&amp; request)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::shared_ptr&lt;PurchaseRequestHandler&gt; successor_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主任类：具体处理者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DirectorHandler</span> : <span class="keyword">public</span> PurchaseRequestHandler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handlePurchaseRequest</span><span class="params">(<span class="type">const</span> PurchaseRequest&amp; request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(request.<span class="built_in">getAmount</span>() &lt; <span class="number">50000</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; successor_-&gt;<span class="built_in">handlePurchaseRequest</span>(request); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">... ...</span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line">PurchaseRequest request;</span><br><span class="line">request.<span class="built_in">setAmount</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;PurchaseRequestHandler&gt; director = std::<span class="built_in">make_shared</span>&lt;DirectorHandler&gt;();</span><br><span class="line">std::shared_ptr&lt;PurchaseRequestHandler&gt; vicePresident = std::<span class="built_in">make_shared</span>&lt;VicePresidentHandler&gt;();</span><br><span class="line">std::shared_ptr&lt;PurchaseRequestHandler&gt; president = std::<span class="built_in">make_shared</span>&lt;PresidentHandler&gt;();</span><br><span class="line">std::shared_ptr&lt;PurchaseRequestHandler&gt; congress = std::<span class="built_in">make_shared</span>&lt;CongressHandler&gt;();</span><br><span class="line">director-&gt;<span class="built_in">setSuccessor</span>(vicePresident);</span><br><span class="line">vicePresident-&gt;<span class="built_in">setSuccessor</span>(president);</span><br><span class="line">president-&gt;<span class="built_in">setSuccessor</span>(congress);</span><br><span class="line"></span><br><span class="line">director-&gt;<span class="built_in">handlePurchaseRequest</span>(request);</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>优点：</p>
<ul>
<li>
<p>由客户端负责职责链的创建，链中对象不需要知道链的结构，降低了系统耦合度</p>
</li>
<li>
<p>灵活性更强，添加一个新的具体请求处理者时无需更改原有系统的代码，只需要在客户端重新建链即可，符合开闭原则。</p>
</li>
</ul>
</li>
<li>
<p>缺点：</p>
<ul>
<li>
<p>可能会出现循环引用的问题，导致系统进入死循环</p>
</li>
<li>
<p>系统性能受到一定影响，代码调试时不太方便</p>
</li>
<li>
<p>由于一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理。</p>
</li>
</ul>
</li>
</ul>
<h3 id="16-状态模式state"><a class="markdownIt-Anchor" href="#16-状态模式state"></a> 16 状态模式（State）</h3>
<p>状态模式将各种可能的行为构建成了状态机，每次请求时自动切换状态（更改行为）。</p>
<ul>
<li>
<p>应用场景：</p>
<p>在软件开发过程中，<strong>应用程序中的有些对象可能会根据不同的情况做出不同的行为</strong>，我们把这种对象称为有状态的对象，而把影响对象行为的一个或多个动态变化的属性称为状态。当有状态的对象与外部事件产生互动时，其内部状态会发生改变，从而使得其行为也随之发生改变。如人的情绪有高兴的时候和伤心的时候，不同的情绪有不同的行为，当然外界也会影响其情绪变化。</p>
</li>
<li>
<p>状态模式流程：</p>
<p>传统方案可能会选择用if…else…来进行分支，涵盖所有的行为。这样的话不符合开闭原则不易维护扩展。状态模式将每种状态及其行为封装成了具体状态类ConcreteState，而所有的具体状态类继承自抽象状态类。用户与Context类交互，Context记录着当前系统的状态，当用户请求时，Context对象将根据当前状态调用具体状态类的行为，同时根据发生的行为更改自己维护的状态，以供下一次请求使用。本质上，在类之间建立状态机，而状态转换的规则维护在了各个具体状态类中。</p>
</li>
</ul>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_hN2yH2ASOc.png" alt="" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Context</span>()&#123;</span><br><span class="line">    m_pState = ConcreteStateA::<span class="built_in">Instance</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Context</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">changeState</span><span class="params">(State * st)</span></span>&#123;</span><br><span class="line">    m_pState = st;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">request</span><span class="params">()</span></span>&#123;</span><br><span class="line">    m_pState-&gt;<span class="built_in">handle</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  State *m_pState;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStateA</span> : <span class="keyword">public</span> State</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">ConcreteStateA</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> State * <span class="title">Instance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="literal">NULL</span> == m_pState)</span><br><span class="line">    &#123;</span><br><span class="line">      m_pState = <span class="keyword">new</span> <span class="built_in">ConcreteStateA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_pState;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handle</span><span class="params">(Context * c)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;doing something in State A.\n done,change state to B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    c-&gt;<span class="built_in">changeState</span>(ConcreteStateB::<span class="built_in">Instance</span>());</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">ConcreteStateA</span>();</span><br><span class="line">  <span class="type">static</span> State * m_pState;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> a = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="string">&#x27;0&#x27;</span> == a)</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;no&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  Context * c = <span class="keyword">new</span> <span class="built_in">Context</span>();</span><br><span class="line">  c-&gt;<span class="built_in">request</span>();</span><br><span class="line">  c-&gt;<span class="built_in">request</span>();</span><br><span class="line">  c-&gt;<span class="built_in">request</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> c;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>优点：</p>
<p>相比于if…else…进行状态变更与判断，状态模式符合单一职责原则，而且开闭原则也支持得更好一些。</p>
</li>
<li>
<p>缺点：</p>
<p>对开闭原则仍然不是很友好，想扩展新状态就必须修改若干具体状态类的源码，修改行为也需要修改对应的源码。因此需要开发者尽可能事先考虑到所有的可能状态。</p>
</li>
</ul>
<h3 id="17-迭代器模式iterator"><a class="markdownIt-Anchor" href="#17-迭代器模式iterator"></a> 17 迭代器模式（Iterator）</h3>
<p>迭代器提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_LPlCPfrZ0o.png" alt="" /></p>
<ul>
<li>
<p>优点：</p>
<ul>
<li>
<p>访问一个聚合对象的内容而无需暴露它的内部表示</p>
</li>
<li>
<p>遍历任务交由迭代器完成，简化了聚合类（聚合类可以不用操心实现迭代的功能）</p>
</li>
<li>
<p>支持以不同的方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历</p>
</li>
<li>
<p>增加新的聚合类和迭代器类都很方便，无需修改原有代码</p>
</li>
<li>
<p>封装性良好，为遍历不同的聚合结构提供一个统一的接口</p>
</li>
</ul>
</li>
</ul>
<p>C++的STL自带了Iterator，无需再手动实现。然而为了能够更直观的看迭代器模式是怎么操作的，这里简单写了一下：</p>
<ul>
<li>Aggregate</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Aggregate</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">count</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> std::string&amp; strValue)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">virtual</span> std::string <span class="keyword">operator</span>[](<span class="type">int</span> nIndex) = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Iterator* <span class="title">createIterator</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteAggregate</span> :</span><br><span class="line">  <span class="keyword">public</span> Aggregate</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ~<span class="built_in">ConcreteAggregate</span>();</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> std::string&amp; strValue)</span><span class="keyword">override</span></span>;</span><br><span class="line">  <span class="comment">//重载下标运算符，只重载了取值功能</span></span><br><span class="line">  std::string <span class="keyword">operator</span>[](<span class="type">int</span> nIndex);</span><br><span class="line">  <span class="function">Iterator* <span class="title">createIterator</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::vector&lt;std::string&gt; m_vecItems;</span><br><span class="line">  Iterator* m_pIterator&#123; <span class="literal">nullptr</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ConcreteAggregate::~<span class="built_in">ConcreteAggregate</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nullptr</span> != m_pIterator)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">delete</span> m_pIterator;</span><br><span class="line">    m_pIterator = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ConcreteAggregate::count</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> m_vecItems.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConcreteAggregate::push</span><span class="params">(<span class="type">const</span> std::string&amp; strValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  m_vecItems.<span class="built_in">push_back</span>(strValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::string ConcreteAggregate::<span class="keyword">operator</span>[](<span class="type">int</span> nIndex)</span><br><span class="line">&#123;</span><br><span class="line">  std::string strRet;</span><br><span class="line">  <span class="keyword">if</span> (nIndex &lt; <span class="built_in">count</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    strRet = m_vecItems[nIndex];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> strRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Iterator* <span class="title">ConcreteAggregate::createIterator</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nullptr</span> == m_pIterator)</span><br><span class="line">  &#123;</span><br><span class="line">    m_pIterator = <span class="keyword">new</span> <span class="built_in">ConcreteIterator</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> m_pIterator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Iterator</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Iterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::string <span class="title">first</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::string <span class="title">next</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">isDone</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::string <span class="title">currentItem</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteIterator</span> :</span><br><span class="line">  <span class="keyword">public</span> Iterator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ConcreteIterator</span>(Aggregate* pAggregate);</span><br><span class="line">  <span class="function">std::string <span class="title">first</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">std::string <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">std::string <span class="title">currentItem</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Aggregate* m_pAggregate&#123; <span class="literal">nullptr</span> &#125;;</span><br><span class="line">  <span class="type">int</span> m_nCurrent&#123; <span class="number">0</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ConcreteIterator::<span class="built_in">ConcreteIterator</span>(Aggregate* pAggregate)</span><br><span class="line">  :<span class="built_in">Iterator</span>(), <span class="built_in">m_pAggregate</span>(pAggregate)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">ConcreteIterator::first</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (*m_pAggregate)[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">ConcreteIterator::next</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::string strRet;</span><br><span class="line">  m_nCurrent++;</span><br><span class="line">  <span class="keyword">if</span> (m_nCurrent &lt; m_pAggregate-&gt;<span class="built_in">count</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    strRet = (*m_pAggregate)[m_nCurrent];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> strRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ConcreteIterator::isDone</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (m_nCurrent &gt;= m_pAggregate-&gt;<span class="built_in">count</span>()) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">ConcreteIterator::currentItem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (*m_pAggregate)[m_nCurrent];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>client</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">client</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ConcreteAggregate* pName = <span class="keyword">new</span> <span class="built_in">ConcreteAggregate</span>();</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nullptr</span> != pName)</span><br><span class="line">  &#123;</span><br><span class="line">    pName-&gt;<span class="built_in">push</span>(<span class="string">&quot;墨白&quot;</span>);</span><br><span class="line">    pName-&gt;<span class="built_in">push</span>(<span class="string">&quot;金戈铁马&quot;</span>);</span><br><span class="line">    pName-&gt;<span class="built_in">push</span>(<span class="string">&quot;气吞万里如虎&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Iterator* iter = pName-&gt;<span class="built_in">createIterator</span>();</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nullptr</span> != iter)</span><br><span class="line">  &#123;</span><br><span class="line">    std::string strItem = iter-&gt;<span class="built_in">first</span>();</span><br><span class="line">    <span class="keyword">while</span> (!iter-&gt;<span class="built_in">isDone</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      std::cout &lt;&lt; iter-&gt;<span class="built_in">currentItem</span>() &lt;&lt; std::endl;</span><br><span class="line">      iter-&gt;<span class="built_in">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;================================&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pName-&gt;<span class="built_in">count</span>(); ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; (*pName)[i] &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="18-访问者模式visitor"><a class="markdownIt-Anchor" href="#18-访问者模式visitor"></a> 18 访问者模式（Visitor）</h3>
<blockquote>
<p>访问者模式表示一个作用于某对象结构中各元素的操作，它使我们可以在不改变各元素的类的前提下，定义作用于这些元素的新操作。</p>
</blockquote>
<ul>
<li>
<p>应用场景：</p>
<p>某对象结构中，各元素的类型可能不一致，而上层需要一个对各元素具体操作的统一接口。</p>
</li>
</ul>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_MkjMugjdg_.png" alt="" /></p>
<ul>
<li>
<p>Visitor：抽象访问者，为ObjectStructure类中每一个元素声明一个访问操作。</p>
</li>
<li>
<p>ConcreteVisitor：具体访问者，针对集合中的各具体类型，定义具体访问操作。</p>
</li>
<li>
<p>Element：抽象元素，即集合中的所有具体元素均继承自该抽象元素类，定义了一个accpet( )方法，方法以一个抽象访问者作为参数。</p>
</li>
<li>
<p>ConcreteElement：具体元素，实现了Accpet( )方法。接收不同的ConcreteVisitor对象作为参数，就表示在使用不同的集合元素操作方式。</p>
</li>
<li>
<p>ObjectStructure：元素的集合，各元素可能属于不同类型，类提供了遍历其内部元素的方法。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteElementA</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteElementB</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*抽象访问者  声明了访问元素对象的方法，通常为每一种类型的元素对象都提供一个访问方法*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Visitor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">VisitConcreteElementA</span><span class="params">(ConcreteElementA *pElementA)</span> </span>= <span class="number">0</span>;</span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">VisitConcreteElementB</span><span class="params">(ConcreteElementB *pElementB)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*具体访问者 用于定义对不同类型元素对象的操作*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteVisitor1</span> : <span class="keyword">public</span> Visitor</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">VisitConcreteElementA</span><span class="params">(ConcreteElementA *pElementA)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 现在根据传进来的pElementA，可以对ConcreteElementA中的element进行操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">VisitConcreteElementB</span><span class="params">(ConcreteElementB *pElementB)</span></span>&#123;</span><br><span class="line">         <span class="comment">// 现在根据传进来的pElementB，可以对ConcreteElementB中的element进行操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*具体访问者2*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteVisitor2</span> : <span class="keyword">public</span> Visitor</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">VisitConcreteElementA</span><span class="params">(ConcreteElementA *pElementA)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">VisitConcreteElementB</span><span class="params">(ConcreteElementB *pElementB)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*抽象元素类 声明accept()方法，用于接受访问者的访问*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Element</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Accept</span><span class="params">(Visitor *pVisitor)</span> </span>= <span class="number">0</span>;<span class="comment">//accept用于接受访问者的访问</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*具体元素类 通过调用Visitor类的visit()方法实现对元素的访问*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteElementA</span> : <span class="keyword">public</span> Element</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">Accept</span><span class="params">(Visitor *pVisitor)</span><span class="comment">//通过调用visitor对象的 visit()方法实现对元素对象的访问</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pVisitor-&gt;<span class="built_in">VisitConcreteElementA</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*具体元素类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteElementB</span> : <span class="keyword">public</span> Element</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">Accept</span><span class="params">(Visitor *pVisitor)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">     pVisitor-&gt;<span class="built_in">VisitConcreteElementB</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ObjectStructure类(对象结构类)，能枚举它的元素，可以提供一个高层的接口以允许访问者访问它的元素</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectStructure</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">Attach</span><span class="params">(Element *pElement)</span></span>&#123;</span><br><span class="line">         elements.<span class="built_in">push_back</span>(pElement);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">Detach</span><span class="params">(Element *pElement)</span>   </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">         vector&lt;Element *&gt;::iterator it = <span class="built_in">find</span>(elements.<span class="built_in">begin</span>(), elements.<span class="built_in">end</span>(), pElement);</span><br><span class="line">         <span class="keyword">if</span> (it != elements.<span class="built_in">end</span>())</span><br><span class="line">         &#123;</span><br><span class="line">              elements.<span class="built_in">erase</span>(it);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">Accept</span><span class="params">(Visitor *pVisitor)</span></span>&#123;</span><br><span class="line">     <span class="comment">// 为每一个element设置visitor，进行对应的操作</span></span><br><span class="line">         <span class="keyword">for</span> (vector&lt;Element *&gt;::const_iterator it = elements.<span class="built_in">begin</span>(); it != elements.<span class="built_in">end</span>(); ++it)</span><br><span class="line">         &#123;</span><br><span class="line">              (*it)-&gt;<span class="built_in">Accept</span>(pVisitor);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">//实例化对象结构，用于存放元素对象，提供遍历其内部元素的方法</span></span><br><span class="line">     ObjectStructure *pObject = <span class="keyword">new</span> ObjectStructure;</span><br><span class="line">      <span class="comment">//实例化具体元素 并将创建好的元素放入对象结构中</span></span><br><span class="line">     ConcreteElementA *pElementA = <span class="keyword">new</span> ConcreteElementA;</span><br><span class="line">     ConcreteElementB *pElementB = <span class="keyword">new</span> ConcreteElementB;</span><br><span class="line">     pObject-&gt;<span class="built_in">Attach</span>(pElementA);</span><br><span class="line">     pObject-&gt;<span class="built_in">Attach</span>(pElementB);</span><br><span class="line">     <span class="comment">//实例化访问者</span></span><br><span class="line">     ConcreteVisitor1 *pVisitor1 = <span class="keyword">new</span> ConcreteVisitor1;</span><br><span class="line">     ConcreteVisitor2 *pVisitor2 = <span class="keyword">new</span> ConcreteVisitor2;</span><br><span class="line">     <span class="comment">//调用accept方法 来接受访问者对象的访问</span></span><br><span class="line">     pObject-&gt;<span class="built_in">Accept</span>(pVisitor1);</span><br><span class="line">     pObject-&gt;<span class="built_in">Accept</span>(pVisitor2);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (pVisitor2) <span class="keyword">delete</span> pVisitor2;</span><br><span class="line">     <span class="keyword">if</span> (pVisitor1) <span class="keyword">delete</span> pVisitor1;</span><br><span class="line">     <span class="keyword">if</span> (pElementB) <span class="keyword">delete</span> pElementB;</span><br><span class="line">     <span class="keyword">if</span> (pElementA) <span class="keyword">delete</span> pElementA;</span><br><span class="line">     <span class="keyword">if</span> (pObject) <span class="keyword">delete</span> pObject;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>优点：</p>
<p>将数据结构和作用于数据结构之上的操作之间的耦合解开，使得操作数据结构集合可以相对自由的演化。换言之，如果系统的数据结构稳定的话，使用访问者模式使得算法更改或者增加变得很容易，只需添加新的具体访问者类即可。</p>
<p>符合单一职责原则，访问者模式把相关的行为封装在一起，使每一个访问者的功能都比较单一。</p>
</li>
<li>
<p>缺点：</p>
<p>虽然扩展面向数据结构的算法会比较容易，但是增加新的元素类会变得困难。每增加一个新的元素类都意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者中增加相应的具体操作，违背了开闭原则。</p>
<p>违反了依赖倒置原则，访问者模式依赖了具体类，而没有依赖抽象类。</p>
</li>
</ul>
<h3 id="19-备忘录模式memento"><a class="markdownIt-Anchor" href="#19-备忘录模式memento"></a> 19 备忘录模式（Memento）</h3>
<blockquote>
<p><code>Memento</code> 在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它</p>
</blockquote>
<p>以打游戏为例，当通过一关时往往会选择存档，下次再玩时就可以从存档的地方开始，而不需要从头开玩。这里就用到了备忘录模式，通过记录状态，而避免不必要的重复劳动。</p>
<p>很多应用软件都提供了这项功能，如 Word、记事本、Photoshop、Eclipse 等软件在编辑时按 Ctrl+Z 组合键时能撤销当前操作，使文档恢复到之前的状态；还有在 IE 中的后退键、数据库事务管理中的回滚操作、玩游戏时的中间结果存档功能、数据库与操作系统的备份操作、棋类游戏中的悔棋功能等都属于这类。</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_E09UNJ-ffJ.png" alt="" /></p>
<ul>
<li>实现代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memento</span> &#123; <span class="comment">// 备忘录</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string state;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Memento</span>(string s) &#123; state = s; &#125;</span><br><span class="line">    <span class="function">string <span class="title">GetState</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> state; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetState</span><span class="params">(string s)</span> </span>&#123; state = s; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Caretaker</span> &#123; <span class="comment">// 管理者</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Memento* menento;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Caretaker(Memento* m) &#123; menento = m; &#125;</span></span><br><span class="line">    <span class="function">Memento* <span class="title">GetMemento</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> menento; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetMemento</span><span class="params">(Memento* m)</span> </span>&#123; menento = m; &#125;</span><br><span class="line">    ~<span class="built_in">Caretaker</span>() &#123; <span class="keyword">delete</span> menento; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Originator</span> &#123; <span class="comment">// 发起人</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string state; <span class="comment">// 需要保存的属性</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">GetState</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> state; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetState</span><span class="params">(string s)</span> </span>&#123; state = s; &#125;</span><br><span class="line">    <span class="function">Memento* <span class="title">CreateMemento</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Memento</span>(state); &#125; <span class="comment">// 创建备忘录对象，保存信息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetMemento</span><span class="params">(Memento* m)</span> </span>&#123; state = m-&gt;<span class="built_in">GetState</span>(); &#125;  <span class="comment">// 恢复备忘录</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;state: &quot;</span> &lt;&lt; state &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Originator* o = <span class="keyword">new</span> <span class="built_in">Originator</span>();</span><br><span class="line">    o-&gt;<span class="built_in">SetState</span>(<span class="string">&quot;On&quot;</span>);</span><br><span class="line">    o-&gt;<span class="built_in">Show</span>();   <span class="comment">// state: On</span></span><br><span class="line"></span><br><span class="line">    Caretaker* c = <span class="keyword">new</span> <span class="built_in">Caretaker</span>();</span><br><span class="line">    c-&gt;<span class="built_in">SetMemento</span>(o-&gt;<span class="built_in">CreateMemento</span>());   <span class="comment">// 保存状态</span></span><br><span class="line"></span><br><span class="line">    o-&gt;<span class="built_in">SetState</span>(<span class="string">&quot;Off&quot;</span>);</span><br><span class="line">    o-&gt;<span class="built_in">Show</span>();   <span class="comment">// state: Off</span></span><br><span class="line"></span><br><span class="line">    o-&gt;<span class="built_in">SetMemento</span>(c-&gt;<span class="built_in">GetMemento</span>()); <span class="comment">// 恢复初始状态</span></span><br><span class="line">    o-&gt;<span class="built_in">Show</span>();   <span class="comment">// state: On</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> o;</span><br><span class="line">    <span class="keyword">delete</span> c;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>优点：</p>
<ul>
<li>
<p>提供了一种可以恢复状态的机制。<strong>当用户需要时能够比较方便地将数据恢复到某个历史的状态</strong>。</p>
</li>
<li>
<p>实现了内部状态的封装。<strong>除了创建它的发起人之外，其他对象都不能够访问这些状态信息</strong>。</p>
</li>
<li>
<p><strong>发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合</strong>。</p>
</li>
</ul>
</li>
<li>
<p>缺点：</p>
<p>资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。</p>
</li>
</ul>
<h3 id="20-命令模式command"><a class="markdownIt-Anchor" href="#20-命令模式command"></a> 20 命令模式（Command）</h3>
<blockquote>
<p>将一个请求封装成一个对象，使<strong>发出请求的责任和执行请求的责任分割开</strong>。</p>
</blockquote>
<p>以12306应用为例：</p>
<ul>
<li>
<p>紧耦合：老版本的12306网站，买票时可以不停地用鼠标点击12306网站上的购票按钮来抢票。对于每一次点击，服务器都要进行处理，做出响应，来告诉用户有没有买到票，这样的话会出现很多次无效的点击，增加了服务器的负担。</p>
<p>此时，发出请求和执行请求，二者进入了紧耦合的状态。用户（命令发送者）通过按钮（具体命令）来买票（12306网站服务器成为命令接收者）。</p>
</li>
<li>
<p>松耦合：新版本的12306网站引入了购票队列机制。当点击购票按钮后，购票请求就进入了相应的购票队列，进入后再次鼠标点击购票时，12306会拒绝新的购票请求，并且告诉用户已经进入了购票队列。处于购票队列的用户也可以选择退出购票队列去购买其他车次的车票。这样就可以有效地减少购票者发送多次无效购票请求的情况。</p>
<p>观察这样的改进方案，可以发现，将前面的发出请求和执行请求解耦了。用户点击按钮后发出请求，请求进入了队列中，此时<strong>队列成为了后面流程下具体的请求发送者</strong>，不同的请求对应了不同的命令。不同命令需要采取不同的动作，动作是由接收者（服务器）做出的，因此将这些动作都封装成类之后，就可以与相应的命令类绑定。而队列发出请求后，先找到相应的命令，再由命令执行绑定的接收者的动作。命令中可以结合备忘录模式记录状态，而队列里可以实现消除无效点击的代码。</p>
<p>也就是说，核心在请求的发送者和请求的执行者之间增加了“命令”和新的“请求管理者”，以解耦二者。命令便于对功能进行扩展。如果想有新的按钮功能，实现新的具体命令类即可，同时具体命令类中可以记录状态，这样请求管理者就方便做撤销、重做等操作。</p>
</li>
</ul>
<p><strong>应用场景</strong>：</p>
<p>软件开发系统中，常常出现“方法的请求者”与“方法的实现者”之间存在紧密的耦合关系，不利于软件功能的扩展与维护。比如，想对行为进行“撤销、重做、记录”等处理都不方便。</p>
<p>命令模式旨在将“请求者”和“实现者”解耦，通过在二者之间增加“命令”。命令中可以记录状态，进行撤销等操作。想要扩展功能，也就可以实现新的具体命令类或新的具体接收者类。</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_FzbBrhJfAw.png" alt="" /></p>
<ul>
<li>
<p>Command：抽象命令类，声明响应请求时待执行操作的接口。</p>
</li>
<li>
<p>ConcreteCommand：具体命令类，绑定一个接收者，通过让接收者做出动作来执行命令。</p>
<p> Execute方法来调用相应的Receiver对象，从而响应请求。也可以实现其他方法来扩展此命令下的可选操作。</p>
</li>
<li>
<p>Invoker：与客户端直接相关，请求的发送者或者请求的管理者。</p>
</li>
<li>
<p>Receiver：真正的接收者，实现响应请求需要做的动作。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 抽象命令类, 声明执行命令的接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractCommand</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractCommand</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Execute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 命令接收者, 执行命令功能的相关操作，是具体命令对象业务的真正实现者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Receiver</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is Receiver::Action!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 具体命令类, 它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCommand</span> : <span class="keyword">public</span> AbstractCommand &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteCommand</span>() &#123;</span><br><span class="line">        receiver_.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Receiver</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver_-&gt;<span class="built_in">Action</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;Receiver&gt; receiver_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 命令请求者, 请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Invoker</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Invoker</span>(AbstractCommand* cmd) : <span class="built_in">cmd_</span>(cmd) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetCommand</span><span class="params">(AbstractCommand* cmd)</span> </span>&#123;</span><br><span class="line">        cmd_ = cmd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cmd_-&gt;<span class="built_in">Execute</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    AbstractCommand* cmd_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>main函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">std::shared_ptr&lt;AbstractCommand&gt; <span class="title">cmd</span><span class="params">(<span class="keyword">new</span> ConcreteCommand())</span></span>;</span><br><span class="line">  <span class="function">Invoker <span class="title">client</span><span class="params">(cmd.get())</span></span>;</span><br><span class="line">  client.<span class="built_in">Request</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>优点：</p>
<ul>
<li>
<p><strong>降低系统的耦合度</strong>，将调用操作的对象与实现该操作的对象解耦。</p>
</li>
<li>
<p><strong>增加或删除命令非常方便</strong>。增加或删除操作不会影响其他类，满足开闭原则。</p>
</li>
<li>
<p>可以实现宏命令。命令模式可以与组合模式结合，<strong>将多个命令装配成一个组合命令，即宏命令</strong>。</p>
</li>
<li>
<p><strong>方便实现Undo和Redo操作</strong>。命令模式可以与备忘录模式结合，实现命令的撤销与恢复。</p>
</li>
</ul>
</li>
</ul>
<h4 id="宏命令"><a class="markdownIt-Anchor" href="#宏命令"></a> 宏命令</h4>
<p>前面提到，命令模式可以与组合模式相结合，从而让多个命令共同组装为一个组合命令，即宏命令。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 抽象命令类, 声明执行命令的接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractMacroCommand</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractMacroCommand</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Execute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 命令接收者, 执行命令功能的相关操作，是具体命令对象业务的真正实现者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CompositeReceiver</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ActionA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is CompositeReceiver::ActionA!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ActionB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is CompositeReceiver::ActionB!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 具体命令类, 它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCommandA</span> : <span class="keyword">public</span> AbstractMacroCommand &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteCommandA</span>() &#123;</span><br><span class="line">        receiver_.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">CompositeReceiver</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver_-&gt;<span class="built_in">ActionA</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;CompositeReceiver&gt; receiver_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCommandB</span> : <span class="keyword">public</span> AbstractMacroCommand &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteCommandB</span>() &#123;</span><br><span class="line">        receiver_.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">CompositeReceiver</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver_-&gt;<span class="built_in">ActionB</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;CompositeReceiver&gt; receiver_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 命令请求者, 请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CompositeInvoker</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddCommand</span><span class="params">(AbstractMacroCommand* cmd)</span> </span>&#123;</span><br><span class="line">        cmds_.<span class="built_in">emplace_back</span>(cmd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RemoveCommand</span><span class="params">(AbstractMacroCommand* cmd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = cmds_.<span class="built_in">begin</span>(); it != cmds_.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cmd == (*it)) &#123;</span><br><span class="line">                cmds_.<span class="built_in">erase</span>(it++);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>* cmd : cmds_) &#123;</span><br><span class="line">            cmd-&gt;<span class="built_in">Execute</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;AbstractMacroCommand*&gt; cmds_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;AbstractMacroCommand&gt; <span class="title">cmd_A</span><span class="params">(<span class="keyword">new</span> ConcreteCommandA())</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;AbstractMacroCommand&gt; <span class="title">cmd_B</span><span class="params">(<span class="keyword">new</span> ConcreteCommandB())</span></span>;</span><br><span class="line"></span><br><span class="line">    CompositeInvoker client;</span><br><span class="line">    client.<span class="built_in">AddCommand</span>(cmd_A.<span class="built_in">get</span>());</span><br><span class="line">    client.<span class="built_in">AddCommand</span>(cmd_B.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">    client.<span class="built_in">Request</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="21-解释器模式interpreter"><a class="markdownIt-Anchor" href="#21-解释器模式interpreter"></a> 21 解释器模式（Interpreter）</h3>
<p>以大数据统计为例：在大数据统计中，通常需要按照计算模型对现有数据统计、分析、预测。由于计算模型有很多，而且总是在更新，因此系统设计时需要具备高扩展性。</p>
<p>一般计算模型中包含两类符号：数据和计算符，可以将二者解耦，同时让各个计算符均为一个类，继承自抽象运算符类。这样，当需要更改一个运算符的行为时，仅更改该类的实现即可。而且想要扩展计算模型，增加新的具体计算符类即可。</p>
<blockquote>
<p>解释器模式：定义一个语法，定义一个解释器，该解释器处理该语法句子。</p>
</blockquote>
<p>类比到上面的例子，众多运算符操作的集合就是解释器，而语法就是在运算符类中实现的。解释器模式的结构如下：客户端给出表达式（算法模型），Context类将表达式分解为各种符号的组合。而抽象表达式类提供interpret的统一接口，其下分为终结符号和非终结符号两种。终结符号一般是数值、数据，而非终结符号一般为运算符，比如加减乘除四则运算。</p>
<p>当然，终结符号也可以扩展，比如从实数改为复数，那么仅需该TerminalExpression的具体实现即可，由于调用该类对象时会使用→interpret方法，因此NonterminalExpression可以改动很小甚至不改。</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_Vfisq6ZU80.png" alt="" /></p>
<p>举一个更具体的例子——计算器。计算器的算法模型是逆波兰式，Calculator就相当于Context，在运算符实现时仅需针对数据类型实现四则运算即可。</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_vFZ9_EcmBy.png" alt="" /></p>
<p>（下面的代码实现并不好，可用职责链模式进一步优化）</p>
<p><strong>抽象表达式类Node（抽象节点）</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象表达式类Node（抽象节点）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">interpret</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><strong>终结符表达式类ValueNode（值节点类）</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//终结符表达式类ValueNode（值节点类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ValueNode</span> : <span class="keyword">public</span> Node &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ValueNode</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">interpret</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>抽象非终结符表达式类SymbolNode（符号节点类）</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象非终结符表达式类SymbolNode（符号节点类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SymbolNode</span> : <span class="keyword">public</span> Node &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SymbolNode</span>(shared_ptr&lt;Node&gt; left,shared_ptr&lt;Node&gt; right) &#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;left = left;</span><br><span class="line">      <span class="keyword">this</span>-&gt;right = right;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    shared_ptr&lt;Node&gt; left;</span><br><span class="line">    shared_ptr&lt;Node&gt; right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>非终结符表达式类MulNode（乘法节点类）</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非终结符表达式类MulNode（乘法节点类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MulNode</span> : <span class="keyword">public</span> SymbolNode &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MulNode</span>(shared_ptr&lt;Node&gt; left,shared_ptr&lt;Node&gt; right) : <span class="built_in">SymbolNode</span>(left,right) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">interpret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> left-&gt;<span class="built_in">interpret</span>()*right-&gt;<span class="built_in">interpret</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p> <strong>非终结符表达式类DivNode（除法节点类）</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非终结符表达式类DivNode（除法节点类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DivNode</span> : <span class="keyword">public</span> SymbolNode &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DivNode</span>(shared_ptr&lt;Node&gt; left,shared_ptr&lt;Node&gt; right) : <span class="built_in">SymbolNode</span>(left,right) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">interpret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> left-&gt;<span class="built_in">interpret</span>()/right-&gt;<span class="built_in">interpret</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>非终结符表达式类ModNode（求模节点类）</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非终结符表达式类ModNode（求模节点类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModNode</span> : <span class="keyword">public</span> SymbolNode &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ModNode</span>(shared_ptr&lt;Node&gt; left,shared_ptr&lt;Node&gt; right) : <span class="built_in">SymbolNode</span>(left,right) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">interpret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> left-&gt;<span class="built_in">interpret</span>()%right-&gt;<span class="built_in">interpret</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>解析器封装类Calculator（计算器类）</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解析器封装类Calculator（计算器类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bulid</span><span class="params">(string statement)</span> </span>&#123;</span><br><span class="line">      shared_ptr&lt;Node&gt; left,right;</span><br><span class="line">      stack&lt;shared_ptr&lt;Node&gt; &gt; s;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//分割语义 </span></span><br><span class="line">      vector&lt;string&gt; statementArr = <span class="built_in">split</span>(statement,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//处理语义</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; statementArr.<span class="built_in">size</span>() ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(statementArr[i] == <span class="string">&quot;*&quot;</span>)&#123;</span><br><span class="line">          left = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">          <span class="type">int</span> val = <span class="built_in">atoi</span>(statementArr[++i].<span class="built_in">c_str</span>());</span><br><span class="line">          right = <span class="built_in">make_shared</span>&lt;ValueNode&gt;(val);</span><br><span class="line">          s.<span class="built_in">push</span>(<span class="built_in">make_shared</span>&lt;MulNode&gt;(left,right));</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(statementArr[i] == <span class="string">&quot;/&quot;</span>)&#123;</span><br><span class="line">          left = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">          <span class="type">int</span> val = <span class="built_in">atoi</span>(statementArr[++i].<span class="built_in">c_str</span>());</span><br><span class="line">          right = <span class="built_in">make_shared</span>&lt;ValueNode&gt;(val);</span><br><span class="line">          s.<span class="built_in">push</span>(<span class="built_in">make_shared</span>&lt;DivNode&gt;(left,right));</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(statementArr[i] == <span class="string">&quot;%&quot;</span>)&#123;</span><br><span class="line">          left = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">          <span class="type">int</span> val = <span class="built_in">atoi</span>(statementArr[++i].<span class="built_in">c_str</span>());</span><br><span class="line">          right = <span class="built_in">make_shared</span>&lt;ValueNode&gt;(val);</span><br><span class="line">          s.<span class="built_in">push</span>(<span class="built_in">make_shared</span>&lt;ModNode&gt;(left,right));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          s.<span class="built_in">push</span>(<span class="built_in">make_shared</span>&lt;ValueNode&gt;(<span class="built_in">atoi</span>(statementArr[i].<span class="built_in">c_str</span>())));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>-&gt;node = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">compute</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> node-&gt;<span class="built_in">interpret</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    string statement;</span><br><span class="line">    shared_ptr&lt;Node&gt; node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>客户端测试 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端测试 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//需要解析的语句 </span></span><br><span class="line">  string statement = <span class="string">&quot;3 * 4 / 2 % 4&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//解析器 </span></span><br><span class="line">  Calculator calculator;</span><br><span class="line">  calculator.<span class="built_in">bulid</span>(statement);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//计算结果 </span></span><br><span class="line">  <span class="type">int</span> result = calculator.<span class="built_in">compute</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//输出 </span></span><br><span class="line">  cout &lt;&lt; statement &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>优点：</p>
<ul>
<li>
<p>扩展性好：由于在解释器模式中使用类来表示语言的文法规则，因此可以<strong>通过继承等机制来改变或扩展文法</strong>。</p>
</li>
<li>
<p>容易实现： 在语法树中的<strong>每个表达式节点类都是相似的</strong>，所以实现其文法较为容易。</p>
</li>
</ul>
</li>
<li>
<p>缺点：</p>
<ul>
<li>
<p>执行效率较低：解释器模式中<strong>通常使用大量的循环和递归调用</strong>，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。</p>
</li>
<li>
<p>可应用的场景比较少：<strong>在软件开发中，需要定义语言文法的应用实例非常少</strong>，所以这种模式很少被使用到。</p>
</li>
</ul>
</li>
</ul>
<h3 id="22-中介模式mediator"><a class="markdownIt-Anchor" href="#22-中介模式mediator"></a> 22 中介模式（Mediator）</h3>
<p>一个由很多对象组成的模块，其对象间可能存在错综复杂的关联性。以P2P聊天为例，用户对象之间构成了网状结构，将会导致如下问题：</p>
<ul>
<li>
<p>系统结构复杂：对象之间存在大量的相互关联和调用，若有一个对象发生变化，则需要跟踪和该对象关联的其他所有对象，并进行适当处理。</p>
</li>
<li>
<p>对象可重用性差：由于一个对象和其他对象具有很强的关联，若没有其他对象的支持，一个对象很难被另一个系统或模块重用，这些对象表现出来更像一个不可分割的整体，职责较为混乱。</p>
</li>
<li>
<p>系统扩展性低：增加一个新的对象需要在原有相关对象上增加引用，增加新的引用关系也需要调整原有对象，系统耦合度很高，对象操作很不灵活，扩展性差。</p>
</li>
</ul>
<p>中介者模式旨在<strong>利用一个中介对象来封装一系列的对象交互</strong>，使得各对象间不需要显式地相互引用，从而将耦合松散。</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/image_BJw7swbIke.png" alt="" /></p>
<ol>
<li>
<p>Mediator：抽象中介者</p>
</li>
<li>
<p>ConcreteMediator：具体中介者</p>
</li>
<li>
<p>Colleague：抽象同事类，也就是那些相互关联的对象的父类</p>
</li>
<li>
<p>ConcreteColleague：具体同事类，相互关联的对象</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 抽象同事类, 定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractMediator</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractColleague</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractColleague</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// @brief 抽象接口</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Receive</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Send</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// @brief 设置中介对象</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetMedium</span><span class="params">(AbstractMediator* mediator)</span> </span>&#123;</span><br><span class="line">        mediator_ = mediator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    AbstractMediator* mediator_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 具体同事类, 抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteColleagueA</span> : <span class="keyword">public</span> AbstractColleague &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Receive</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteColleagueB</span> : <span class="keyword">public</span> AbstractColleague &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Receive</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 抽象中介类, 中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractMediator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractMediator</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// @brief 注册</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Register</span><span class="params">(AbstractColleague* colleague)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/// @brief 转发</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Relay</span><span class="params">(AbstractColleague* colleague)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 具体中介类, 实现中介者接口. 管理同事对象，协调各个同事角色之间的交互关系，依赖于同事角色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteMediator</span> : <span class="keyword">public</span> AbstractMediator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Register</span><span class="params">(AbstractColleague* colleague)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>* c : colleagues_) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == colleague) <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        colleagues_.<span class="built_in">emplace_back</span>(colleague);</span><br><span class="line">        colleague-&gt;<span class="built_in">SetMedium</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Relay</span><span class="params">(AbstractColleague* colleague)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>* c : colleagues_) &#123;</span><br><span class="line">            <span class="comment">// 转发给除自己外的同事</span></span><br><span class="line">            <span class="keyword">if</span> (c != colleague) c-&gt;<span class="built_in">Receive</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::list&lt;AbstractColleague*&gt; colleagues_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////// 同事类实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConcreteColleagueA::Receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;this is ConcreteColleagueA::Receive!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConcreteColleagueA::Send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;this is ConcreteColleagueA::Send!\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 请中介者转发</span></span><br><span class="line">    mediator_-&gt;<span class="built_in">Relay</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConcreteColleagueB::Receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;this is ConcreteColleagueB::Receive!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConcreteColleagueB::Send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;this is ConcreteColleagueB::Send!\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 请中介者转发</span></span><br><span class="line">    mediator_-&gt;<span class="built_in">Relay</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-------------------- %s --------------------\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="function">std::shared_ptr&lt;AbstractMediator&gt; <span class="title">ptr_md</span><span class="params">(<span class="keyword">new</span> ConcreteMediator())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;AbstractColleague&gt; <span class="title">ptr_c1</span><span class="params">(<span class="keyword">new</span> ConcreteColleagueA())</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;AbstractColleague&gt; <span class="title">ptr_c2</span><span class="params">(<span class="keyword">new</span> ConcreteColleagueB())</span></span>;</span><br><span class="line"></span><br><span class="line">    ptr_md-&gt;<span class="built_in">Register</span>(ptr_c1.<span class="built_in">get</span>());</span><br><span class="line">    ptr_md-&gt;<span class="built_in">Register</span>(ptr_c2.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">    ptr_c1-&gt;<span class="built_in">Send</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-----------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ptr_c2-&gt;<span class="built_in">Send</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>优点：</p>
<ul>
<li>
<p>简化了对象之间的交互；</p>
</li>
<li>
<p>将各同事解耦。</p>
</li>
</ul>
</li>
<li>
<p>缺点：</p>
<p>具体中介者类中包含了同事之间的交互细节，可能会导致具体中介者类非常复杂，让系统难维护。</p>
</li>
</ul>
<h2 id="设计模式思维导图"><a class="markdownIt-Anchor" href="#设计模式思维导图"></a> 设计模式思维导图</h2>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/design-pattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_bWnBly4dT4.jpg" alt="" /></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag"># 设计模式</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/05/18/%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB/" rel="prev" title="【置顶】知识管理">
                  <i class="fa fa-chevron-left"></i> 【置顶】知识管理
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/07/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="next" title="C++基础知识">
                  C++基础知识 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">OliverPai</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.0/katex.min.css" integrity="sha256-uik/hNqHWZldXh/0K35nqOSCff9F61/ZOFReqNOBgB0=" crossorigin="anonymous">



</body>
</html>
