<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.12.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Wolai版笔记：https:&#x2F;&#x2F;www.wolai.com&#x2F;uY47FJQ4xnSAoqV3vPWg1B ，本文简要介绍了TCP协议及其拥塞控制、丢包重传算法，包括Reno、SACK、Vegas、Cubic等。">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP的拥塞控制">
<meta property="og:url" content="http://example.com/2022/10/16/TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/index.html">
<meta property="og:site_name" content="OliverPai">
<meta property="og:description" content="Wolai版笔记：https:&#x2F;&#x2F;www.wolai.com&#x2F;uY47FJQ4xnSAoqV3vPWg1B ，本文简要介绍了TCP协议及其拥塞控制、丢包重传算法，包括Reno、SACK、Vegas、Cubic等。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_W0c1FL4Wnv.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_1eQyo-iD9n.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_kejlS8_D9a.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_Jk7UcOo5Zi.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_q-h63GSf0j.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_xMxRdqyZeZ.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_18ftqd0DZC.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_sl_pxuIvrH.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_glbK10wh_P.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_lEH9Zjbt4H.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_eio3sZSXMM.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_9QghnNMtTc.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_MDa76CuYvD.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_Y_5K4KylPr.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_xR9rX3G_vM.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_OSMjvAxAkP.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_DnEO3e3ir3.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_W8bR5H11M9.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_-mzvMhracw.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_rGnavodHr_.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_eZwI-FUJZY.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_PqyRWborTM.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_dbxJ9GB-Og.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_ysPIi1S8AS.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_JK6i4VBRJ6.png">
<meta property="article:published_time" content="2022-10-16T15:01:49.000Z">
<meta property="article:modified_time" content="2022-10-16T15:04:07.586Z">
<meta property="article:author" content="OliverPai">
<meta property="article:tag" content="WebRTC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_W0c1FL4Wnv.png">


<link rel="canonical" href="http://example.com/2022/10/16/TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2022/10/16/TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/","path":"2022/10/16/TCP的拥塞控制/","title":"TCP的拥塞控制"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>TCP的拥塞控制 | OliverPai</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="OliverPai" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">OliverPai</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">落叶本就是假的</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#tcp%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">1.</span> <span class="nav-text"> TCP的拥塞控制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#udp%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.</span> <span class="nav-text"> UDP协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%92%8C%E8%A7%A3%E5%A4%8D%E7%94%A8"><span class="nav-number">2.1.</span> <span class="nav-text"> 多路复用和解复用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%A1%E9%AA%8C%E5%92%8C"><span class="nav-number">2.2.</span> <span class="nav-text"> 校验和</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#tcp%E7%AE%80%E8%BF%B0"><span class="nav-number">3.</span> <span class="nav-text"> TCP简述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%87%8D%E4%BC%A0"><span class="nav-number">3.1.</span> <span class="nav-text"> 快重传</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-number">3.2.</span> <span class="nav-text"> 流量控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="nav-number">3.3.</span> <span class="nav-text"> 连接管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="nav-number">3.3.1.</span> <span class="nav-text"> 三次握手建立连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5"><span class="nav-number">3.3.2.</span> <span class="nav-text"> 四次挥手断开连接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">3.4.</span> <span class="nav-text"> 拥塞控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%8E%E7%9F%AD%E8%BF%9E%E6%8E%A5"><span class="nav-number">3.5.</span> <span class="nav-text"> 长连接与短连接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E6%B4%BB%E6%9C%BA%E5%88%B6"><span class="nav-number">3.5.1.</span> <span class="nav-text"> 保活机制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#tcp%E7%9A%84%E6%8B%A5%E6%8E%A7%E7%AE%97%E6%B3%95"><span class="nav-number">4.</span> <span class="nav-text"> TCP的拥控算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#tahoe"><span class="nav-number">4.1.</span> <span class="nav-text"> Tahoe</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#reno"><span class="nav-number">4.2.</span> <span class="nav-text"> Reno</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new-reno"><span class="nav-number">4.3.</span> <span class="nav-text"> New Reno</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sack"><span class="nav-number">4.4.</span> <span class="nav-text"> SACK</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vegas"><span class="nav-number">4.5.</span> <span class="nav-text"> Vegas</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cubic"><span class="nav-number">4.6.</span> <span class="nav-text"> CUBIC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ecn"><span class="nav-number">4.7.</span> <span class="nav-text"> ECN</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="OliverPai"
      src="/images/avatar-star.png">
  <p class="site-author-name" itemprop="name">OliverPai</p>
  <div class="site-description" itemprop="description">求索与记录</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/OliverPai" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;OliverPai" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/16/TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar-star.png">
      <meta itemprop="name" content="OliverPai">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OliverPai">
      <meta itemprop="description" content="求索与记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="TCP的拥塞控制 | OliverPai">
      <meta itemprop="description" content="Wolai版笔记：https://www.wolai.com/uY47FJQ4xnSAoqV3vPWg1B ，本文简要介绍了TCP协议及其拥塞控制、丢包重传算法，包括Reno、SACK、Vegas、Cubic等。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          TCP的拥塞控制
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-10-16 23:01:49 / 修改时间：23:04:07" itemprop="dateCreated datePublished" datetime="2022-10-16T23:01:49+08:00">2022-10-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">计算机基础知识</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">Wolai版笔记：https://www.wolai.com/uY47FJQ4xnSAoqV3vPWg1B ，本文简要介绍了TCP协议及其拥塞控制、丢包重传算法，包括Reno、SACK、Vegas、Cubic等。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="tcp的拥塞控制"><a class="markdownIt-Anchor" href="#tcp的拥塞控制"></a> TCP的拥塞控制</h1>
<blockquote>
<p>参考资料：B站中科大郑烇老师系列视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV16g411g7uj/?spm_id_from=333.788&amp;vd_source=9c16706f7b5875153903faf53062a899" title="https://www.bilibili.com/video/BV16g411g7uj/?spm_id_from=333.788&amp;vd_source=9c16706f7b5875153903faf53062a899">https://www.bilibili.com/video/BV16g411g7uj/?spm_id_from=333.788&amp;vd_source=9c16706f7b5875153903faf53062a899</a></p>
</blockquote>
<h1 id="udp协议"><a class="markdownIt-Anchor" href="#udp协议"></a> UDP协议</h1>
<p>UDP在IP协议的基础上没有增加太多特性，只增加了<strong>多路复用和解复用</strong>，这样原先只能<strong>主机到主机</strong>的IP协议，现在可以通过UDP协议实现<strong>进程到进程</strong>。</p>
<img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_W0c1FL4Wnv.png" style="zoom:67%;" />
<p>UDP的头部包含8个字节，四个部分，每部分两个字节（16比特）。在头部这方面UDP的开销就要比TCP小很多，TCP的头部不包括option就要有20字节，类比于一个货车，如果货车头占比太重，那么货车能拉的载荷自然会少很多，因此从头部开销的角度来看，UDP的速率就会快很多。</p>
<p>UDP不提供纠错机制，只提供校验和来检测报文段是否在传输过程中有错误发生，而且有时也检测不出来（残存错误）。</p>
<h2 id="多路复用和解复用"><a class="markdownIt-Anchor" href="#多路复用和解复用"></a> 多路复用和解复用</h2>
<p>套接字（socket）与进程PID绑定，所以同一条链路可被多个数据流复用，之后再利用套接字解复用，将不同的数据流交付给不同的进程。</p>
<ul>
<li>
<p>UDP的多路复用：无连接的多路解复用</p>
<table>
<thead>
<tr>
<th>Socket</th>
<th>ip</th>
<th>port</th>
<th>PID</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>UDP将二元组（目标IP、目标端口）与Socket绑定。即复用的数据流，可以通过该二元组查找到对应Socket，进而找到其绑定的进程PID，将相应的数据流转交给该进程。</p>
</li>
<li>
<p>TCP的多路复用：有连接的多路解复用</p>
<table>
<thead>
<tr>
<th>Socket</th>
<th>source IP</th>
<th>source Port</th>
<th>destination IP</th>
<th>destination Port</th>
<th>PID</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>TCP将四元组（源IP、源端口、目标IP、目标端口）与Socket绑定。复用的来自不同连接的数据流，可以通过四元组查找到对应连接的Socket，进而确定其绑定的进程PID，将数据交付给进程。</p>
</li>
</ul>
<p>下面两个例子体现了UDP和TCP进行多路复用时的差别：</p>
<img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_1eQyo-iD9n.png"  />
<p>左图为基于UDP的多路复用和解复用，右图为基于TCP的。在左图中，P1和P2向相同的IP+Port通信，即使P1和P2的源IP与源端口均不相同，两个终端的数据最终只会由P3这一个进程接收。即UDP在解复用时，只关注封装在UDP数据报中的目标端口（在这里就是46428），所有汇到此端口的数据均被送入同一个进程。</p>
<p>而右图中，P4与P1通信（图中有误，最左的进程应该是P1），P5与P3通信，P6与P2通信。其中P1发送到P4，P2发送到P5，和P3发送到P6时，目标端口均为80，但由于源IP和源port不同，因此三条链路对应三个进程。</p>
<p>总结来说，UDP解复用是不需要查看连接的，只要目的地一致，多路数据流共同汇入同一个进程；而TCP解复用是需要找到对应连接的Socket的，将各路数据流分别交付给连接所处的进程中。</p>
<h2 id="校验和"><a class="markdownIt-Anchor" href="#校验和"></a> 校验和</h2>
<p><strong>发送方：</strong></p>
<p>有效载荷中的数据，不管原本要表达字符还是浮点数，统一划分成若干16比特的整数，将这些整数相加，对应“校验和”的概念。涉及到溢出的问题时，就进行进位回滚，如图：</p>
<img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_kejlS8_D9a.png" style="zoom: 50%;" />
<p>两个16位整数求和后出现了进位，结果不再是16位，那就将最高位多出来的那个1，作为0x0001加到后面16位上，从而得到不溢出的16位数字。</p>
<p>这仅仅是载荷的和，校验和还要在和的基础上取反码。</p>
<p><strong>接收方：</strong></p>
<p>接收端收到UDP报文段后，便会进行数据校验。把校验范围内的载荷，按16比特划分整数后相加，相加的过程中有溢出依然遵循进位回滚策略。加和结果，再与校验和字段的16比特进行求和。</p>
<p>若最终的结果是0xffff，即16位均是1，那么就通过校验。否则说明检测出了差错。</p>
<blockquote>
<p>UDP的校验范围可能不仅限于有效载荷，有时还有考虑头部或伪头部，视具体情况而定。</p>
</blockquote>
<p>虽说发收双方可以通过校验和来检错，但是可能会存在极端情况，在传输过程中校验范围的载荷，和检验和字段都出错了，而且错的很离奇，碰巧接收端求和之后还能得到16位1，那么这种错误对于纯UDP协议而言是无能为力的。</p>
<p>这类错误被称为残存错误，也就是即使通过了校验，依然未能发现的错误。</p>
<blockquote>
<p>📌残存错误是有时候在网上下载大文件后，打不开的原因之一：用UDP下载，但是碰巧出现了残存错误，检测不出来，所以虽然表面上下载了完整的文件，但其实内容是错的。</p>
</blockquote>
<h1 id="tcp简述"><a class="markdownIt-Anchor" href="#tcp简述"></a> TCP简述</h1>
<p>TCP要将字节流（应用层交付过来的报文）根据MSS（Maximum Segment Size）的大小来分段，分后的每个段加上头部，构成了TCP报文段。</p>
<p>而之所以要有MSS来分段，原因在于任何类型的网络都要有MTU（Maximum transmission unit），比如以太网的MTU是1500字节，表示一次最大传输的载荷数量。而应用层交付的报文可能过大，因此需要用MSS来划分，这样划分后的段，加上TCP头部，加上IP头部，得到的字节数正好可以在MTU限制下。</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_Jk7UcOo5Zi.png" alt="" /></p>
<p>注意这里的序号，描述的是报文中数据的第一个字节，在整个字节流的偏移量（以字节为单位），如下图。</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_q-h63GSf0j.png" alt="" /></p>
<p>确认号也是类似的，以字节为单位。主机A向主机B发送的确认号，意味着其期望从主机B收到的下一个字节的序号，也标识着主机A已经成功接收到该序号之前的所有字节。</p>
<p>比如确认了ACK=555，说明主机A已经收到554及之前的字节，请求555。</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_xMxRdqyZeZ.png" alt="" /></p>
<blockquote>
<p>📌TCP接收方如何处理乱序的报文段？<br />
标准中没有相应规定，取决于实现者自己，既可以缓存起来，也可以直接丢弃。</p>
</blockquote>
<ul>
<li>
<p>TCP的超时重传：</p>
<p>TCP在发送某个报文后就开启一个计时器，在一定时间内如果没有得到发送的报文的ACK报文，那么就重新发送数据，直到发送成功为止。</p>
<p>这里的关键就在于<strong>计时器的超时时间如何设置</strong>，如果太短会造成不必要的重传，太长则反应太慢。</p>
<p>TCP中的定时是动态变化的。会测量从报文段发出到收到确认的时间<code>SampleRTT</code>（如果有重传，忽略此次测量），之后对几个最近的测量值做平滑操作：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>EstimatedRTT</mtext><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="false">)</mo><mo>×</mo><mtext>EstimatedRTT</mtext><mo>+</mo><mi>α</mi><mo>×</mo><mtext>SampleRTT</mtext></mrow><annotation encoding="application/x-tex">\text{EstimatedRTT}=(1-\alpha)\times \text{EstimatedRTT}+\alpha\times \text{SampleRTT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">EstimatedRTT</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord text"><span class="mord">EstimatedRTT</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">SampleRTT</span></span></span></span></span></p>
<p>一般推荐<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mn>0.125</mn></mrow><annotation encoding="application/x-tex">\alpha = 0.125</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">1</span><span class="mord">2</span><span class="mord">5</span></span></span></span>。之后往返延时的平均值+4倍方差，作为超时时间。这里加上4倍方差的目的也是为了处理抖动特别大的情况，用方差来表示抖动情况，从而使得计时器能够有一个较大的安全边界时间。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>DevRTT</mtext><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>β</mi><mo stretchy="false">)</mo><mo>×</mo><mtext>DevRTT</mtext><mo>+</mo><mi>β</mi><mo>×</mo><mi mathvariant="normal">∣</mi><mtext>SampleRTT</mtext><mo>−</mo><mtext>EstimatedRTT</mtext><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">\text{DevRTT}=(1-\beta)\times \text{DevRTT}+\beta\times|\text{SampleRTT}-\text{EstimatedRTT}|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">DevRTT</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord text"><span class="mord">DevRTT</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord text"><span class="mord">SampleRTT</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">EstimatedRTT</span></span><span class="mord">∣</span></span></span></span></p>
<p>一般推荐<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>=</mo><mn>0.25</mn></mrow><annotation encoding="application/x-tex">\beta = 0.25</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">2</span><span class="mord">5</span></span></span></span>。</p>
<p>$ \text{TimeoutInterval} = \text{EstimatedRTT}+4\times\text{DevRTT}  $</p>
</li>
</ul>
<blockquote>
<p>📌TCP发送一个字节流时（多个报文段的组合）只有一个计时器，并不是每个报文段都有自己的计时器。<br />
通过这样的机制，相当于使用了GBN（Go back-N）这种RDT策略。</p>
</blockquote>
<blockquote>
<p>RDT：Reliable Data Transfer，可靠数据传输<br />
Go-Back-N：回退N步，接收方则是只接受最小的未接收报文段，对错序到达段，都丢弃<br />
Selective Repeat：只重传丢失的报文段，乱序到达的报文段缓存起来</p>
</blockquote>
<ul>
<li>
<p>TCP的累积确认</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_18ftqd0DZC.png" alt="" /></p>
<p>TCP建立了一个滑动窗口以进行超时重传，用Base（窗口后沿）和Next（窗口前沿）来标识。最老的未被接收的报文段序号用Base表示，而Next就是窗口均被确认后，下一次该发的段序号。</p>
<p>TCP发送方会经历的一系列事件：</p>
<ol>
<li>
<p>从应用层接收数据</p>
<ul>
<li>
<p>创建报文段</p>
</li>
<li>
<p>若定时器还没运行，则启动定时器，定时器与Base相关联</p>
</li>
</ul>
</li>
<li>
<p>收到确认</p>
<ul>
<li>
<p>更新已被确认的报文段序号</p>
</li>
<li>
<p>如果窗口内还有未被确认的报文段，重新启动定时器</p>
</li>
</ul>
</li>
<li>
<p>超时</p>
<ul>
<li>重传最老的未接收报文段（Base），重新启动定时器</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">NextSeqNum = InitialSeqNum</span><br><span class="line">SendBase = InitialSeqNum</span><br><span class="line"></span><br><span class="line"><span class="built_in">loop</span> (forever) &#123;</span><br><span class="line">  <span class="keyword">switch</span>(event)</span><br><span class="line">  </span><br><span class="line">  event: data received from application above</span><br><span class="line">    create TCP segment with sequence number NextSeqNum</span><br><span class="line">    <span class="keyword">if</span> (timer currently <span class="keyword">not</span> running)</span><br><span class="line">      start timer</span><br><span class="line">    pass segment to IP</span><br><span class="line">    NextSeqNum = NextSeqNum + <span class="built_in">length</span>(data)</span><br><span class="line"></span><br><span class="line">  event: timer timeout</span><br><span class="line">    retransmit <span class="keyword">not</span>-yet-acknowledged segment with</span><br><span class="line">      smallest sequence number</span><br><span class="line">  start timer</span><br><span class="line"></span><br><span class="line">  event: ACK received, with ACK field value of y</span><br><span class="line">    <span class="keyword">if</span> (y &gt; SendBase) &#123;</span><br><span class="line">      SendBase = y</span><br><span class="line">      <span class="keyword">if</span> (there are currently <span class="keyword">not</span>-yet-acknowledged segments)</span><br><span class="line">        start timer</span><br><span class="line">      &#125;</span><br><span class="line">&#125; <span class="comment">/* end of loop forever */</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>TCP的累积确认很像GBN，即只重传最老未被确认的报文。考虑以下几种情况：</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_sl_pxuIvrH.png" alt="" /></p>
<p>除此之外，TCP还提供了SR（Selective Repeat），通过接收端的SACK报文来实现。关于SACK可见后文。</p>
<blockquote>
<p>📌TCP的重传机制不是永无止境的，有一个最大的重传次数限制。默认是16次，而且同一个包，重传之间的时间间隔也不是固定值，而是从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">2^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">2^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span>。<br />
比如第一次重传等1秒，没有回应就重传第二次，等2秒。还没有回应就重传第三次，等4秒，以此类推。<br />
当然，Linux系统下，16次之类的参数也是可以修改的。</p>
</blockquote>
<h2 id="快重传"><a class="markdownIt-Anchor" href="#快重传"></a> 快重传</h2>
<p>不同于超时重传，TCP中还提供了快速重传机制。对于3个冗余ACK，会判定此时发生丢包，进行重传。此时的重传不是由计时器触发的，而是冗余ACK的行为触发的。</p>
<img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_glbK10wh_P.png" style="zoom:80%;" />
<p>与超时重传相比, 快速重传能更加及时有效地修复丢包情况。而之所以用3个冗余ACK来触发快重传，也是避免重传风暴的发生。单个冗余ACK，可能仅仅是因为抖动，导致包到达接收端比较慢，如果一有冗余包就重传的话，必然会导致大量重复的重传包出现。</p>
<h2 id="流量控制"><a class="markdownIt-Anchor" href="#流量控制"></a> 流量控制</h2>
<p>流量控制的目的在于避免接收端的缓存溢出。接收端的buffer，由TCP协议栈向buffer中放数据，由应用进程从buffer中取数据。如果放数据的速度太快，快过了取数据的速度，那么接收buffer放不下，出现了缓存溢出，就会出现丢包。</p>
<p>TCP的流量控制借由头部的rwnd字段（接收窗口），由接收端向发送端反馈当前可用buffer空间。</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_lEH9Zjbt4H.png" alt="" /></p>
<p>RcvBuffer的大小，减去已在buffer中存储，有待应用进程取出的数据大小，作为可用buffer空间，用于确定rwnd。</p>
<blockquote>
<p>RcvBuffer可通过Socket选项来设置，典型默认大小为4096字节。</p>
</blockquote>
<p>发送方收到反馈，直到rwnd，即接收buffer可用空间后，就会限制inflight包的数据量不大于rwnd。</p>
<p>而rwnd的确定公式为：RcvWindow = RcvBuffer - [LastByteRecv - LastByteRead]。也就是最后一个接收到的offset，减最后一个被应用进程读走的offset，用来确定当前buffer占用的size。</p>
<p>流量控制中还暗含着捎带（Piggybacking）技术。如果接收方在反馈ACK之后，再发一个段，里面包含rwnd，是对链路资源的浪费。而捎带技术就是在ACK反馈时，把要发给发送方的数据放入载荷，并将rwnd放入头部，充分利用报文段。</p>
<h2 id="连接管理"><a class="markdownIt-Anchor" href="#连接管理"></a> 连接管理</h2>
<h3 id="三次握手建立连接"><a class="markdownIt-Anchor" href="#三次握手建立连接"></a> 三次握手建立连接</h3>
<ul>
<li>为什么不能两次握手建立连接？</li>
</ul>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_eio3sZSXMM.png" alt="" /></p>
<p>两次握手的失败场景：<strong>半连接</strong>和<strong>老数据接收</strong>。</p>
<p>左图中，客户端向服务端发起第一次握手req_conn(x)，虽然服务端发了第二次握手，但可能时间较长，客户端在定时周期内没收到，从而重发了第一次握手。过一会儿，第二次握手被客户端收到了，但重发的第一次握手滞留在了网络中。有可能，之后两端断开了连接，滞留的第一次握手才到达服务端。</p>
<p>此时服务端认为客户端要发起连接，便会发起第二次握手，同时在自己这里认为已经建立了连接。但是客户端在收到第二次握手后会直接丢弃，因此自己并没有发起要重新连接的第一次握手，那么客户端就不认为现在建立了连接。</p>
<p>由此，形成了半连接，服务端在维护连接，而客户端则不维护连接。</p>
<p>如果大量这样的半连接被服务端所维护，那么服务端的资源将会被耗尽。</p>
<p>右图中，不仅第一次握手被重传了，数据data(x+1)也因为没有在定时周期内收到ACK而被重传。但是重传的握手和数据都在网络中滞留了，以至于两端连接断开了，才被送至服务端。服务端收到迟来的第一次握手，便发起了第二次握手建立连接，而正好迟来的数据也被发送到，并且与第一次握手的序号一脉相承。那么服务端也会接收该数据。此时，不仅建立了半连接，还接收了不该接的数据。</p>
<p><strong>三次握手解决半连接</strong></p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_9QghnNMtTc.png" alt="" /></p>
<p>如图，第一次的req_conn(x)被客户端认定超时后，客户端会重发一个第一次握手。而如果这个重发的握手因为一些未知原因滞留在网络很久，久到两端已经断开连接了，才发送到服务端。那么服务端依然会认为此时客户端想建立连接，从而发起第二次握手。</p>
<p>但客户端收到第二次握手时，由于自己并没有发起连接，因此会给服务端发送refuse。那么不管服务端是否收到了refuse，连接都没有建立起来。就不会出现半连接空耗服务端资源的问题了。</p>
<p><strong>三次握手解决接收老数据问题</strong></p>
<p>与上面的图类似，如果某一个数据在建立连接后，被发送（可能是客户端发，可能是服务端发），而且被判定超时重发后不久，最初发的包到了对端，而重发的包滞留在网络中。之后两端连接断开，滞留的包才被送到对端。此时因为双方都已不再维护连接，因此到的包会被对端直接忽略，如此解决接收老数据的问题。</p>
<p><strong>一种特殊的情况</strong></p>
<p>有一种极其特殊的情况，就是依然是老数据，但是在老数据到达之前，客户端又向服务端发起握手，建立了连接，建立连接后，老数据到达服务端，服务端会不会接呢?</p>
<p>大概率还是不会接的，因为虽然此时四元组可能一样，但是序号不一致了。客户端和服务端的初始序号都是随机生成，或根据时钟周期确定的。前后两次的初始序号很难做到一样。而老数据的序号，很大概率上并不会落在新连接的序号范围内，因此服务端接收到了这个序号奇怪的数据包，依然会丢弃。</p>
<blockquote>
<p>这时服务端也会向客户端发送一个RST包，表示老数据丢弃了</p>
</blockquote>
<blockquote>
<p>📌已经建立TCP连接，而客户端中途宕机，恢复后又向服务端发起连接，服务端会怎么做？<br />
需要分为两种情况讨论：</p>
<p>1. 新连接的SYN报文的端口号，与旧连接的不相同<br />
此时服务端会认为是新的连接要建立，于是通过三次握手建立新连接。<br />
如果服务端在旧连接中发送数据到客户端，那么客户端的连接已关闭，就会返回RST报文，服务端收到后会释放连接。<br />
如果服务端一直没有发送数据到客户端，也会释放连接。因为超过一段时间后，TCP保活机制被触发，检测到客户端未存活，便会立即释放旧连接。</p>
<p>2. 新连接的SYN报文的端口号，与旧连接的相同<br />
服务端在收到新连接的SYN报文，会发现该报文携带的序号与服务端这里维护的有出入，因此会回复客户端一个带有“正确”序号和确认号的报文（同时ACK置1）。这个ACK被称为challenge ACK。当客户端收到此ACK后，发现并不是预期的确认号，会回服务端RST报文。那么服务端收到后，就会释放掉旧连接。此时，新连接就可以开始建立了。</p>
</blockquote>
<h3 id="四次挥手断开连接"><a class="markdownIt-Anchor" href="#四次挥手断开连接"></a> 四次挥手断开连接</h3>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_MDa76CuYvD.png" alt="" /></p>
<p>A客户端，B服务器</p>
<ul>
<li>
<p>A发送连接释放报文，FIN=1</p>
</li>
<li>
<p>B收到之后发出确认，此时TCP属于半关闭状态，B能向A发送数据但是A不能向B发送数据</p>
</li>
<li>
<p>B在CLOSE_WAIT把所有数据发送完后，不再需要连接时，发送连接释放报文，FIN=1</p>
</li>
<li>
<p>A收到后发出确认，进入TIME_WAIT状态，等待2MSL后释放连接</p>
</li>
<li>
<p>B收到A的确认后释放连接</p>
</li>
</ul>
<p><strong>为什么需要TIME_WAIT</strong>：</p>
<p>TIME_WAIT用来重发可能丢失的ACK报文。客户端最后发送的ACK可能会丢失，若丢失则服务器会重复发送FIN报文，此时客户端必须接收到并重发ACK，确保服务器端连接的正常关闭。</p>
<p><strong>为什么TIME_WAIT需要经过2MSL（最大报文段生存时间）</strong>：</p>
<p>MSL是一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，客户端都没有再次收到FIN，那么客户端推断ACK已经被成功接收，则结束TCP连接。</p>
<blockquote>
<p>📌<strong>为什么建立连接是三次握手，而关闭连接却需要四次握手</strong>：<br />
当服务器接收到连接请求后，可以直接发送SYN+ACK。但关闭连接时，当服务器收到FIN报文时，很可能不会立刻关闭socket，所以先回复一个ACK，等准备好关闭后再发送FIN。</p>
</blockquote>
<h2 id="拥塞控制"><a class="markdownIt-Anchor" href="#拥塞控制"></a> 拥塞控制</h2>
<p>在TCP中，除了有一个流量控制的接收窗口，还有一个拥塞窗口Congestion Window。控制发送速率，事实上就是控制已发送未确认的数据量（inflight）小于这个拥塞窗口。</p>
<p>即LastByteSent - LastByteAcked ≤ Congestion Window。</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_Y_5K4KylPr.png" alt="" /></p>
<p>发送端控制inflight的量既不能超过接收窗口，也不能超过拥塞窗口，同时满足拥塞控制和流量控制：</p>
<p>SendWin =  min (CongWin,  RecvWin)</p>
<p>更详细的拥塞控制算法可以看下面的Reno部分。</p>
<h2 id="长连接与短连接"><a class="markdownIt-Anchor" href="#长连接与短连接"></a> 长连接与短连接</h2>
<p>http1.1开始支持长连接。短连接就是三次握手之后，传完了当前批次的数据，便四次挥手释放连接。而长连接的话，在TCP三次握手建立连接后，即使当前批次的数据传完了，客户端与服务端也不主动释放连接，就可以直接传输后续的数据了。</p>
<p>如果http头部设置connection: keep-alive，那么就是启用了长连接。</p>
<h3 id="保活机制"><a class="markdownIt-Anchor" href="#保活机制"></a> 保活机制</h3>
<p>http的长连接基于tcp的keep-alive（保活）机制 ，除非主动断开、宕机，否则TCP的连接不会被释放。</p>
<p>默认情况下，TCP建立连接并传完数据后，开始计时，若7200秒（两小时）都没有数据的交互，建立连接的双方开始发送keep-alive报文，如果75秒没有回应，就再次发送keep-alive包，最多重复9次，若仍然没有回应，那么tcp就断开了。</p>
<blockquote>
<p>📌7200秒和75秒的时间都是可以在上层修改的</p>
</blockquote>
<p>http可看作控制了tcp的参数。如果是http长连接，那么主动释放的时间就会长一些，如果是http短连接，那么主动释放的时间就会短一些。</p>
<blockquote>
<p>http的keep-alive和tcp的keep-alive是不一样的，tcp的是在ESTABLISHED状态时，检测连接的可用性；而http的是避免重复的TCP三次握手四次挥手</p>
</blockquote>
<p>最后盘点一下TCP中，会发送RST报文，来释放连接的几种情况：</p>
<ul>
<li>
<p>端口未打开</p>
</li>
<li>
<p>请求超时（发送端判定第一、二次握手间超时）</p>
</li>
<li>
<p>socket已关闭</p>
</li>
</ul>
<h1 id="tcp的拥控算法"><a class="markdownIt-Anchor" href="#tcp的拥控算法"></a> TCP的拥控算法</h1>
<h2 id="tahoe"><a class="markdownIt-Anchor" href="#tahoe"></a> Tahoe</h2>
<p>Tahoe只有两个状态：慢启动（slow start）和拥塞避免（Congestion Avoidance）</p>
<p>发生超时事件时，或3个冗余ACK时，认为是丢包，进入慢启动阶段并重置ssthresh。</p>
<blockquote>
<p>📌注意，要先将超时/冗余ACK的数据包重传，再重进入慢启动阶段</p>
</blockquote>
<p><strong>在Tahoe算法中，是没有快速恢复阶段的</strong>。</p>
<ul>
<li>
<p>慢启动：</p>
<ul>
<li>
<p>每个RTT，拥塞窗口加倍；</p>
</li>
<li>
<p>达到ssthresh时，进入 拥塞避免阶段；</p>
</li>
<li>
<p>发生超时或者三个冗余ACK时，首先重传丢失的包，之后将拥塞窗口设置为1个MSS，令ssthresh为当前拥塞窗口的一半，重新进入慢启动。</p>
</li>
</ul>
<p>（对于超时，此时的重传是超时重传，对于冗余ACK，此时的重传是快速重传）</p>
</li>
<li>
<p>拥塞避免：</p>
<ul>
<li>
<p>每个RTT，拥塞窗口+1MSS</p>
</li>
<li>
<p> 发生超时或者三个冗余ACK时，首先重传丢失的包，之后将拥塞窗口设置为1个MSS，令ssthresh为当前拥塞窗口的一半，重新进入慢启动。</p>
</li>
</ul>
</li>
</ul>
<p>进一步介绍细节的话，是这样的，每个RTT都会流水线地发cwnd个报文段，这些报文段的ACK每来一个，对应到慢启动和拥塞避免来说，都是不一样的cwnd增量。</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_xR9rX3G_vM.png" alt="" /></p>
<p>比如对于慢启动，每来一个新ACK，就加一个MSS，那么一个RTT过去，cwnd就会翻倍。举例来说，当前cwnd为4，所以会连发4个报文段，而每个报文段的ACK到来，cwnd都会加1，这样一个RTT过去，cwnd会加4，变成了8，达到了翻倍的效果。</p>
<p>而对于拥塞避免阶段，每来一个新ACK，会增加MSS *(MSS/cwnd)，那么一个RTT过去，cwnd就相当于加了一倍的MSS。</p>
<h2 id="reno"><a class="markdownIt-Anchor" href="#reno"></a> Reno</h2>
<img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_OSMjvAxAkP.png" style="zoom:67%;" />
<p>Reno算法是对Tahoe的改进。在Tahoe中，一旦发生超时或冗余ACK，就要让拥塞窗口回到1MSS，这是一种效率较低的方式。比如发了ABCDE的报文段，ACDE都被接收到了，而发送端收到了请求B的冗余ACK。此时本不需要将拥塞窗口调整到1MSS这么小，只需快速重传B即可。但是不可避免要进入慢启动，就会带来本不应该有的延迟。</p>
<p>而Reno引入了快速恢复阶段，在冗余ACK时可以不进入慢启动，使得传输效率更高一些。认为如果有三个冗余ACK，相比于超时重传，网络条件应该也没有那么糟糕，不必非要激进地调整拥塞窗口。</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_DnEO3e3ir3.png" alt="" /></p>
<p>在快速避免状态中，将超时和3个冗余ACK对应的反应动作区分开来：</p>
<p>超时：ssthresh = cwnd / 2, cwnd = 1MSS，进入慢启动</p>
<p>三个冗余ACK：先将丢失的包快速重传，然后ssthresh=cwnd/2, cwnd=ssthresh+3，并进入快速恢复状态</p>
<p>在快速恢复状态中：</p>
<ul>
<li>
<p>一旦收到冗余ACK：cwnd = cwnd+1MSS</p>
</li>
<li>
<p>一旦收到新ACK：认为恢复成功了，退出快速恢复，进入拥塞避免，cwnd = thresh+3</p>
</li>
<li>
<p>一旦超时了，不可避免还是从头再来（cwnd=1MSS, ssthresh = cwnd/2），进入慢启动</p>
</li>
</ul>
<h2 id="new-reno"><a class="markdownIt-Anchor" href="#new-reno"></a> New Reno</h2>
<p>New Reno是在Reno算法的基础上进行了改进。Reno在收到一个新ack时，就会退出快速恢复状态，而进入拥塞避免状态。这使得Reno非常适合于出现单个报文段丢失的情况。但是，在网络拥塞时，经常会出现好几个报文段一起丢失的情况，此时Reno反而效率比较低，以下图为例。</p>
<img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_W8bR5H11M9.png" style="zoom: 67%;" />
<p>蓝色表示接收端成功收到的报文段，而黄色则是丢失的报文段。发送端收到对应第一个黄色段的冗余ACK后，便会进入快速恢复状态，并快速重传第一个黄色段。第一个黄色段重传成功后，会收到与该段对应的ACK，而这个ACK对于发送端来说，属于新ACK，因此快速恢复状态退出，进入拥塞避免状态。</p>
<p>但是，此时第二个黄色段依然没有得到重传，因此进入拥塞避免阶段发数据时，也有可能出现连续三个冗余ACK请求第二个黄色段的情况，那么又要进入快速恢复状态。每次进入快速恢复，cwnd和ssthresh几乎都要砍半，导致了发送速率呈指数降低，吞吐量急剧下降。</p>
<p>举个例子，发包1-20，其中4、5、6丢失，但7、8、9、10到了，因此发送端收到了4个ack4，进入快速恢复，拥塞窗口减半。重传4成功时，10之后的包陆续到了，又会收到4个ack5，再次进入快速恢复，拥塞窗口再砍半。如果后面又出现了冗余ack6，相当于拥塞窗口直接减到了原先的1/8。</p>
<blockquote>
<p>📌可能出现极端情况，cwnd减到特别小（比如4，即1+3），中间若出现丢包，此时的窗口大小不足以支撑3个冗余ACK，导致只能等待超时，进入慢启动，导致更差的吞吐量。</p>
</blockquote>
<p>而New Reno是针对连续丢包的情况进行改进。还是以上面的图为例，出现了连续多个段的丢失，那么仍然首先进入快速恢复阶段，执行对第一个丢失段的快速重传，收到对应的ACK后，并不直接退出，而是认为其是一个partial ACK(PACK)，接着继续重传第二个丢失段，依次类推，直到收到的不再是PACK，而是Recovery ACK(RACK)，那么再退出快速恢复阶段，进入拥塞避免阶段</p>
<img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_-mzvMhracw.png" style="zoom:67%;" />
<blockquote>
<p>📌New Reno也是有局限的，就是快速恢复阶段的多个段的重传，并不是流水线形式的。每个RTT只能重传一个段，收到PACK后再传下一个丢失段。有n个丢失段就需要n个RTT，也使得效率略低。</p>
</blockquote>
<ul>
<li>
<p>三个冗余ACK，进行快速恢复状态（ssthresh = cwnd/2, cwnd = ssthresh + 3）</p>
</li>
<li>
<p>在快速恢复状态中：</p>
<ol>
<li>
<p>再次收到冗余ACK</p>
</li>
<li>
<p>收到PACK，仍保持快速恢复状态</p>
<ul>
<li>
<p>发送后面丢失的段，dupACK=0，定时器复位，cwnd = cwnd+1</p>
</li>
<li>
<p>若有新的报文段可以发送，则发送该段以收获RACK</p>
</li>
</ul>
</li>
<li>
<p>收到RACK：令cwnd = ssthresh，定时器复位，进入拥塞避免阶段</p>
</li>
</ol>
</li>
</ul>
<p>Recovery ACK的判定方法：TCP已发出的最大序号报文是PKTy，而此时收到的ACK报文为ACKx，若ACKx恰好是PKTy的应答报文，则属于Recovery ACK，否则判定为Partial ACK。</p>
<blockquote>
<p>TCP中还有另一种RACK：Recent ACK。需要注意不要与此处的Recovery ACK混淆。</p>
</blockquote>
<h2 id="sack"><a class="markdownIt-Anchor" href="#sack"></a> SACK</h2>
<p>New Reno在Reno的基础上增加了对多个丢失段的处理能力，但是也有局限：每个RTT只能重传一个报文，这会导致效率较低。而SACK在此基础上，进行了进一步的改进：</p>
<p><strong>接受端向发送方反馈包乱序到达的信息，而发送方则在cwnd允许的条件下，一次发送多个丢失段，这样每个RTT可以重传多个段，以提升效率。</strong></p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_rGnavodHr_.png" alt="" /></p>
<p>SACK依托于TCP options，可理解为扩展头。设置option为5表示此时的扩展头部用于表示SACK的信息，而一对left edge和right edge表示一个<strong>已接收到的乱序报文段</strong>的左边界和右边界，可以用多对来表示多个乱序的报文段。L字段表示用多少字节来刻画的SACK，比如SACK(5)需要一个字节，L需要一个字节，left edge和right edge各需要4字节，那么L就等于10，如果还有一对left edge和right edge，就L=18。</p>
<p>除此之外，TCP头部中的head len（4比特）也用于标识整个头部（头+options）的大小。原始头部20字节，若L=10，加上前面无用的两个1字节的nop，就是32个字节。因为head len只有4比特，要除以4，即head len = 32 / 4 = 8。至此，当前TCP报文段哪些是原始头部，哪些是options就一目了然了。</p>
<p>options中只承载SACK，即乱序到达的报文段的ACK，而原始头部中的ACK依然是按顺序到达的最大确认号。那么根据ACK，和各乱序SACK的左右边界，就可以知道哪些包发生了丢失。发送端会维护一个<strong>计分板（ScoreBoard）</strong>，其本质是一个链表，记录着需要以selective repeat方式重发的报文段。</p>
<p>具体流程如下：（发送端维护一个pipe变量）</p>
<ul>
<li>
<p>3个冗余ACK，进入快速恢复阶段：</p>
<ul>
<li>
<p>快速重传ACK后面的报文段</p>
</li>
<li>
<p>ssthresh = cwnd / 2, cwnd = ssthresh+3。同时pipe = 待确认的段数量</p>
<blockquote>
<p>pipe，顾名思义可以理解为一个管道，管道中都是还没有确认的段，一旦某个段发了出去，就可以进入管道中，而当收到针对该段的确认，就可以从管道中出来。这里的确认包含正常的ACK，和SACK。（虽是这么理解，但是pipe存储的只是一个<strong>整数</strong>，表示管道里内容多少）</p>
</blockquote>
<blockquote>
<p>pipe不能太满，太满了（大于cwnd）容易出现网络拥塞，也不能太少，太少利用率不够。</p>
</blockquote>
</li>
<li>
<p>当pipe &lt; cwnd，此时可以发丢失的报文段（优先发ScoreBoard中的段），如果计分板空了，仍然pipe &lt; cwnd，可以发新段。</p>
<ul>
<li>
<p>发一个段：pipe = pipe+1</p>
</li>
<li>
<p>收到确认：pipe = pipe - x，x表示从管道中走出的段</p>
<p>当此时的确认是RACK(recovery ack)时，退出快速恢复阶段，进入拥塞避免阶段</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>通过pipe和Scoreboard，可以确定发送丢失段的时机（pipe &lt; cwnd），和发送的内容（先Scoreboard，再新段），从而实现selective repeat。</p>
<p>但是SACK也是有缺点的，体现在<strong>兼容性</strong>：</p>
<ol>
<li>
<p>需要修改接收端，使其能够发出SACK；</p>
</li>
<li>
<p>需要修改发送端，使其能够根据SACK做出相应动作。</p>
</li>
</ol>
<h2 id="vegas"><a class="markdownIt-Anchor" href="#vegas"></a> Vegas</h2>
<p> 前面的几类算法可以看作是一脉相承（Reno类），都是慢启动迅速，乘性减，而Vegas则有显著不同。</p>
<p>Reno类算法存在的问题如下：</p>
<ul>
<li>
<p>只能不断调整cwnd来探测，直至拥塞。因此速率的波动是很频繁且比较大的；</p>
</li>
<li>
<p>在一个RTT内可能出现报文段的连续丢失，导致cwnd反复降低，带宽利用率较低；</p>
<p>事实上一个RTT内的多次降低cwnd完全是不必要的。因为降低一次cwnd，需要等到下个RTT时才能看出效果，还没到下一个RTT，就继续降低cwnd，最终降低幅度可能过大。</p>
</li>
<li>
<p>粗颗粒度的超时重传（RTO基于500ms的颗粒度），即使快速重传，也需要3个冗余ACK，反应比较迟钝。</p>
</li>
</ul>
<p>而对拥塞的检测，其实可以有这几种方式：丢失超时、3个冗余ACK、网络反馈、<strong>延迟变化</strong></p>
<p>其中延迟变化对于网络拥塞是最敏感的，因为瓶颈链路的排队队列会先增长，当队列满了，再丢弃。所以会有先延迟增大，再出现丢包的情况发生。而Vegas正是通过延迟变化，来更早地感知拥塞，并且更加温和地调节速度，让速率接近可用带宽。</p>
<p>算法流程如下：</p>
<hr />
<ul>
<li>
<p>连接建立时，进入慢启动阶段，记下第一次测量的RTT，作为BaseRTT</p>
<p>建立连接时的RTT一般是最小的，因为这个时候还没有流量注入。</p>
</li>
<li>
<p>在慢启动阶段，不同于Reno类算法，Vegas要用两个RTT再倍增cwnd</p>
<ul>
<li>
<p>第一个RTT：增长期，增加窗口</p>
</li>
<li>
<p>第二个RTT：测量期，计算期望速率和实际速率的差</p>
<p>期望速率Expected = cwnd / BaseRTT</p>
<p>实际速率Actual = cwnd / RTT（这里的RTT就是第二个RTT测量到的值）</p>
<p>二者之差Diff = (Expected - Actual) * BaseRTT</p>
<p>由于一般测量到的RTT会比BaseRTT大，所以Diff往往会大于等于0。</p>
</li>
</ul>
</li>
<li>
<p>如果前面所计算的diff大于一个阈值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>（默认是1），那么从慢启动阶段进入拥塞避免阶段</p>
<p>同时窗口减少1/8，即变为原来的7/8</p>
</li>
<li>
<p>在拥塞避免阶段，会根据两个阈值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>来决定cwnd的线性增加和减小。（默认<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>β</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">\alpha=1,\beta=3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>）</p>
<p>Diff &lt; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>：cwnd = cwnd+1，当前没有进入拥塞状态</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>≤ Diff ≤ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>：cwnd不变，当前瓶颈链路的队列不多也不少 </p>
<p>Diff &gt; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>：cwnd = cwnd - 1，拥塞较严重</p>
</li>
</ul>
<p>并且，Vegas与Reno类算法的重传的时机选择上也有很大不同。Vegas看重两个时机：</p>
<p><strong>时机1</strong>：收到了一个冗余ACK，且当前时间距离对应未确认的段发送时间之差超过RTO。</p>
<p>这样就会比3个冗余ACK，更早地开始重传。</p>
<p><strong>时机2</strong>：已经重发后，收到了一或两个非冗余ACK，若当前时间距离还未确认的最早段的发送时间之差超过了RTO，则还要将该段重传。</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_eZwI-FUJZY.png" alt="" /></p>
<p>而且重传之后，窗口减少1/8。同时，一个RTT内不会减少两次，从而规避Reno类算法的重复降低cwnd的问题。这里RTO的计算与上面TCP超时重传的算法一致，smoothed RTT加4倍方差。但是由于Vegas涉及比较细致的RTT的测量，所以RTO算的也不会太粗放。</p>
<blockquote>
<p>📌Vegas中除了上述重传机制，也保留了Reno类的重传，在Vegas检查丢包失效时便会用Reno类算法的重传来兜底。</p>
</blockquote>
<blockquote>
<p>📌BaseRTT也是一直在做调整的，Vegas中会维护一个minRTT记录一轮探测下来的最短RTT，并将该值与BaseRTT，取最小作为新的BaseRTT。</p>
</blockquote>
<hr />
<p>Vegas由于两个问题，在互联网上使用的不多：</p>
<ol>
<li>
<p>路径变化导致的RTT变化，被误认为是拥塞，导致了错误的动作</p>
</li>
<li>
<p>不公平性：Vegas可以看作是一个敏感且温和的秀才，而Reno、Cubic之类的算法则是迟钝且粗鲁的兵，后者拥塞窗口增加的速度非常快，而前者则略慢，所以当网络中同时出现Vegas、Reno、Cubic这些算法时，Vegas是竞争不过的，导致速率比较小。</p>
</li>
</ol>
<p>Linux操作系统中，将Vegas设置为一个可选项，由用户手动启动。其应用在服务器机房这种条件可控的场景下比较多。</p>
<h2 id="cubic"><a class="markdownIt-Anchor" href="#cubic"></a> CUBIC</h2>
<p>CUBIC的前身是BIC（Binary Increase Congestion control）算法。在拥塞避免阶段，每个RTT增加一个MSS可能比较慢，难以快速找到最佳拥塞窗口。</p>
<blockquote>
<p>最佳拥塞窗口：能避免拥塞的最大窗口，即不引发拥塞的最大速率。探测最佳拥塞窗口不能太快也不能太慢，太快探测可能导致更严重的拥塞，太慢的话带宽利用率不够。</p>
</blockquote>
<p>而BIC算法采取的策略是：</p>
<ul>
<li>
<p>在发生丢包事件时，以乘性因子<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>降低cwnd。丢包前的窗口大小赋值给<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">W_{max}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>变量，而丢包后的窗口大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>=</mo><mi>β</mi><mo>×</mo><msub><mi>W</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">W_{min} = \beta\times W_{max}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
</li>
<li>
<p>码率爬升至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">W_{max}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>前，BIC算法就是在做二分搜索，所以当为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">W_{min}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>时，就开始找与$ W_{max}  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>之间的中点，但是直接一个</mtext><mi>R</mi><mi>T</mi><mi>T</mi><mtext>就到达中点可能过快了，所以会判断一下这一下</mtext><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mtext>增加的数值是否大于</mtext></mrow><annotation encoding="application/x-tex">之间的中点，但是直接一个RTT就到达中点可能过快了，所以会判断一下这一下cwnd增加的数值是否大于</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord cjk_fallback">之</span><span class="mord cjk_fallback">间</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">但</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">直</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">到</span><span class="mord cjk_fallback">达</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">能</span><span class="mord cjk_fallback">过</span><span class="mord cjk_fallback">快</span><span class="mord cjk_fallback">了</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">所</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">会</span><span class="mord cjk_fallback">判</span><span class="mord cjk_fallback">断</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">下</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">下</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mord cjk_fallback">增</span><span class="mord cjk_fallback">加</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">值</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">否</span><span class="mord cjk_fallback">大</span><span class="mord cjk_fallback">于</span></span></span></span>S_{max}<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>，如果大于，就按</mtext></mrow><annotation encoding="application/x-tex">，如果大于，就按</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">果</span><span class="mord cjk_fallback">大</span><span class="mord cjk_fallback">于</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">按</span></span></span></span>S_{max}<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>的增量，否则直达中点。这一过程持续到增量小于</mtext></mrow><annotation encoding="application/x-tex">的增量，否则直达中点。这一过程持续到增量小于</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">增</span><span class="mord cjk_fallback">量</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">否</span><span class="mord cjk_fallback">则</span><span class="mord cjk_fallback">直</span><span class="mord cjk_fallback">达</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">过</span><span class="mord cjk_fallback">程</span><span class="mord cjk_fallback">持</span><span class="mord cjk_fallback">续</span><span class="mord cjk_fallback">到</span><span class="mord cjk_fallback">增</span><span class="mord cjk_fallback">量</span><span class="mord cjk_fallback">小</span><span class="mord cjk_fallback">于</span></span></span></span>S_{min}$变量。呈现的效果就如下图左半部分，看上去像一个log函数后面接了一个线性函数（对应加性增和二分搜索）。</p>
</li>
<li>
<p>如果到达<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">W_{max}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>还没发生拥塞，说明此时未到饱和点，可以进一步探索更大的拥塞窗口，找到最佳拥塞窗口。此时会进入max probing阶段。max probing阶段的窗口增长函数与前面对称，跨过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">W_{max}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>之后先缓缓试探，再加速探测。</p>
</li>
</ul>
<img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_PqyRWborTM.png" style="zoom:67%;" />
<p>BIC算法有其局限性，多个阶段的控制给算法的部署带来了很大的复杂性，而且cwnd增长仍然过快。</p>
<p>cubic算法在此基础上进行了改进，观察到上述多阶段曲线，其实可以用多项式来逼近，因此cubic通过这种手段来取代BIC算法。（在出现丢包后的措施一样，都是取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>×</mo><msub><mi>W</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\beta\times W_{max}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）</p>
<blockquote>
<p>📌理解cubic算法就不要按Reno先入为主，不要再理所当然地区分慢启动、拥塞避免、快速恢复这几个阶段。cubic中没有对这几个阶段的严格区分，按算法状态机执行即可。</p>
</blockquote>
<p>cubic选择的多项式是：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>W</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>C</mi><mo stretchy="false">(</mo><mi>t</mi><mo>−</mo><mi>K</mi><msup><mo stretchy="false">)</mo><mn>3</mn></msup><mo>+</mo><msub><mi>W</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">W(t)=C(t-K)^3+W_{max}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>其中C是一个系数，t表示从上次窗口下调，到当前时刻的时间间隔，K表示从现在的cwnd增长到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">W_{max}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的预期时间，而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">W_{max}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>也是在上次丢包出现前的最大拥塞窗口值。</p>
<p>用K可以控制增长的速度，避开增长过快的问题。而且三次多项式也便于实现。</p>
<p>由于当t=0时，窗口应该为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>=</mo><mi>β</mi><mo>×</mo><msub><mi>W</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">W_{min}=\beta\times W_{max}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，所以可以计算出K的取值：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>K</mi><mo>=</mo><mroot><mfrac><mrow><msub><mi>W</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mi>β</mi></mrow><mi>C</mi></mfrac><mn>3</mn></mroot></mrow><annotation encoding="application/x-tex">K=\sqrt[3]{\frac{W_{max}\beta}{C}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.44em;vertical-align:-0.7634050000000001em;"></span><span class="mord sqrt"><span class="root"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8701339999999997em;"><span style="top:-3.0479139999999996em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size6 size1 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6765949999999998em;"><span class="svg-align" style="top:-4.4em;"><span class="pstrut" style="height:4.4em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.6365950000000002em;"><span class="pstrut" style="height:4.4em;"></span><span class="hide-tail" style="min-width:1.02em;height:2.48em;"><svg width='400em' height='2.48em' viewBox='0 0 400000 2592' preserveAspectRatio='xMinYMin slice'><path d='M424,2478
c-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514
c0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20
s-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121
s209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081
l0 -0c4,-6.7,10,-10,18,-10 H400000
v40H1014.6
s-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185
c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2z M1001 80
h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7634050000000001em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>一个RTT后的cwnd为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo>=</mo><mi>W</mi><mo stretchy="false">(</mo><mi>t</mi><mo>+</mo><mi>R</mi><mi>T</mi><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">target = W(t+RTT)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span>，所以每收到一个ACK，增量为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>W</mi><mo stretchy="false">(</mo><mi>t</mi><mo>+</mo><mi>R</mi><mi>T</mi><mi>T</mi><mo stretchy="false">)</mo><mo>−</mo><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{W(t+RTT)-cwnd}{cwnd}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">d</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">W</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">t</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mclose mtight">)</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。</p>
<p>直到丢包发生，更新<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">W_{max}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为当前窗口，之后设置窗口大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>=</mo><mi>β</mi><mo>×</mo><msub><mi>W</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">W_{min}=\beta\times W_{max}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<p>超时和三次冗余ACK都算丢包，以下是Reno和CUBIC的效果对比图，整体上后者吞吐量大一些。</p>
<img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_dbxJ9GB-Og.png" style="zoom:80%;" />
<h2 id="ecn"><a class="markdownIt-Anchor" href="#ecn"></a> ECN</h2>
<blockquote>
<p>Explicit Congestion Notification</p>
</blockquote>
<p>前面所提到的算法，不管是基于丢包还是基于时延，都是由两客户端来自行感知网络拥塞的。而ECN则要简单很多，不去有那些探测的步骤，而是通过<strong>网络反馈</strong>，来调整拥塞窗口。</p>
<p>这么做带来的好处是：反馈可能比超时等拥塞事件来的更早，控制效果可以更好。但是缺点也体现在了兼容性：涉及到对TCP协议和IP协议的修改。</p>
<ul>
<li>
<p>对IP协议的修改：</p>
<p>如下图，利用IP协议中第14、15两个标志位（从0开始计数的话）：ECT和CE。ECT表示设备和协议支持ECN，而CE表示网络中出现拥塞。当报文经过了一个路由器，而且在该路由器的链路上出现了拥塞，那么路由器就会将这两个标志位置1。</p>
<p>两个标志位可以有四种组合：</p>
<table>
<thead>
<tr>
<th>ECT</th>
<th>CE</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>不支持ECN</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>支持ECN，还没有拥塞</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>支持ECN，还没有拥塞</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>支持ECN，发生了拥塞</td>
</tr>
</tbody>
</table>
</li>
</ul>
<img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_ysPIi1S8AS.png" style="zoom:80%;" />
<ul>
<li>
<p>对TCP协议的修改</p>
<p>对TCP协议来说，相关的是两个标志位：CWR（Congestion Window Reduce）和ECE（ECN-Echo）。后者是接收端向发送端反馈当前出现了拥塞，而前者是发送端向接收端反馈：ECE已收到，目前拥塞窗口已减少。</p>
</li>
</ul>
<img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/tcp-congestion/image_JK6i4VBRJ6.png" style="zoom:80%;" />
<p>算法流程如下：</p>
<hr />
<ul>
<li>
<p>源主机发出的TCP段，添加IP头部时，相关标志位置位表示使能ECN：(ECT,CE)=(1,0) or (0,1)</p>
</li>
<li>
<p>IP分组经过了发生拥塞的路由器，被路由器置位：(1,1)</p>
</li>
<li>
<p>目的主机解开IP头部，发现出现拥塞，在向发送端反馈的ACK报文中，ECE置位1，并且后续的报文ECE都置1（也就是说，发送端会收到很多ECE置1的报文）</p>
</li>
<li>
<p>源主机收到了ECE=1，将拥塞窗口减半，并且在新报文中将CWR置位1。</p>
<p>同时，虽然这个RTT内收到了很多ECE=1的ACK，但是本RTT内只减少一次窗口</p>
</li>
<li>
<p>接收端收到CWR=1的段，如果IP分组没再发现拥塞，就不再让后续的ACK报文ECE为1</p>
<p>若接收端发现，虽然有CWR=1，但新来的IP分组中又有拥塞发生，再反馈ECE=1。</p>
</li>
</ul>
<hr />
<p>ECN存在以下若干局限：</p>
<ol>
<li>
<p>安全问题：如果有攻击者在中间某些路由器，将IP分组的两标志位强行置为11，那么速率就会被降到非常非常低；</p>
</li>
<li>
<p>实际部署：刚才所说的是降速的策略，但是并没有明确的增速方案，这个需要依托于具体的实施方案。</p>
</li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/WebRTC/" rel="tag"># WebRTC</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/09/03/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%86/" rel="prev" title="函数调用原理">
                  <i class="fa fa-chevron-left"></i> 函数调用原理
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/11/10/%E7%BC%96%E7%A0%81%E5%88%86%E5%B8%83%E5%BC%8F%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/" rel="next" title="编码分布式计算：梯度下降">
                  编码分布式计算：梯度下降 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">OliverPai</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.2.8/pdfobject.min.js","integrity":"sha256-tu9j5pBilBQrWSDePOOajCUdz6hWsid/lBNzK4KgEPM="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>




  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.0/katex.min.css" integrity="sha256-uik/hNqHWZldXh/0K35nqOSCff9F61/ZOFReqNOBgB0=" crossorigin="anonymous">



</body>
</html>
