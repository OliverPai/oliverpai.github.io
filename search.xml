<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JavaScript</title>
    <url>/2020/02/24/JavaScript/</url>
    <content><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="1-在HTML中使用JS"><a href="#1-在HTML中使用JS" class="headerlink" title="1 在HTML中使用JS"></a>1 在HTML中使用JS</h2><ul>
<li>方式1</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello World!&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>方式2</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">src = <span class="string">&quot;main.js&quot;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//main.js</span><br><span class="line">console.log(&#x27;Hello World!&#x27;)</span><br></pre></td></tr></table></figure>

<h2 id="2-变量"><a href="#2-变量" class="headerlink" title="2 变量"></a>2 变量</h2><p>三种方式声明</p>
<ol>
<li><p>var：全局作用域，最不常用</p>
</li>
<li><p>let：可重新赋值的局部变量</p>
</li>
<li><p>const：不可重新赋值的局部变量；必须初始化，否则报错；最常用</p>
</li>
</ol>
<h2 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3 数据类型"></a>3 数据类型</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//string number boolean null undefined</span><br><span class="line">const name = &#x27;John&#x27;; //string</span><br><span class="line">const age = 30;      //number</span><br><span class="line">const rating = 4.5;  //number</span><br><span class="line">const isCool = true; //boolean</span><br><span class="line">const x = null;      //null</span><br><span class="line">const y = undefined; //undefined</span><br><span class="line">let z;               //undefined</span><br><span class="line">//查看变量的数据类型：typeof</span><br><span class="line">console.log(typeof x);//此时会输出object而不是null，这是JS的一个bug</span><br></pre></td></tr></table></figure>

<ul>
<li>JS的数字不区分整形和浮点数</li>
</ul>
<h2 id="4-字符串"><a href="#4-字符串" class="headerlink" title="4 字符串"></a>4 字符串</h2><ul>
<li>字符串中加入变量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const name = &#x27;John&#x27;;</span><br><span class="line">const age = 30;</span><br><span class="line">//方式1：拼接</span><br><span class="line">console.log(&#x27;My name is &#x27;+name+&#x27; and I am &#x27;+age);</span><br><span class="line">//方式2：模板字符串，需反引号</span><br><span class="line">console.log(`My name is $&#123;name&#125; and I am $&#123;age&#125;`);</span><br></pre></td></tr></table></figure>

<ul>
<li>部分字符串属性与方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const s = &#x27;Hello World!&#x27;;</span><br><span class="line">console.log(s.length);//长度属性</span><br><span class="line">console.log(s.toUpperCase());//转大写方法</span><br><span class="line">console.log(s.toLowerCase());//转小写方法</span><br><span class="line">console.log(s.substring(0,5));//截取子串，从0开始，在5之前结束，输出&#x27;Hello&#x27;</span><br><span class="line">console.log(s.substring(0,5).toUpperCase());//HELLO</span><br><span class="line">//分割字符串到数组中</span><br><span class="line">const v = &#x27;technology, computer, it, code&#x27;</span><br><span class="line">console.log(v.split(&#x27;, &#x27;))//输出[technology,computer,it,code];</span><br></pre></td></tr></table></figure>

<h2 id="5-数组"><a href="#5-数组" class="headerlink" title="5 数组"></a>5 数组</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//JS数组不需要指定长度和类型</span><br><span class="line">/*-------创建数组-------*/</span><br><span class="line">//创建方式1</span><br><span class="line">const numbers = new Array(1,2,3,4,5);</span><br><span class="line">//创建方式2</span><br><span class="line">const fruits = [&#x27;Apple&#x27;, &#x27;Orange&#x27;, 10, true];//JS中数组可以存放不同类型值</span><br><span class="line">//在数组末尾添加值</span><br><span class="line">fruits[4]=&#x27;Mangos&#x27;;</span><br><span class="line">fruits.push(&#x27;Grapes&#x27;);</span><br><span class="line">//在数组开头添加值</span><br><span class="line">fruits.unshift(&#x27;Strawberries&#x27;);</span><br><span class="line">//数组末尾删除值</span><br><span class="line">fruits.pop();</span><br><span class="line">//判断是否是数组</span><br><span class="line">console.log(Array.isArray(fruits));</span><br><span class="line">//寻找索引</span><br><span class="line">console.log(fruits.indexOf(&#x27;Orange&#x27;));</span><br></pre></td></tr></table></figure>

<h2 id="6-对象"><a href="#6-对象" class="headerlink" title="6 对象"></a>6 对象</h2><p>JS中的对象就是键值对</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  firstName:&#x27;John&#x27;,</span><br><span class="line">  lastName:&#x27;Doe&#x27;,</span><br><span class="line">  age:30,</span><br><span class="line">  hobbies:[&#x27;music&#x27;,&#x27;movie&#x27;,&#x27;sport&#x27;],</span><br><span class="line">  address:&#123;//对象里可以嵌套对象</span><br><span class="line">    street:&#x27;50 main st&#x27;,</span><br><span class="line">    city:&#x27;Boston&#x27;,</span><br><span class="line">    state:&#x27;MA&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//找到&#x27;movie&#x27;</span><br><span class="line">person.hobbies[1]</span><br><span class="line">//找到Boston</span><br><span class="line">person.address.city</span><br></pre></td></tr></table></figure>

<ul>
<li>定义后仍可添加属性</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">person.email = &#x27;john@gmail.com&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li>解构</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const &#123;firstName, lastName&#125; = person;</span><br><span class="line">//firstName变量被创建，并赋值为person.firstName，即Bob</span><br><span class="line">//lastName变量被创建，并赋值为person.lastName，即Doe</span><br><span class="line"></span><br><span class="line">//对象里的嵌套对象的属性也可以被结构</span><br><span class="line">const &#123;firstName, lastName, address:&#123;city&#125;&#125; = person;</span><br><span class="line">//city变量被创建，并赋值为person.address.city，即Boston</span><br></pre></td></tr></table></figure>

<ul>
<li>对象数组</li>
</ul>
<!---->

<ul>
<li>JSON</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const todos = [</span><br><span class="line">  &#123;</span><br><span class="line">    id: 1,</span><br><span class="line">    text: &#x27;Take out trash&#x27;,</span><br><span class="line">    isCompleted:true</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    id: 2,</span><br><span class="line">    text: &#x27;Meeting with boss&#x27;,</span><br><span class="line">    isCompleted:true</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    id: 3,</span><br><span class="line">    text: &#x27;Dentist appt&#x27;,</span><br><span class="line">    isCompleted:false</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;//所有属性要加上双引号</span><br><span class="line">    &quot;id&quot;: 1,</span><br><span class="line">             //字符串不能再用单引号</span><br><span class="line">    &quot;text&quot;: &quot;Take out trash&quot;,</span><br><span class="line">    isCompleted:true</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;id&quot;: 2,</span><br><span class="line">    &quot;text&quot;: &quot;Meeting with boss&quot;,</span><br><span class="line">    &quot;isCompleted&quot;:true</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;id&quot;: 3,</span><br><span class="line">    &quot;text&quot;: &quot;Dentist appt&quot;,</span><br><span class="line">    &quot;isCompleted&quot;:false</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对象数组转JSON</span></span><br><span class="line"><span class="keyword">const</span> todoJSON = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(todos);</span><br></pre></td></tr></table></figure>

<h2 id="7-循环"><a href="#7-循环" class="headerlink" title="7 循环"></a>7 循环</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//for</span><br><span class="line">for(let i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//while</span><br><span class="line">let i = 0;</span><br><span class="line">while(i &lt; 10)&#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//for...of</span><br><span class="line">for(let todo of todos)&#123;</span><br><span class="line">  console.log(todo.text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//forEach：foreach是方法，输入参数为函数，该函数为每一个数组元素执行任务，无返回值</span><br><span class="line">todos.forEach(function(todo)&#123;//todo可被看作每个数组元素的代称</span><br><span class="line">  console.log(todo.text);</span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line">//map：与forEach一致，但是有返回值，最后会创建新数组，不影响旧数组</span><br><span class="line">const todoText = todos.map(function(todo)&#123;</span><br><span class="line">  return todo.text;</span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line">//filter：也会返回新数组，但是只摘取原数组中满足条件的元素</span><br><span class="line">const todoCompleted = todos.filter(function(todo)&#123;</span><br><span class="line">  return todo.isCompleted === true;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="8-条件"><a href="#8-条件" class="headerlink" title="8 条件"></a>8 条件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(a &gt; 5)&#123;</span><br><span class="line">  console.log(&#x27;a is bigger than 5&#x27;);</span><br><span class="line">&#125;else if(a &lt; 5)&#123;</span><br><span class="line">  console.log(&#x27;a is less than 5&#x27;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">  console.log(&#x27;a is equal to 5&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">switch(color)&#123;</span><br><span class="line">case &#x27;blue&#x27;:</span><br><span class="line">  console.log(&#x27;color is blue&#x27;);</span><br><span class="line">  break;</span><br><span class="line">case &#x27;red&#x27;:</span><br><span class="line">  console.log(&#x27;color is red&#x27;);</span><br><span class="line">  break;</span><br><span class="line">default:</span><br><span class="line">  console.log(&#x27;color is others&#x27;);</span><br><span class="line">  break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>JS中&#x3D;&#x3D;&#x3D;要求数据类型一致且数值相等；而&#x3D;&#x3D;不要求数据一致，’10’&#x3D;&#x3D;10，自动类型转换</li>
</ul>
<h2 id="9-函数"><a href="#9-函数" class="headerlink" title="9 函数"></a>9 函数</h2><ul>
<li>典型函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//格式：function 函数名(参数名,...)&#123;&#125;</span><br><span class="line">function addNums(num1 = 1, num2 = 1)&#123;//这里只是设置默认值，可不写=</span><br><span class="line">  return num1+num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>箭头函数，好处体现在只有一行的函数可以写得简短些</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const addNums(num1 = 1, num2 = 1) =&gt; &#123;</span><br><span class="line">  return num1+num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-面向对象"><a href="#10-面向对象" class="headerlink" title="10 面向对象"></a>10 面向对象</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*-------假设已经定义person对象为例-------*/</span><br><span class="line">//构造函数</span><br><span class="line">function Person(firstName,lastName,dob)&#123;</span><br><span class="line">  this.firstName = firstName;</span><br><span class="line">  this.lastName = lastName;</span><br><span class="line">  this.dob = new Date(dob);</span><br><span class="line">  //创建方法</span><br><span class="line">  this.getBirthday = function()&#123;</span><br><span class="line">    return this.dob.getFullYear();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//初始化</span><br><span class="line">const person1 = new Person(&#x27;John&#x27;,&#x27;Doe&#x27;,&#x27;4-3-1980&#x27;);</span><br></pre></td></tr></table></figure>

<ul>
<li>原型</li>
</ul>
<p>原型是所有对象都会继承的对象，可以通过在原型添加属性、方法，实现在对象中添加属性与方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(firstName,lastName,dob)&#123;</span><br><span class="line">  this.firstName = firstName;</span><br><span class="line">  this.lastName = lastName;</span><br><span class="line">  this.dob = new Date(dob);</span><br><span class="line">&#125;</span><br><span class="line">//创建方法</span><br><span class="line">Person.prototype.getBirthday = function()&#123;</span><br><span class="line">  return this.dob.getFullYear();</span><br><span class="line">&#125;</span><br><span class="line">//初始化</span><br><span class="line">const person1 = new Person(&#x27;John&#x27;,&#x27;Doe&#x27;,&#x27;4-3-1980&#x27;);</span><br><span class="line">//调用方法不需要写原型</span><br><span class="line">person1.getBirthday();</span><br></pre></td></tr></table></figure>

<ul>
<li>类：ES6引入先特性，与上述对象行为一致，只是写法更清晰</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  //构造函数</span><br><span class="line">  constructor(firstName, lastName, dob)&#123;</span><br><span class="line">    this.firstName = firstName;</span><br><span class="line">    this.lastName = lastName;</span><br><span class="line">    this.dob = new Date(dob);</span><br><span class="line">  &#125;</span><br><span class="line">  //方法</span><br><span class="line">  getBirthday()&#123;</span><br><span class="line">    return this.dob.getFullYear();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-DOM"><a href="#11-DOM" class="headerlink" title="11 DOM"></a>11 DOM</h2><p>DOM(Document Object Model)，是借助window对象的document属性，获取HTML的ID、类、标签、文本等等元素，并且可以对HTML\CSS进行修改，从而获取有用数据或者改变网页状态。</p>
<ul>
<li>window对象就是浏览器的窗口，网页应用皆继承window对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="12-同步与异步"><a href="#12-同步与异步" class="headerlink" title="12 同步与异步"></a>12 同步与异步</h2>]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>在线优化利器——李雅普诺夫优化</title>
    <url>/2022/01/30/Lyapunov%20Optimization/</url>
    <content><![CDATA[<h1 id="Lyapunov-Optimization"><a href="#Lyapunov-Optimization" class="headerlink" title="Lyapunov Optimization"></a>Lyapunov Optimization</h1><p><a href="https://en.wikipedia.org/wiki/Lyapunov_optimization" title="维基百科李雅普诺夫优化介绍">维基百科李雅普诺夫优化介绍</a></p>
<p><a href="https://en.wikipedia.org/wiki/Drift_plus_penalty" title="维基百科漂移加罚介绍">维基百科漂移加罚介绍</a></p>
<p><a href="http://hliangzhao.me/math/Lyapunov_optimization.pdf" title="浙大赵海亮文档">浙大赵海亮文档</a></p>
<blockquote>
<p>李雅普诺夫优化旨在，利用李雅普诺夫函数(Lyapunov function)以非负标量的形式描述一个用多维向量表示的状态，通过优化该函数实现逼近用向量表示的原问题的最优解</p>
</blockquote>
<p><strong>李雅普诺夫优化的一般步骤</strong></p>
<p>为随机优化问题建模 → 构造队列 → 得到使用李雅普诺夫优化求的解 → 分析解与原始最优解的差距</p>
<h2 id="1-随机优化建模"><a href="#1-随机优化建模" class="headerlink" title="1. 随机优化建模"></a>1. 随机优化建模</h2><p>&amp;#x20;      随机优化问题中的“随机”指的是每个时间片内都有随机事件发生，针对随机事件有相应的策略。定义第t个时隙内产生的所有随机事件为$\textbf{w}(t)\triangleq[w_1(t),w_2(t),…,w_n(t)]\in\Omega^n$，系统在每个时间片内采取的策略，即“动作”（control action）定义为$\alpha(t)\triangleq[\alpha_1(t),\alpha_2(t),…,\alpha_m(t)]\in\mathcal{A}^m$，其中$\Omega^n和\mathcal{A}^m$分别是随机事件和控制决策的集合。</p>
<p>&amp;#x20;      如果我们的目标函数是$p(t)$，那么在每个时隙t，它会根据发生的随机事件和采取的措施，计算出当前时隙的目标函数值，即$p(t)&#x3D;P(\textbf{w}(t),\alpha(t))$，其中$P(\cdot)$是一个确定的函数。这里的$p(t)$的物理含义可以很丰富，比如令其表示功率，那么问题就是最小化功率消耗；令其为吞吐量的负$p(t)&#x3D;-r(t)$，那么最小化$p(t)$就是在最大化吞吐量。此外，系统中的一系列变量也会受到随机事件和控制决策的影响，可以描述为$y_k(t)&#x3D;Y_k(\textbf{w}(t),\alpha(t)),k\in{1,…,K}$，其中$\forall k\in{1,…,K}，Y_k(\cdot)$均为确定函数。由于最终需要把所有时间片的表现都考虑进去，从而得到最终系统表现，所以在优化目标时，需要优化的是各时间片的目标函数值的平均。</p>
<p>那么随机优化问题的标准形式为：</p>
<p>$$<br>\begin{aligned}\mathcal{P}1:&amp;\min_{\forall t,\alpha(t)\in\mathcal{A}^m}\lim_{T\rightarrow\infty}\frac 1 T\sum_{t&#x3D;0}^{T-1}\mathbb{E}[p(t)]\s.t.&amp;\ \lim_{T\rightarrow\infty}\frac 1 T\sum_{t&#x3D;0}^{T-1}\mathbb{E}[y_k(t)]\le 0,k\in{1,…,K}\end{aligned}<br>$$</p>
<h2 id="2-队列构造"><a href="#2-队列构造" class="headerlink" title="2 队列构造"></a>2 队列构造</h2><p>&amp;#x20;     李雅普诺夫优化希望将长期约束分割到各个时间片中，在每个时间片约束变量遵守相应的条件，从而使得长期约束不被破坏，即保持稳定。由此，每一个约束$y_k(t)$可以对应一个队列，该队列中的元素随时间片的迭代而进进出出，最终达成保持队列稳定的目标。定义初值为0的队列为：</p>
<p>$$<br>Q_k(t+1)&#x3D;\max{Q_k(t)+y_k(t),0},k\in{1,2,…,K}<br>$$</p>
<p>这里的$y_k(t)$可以用$y_k(t)&#x3D;a_k(t)-b_k(t)$，其中$a_k(t)$是进，$b_k(t)$是出，从而实现队列的进出。需要注意的是，这里的$Q_k(t)$并不是队列本身，而是队列的积压量(backlog)。而由于前面随机优化问题中的约束条件，我们希望每一个时间片的$b_k(t)$尽可能大于等于$a_k(t)$，从而使$y_k(t)$尽可能小于等于0。</p>
<p>易得$y_k(t)\le Q_k(t+1)-Q_k(t)$，对所有时间片累加可得$\sum_{t&#x3D;0}^{T-1}y_k(t)\le Q_k(T)-Q_k(0)&#x3D;Q_k(T),k&#x3D;{1,2,…,K}$，取期望可得：</p>
<p>$$<br>\frac 1 T\sum_{t&#x3D;0}^{T-1}\mathbb{E}[y_k(t)]\le \frac{\mathbb{E}[Q_k(T)]}T,k\in{1,2,…,K}<br>$$</p>
<p>由于前面随机优化的约束$\lim_{T\rightarrow\infty}\frac 1 T\sum_{t&#x3D;0}^{T-1}\mathbb{E}[y_k(t)]\le 0,k\in{1,…,K}$，再由于上式，可以得到李雅普诺夫形式的随机优化约束条件$\lim_{T\rightarrow\infty}\frac{\mathbb{E}[Q_k(T)]}{T}&#x3D;0,k\in{1,2,…,K}$。</p>
<p>因此，构造好虚拟队列的随机优化问题新形式可表示为：</p>
<p>$$<br>\begin{aligned}\mathcal{P}2:&amp;\min_{\forall t,\alpha(t)\in\mathcal{A}^m}\lim_{T\rightarrow\infty}\frac 1 T\sum_{t&#x3D;0}^{T-1}\mathbb{E}[p(t)]&amp;(1)\&amp;s.t.\lim_{T\rightarrow\infty}\frac{\mathbb{E}[Q_k(T)]}{T}&#x3D;0,k\in{1,2,…,K}\qquad&amp;(2)\end{aligned}<br>$$</p>
<blockquote>
<p>📌注：其实李雅普诺夫形式的约束条件还有另一种更加严格的表述，即下式，但一般采用上式</p>
</blockquote>
<p>$$<br>\exist\delta\le 0,\lim_{T\rightarrow 0}\frac{\mathbb{E}[Q_k(T)]}T\le\delta,k\in{1,2,…,K}<br>$$</p>
<h2 id="3-漂移加罚算法-drift-plus-penalty-algorithm"><a href="#3-漂移加罚算法-drift-plus-penalty-algorithm" class="headerlink" title="3 漂移加罚算法(drift plus penalty algorithm)"></a>3 漂移加罚算法(drift plus penalty algorithm)</h2><p>将队列全体用一个向量表示为$(t)\triangleq[Q_1(t),Q_2(t),…,Q_K(t)]$，则李雅普诺夫函数定义为</p>
<p>$$<br>L(\Theta(t))\triangleq\frac 1 2\sum_{k&#x3D;1}^KQ_k(t)^2<br>$$</p>
<p>从而，可利用李雅普诺夫函数描述队列在时隙t的积压量$\Delta(\Theta(t))\triangleq L(\Theta(t+1))-L(\Theta(t))$，该式被称为李雅普诺夫漂移(Lyapunov drift)。易得$Q_k(t+1)^2\le(Q_k(t)+y_k(t))^2,k\in{1,2,…,K}$，对K个队列进行累加可得</p>
<p>$$<br>\frac 1 2\sum_{k&#x3D;1}^KQ_k(t+1)^2\le\frac 1 2\sum_{k&#x3D;1}^KQ_k(t)^2+\frac 1 2\sum_{k&#x3D;1}^Ky_k(t)^2+\sum_{k&#x3D;1}^KQ_k(t)y_k(t)<br>$$</p>
<p>由于队列的进出都是有限的，因此$\frac 1 2\sum_{k&#x3D;1}^Ky_k(t)^2$是存在上界$B&gt;0$的，所以可得</p>
<p>$$<br>\begin{aligned}\Delta(\Theta(t))&amp;\triangleq\frac 1 2\sum_{k&#x3D;1}^KQ_k(t+1)^2-\frac 1 2\sum_{k&#x3D;1}^KQ_k(t)^2\&amp;\le\frac 1 2\sum_{k&#x3D;1}^Ky_k(t)^2+\sum_{k&#x3D;1}^KQ_k(t)y_k(t)\le B+\sum_{k&#x3D;1}^KQ_k(t)y_k(t)\end{aligned}\qquad(3)<br>$$</p>
<p>$$<br>\begin{aligned}\mathcal{P}3:\min_{\forall t,\alpha(t)\in\mathcal{A}^m}\mathbb{E}[\Delta(\Theta(t))+V\cdot p(t)|\mathcal{\Theta}(t)]\s.t.\lim_{T\rightarrow\infty}\frac{\mathbb{E}[Q_k(T)]}{T}&#x3D;0,k\in{1,2,…,K}\end{aligned}<br>$$</p>
<p>其中，V是一个权重，用来调节对二者的重视程度。然而此时计算李雅普诺夫漂移需要下一时隙的排队信息，这样的话无法在当前时隙中求得该问题的解，但是可以利用式(3)对问题$\mathcal{P}3$进行放缩，从而得到问题$\mathcal{P}4$ ：</p>
<p>$$<br>\mathcal{P}4:\min_{\forall t,\alpha(t)\in\mathcal{A}^m}\mathbb{E}[B+V\cdot p(t)+\sum_{k&#x3D;1}^KQ_k(t)y_k(t)|\Theta(t)]\s.t.\lim_{T\rightarrow\infty}\frac{\mathbb{E}[Q_k(T)]}{T}&#x3D;0,k\in{1,2,…,K}<br>$$</p>
<p>漂移加罚算法（DPP），就是求解$\mathcal{P}4$的近似最优解从而求解$\mathcal{P}3$</p>
<p>算法步骤：</p>
<p>（1）在时隙t开头，观察发生的所有随机事件以及所有队列的积压量：$\textbf{w}(t),\Theta(t)$</p>
<p>（2）通过求解如下问题确定最优的控制决策$\alpha^*(t)$：</p>
<p>$$<br>\alpha^*(t)&#x3D;\argmin_{\alpha(t)\in\mathcal{A}^m}\mathbb{E}[B+V\cdot p(t)+\sum_{k&#x3D;1}^KQ_k(t)y_k(t)|\Theta(t)]\qquad(4)<br>$$</p>
<p>（3）$\forall k\in{1,2,…,K},Q_k(t+1)&#x3D;\max{Q_k(t)+y_k(t),0}$更新$Q_k(t)$</p>
<p>（4）$t\leftarrow t+1$</p>
<blockquote>
<p>📌可以看到漂移加罚算法并没有管约束条件(2)，下方证明算法隐式地满足约束</p>
</blockquote>
<h2 id="4-性能分析"><a href="#4-性能分析" class="headerlink" title="4 性能分析"></a>4 性能分析</h2><h3 id="4-1-计算结果精度"><a href="#4-1-计算结果精度" class="headerlink" title="4.1 计算结果精度"></a>4.1 计算结果精度</h3><ul>
<li><p>最优$\textbf{w}-only$策略：</p>
<p>$\textbf{w}-only\ policy$是指每个时隙内仅依赖于观测到的$\textbf{w}(t)$选择最优控制动作，而不依赖于队列状态(backlog)的策略。最优$\textbf{w}-only$则是满足如下条件的$\textbf{w}-only$策略：</p>
</li>
</ul>
<p>在每个时隙内，采取动作$\alpha^*(t)$满足：</p>
<p>$$<br>P(\textbf{w}(t),\alpha^*(t))&#x3D;p^<em>\Y_k(\textbf{w}(t),\alpha^</em>(t))\le0,\ k\in{1,2,…,K}\qquad(5)<br>$$</p>
<p>其中$p^*$是不考虑约束条件的原问题$\mathcal{P}1$的最优目标函数值，即</p>
<p>$$<br>p^*&#x3D;\min(\lim_{T\rightarrow\infty}\frac 1 T\sum_{t&#x3D;0}^{T-1}\mathbb{E}[p(t)])<br>$$</p>
<blockquote>
<p>📌定理：如果原始问题P1有最优解，那么P1一定存在最优w-only策略</p>
</blockquote>
<ul>
<li>DPP解与最优解之间的差距：</li>
</ul>
<p>由式(3)&amp;(4)可得，</p>
<p>$$<br>\begin{aligned}\Delta(\Theta(t))+V\cdot p(t)&amp;\le B+V\cdot p(t)+\sum_{k&#x3D;1}^K Q_k(t)y_k(t)\&amp;&#x3D;B+V\cdot P(\textbf{w}(t),\alpha(t))+\sum_{k&#x3D;1}^KQ_k(t)Y_k(\textbf{w}(t),\alpha(t))\&amp;\le B+V\cdot P(\textbf{w}(t),\alpha^*(t))+\sum_{k&#x3D;1}^KQ_k(t)Y_k(\textbf{w}(t),\alpha^*(t))\end{aligned}<br>$$</p>
<p>取期望得</p>
<p>$$<br>\begin{aligned}&amp;\mathbb{E}[\Delta(\Theta(t))+V\cdot p(t)|\Theta(t)]\&amp;\le B+V\cdot\mathbb{E}[P(\textbf{w}(t),\alpha^*(t))]+\sum_{k&#x3D;1}^K\mathbb{E}[Q_k(t)Y_k(\textbf{w}(t),\alpha^*(t))|\Theta(t)]\&amp;&#x3D;B+V\cdot\mathbb{E}[P(\textbf{w}(t),\alpha^*(t))]+\sum_{k&#x3D;1}^K\mathbb{E}[Q_k(t)|\Theta(t)]\mathbb{E}[Y_k(\textbf{w}(t),\alpha^*(t))|\Theta(t)]\ (相互独立)\&amp;\le B+V\cdot p^*\qquad(这是因为式(5))\end{aligned}<br>$$</p>
<p>时隙累加，可得</p>
<p>$$<br>\begin{aligned}(B+V\cdot p^*)T&amp;\ge\sum_{t&#x3D;0}^{T-1}\mathbb{E}[\Delta(\Theta(t))+V\cdot p(t)|\Theta(t)]\&amp;&#x3D;\mathbb{E}[L(\Theta(t))-L(\Theta(0))]+V\cdot\sum_{t&#x3D;0}^{T-1}\mathbb{E}[p(t)|\Theta(t)]\&amp;\ge V\cdot\sum_{t&#x3D;0}^{T-1}\mathbb{E}[p(t)|\Theta(t)]\end{aligned}<br>$$</p>
<p>也就是说$\mathcal{P}4$得到的近似最优解与不加约束的$\mathcal{P}1$的最优解之间的关系是一个不等式：</p>
<p>$$<br>\frac1T\sum_{t&#x3D;0}^{T-1}\mathbb{E}[p(t)|\Theta(t)]\le p^*+\frac B V\qquad(6)<br>$$</p>
<p>所以可知，$\mathcal{P}4$得到的近似最优解与不加约束的$\mathcal{P}1$的最优解之间的差距是$O(\frac 1 V)$的</p>
<h3 id="4-2-队列长度"><a href="#4-2-队列长度" class="headerlink" title="4.2 队列长度"></a>4.2 队列长度</h3><p>假设存在一个$\textbf{w}-only$策略，满足$\exist\epsilon &gt;0,\ \mathbb{E}[Y_k(\textbf{w}(t),\alpha^*(t))]\le-\epsilon$（不要求是最优$\textbf{w}-only$策略），那么存在下列不等式：</p>
<p>$$<br>\Delta(\Theta(t))+V\cdot p(t)\le B+V\cdot P(\textbf{w}(t),\alpha(t))+\sum_{k&#x3D;1}^KQ_k(t)Y_k(\textbf{w}(t),\alpha^*(t))\\Delta(\Theta(t))+V\cdot p_{min}\le B+V\cdot p_{max}+\sum_{k&#x3D;1}^KQ_k(t)Y_k(\textbf{w}(t),\alpha^*(t))\\begin{aligned}\mathbb{E}[\Delta(\Theta(t))]+V\cdot p_{min}&amp;\le B+V\cdot p_{max}+\sum_{k&#x3D;1}^K\mathbb<br>{E}[Q_k(t)]\mathbb{E}[Y_k(\textbf{w}(t),\alpha^*(t))]\&amp;\le B+V\cdot p_{max}+\sum_{k&#x3D;1}^K\mathbb{E}<a href="-%5Cepsilon">Q_k(t)</a>\end{aligned}<br>$$</p>
<p>移项，累加可有</p>
<p>$$<br>\frac 1 T\sum_{t&#x3D;0}^{T-1}\sum_{k&#x3D;1}^K\mathbb{E}[Q_k(t)]\le\frac{B+V\cdot(p_{max}-p_{min})}{\epsilon}\qquad(7)<br>$$</p>
<p>由此可知，平均每时隙内所有队列长度是$O(V)$的</p>
<h3 id="4-3-精度与时间的权衡"><a href="#4-3-精度与时间的权衡" class="headerlink" title="4.3 精度与时间的权衡"></a>4.3 精度与时间的权衡</h3><p>式(6)和式(7)共同构成了李雅普诺夫优化定理。</p>
<p>时均队列大小是$O(V)$的，其反映算法的执行时间，而计算精度是$O(\frac 1 V)$的。</p>
<p>也就是说增大V可以获得更加逼近与原始问题$\mathcal{P}1$最优解的解，而减少V则可以更快的满足约束条件，降低执行时间。所以说，需要调整V，找到算法执行时间与计算结果精度之间的trade-off</p>
<h3 id="4-4-证明漂移加罚算法满足约束条件"><a href="#4-4-证明漂移加罚算法满足约束条件" class="headerlink" title="4.4 证明漂移加罚算法满足约束条件"></a>4.4 证明漂移加罚算法满足约束条件</h3><p>由前面可得，$\mathbb{E}[\Delta(\Theta(t))]+V\cdot p_{min}\le B+V\cdot p_{max}+\sum_{k&#x3D;1}^K\mathbb{E}<a href="-%5Cepsilon">Q_k(t)</a>$，对时隙进行累加有</p>
<p>$$<br>\begin{aligned}\mathbb{E}[L(\Theta(t))]-\mathbb{E}[L(\Theta(0))]&amp;\le(B+V(p_{max}-p_{min}))\cdot T-\epsilon\sum_{t&#x3D;0}^{T-1}\sum_{k&#x3D;1}^K\mathbb{E}[Q_k(t)|\Theta(t)]\&amp;\le B’\cdot T\end{aligned}<br>$$</p>
<p>$$<br>\frac 1 2\sum_{k&#x3D;1}^K\mathbb{E}[Q_k(T)^2]\le B’\cdot T\(\sum_{k&#x3D;1}^K\mathbb{E}[Q_k(T)])^2\le K\sum_{k&#x3D;1}^K\mathbb{E}[Q_k(T)^2]\le 2KB’\cdot T<br>$$</p>
<p>取极限有</p>
<p>$$<br>\lim_{T\rightarrow\infty}\frac{\sum_{k&#x3D;1}^K\mathbb{E}[Q_k(T)]}T\le\lim_{T\rightarrow\infty}\sqrt{\frac{2KB’}T}&#x3D;0<br>$$</p>
<p>又由于$Q_k(t)\ge 0$，所以有</p>
<p>$$<br>\forall k\in{1,2,…,K},\lim_{T\rightarrow\infty}\frac{\mathbb{E}[Q_k(T)]}T&#x3D;0<br>$$</p>
<p>即，在漂移加罚算法的执行过程中，约束条件(2)是一直成立的</p>
<h2 id="5-Case-Study"><a href="#5-Case-Study" class="headerlink" title="5 Case Study"></a>5 Case Study</h2><h3 id="5-1-LODCO"><a href="#5-1-LODCO" class="headerlink" title="5.1 LODCO"></a>5.1 LODCO</h3><p>其中$B’&#x3D;B+V\cdot(p_{max}-p_{min})$，代入李雅普诺夫函数和柯西不等式$(\sum_{i&#x3D;1}^nx_iy_i)^2\le(\sum_{i&#x3D;1}^nx_i^2)(\sum_{i&#x3D;1}^ny_i^2)$可得</p>
<p>将前文所述的$p(t)$作为惩罚项(penalty)，同时求解李雅普诺夫漂移和惩罚项的最小值，便可以得到新问题</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学方法</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo使用方法</title>
    <url>/2022/05/10/hexo%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>【置顶】知识管理</title>
    <url>/2022/05/18/%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h1><ul>
<li><p>C++</p>
<ul>
<li><p>C++基础知识：<p align="right">（更新中）-&gt;<a href="https://www.wolai.com/i4fuq7u3G5X9fh79fG4yqS">链接</a></p></p>
<blockquote>
<p>参考资料：</p>
<p>《C++语言导学》第一版</p>
<p>《C++ Primer》第五版</p>
<p>《C++新经典：对象模型》第一版</p>
</blockquote>
</li>
<li><p>C++三部曲阅读笔记：<p align="right">（开坑未填）-&gt;链接</p></p>
<blockquote>
<p>参考资料：</p>
<p>《Effective C++》</p>
<p>《More Effective C++》</p>
<p>《Effective Modern C++》</p>
</blockquote>
</li>
<li><p>C++泛型编程笔记：<p align="right">（开坑未填）-&gt;链接</p></p>
<blockquote>
<p>参考资料：</p>
<p>《C++模板元编程实战：一个深度学习框架的初步实现》</p>
<p>《C++新经典：模板与泛型编程》</p>
</blockquote>
</li>
</ul>
</li>
<li><p>Golang</p>
<ul>
<li><p>Go语言基础知识：<p align="right">（更新中）-&gt;<a href="https://www.wolai.com/cAyKwE7zy55YMwUgK7dtM6">链接</a></p></p>
<blockquote>
<p>参考资料：</p>
<p>B站up主“七米老师”的<a href="https://space.bilibili.com/4638193/channel/collectiondetail?sid=337211&ctype=0">Go语言系列教程</a></p>
<p>刘丹冰——<a href="https://www.kancloud.cn/aceld/golang">Golang修养之路</a></p>
<p>《Go语言底层原理剖析》</p>
</blockquote>
</li>
<li><p>Go语言进阶：<p align="right">（开坑未填）-&gt;链接</p></p>
<blockquote>
<p>参考资料：</p>
<p>《Go语言进阶之路》</p>
</blockquote>
</li>
</ul>
</li>
<li><p>JavaScript</p>
<ul>
<li><p>JS基础：<p align="right">（更新中）-&gt;<a href="https://www.wolai.com/wVoyKEaHQ9a8xJfYj9Rr9g">链接</a></p></p>
<blockquote>
<p>参考资料：</p>
<p><a href="https://www.bilibili.com/video/BV11E411R7Mp">JavaScript——45分钟快速上车</a></p>
<p><a href="https://www.bilibili.com/video/BV18a4y1L7kD">微软官方JavaScript入门教程</a></p>
</blockquote>
</li>
<li><p>Node.js进阶：<p align="right">（开坑未填）-&gt;链接</p></p>
<blockquote>
<p>参考资料：</p>
<p><a href="https://www.bilibili.com/video/BV1kN41197vw">微软官方Node.js入门教程</a></p>
</blockquote>
</li>
</ul>
</li>
<li><p>Python</p>
<ul>
<li><p>Python基础知识：<p align="right">（更新中）-&gt;<a href="https://www.wolai.com/cnfQrSS4QVToejo5oHMUiC">链接</a></p></p>
<blockquote>
<p>参考资料：</p>
<p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400">廖雪峰的Python教程</a></p>
</blockquote>
</li>
<li><p>Python Cookbook奇技淫巧：<p align="right">（开坑未填）-&gt;链接</p></p>
<blockquote>
<p>参考资料：</p>
<p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/preface.html">Python Cookbook 中文版</a></p>
</blockquote>
</li>
</ul>
</li>
<li><p>Matlab基础：<p align="right">（暂时完结）-&gt;<a href="https://www.wolai.com/6A8LJGxGgXPdjKLJoQPfQC">链接</a></p></p>
</li>
</ul>
<h1 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h1><ul>
<li><p>Docker：<p align="right">（暂时完结）-&gt;<a href="https://www.wolai.com/oNuD4Pvm1Zyd1AK5CT5HZ5">链接</a></p></p>
<blockquote>
<p>参考资料：</p>
<p><a href="https://docs.docker.com/get-started/overview/">Docker官方文档</a></p>
<p>本人译制的<a href="https://www.bilibili.com/video/BV1Ft4y1S7ax">Docker速成视频</a></p>
</blockquote>
</li>
<li><p>WebRTC：<p align="right">（更新中）-&gt;<a href="https://www.wolai.com/rjmCB8E1VC7N8fhv4pBsSP">链接</a></p></p>
<blockquote>
<p>参考资料：</p>
<p>《WebRTC音视频实时互动技术：原理、实战与源码分析》</p>
</blockquote>
</li>
<li><p>Kubernetes：<p align="right">（更新中）-&gt;<a href="https://www.wolai.com/tpvNeU46wsLMCngKnbViyx">链接</a></p></p>
<blockquote>
<p>参考资料：</p>
<p>本人译制的<a href="https://www.bilibili.com/video/BV1i5411E7MU">Kubernetes速成视频</a></p>
<p>极客时间《深入剖析Kubernetes》</p>
</blockquote>
</li>
<li><p>Pytorch：<p align="right">（更新中）-&gt;<a href="https://www.wolai.com/v42SEByYqECDFrB1M12gy6">链接</a></p></p>
<blockquote>
<p>参考资料：</p>
<p><a href="https://www.bilibili.com/video/BV1Vx411j7kT">莫烦教程</a></p>
<p><a href="https://pytorch.org/docs/1.11/">Pytorch官方文档</a></p>
</blockquote>
</li>
</ul>
<h1 id="编程算法"><a href="#编程算法" class="headerlink" title="编程算法"></a>编程算法</h1><blockquote>
<p>参考资料：</p>
<p><a href="https://www.acwing.com/">ACwing</a>网站 “算法基础课” &amp; “算法提高课” &amp; “算法面试笔试辅导课”</p>
<p>程序员Karl——<a href="https://www.programmercarl.com/">代码随想录</a></p>
</blockquote>
<h1 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a>数学知识</h1><ul>
<li><p>Lyapunov Optimization</p>
<blockquote>
<p>参考资料：</p>
</blockquote>
</li>
<li><p>次模优化</p>
<blockquote>
<p>参考资料：</p>
</blockquote>
</li>
<li><p>矩阵论</p>
<blockquote>
<p>参考资料：</p>
</blockquote>
</li>
<li><p>概率论</p>
<blockquote>
<p>参考资料：</p>
</blockquote>
</li>
<li><p>经典凸优化理论</p>
<blockquote>
<p>参考资料：</p>
<p>Stephen Boyd《Convex Optimization》</p>
</blockquote>
</li>
<li><p>Majorization Minimization</p>
<blockquote>
<p>参考资料：</p>
</blockquote>
</li>
</ul>
<h1 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h1><ul>
<li><p>操作系统：<p align="right">（更新中）-&gt;<a href="https://www.wolai.com/c1N512Jq3vxNKYzzCvqyZM">链接</a></p></p>
<blockquote>
<p>参考资料：</p>
<p>南京大学蒋炎岩 “<a href="https://space.bilibili.com/202224425/channel/collectiondetail?sid=192498&ctype=0">操作系统：设计与实现</a>”</p>
</blockquote>
</li>
<li><p>数据库</p>
<ul>
<li><p>MySQL：<p align="right">（更新中）-&gt;<a href="https://www.wolai.com/5fP6Py1Z4rerX62PJiiyA2">链接</a></p></p>
<blockquote>
<p>参考资料：</p>
<p><a href="https://www.runoob.com/mysql/mysql-tutorial.html">菜鸟教程——MySQL基础</a></p>
<p>《MySQL是怎样运行的：从根儿上理解MySQL》</p>
</blockquote>
</li>
</ul>
</li>
<li><p>分布式系统</p>
<ul>
<li><p>MIT 6.824（2020）笔记：<p align="right">（开坑未填）-&gt;链接</p></p>
<blockquote>
<p>参考资料：<a href="https://www.simtoco.com/#/home">Simviso网站</a>译制课程</p>
</blockquote>
</li>
</ul>
</li>
<li><p>设计模式：<p align="right">（更新中）-&gt;<a href="https://www.wolai.com/vKvsLtKSQ2EDi2QDfPCfyp">链接</a></p></p>
<blockquote>
<p>参考资料：</p>
<p>《设计模式的艺术：一本实例驱动的设计模式实践指南》</p>
</blockquote>
</li>
<li><p>编译原理：<p align="right">（开坑未填）-&gt;链接</p></p>
<blockquote>
<p>参考资料：</p>
<p>虎书《现代编译原理：C语言描述》</p>
</blockquote>
</li>
<li><p>嵌入式开发（属于会的技能，但是否填坑再议）</p>
<ul>
<li><p>STM32</p>
</li>
<li><p>嵌入式Linux</p>
</li>
<li><p>freeRTOS</p>
</li>
<li><p>FPGA</p>
</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>矩阵论</title>
    <url>/2021/05/25/%E7%9F%A9%E9%98%B5%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="矩阵论"><a href="#矩阵论" class="headerlink" title="矩阵论"></a>矩阵论</h1><p><a href="https://github.com/Zessay/HUST_Matrix" title="原文出处">原文出处</a></p>
<h1 id="1-线性空间与线性变换"><a href="#1-线性空间与线性变换" class="headerlink" title="1 线性空间与线性变换"></a>1 线性空间与线性变换</h1><hr>
<p>（1）线性空间的定义：</p>
<blockquote>
<p>以$\alpha, \beta, \gamma,…$为元素的非空集合$V$，数域$F$，定义<strong>两种运算</strong>： <em>加法</em>：$\forall \alpha , \beta \in V, ; \alpha + \beta \in V$； <em>数乘</em>：$\forall k \in F, \alpha \in V, k \alpha \in V$。 **满足8条：<strong><strong>加法交换律、加法结合律、数乘结合律、两个分配律，0元存在，1元存在，负元存在</strong></strong>。称 **$V$<strong>为数域</strong>$F$<strong>上的线性空间</strong>。</p>
</blockquote>
<hr>
<p>（2）证明一组向量是线性空间的基，两步走：</p>
<ul>
<li><p>证明这组向量线性无关；</p>
</li>
<li><p>证明线性空间任意向量可由这组向量表示。</p>
</li>
</ul>
<hr>
<p>（3）如果${E_{ij}, i&#x3D;1,2,…,m;j&#x3D;1,2,…,n}$是矩阵空间$R^{m \times n}$的一组基，则$\dim R^{m \times n} &#x3D; m \times n$。</p>
<blockquote>
<p>📌<strong>注：这里有前提条件，实际上</strong>$\dim R^{m \times n}$<strong>并不是总等于</strong>$m \times n$</p>
</blockquote>
<hr>
<p>（4）$\alpha_1, \alpha_2, …, \alpha_n$是线性空间$V_n(F)$的一组基，对于$\forall \beta \in V$,</p>
<p>$$<br>\beta &#x3D; (\alpha_1 ; \alpha_2 ; … ; \alpha_n)\begin{bmatrix}x_1\ x_2\ …\ x_n\end{bmatrix}&#x3D; (\alpha_1 ; \alpha_2 ; … ; \alpha_n)X<br>$$</p>
<p>其中$X$称为向量$\beta$在基$(\alpha_1 ; \alpha_2 ; … ; \alpha_n)$下对应的坐标。</p>
<p>$V_n(F)$中向量组${\beta_1 ; \beta_2 ; … ; \beta_m}$线性相关的充要条件是坐标向量组${X_1,X_2,…,X_m}$是线性相关组。</p>
<hr>
<p>（5）设$(\alpha_1 ; \alpha_2 ; … ; \alpha_n)$和$(\beta_1 ; \beta_2 ; … ; \beta_n)$是$n$维线性空间$V_n(F)$中的两组基，则有$C\in F^{m \times n}$</p>
<p>$$<br>(\beta_1 ; \beta_2 ; … ; \beta_n) &#x3D; (\alpha_1 ; \alpha_2 ; … ; \alpha_n)C<br>$$</p>
<p>其中$C$称为从基$(\alpha_1 ; \alpha_2 ; … ; \alpha_n)$到$(\beta_1 ; \beta_2 ; … ; \beta_n)$的<strong>过渡矩阵</strong>。</p>
<blockquote>
<p>📌重要推论：如果向量$\alpha \in V_n(F)$，$\alpha$在两组基下对应坐标分别是$X$和$Y$，则有： $\alpha &#x3D; (\alpha_1 ; \alpha_2 ; … ; \alpha_n)X\\alpha &#x3D; (\beta_1 ; \beta_2 ; … ; \beta_n)Y$ <em>显然有</em>：$\color{red}{X &#x3D; CY}$。</p>
</blockquote>
<hr>
<p>（6）设$W$是线性空间$V_n(F)$的非空子集合，则$W$是$V_n(F)$的子空间的充要条件是：</p>
<ul>
<li><p><strong>若</strong>$\alpha, \beta \in W$<strong>，则</strong>$\alpha + \beta \in W$</p>
</li>
<li><p><strong>若</strong>$\alpha \in W, ; k \in F$<strong>，则</strong>$k \alpha \in W$</p>
</li>
</ul>
<p>也就是说只需要验证<strong>对加法和数乘封闭</strong>即可。</p>
<hr>
<p>（7）设$W_1, ; W_2$是线性空间$V$的子空间，则：</p>
<ul>
<li><p>$W_1$与$W_2$的<strong>交空间</strong>为：$W_1 \cap W_2 &#x3D; { \alpha | \alpha \in W_1 ; and ; \alpha \in W_2 }$</p>
</li>
<li><p>$W_1$与$W_2$的<strong>和空间</strong>为：$W_1 + W_2 &#x3D; { \alpha | \alpha &#x3D; \alpha_1 + \alpha_2, ; \alpha_1 \in W_1, ; \alpha_2 \in W_2 }$</p>
</li>
</ul>
<blockquote>
<p>📌***两个重要的维数公式 <em><strong>$\dim (W_1 \cap W_2) \leqslant \dim W_i \leqslant \dim(W_1 + W_2) \leqslant \dim V$</strong></em> ***$\dim W_1 + \dim W_2  &#x3D; \dim (W_1 + W_2) + \dim(W_1 \cap W_2)$</p>
</blockquote>
<blockquote>
<p>📌<em>直和子空间</em>：如果$W &#x3D; W_1 + W_2$，并且$W_1 \cap W_2 &#x3D; {0}$，那么称$W$是$W_1$与$W_2$的直和子空间，表示为$W &#x3D; W_1 \oplus W_2$。</p>
</blockquote>
<blockquote>
<p>📌<em>直和补子空间</em>：对$n$维空间$V$的任何子空间$W$，设$\alpha_1, …,\alpha_r$为$W$的基，$r &lt; n$，把它们扩充为$V$的基${\alpha_1, …,\alpha_r; \beta_{r+1}, …, \beta_n}, \quad U &#x3D; L{\beta_{r+1}, …, \beta_n }$有$V &#x3D; W \oplus U$成立，则称$U$是$W$的直和补子空间。</p>
</blockquote>
<hr>
<p>（8）若$(\alpha_1 ; \alpha_2 ; … ; \alpha_n)$是线性空间$V_n(F)$的一组基，则$V_n(F) &#x3D; L {\alpha_1, \alpha_2, .., \alpha_n}$</p>
<p>对一个矩阵$A \in F^{m \times n}$，可以得到两个与$A$相关的子空间：</p>
<p>$N(A) &#x3D; {X |AX&#x3D;0 } \subseteq F^n\R(A) &#x3D; L{A_1, A_2, …,A_n } \subseteq F^m$</p>
<p>其中$N(A)$称为矩阵$A$的<strong>零空间</strong>，$R(A)$称为矩阵$A$的<strong>列空间</strong></p>
<hr>
<p>（9）内积：</p>
<ul>
<li><p><strong>欧氏空间的内积</strong>：$(\alpha, \beta) &#x3D; \alpha^T \beta ; \quad (A, B) &#x3D; tr(AB^T)$</p>
</li>
<li><p><strong>酉空间的内积</strong>：$(\alpha, \beta) &#x3D; \beta^H \alpha ; \quad (A, B) &#x3D; tr(B^HA)$</p>
</li>
</ul>
<blockquote>
<p>📌柯西不等式：$|(\alpha, \beta)|^2 \leqslant (\alpha, \alpha)(\beta, \beta)$</p>
</blockquote>
<blockquote>
<p><strong>正交补子空间****：设</strong>​$U$<strong>为内积空间</strong>$V_n(F)$<strong>的一个子空间，定义</strong>$V_n(F)$<strong>上的一个子集</strong>$U^{\perp} &#x3D; {\alpha ;| ;\alpha \in V_n(F), ; \forall \beta \in U, ; (\alpha, \beta)&#x3D;0 }$<strong>称为</strong>$U$<strong>的正交补子空间</strong>，有$V_n(F) &#x3D; U \oplus U^{\perp}$。</p>
</blockquote>
<hr>
<p>（10）设$T$是线性空间$V_n(F)$上的线性变换，则满足$T(k_1 \alpha_1 + k_2 \alpha_2) &#x3D; k_1 T(\alpha_1) + k_2 T(\alpha_2)$，则有：</p>
<blockquote>
<p><strong>像空间****：</strong> ​$R(T) &#x3D; {\beta | ; \exists \alpha \in V_n(F), s.t. ; \beta &#x3D; T(\alpha)}$<strong>是</strong>$V_n(F)$<strong>上的子空间，称为</strong>$T$<strong>的像空间；</strong>$\dim R(T)$<strong>称为</strong>$T$<strong>的<strong><strong>秩</strong></strong>。</strong></p>
</blockquote>
<blockquote>
<p><strong>零空间****：</strong> ​$N(T) &#x3D; {\alpha |; T(\alpha) &#x3D; 0}$<strong>是</strong>$V_n(F)$<strong>上的子空间，称为</strong>$T$<strong>的零空间；</strong>$\dim N(T)$<strong>称为</strong>$T$<strong>的<strong><strong>零度</strong></strong>。</strong></p>
</blockquote>
<hr>
<p>（11）设$T$为$V_n(F)$上的线性变换，${\alpha_1, \alpha_2, …, \alpha_n}$是$V_n(F)$的基，若存在$n$阶方阵$A$，有：</p>
<p>$$<br>T(\alpha_1 ; \alpha_2 ; … ; \alpha_n) &#x3D; (\alpha_1 ; \alpha_2 ; … ; \alpha_n)A<br>$$</p>
<p>称$A$为$T$在基${\alpha_1, \alpha_2, …, \alpha_n}$下的矩阵。</p>
<ul>
<li><p>设$\alpha$与$T(\alpha)$在基${\alpha_1, \alpha_2, … , \alpha_n}$下的坐标分别是$X$与$Y$，则有：${\color {red}{ Y &#x3D; AX}}$。</p>
</li>
<li><p>设${\alpha_1, \alpha_2, … , \alpha_n}$和${\beta_1, \beta_2, … , \beta_n}$是$V_n(F)$的两组基，且有$(\beta_1 ; \beta_2 ; … ; \beta_n) &#x3D; (\alpha_1 ; \alpha_2 ; … ; \alpha_n)C$；$T$在两组基下的变换矩阵分别是$A$与$B$，则${\color{red} {B&#x3D;C^{-1}AC}}$。</p>
</li>
</ul>
<blockquote>
<p>📌如何对矩阵做线性变换？ $E_{11}&#x3D;\begin{bmatrix} 1 &amp; 0 \ 0 &amp; 0 \end{bmatrix}\ E_{12}&#x3D;\begin{bmatrix} 0 &amp; 1 \ 0 &amp; 0 \end{bmatrix}\ E_{21}&#x3D;\begin{bmatrix} 0 &amp; 0 \ 1 &amp; 0 \end{bmatrix}\ E_{22}&#x3D;\begin{bmatrix} 0 &amp; 0 \ 0 &amp; 1 \end{bmatrix}$是$R^{2\times2}$的基，那么线性变换对应的矩阵为$4\times4$，每一列对应着对${E_{11},E_{12},E_{21},E_{22}}$相应基进行的变换。</p>
</blockquote>
<blockquote>
<p>📌如$T(E_{11})&#x3D;-bE_{12}+cE_{21}\ T(E_{12})&#x3D;-cE_{11}+(a-d)E_{12}+cE_{22}\ T(E_{21})&#x3D;bE_{11}+(d-a)E_{21}-bE_{22}\ T(E_{22})&#x3D;bE_{12}-cE_{21}$</p>
</blockquote>
<blockquote>
<p>📌则T在基$E_{11},E_{12},E_{21},E_{22}$下的矩阵为 $\begin{bmatrix} 0 &amp; -c &amp; b &amp; 0 \ -b &amp; a-d &amp; 0 &amp; b\c &amp; 0 &amp; d-a &amp; -c\0 &amp; c &amp; -b &amp; 0 \end{bmatrix}$</p>
</blockquote>
<hr>
<p>（12）设$T$是线性空间$V_n(F)$上的线性变换，$W$是$V_n(F)$的子空间，如果$\forall \alpha \in W, ; T(\alpha) \in W$，即值域$T(W) \subseteq W$，则称$W$是$T$的<strong>不变子空间</strong>。</p>
<blockquote>
<p>📌<em><strong>重要例题</strong></em> 设$T$是欧式空间$R^3$上的线性变换，对$R^3$中单位矢量$u$，$\forall x \in R^3$，$T(x) &#x3D; x - (1-k)(x,u)u$，问：T的不变子空间的直和分解以及相应的矩阵分解。</p>
</blockquote>
<blockquote>
<p>📌答：对向量$u$有$T(u) &#x3D; u - (1-k)(u,u)u&#x3D; u - (1-k)u &#x3D; ku$ 所以以$u$为基向量的空间是不变子空间，表示为$L{u}$； 同理，对于$u$的正交补子空间$u^{\perp}$，对于任意向量$X \in u^{\perp}$，有 $T(X) &#x3D; X - (1-k)(X,u)u &#x3D; X-0&#x3D;X$ 于是另一个不变子空间为$u^{\perp}$；即$R^3 &#x3D; L{u} \oplus u^{\perp}$。 显然有$L{u}$是一维空间，特征值$k$对应的特征向量是$u_1 &#x3D; u$；那么$u^{\perp}$就是二维空间，特征值$1$对应两个线性无关的特征向量，可以找到两个单位正交特征向量$u_2, u_3$，所以相应的矩阵分解为$\begin{bmatrix}k &amp; &amp; \ &amp; 1 &amp; \ &amp; &amp; 1\end{bmatrix}$，对应的特征向量组 ${u_1,u_2,u_3}$为标准正交基。</p>
</blockquote>
<hr>
<p>（13）<strong>正交变换（酉变换）：线性变换</strong>$T$<strong>不改变向量内积，即</strong>$(T(\alpha), T(\beta)) &#x3D; (\alpha, \beta)$。</p>
<ul>
<li><p>正交变换$T$关于任一标准正交基的矩阵$C$满足$C^TC &#x3D; CC^T&#x3D;I$；酉变换关于任一标准正交基的矩阵$U$满足$U^HU&#x3D;UU^H&#x3D;I$。</p>
</li>
<li><p>正交矩阵的行列式为$\pm 1$；酉矩阵的行列式的模长为$1$。</p>
</li>
</ul>
<hr>
<p>（14）<strong>常见的正交变换</strong></p>
<ul>
<li><p>$R^2$上<strong>绕原点逆时针旋转</strong>$\theta$<strong>角的线性变换</strong>$T_{\theta}$<strong>称为_正交变换_<strong>，在标准正交基下对应的变换矩阵$\begin{bmatrix} \cos \theta &amp; - \sin \theta \ \sin \theta &amp; \cos \theta \end{bmatrix}$是</strong>正交矩阵</strong>。</p>
</li>
<li><p>空间$R^3$上<strong>绕过原点的直线</strong>$l$<strong>旋转</strong>$\theta$<strong>角的变化</strong>$T_{L_{\theta}}$<strong>为_正交变换_<strong>，在标准正交基下对应的变换矩阵$\begin{bmatrix}1 &amp; &amp; \ &amp; \cos \theta &amp; -\sin \theta \ &amp; \sin \theta &amp; \cos \theta \end{bmatrix}$是</strong>正交矩阵</strong>。</p>
</li>
</ul>
<hr>
<h1 id="2-Jordan标准型"><a href="#2-Jordan标准型" class="headerlink" title="2 Jordan标准型"></a>2 Jordan标准型</h1><hr>
<p>（1）若有$T(\xi) &#x3D; \lambda \xi$，称$\lambda$为$T$的特征值，$\xi$为$T$的特征向量。如果$A$是线性变换$T$对应的矩阵，那么，$\lambda$和$\xi$也是$A$的特征值和特征向量。</p>
<hr>
<p>（2）设$\lambda_1, \lambda_2, …, \lambda_s$是$V_n(F)$上线性变换$T$的$s$个互异特征值，$V_{\lambda_i}$是$\lambda_i$的<strong>特征子空间</strong>，其中$i&#x3D;1,2,…,s$，则：</p>
<ul>
<li><p>$V_{\lambda_i}$是$T$的<strong>不变子空间</strong>；</p>
</li>
<li><p>$\lambda_i \neq \lambda_j$时，$V_{\lambda_i} \cap V_{\lambda_j} &#x3D; {0}$；</p>
</li>
<li><p>若$\lambda_i$是$k_i$重（<em>代数重数</em>）的，$\dim V_{\lambda_i}$是_几何重数_，则有$\dim V_{\lambda_i} \leqslant k_i$。</p>
</li>
</ul>
<hr>
<p>（3）线性变换$T$有对角矩阵表示的充分必要条件是 $T$<strong>有</strong>$n$<strong>个线性无关的特征向量</strong>。</p>
<blockquote>
<p><strong>幂等矩阵</strong>**：**$A^2 &#x3D; A$<strong>，</strong>$A$<strong>相似于对角矩阵</strong>$\begin{bmatrix} I_r&amp; \ &amp; 0\end{bmatrix}$**，其中**$r$<strong>为矩阵</strong>$A$<strong>的秩。</strong></p>
</blockquote>
<blockquote>
<p><strong>乘方矩阵</strong>**：**$A^2 &#x3D; I$<strong>，</strong>$A$<strong>相似于对角阵</strong>$\begin{bmatrix}I_s &amp; \ &amp; I_t\end{bmatrix}$**，其中**$s+t&#x3D;n$<strong>。</strong></p>
</blockquote>
<hr>
<p>（4）关于秩的不等式：</p>
<p>$rank(A \pm B) \leqslant rank(A) + rank(B)$</p>
<p>$rank(A) + rank(B) -n \leqslant rank(A_{m \times n}B_{n \times m}) \leqslant \min(r(A), r(B))$</p>
<p>$if ;A_{m \times n}B_{n \times m}&#x3D;0, \quad rank(A) + rank(B) \leqslant n$</p>
<hr>
<p>（5）形如$J(\lambda) &#x3D; \begin{bmatrix}\lambda &amp; 1 &amp; &amp; \ &amp; \lambda &amp; 1 &amp; \ &amp; &amp; … &amp; 1\ &amp; &amp; &amp; \lambda\end{bmatrix}$，称为<strong>Jordan块</strong>。Jordan块呈上三角，主对角线是它的全部特征值，特点是<strong>主对角线上元素相等，紧邻上方元素</strong>$a_{i,i+1} &#x3D; 1$<strong>，其余元素为0</strong>。</p>
<hr>
<p>（6）每个$n$阶方阵$A$都相似于一个Jordan矩阵，即存在可逆矩阵$P$，有：</p>
<p>$P^{-1}AP &#x3D; J_A &#x3D; \begin{bmatrix}J_1(\lambda_1) &amp;  &amp;  &amp; \  &amp; J_2(\lambda_2) &amp;  &amp; \  &amp;  &amp; … &amp; \  &amp;  &amp;  &amp; J_s(\lambda_s)\end{bmatrix}$</p>
<p>其中$J_A$称为<strong>Jordan标准形</strong>。</p>
<hr>
<p>（7）<strong>Jordan标准形</strong>的求法：</p>
<ul>
<li><p>求矩阵$A$的特征多项式$|\lambda I-A| &#x3D; (\lambda - \lambda_1)^{k_1}(\lambda-\lambda_2)^{k_2}…(\lambda - \lambda_s)^{k_s}$，其中$k_i$是特征值$\lambda_i$的<strong>代数重数，决定了对角线上特征值</strong>$\lambda_i$<strong>的个数</strong>；</p>
</li>
<li><p>对$\lambda_i$，由$(A-\lambda_i I)X&#x3D;0$，求$A$的<strong>线性无关的特征向量</strong>$\alpha_1,\alpha_2, …,\alpha_{t_i}$，其中$t_i$是特征值$\lambda_i$的<strong>几何重数，决定了Jordan块的个数</strong>；</p>
<ul>
<li><p>如果$k_i &#x3D; t_i$，即<strong>代数重数等于几何重数</strong>，说明$\lambda_i$对应的Jordan块是对角阵；</p>
</li>
<li><p>如果$t_i &lt; k_i$，就选择合适的特征向量$\alpha_j$，利用${\color{red} {|A-\lambda_i I| &#x3D; \alpha_j}}$<strong>求Jordan链</strong>，确定每一个小Jordan块的阶数。</p>
</li>
</ul>
</li>
<li><p>将所有特征值$\lambda_i$对应的Jordan块组合起来，形成Jordan矩阵$J_A$。</p>
</li>
</ul>
<hr>
<p>（8）<strong>矩阵多项式</strong>可以表示为$g(A) &#x3D; a_m A^m + a_{m-1}A^{m-1}+…+a_1A +a_0 I$ ，由于有$A &#x3D; P J_AP^{-1}$，所以有：</p>
<p>$g(A) &#x3D; P \begin{bmatrix}g(J_1(\lambda_1)) &amp;  &amp;  &amp; \  &amp; g(J_2(\lambda_2)) &amp;  &amp; \  &amp;  &amp; … &amp; \  &amp;  &amp;  &amp; g(J_s(\lambda_s)) \end{bmatrix} P^{-1}$</p>
<p>而对于$g(J(\lambda))$则有：</p>
<p>$g(J(\lambda)) &#x3D; \begin{bmatrix}g(\lambda) &amp; g’(\lambda) &amp; … &amp; \frac{g^{(r-1)}(\lambda)}{(r-1)!} \  &amp; g(\lambda) &amp; … &amp; .\  &amp;  &amp; … &amp; .\  &amp;  &amp;  &amp; g(\lambda)\end{bmatrix}$</p>
<p>对于<strong>常用的幂指数形式</strong>有</p>
<p>$J^k(\lambda) &#x3D; \begin{bmatrix}\lambda^k &amp; \frac{(\lambda^k)’}{1!} &amp; \frac{(\lambda^k)’’}{2!} &amp;… \  &amp;  \lambda^k&amp; … &amp; .\  &amp;  &amp; … &amp; .\  &amp;  &amp;  &amp;  \lambda^k\end{bmatrix}$</p>
<hr>
<p>（9）使$g(A)&#x3D;0$的多项式$g(\lambda)$称为$A$的<strong>化零多项式</strong>，<strong>特征多项式必是矩阵</strong>$A$<strong>的化零多项式</strong>。</p>
<blockquote>
<p>📌注：化零多项式的根一定包含了所有的特征值，但不能说化零多项式的根一定是特征值。</p>
</blockquote>
<hr>
<p>（10）对于<strong>最小多项式</strong></p>
<ul>
<li><p>$m_T(\lambda)$最高项系数为<code>1</code>；</p>
</li>
<li><p>$m_T(\lambda)$是$T$的一个化零多项式；</p>
</li>
<li><p>$m_T(\lambda)$是化零多项式中次数最低的那一个。</p>
</li>
</ul>
<blockquote>
<p><strong>最小多项式</strong>$m_T(\lambda)$<strong>的根一定包含了所有的特征值</strong>$\lambda_i$<strong>，子式</strong>$(\lambda-\lambda_i)^{r_i}$<strong>的幂</strong>$r_i$<strong>等于Jordan标准形中关于特征值</strong>$\lambda_i$<strong>的Jordan块中的最高阶数</strong>。</p>
</blockquote>
<blockquote>
<p>📌比如矩阵$A$有一个代数重数为3的特征值2，该特征值对应两个Jordan块，分别是 $\begin{bmatrix}2 &amp; 1 \ &amp; 2 \end{bmatrix}$以及$[2]$， 说明其中其最高阶数为2，那么在最小多项式中对应的子式为$(\lambda -2)^2$。</p>
</blockquote>
<blockquote>
<p>📌线性变换可以对角化的充要条件是其最小多项式是一次因子的乘积</p>
</blockquote>
<hr>
<p>（11）线性变换与Jordan标准型的结合</p>
<ul>
<li>线性变换在原基的变换矩阵不是对角矩阵，如何求得新基，使得在新基下的变换矩阵是对角矩阵</li>
</ul>
<!---->

<ul>
<li>线性变换在原基的变换矩阵不是Jordan标准型，如何求得新基，使得在新基下的变换矩阵是Jordan标准型</li>
</ul>
<p>对原基下的变换矩阵求<strong>相似对角化</strong>，得到的特征向量组成的矩阵P右乘原基，即是可使变换矩阵成为对角阵的新基</p>
<p>对原基下的变换矩阵求<strong>相似的Jordan标准型</strong>$P\Lambda P^{-1}$，用$P$右乘原基，即是可使变换矩阵成为Jordan标准型的新基</p>
<blockquote>
<p>📌左式在书上定义2.1处有证明，即<br>$T(\xi)&#x3D;\lambda\xi$&amp;#x20;<br>$\xi&#x3D;(\alpha_1,\alpha_2…\alpha_n)\bold X$$T(\xi)&#x3D;(\alpha1,\alpha_2…\alpha_n) A\bold{X}\rightarrow A\bold X&#x3D;\lambda\bold X$&amp;#x20;<br>这说明$\lambda$是矩阵A的特征值，$\bold X$是矩阵A关于$\lambda$的特征向量</p>
</blockquote>
<hr>
<h1 id="3-矩阵分解"><a href="#3-矩阵分解" class="headerlink" title="3 矩阵分解"></a>3 矩阵分解</h1><hr>
<p>（1）<strong>等价标准形</strong></p>
<p>对于$A \in C^{m \times n}$，存在可逆矩阵$P \in C^{m \times m}, Q \in C^{n \times n}$，使得</p>
<p>$$<br>A &#x3D; P \begin{bmatrix}I_r &amp; 0  \ 0 &amp; 0\end{bmatrix}Q<br>$$</p>
<p>其中$r$是矩阵$A$的秩。</p>
<hr>
<p>（2）<strong>相似标准形</strong></p>
<p>存在可逆矩阵$P \in C^{ n \times n}$，有</p>
<p>$$<br>A &#x3D; P \begin{bmatrix}\lambda_1 &amp;  &amp;  &amp; \  &amp; \lambda_2 &amp;  &amp; \  &amp;  &amp; … &amp; \  &amp;  &amp;  &amp; \lambda_n\end{bmatrix} P^{-1}<br>$$</p>
<hr>
<p>（3）<strong>LU分解</strong></p>
<blockquote>
<p>定义：$L$<strong>是下三角矩阵，</strong>$U$<strong>是上三角矩阵</strong>，$A&#x3D;LU$。</p>
</blockquote>
<blockquote>
<p>📌存在条件：A的秩为r，前r阶顺序主子式不为0，则存在LU分解</p>
</blockquote>
<p><em>求法</em>：</p>
<ul>
<li><p>对于$(A ;|; I_n)$，<strong>只用第</strong>$i$<strong>行乘数</strong>$k$<strong>加到第</strong>$j$<strong>行（</strong>$i &lt; j$<strong>）型初等变换将</strong>$A$<strong>化为上三角形</strong>$U$<strong>，可以得到</strong>${\color{red} (U ; |; P)}$；</p>
</li>
<li><p><strong>可知</strong>$PA&#x3D;U$<strong>，于是有</strong>$L&#x3D;P^{-1}$<strong>，则</strong>$A&#x3D;LU$。</p>
</li>
</ul>
<hr>
<p>（4）<strong>LDV分解</strong></p>
<blockquote>
<p>定义：$L, V$分别是<strong>对角线元素为1</strong>的下三角矩阵和上三角矩阵，$D$为对角矩阵，$A&#x3D;LDV$。</p>
</blockquote>
<p><em>求法</em>：</p>
<ul>
<li><p>方法一：</p>
<ol>
<li><p>由LU分解得到$A &#x3D; LU$；</p>
</li>
<li><p>通过每行除以对应的对角线上元素的值，<strong>将</strong>$U$<strong>的对角线元素化为1</strong>，得到$U&#x3D;D_1V$；</p>
</li>
<li><p>通过每列除以对应的对角线上元素的值，将$L$的对角线元素化为1，得到$L&#x3D;L_{real}D_2$</p>
</li>
<li><p>有$A&#x3D;L_{real}D_2D_1V&#x3D;LDV$。</p>
</li>
</ol>
</li>
<li><p>方法二：</p>
<ol>
<li><p>取矩阵$A$对角线第一个元素，得到矩阵$A_1&#x3D;[a_{11}]$，则有$A_1 &#x3D; L_1D_1V_1 &#x3D; [1][a_{11}][1]$；</p>
</li>
<li><p>取包含对角线前两个元素的二阶矩阵$A_2 &#x3D; \begin{bmatrix}A_1 &amp; \alpha\ \beta &amp; a_{22}\end{bmatrix}$，则有矩阵$A_2 &#x3D; L_2 D_2 V_2$，其中$L_2 &#x3D; \begin{bmatrix}L_1 &amp; 0\ x &amp; 1\end{bmatrix}$，$D_2 &#x3D; \begin{bmatrix}D_1 &amp; 0\ 0 &amp; d_2\end{bmatrix}$，$V_2 &#x3D; \begin{bmatrix}V_1 &amp; y\ 0 &amp; 1\end{bmatrix}$，求得未知量$x, d_2, y$；</p>
</li>
<li><p>以此类推，最终得到$A &#x3D; L_n D_n V_n$。</p>
</li>
</ol>
</li>
</ul>
<blockquote>
<p>📌方法二即： $A_n &#x3D; \begin{bmatrix}A_{n-1} &amp; \tau\ u^T &amp; a_{nn}\end{bmatrix}&#x3D;\begin{bmatrix}L_{n-1} &amp; 0\ l^T &amp; 1\end{bmatrix}\begin{bmatrix}D_{n-1} &amp; 0\ 0 &amp; d_n\end{bmatrix}\begin{bmatrix}V_{n-1} &amp; v\ 0 &amp; 1\end{bmatrix}$<br>迭代：<br>&amp;#x20;$A_{n-1}&#x3D;L_{n-1}D_{n-1}V_{n-1}\\tau_n&#x3D;L_{n-1}D_{n-1}v_n\u_n^T&#x3D;l_n^TD_{n-1}V_{n-1}\a_{nn}&#x3D;l_n^TD_nv_n+d_n$</p>
</blockquote>
<blockquote>
<p>📌有LU分解不一定有LDV分解，LU的对角线可以是0，而LDV对角线只能是1</p>
</blockquote>
<hr>
<p>（5）<strong>满秩分解</strong></p>
<blockquote>
<p>定义：对于$rank(A)&#x3D;r$的矩阵$A$，若存在秩为$r$的矩阵$B \in F^{m \times r}, ; C \in F^{r \times n}$，有$A&#x3D;BC$，称为矩阵$A$的满秩分解。</p>
</blockquote>
<blockquote>
<p>📌任何非零矩阵，都存在满秩分解</p>
</blockquote>
<p><em>求法：方法较多，一般只用最简单的第3种。</em></p>
<ul>
<li><p>用<strong>行初等变换</strong>把$A$化为Hermite标准形；</p>
</li>
<li><p>依Hermite标准形中向量$e_i$所在的列的位置第$j_i$列，相应地取出$A$的第$j_i$列$a_{ji}$，得到 $A$的<strong>列向量极大无关组</strong>${a_{j_1}, a_{j_2}, …, a_{j_r}}$，$B &#x3D;(a_{j_1}, a_{j_2}, …, a_{j_r})$;</p>
</li>
<li><p>$A$的Hermite矩阵中的<strong>非零行</strong>构成矩阵$C$，得到满秩分解$A&#x3D;BC$。</p>
</li>
</ul>
<blockquote>
<p>📌求矩阵$A&#x3D;\begin{bmatrix}1 &amp; 1 &amp; 2\ 0 &amp; 2 &amp; 2\ 1 &amp; 0 &amp; 1\end{bmatrix}$的满秩分解。</p>
<p>答： 用行初等变换化$A$为Hermite标准形：<br>$A &#x3D; \begin{bmatrix}1 &amp; 1 &amp; 2\ 0 &amp; 2 &amp; 2\ 1 &amp; 0 &amp; 1\end{bmatrix} \rightarrow \begin{bmatrix}1 &amp; 1 &amp; 2\ 0 &amp; 2 &amp; 2\ 0 &amp; -1 &amp; -1\end{bmatrix} \rightarrow \begin{bmatrix}1 &amp; 0 &amp; 1\ 0 &amp; 1 &amp; 1\ 0 &amp;0 &amp;0 \end{bmatrix}$<br>可知$rank(A)&#x3D;2$，$A$的前两列线性无关，取出构成$B$；取出$A$的Hermite标准形的前两行作为$C$，有$B &#x3D; \begin{bmatrix} 1&amp;1  \  0&amp;2  \  1&amp;0  \end{bmatrix}, C &#x3D; \begin{bmatrix}1 &amp; 0 &amp; 1\ 0 &amp; 1 &amp; 1\end{bmatrix}, A&#x3D;BC$</p>
</blockquote>
<hr>
<p>（6）<strong>谱分解</strong></p>
<blockquote>
<p>定义：矩阵$A$互异的特征值${\lambda_1, \lambda_2, …, \lambda_s}$称为矩阵$A$的<strong>谱</strong>。<strong>可相似对角化是可以谱分解的充要条件</strong>。</p>
</blockquote>
<p><em>求法</em>：</p>
<ul>
<li><p>通过求特征值和特征向量得到</p>
<p>$A &#x3D; P\begin{bmatrix}\lambda_1 &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; \ &amp; … &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; \ &amp; &amp; \lambda_1 &amp; &amp; &amp; &amp; &amp; &amp; &amp; \ &amp; &amp; &amp; \lambda_2&amp; &amp; &amp; &amp; &amp; &amp; \ &amp; &amp; &amp; &amp; … &amp; &amp; &amp; &amp; &amp; \ &amp; &amp; &amp; &amp; &amp; \lambda_2 &amp; &amp; &amp; &amp; \ &amp; &amp; &amp; &amp; &amp; &amp; … &amp; &amp; &amp; \ &amp; &amp; &amp; &amp; &amp; &amp; &amp; \lambda_s &amp; &amp; \ &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; … &amp; \ &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; \lambda_s\end{bmatrix} P^{-1}$；</p>
</li>
<li><p>对角阵$\Lambda &#x3D; \lambda_1 \begin{bmatrix}I_{r_1} &amp; &amp; &amp; \ &amp; 0 &amp; &amp; \ &amp; &amp; … &amp; \ &amp; &amp; &amp; 0\end{bmatrix} + \lambda_2\begin{bmatrix}0 &amp; &amp; &amp; \ &amp; I_{r_2} &amp; &amp; \ &amp; &amp; 0 &amp; \ &amp; &amp; &amp; 0\end{bmatrix} + … + \lambda_s\begin{bmatrix}0 &amp; &amp; &amp; \ &amp; 0 &amp; &amp; \ &amp; &amp; 0 &amp; \ &amp; &amp; &amp; I_{r_s}\end{bmatrix}$，令$Q_i &#x3D; \begin{bmatrix}0 &amp; &amp; &amp; \ &amp;… &amp; &amp; \ &amp; &amp; I_{r_i} &amp; \ &amp; &amp; &amp; …\end{bmatrix}$；</p>
</li>
<li><p>得到$A &#x3D; \sum_{i&#x3D;1}^s \lambda_i P_i$，其中$P_i &#x3D; P Q_i P^{-1}$。</p>
</li>
</ul>
<hr>
<p>（7）<strong>Schur分解</strong></p>
<blockquote>
<p>UR分解：对可逆矩阵$A$，存在<strong>酉矩阵</strong>$U$<strong>和</strong>主对角线上元素都为正的上三角矩阵$R$，使$A&#x3D;UR$。</p>
</blockquote>
<blockquote>
<p>Schur分解：设$A\in C^{n\times n}$，则存在酉矩阵$U$和上三角矩阵$T$，使得</p>
</blockquote>
<p>$U^HAU&#x3D;T&#x3D;\begin{bmatrix}\lambda_1&amp;t_{12} &amp;… &amp;t_{1n} \ &amp;\lambda_2 &amp;… &amp;t_{2n} \ &amp; &amp; … &amp; \ &amp; &amp; &amp; \lambda_n\end{bmatrix}$</p>
<p>其中$\lambda_i$是矩阵$A$的特征值，$i&#x3D;1,2,…,n$</p>
<p><em>UR分解**求法</em>：</p>
<ul>
<li><p>取矩阵$A &#x3D; (A_1, A_2, …, A_n)$的列向量，进行<strong>施密特正交化</strong>，得到$u_1,u_2, …,u_n$，有$U&#x3D;(u_1,u_2,…,u_n)$；</p>
</li>
<li><p>再由$R &#x3D; U^H A$得到$R$，于是$A&#x3D;UR$。</p>
</li>
</ul>
<blockquote>
<p>📌施密特正交化方法： 设$\alpha_1,\alpha_2,…,a_r(r\le n)$是线性无关的向量组，则通过以下方法 $\beta_1&#x3D;\alpha_1\\beta_2&#x3D;\alpha_2-\frac{(\alpha_2,\beta_1)}{(\beta_1,\beta_1)}\beta_1\……\\beta_k&#x3D;\alpha_k-\sum_{i&#x3D;1}^{k-1}\frac{(\alpha_k,\beta_i)}{(\beta_i,\beta_i)}\beta_i\k&#x3D;3,4,…,r$&amp;#x20;<br>得到的向量组$\beta_1,\beta_2,…,\beta_r$是正交向量组</p>
</blockquote>
<p><em>Schur分解求法</em>：</p>
<ul>
<li><p>$A$相似于Jordan标准型$A&#x3D;PJP^{-1}$；</p>
</li>
<li><p>通过$P$的UR分解有$P&#x3D;UR$，则$A&#x3D;PJP^{-1}&#x3D;URJR^{-1}U^H$；</p>
</li>
<li><p>令$T&#x3D;RJR^{-1}$，则$T$是一个上三角形矩阵，即有$U^HAU&#x3D;T$。</p>
</li>
</ul>
<hr>
<p>（8）几种特殊矩阵：</p>
<ul>
<li><p><strong>正规矩阵</strong>：$A^HA &#x3D; AA^H$ （<strong>正规矩阵酉相似于对角阵</strong>）</p>
</li>
<li><p><strong>酉矩阵</strong>：$A^HA &#x3D; AA^H&#x3D;I$</p>
</li>
<li><p><strong>Hermite矩阵</strong>：$A^H &#x3D; A$</p>
</li>
</ul>
<blockquote>
<p>📌对于正规矩阵，$A$和$A^H$的特征向量相等，更一般地，只要$AB&#x3D;BA$且$A$和$B$都可相似对角化，那么A和B特征向量就相同。&amp;#x20;<br>证明： $A&#x3D;P\Lambda_1 P^{-1}&#x3D;P\begin{bmatrix}\lambda_1 &amp; \ &amp; \lambda_2\ &amp; &amp; …\ &amp; &amp; &amp; \lambda_n\end{bmatrix}P^{-1}$<br>则$P^{-1}APP^{-1}BP&#x3D;P^{-1}ABP&#x3D;P^{-1}BAP&#x3D;P^{-1}BPP^{-1}AP$&amp;#x20;<br>即$\begin{bmatrix}\lambda_1&amp;&amp;&amp;\&amp;\lambda_2&amp;&amp;\&amp;&amp;…&amp;\&amp;&amp;&amp;\lambda_n\end{bmatrix}P^{-1}BP&#x3D;P^{-1}BP\begin{bmatrix}\lambda_1&amp;&amp;&amp;\&amp;\lambda_2&amp;&amp;\&amp;&amp;…&amp;\&amp;&amp;&amp;\lambda_n\end{bmatrix}$&amp;#x20;<br>所以$P^{-1}BP&#x3D;\begin{bmatrix}\lambda_1^{-1}&amp;&amp;&amp;\&amp;\lambda_2^{-1}&amp;&amp;\&amp;&amp;…&amp;\&amp;&amp;&amp;\lambda_n^{-1}\end{bmatrix}P^{-1}BP\begin{bmatrix}\lambda_1&amp;&amp;&amp;\&amp;\lambda_2&amp;&amp;\&amp;&amp;…&amp;\&amp;&amp;&amp;\lambda_n\end{bmatrix}$<br>也就是说$P^{-1}BP$的每个元素$a_{ij}&#x3D;a_{ij}\frac{\lambda_j}{\lambda_i}$，只有对角线元素是可以满足此条件的，所以$P^{-1}BP$是对角矩阵$\begin{bmatrix}k_1&amp;&amp;&amp;\&amp;k_2&amp;&amp;\&amp;&amp;…&amp;\&amp;&amp;&amp;k_n\end{bmatrix}$ ，$k_1,k_2,…k_n$也就是B的特征向量。<br>对于$P&#x3D;[\alpha_1,\alpha_2,…\alpha_n]$的列向量$\alpha_i$，有$A\alpha_i&#x3D;\lambda_i\alpha_i,B\alpha_i&#x3D;k_i\alpha_i$，所以$\alpha_i$同时是A和B的特征向量。即A和B特征向量相同</p>
</blockquote>
<hr>
<p>（9）<strong>奇异值分解（SVD分解）</strong></p>
<blockquote>
<p><strong>奇异值</strong>：对$rank(A)&#x3D;r$的矩阵A，矩阵$A^HA$的<strong>非零特征值</strong>有$\lambda_1 \geqslant \lambda_2 \geqslant … \geqslant \lambda_r &gt;0$，则称正数$\sigma_i &#x3D; \sqrt{\lambda_i}$为矩阵A的奇异值。</p>
</blockquote>
<blockquote>
<p>定义：对$rank(A)&#x3D;r$的矩阵$A \in C^{m \times n}$，奇异值有$\sigma_1 \geqslant \sigma_2 \geqslant … \geqslant \sigma_r &gt; 0$，则存在<strong>酉矩阵</strong>$U \in C^{m \times m}, ; V \in C^{n \times n}$，分块矩阵$\Sigma &#x3D; \begin{bmatrix}\Delta &amp; 0\ 0 &amp; 0\end{bmatrix}$，有$A &#x3D; U \Sigma V^H$，其中$\Delta &#x3D; \begin{bmatrix}\sigma_1 &amp; &amp; &amp; \ &amp; \sigma_2 &amp; &amp; \ &amp; &amp; … &amp; \ &amp; &amp; &amp; \sigma_r\end{bmatrix}$。</p>
</blockquote>
<p><em>求解</em>：第一步和第三步要求非零特征值，而第二步无此要求</p>
<ul>
<li><p>由特征多项式$|\lambda I - A^HA| &#x3D; 0$求得特征值$\lambda_1 \geqslant \lambda_2 \geqslant .. \geqslant \lambda_n$，（<strong>务必按照从大到小排列</strong>）（<strong>奇异值矩阵中某奇异值个数等于特征值重数</strong>），以及每个特征值对应的特征向量$\alpha_1, \alpha_2, …, \alpha_n$；</p>
</li>
<li><p>对特征向量进行施密特正交化和单位化（一般只需要单位化），得到单位正交向量组$v_1, v_2, ..,v_n$，则$V&#x3D;(v_1, v_2, …,v_n)$；</p>
</li>
<li><p>对于非零特征值$\lambda_1, …, \lambda_r$对应奇异值$\sigma_1, … , \sigma_r$，于是有${\color{red} {u_i &#x3D; \frac{1}{\sigma_i}Av_i}}$，这样得到了$r$个列向量，剩余的设为$\beta$，通过正交的特性$u_i^T \beta &#x3D; 0$即可求得；（U的列向量也需要标准化）</p>
</li>
<li><p>于是得到$A&#x3D;U \Sigma V^H$</p>
</li>
</ul>
<blockquote>
<p>📌奇异值性质：<br>&amp;#x20;(1) 求逆与共轭转置的可交换性： $(AA^{-1})^H&#x3D;(A^{-1})^HA^H&#x3D;I因此(A^{-1})^H&#x3D;(A^H)^{-1}$&amp;#x20;<br>(2) $rank(A)&#x3D;rank(A^HA)&#x3D;rank(AA^H)$&amp;#x20;<br>(3) $AA^H$与$A^HA$的非零特征值相等&amp;#x20;<br>(4) $AA^H$与$A^HA$都是半正定矩阵，$A\in C^{m\times n}$，当$rank(A)&#x3D;m或n$时，二者分别正定&amp;#x20;<br>(5) $A$与$A^{-1}$的特征值互为倒数<br>&amp;#x20;$Ax&#x3D;\lambda x\A^{-1}Ax&#x3D;\lambda A^{-1}x\\frac 1\lambda x&#x3D;A^{-1}x$</p>
</blockquote>
<hr>
<p>（10）<strong>极分解（不考）</strong></p>
<blockquote>
<p>定义：对于$rank(A)&#x3D;r$的矩阵$A \in C^{n \times n}$，可以被分解为$A&#x3D;PQ$，其中$P$为半正定矩阵，$Q$为酉矩阵。</p>
</blockquote>
<p><em>求法：</em></p>
<ul>
<li><p>对$A$进行奇异值分解，得到$A&#x3D;U \Sigma V^H$;</p>
</li>
<li><p>可以得到$A &#x3D; (U \Sigma U^H)(UV^H)$，于是$P&#x3D;U \Sigma U^H, ; Q&#x3D;UV^H$，$A&#x3D;PQ$。</p>
</li>
</ul>
<hr>
<h1 id="4-矩阵广义逆"><a href="#4-矩阵广义逆" class="headerlink" title="4 矩阵广义逆"></a>4 矩阵广义逆</h1><hr>
<p>（1）设$A \in C^{m \times n}, B \in C^{n \times m}$，若有$BA&#x3D;I_n$，则称$B$是$A$的一个<strong>左逆</strong>。</p>
<blockquote>
<p>📌等价条件：<br>- $A$的零空间$N(A)&#x3D;{0}$<br>- $m \geqslant n, ; rank(A)&#x3D; n$，即$A$是<strong>列满秩的</strong><br>- $A^H A$可逆</p>
</blockquote>
<hr>
<p>（2）设$A \in C^{m \times n}, B \in C^{n \times m}$，若有$AC &#x3D; I_m$，则称$C$是$A$的一个<strong>右逆</strong>。</p>
<blockquote>
<p>📌等价条件：<br>- $A$的列空间$R(A)&#x3D;C^m$<br>- $m \leqslant n, ; rank(A)&#x3D;m$，即$A$是<strong>行满秩的</strong><br>- $AA^H$可逆</p>
</blockquote>
<hr>
<p>（3）对于$A \in C^{m \times n}, ; G \in C^{n \times m}$，有$AGA&#x3D;A$，称$G$是$A$的一个<strong>减号广义逆</strong>。</p>
<p><em>求法：</em></p>
<ul>
<li><p>对$rank(A)&#x3D;r$的矩阵$A$，有矩阵$\begin{bmatrix}A &amp; I_m\ I_n &amp; 0 \end{bmatrix}$进行<strong>初等变换，对</strong>$A$<strong>行变换时</strong>$I_m$<strong>保持同步，对</strong>$A$<strong>列变换时，</strong>$I_n$<strong>保持同步，将</strong>$A$<strong>化为最简形</strong>，得到$\begin{bmatrix} I_r&amp; 0 &amp; P \ 0 &amp; 0 &amp; \ \ Q &amp; &amp; 0 &amp; \end{bmatrix}$；</p>
</li>
<li><p>有$G &#x3D; Q\begin{bmatrix}I_r &amp; U\ V &amp; W\end{bmatrix}P$，其中$U,V,W$是满足固定阶次的任意矩阵。</p>
</li>
</ul>
<hr>
<p>（4）<strong>加号广义逆（M-P逆）</strong></p>
<blockquote>
<p><strong>定义</strong>：对于矩阵$A \in C^{m \times n}, ; G \in C^{n \times m}$，满足4条<br>- $AGA&#x3D;A$<br>- $GAG&#x3D;G$<br>- $(AG)^H &#x3D; AG$<br>- $(GA)^H&#x3D;GA$&amp;#x20;<br>称$G$为$A$的M-P逆。</p>
</blockquote>
<p><em>求法：</em></p>
<ul>
<li>方法一：</li>
</ul>
<ol>
<li><p>对矩阵$A$进行<strong>满秩分解</strong>，得到$A&#x3D;BC$;</p>
</li>
<li><p>则$\color{red}{A^+ &#x3D; C^H(CC^H)^{-1}(B^HB)^{-1}B^H}$，也就是等于<code>C的右逆 x B的左逆</code>。</p>
</li>
</ol>
<ul>
<li>方法二：</li>
</ul>
<ol>
<li><p>对矩阵$A$进行<strong>奇异值分解</strong>，得到$A &#x3D; U \begin{bmatrix}\Delta &amp;0 \ 0 &amp; 0\end{bmatrix}V^H$；</p>
</li>
<li><p>则$\color{red}{A^+ &#x3D; V \begin{bmatrix}\Delta^{-1} &amp; 0\ 0 &amp; 0\end{bmatrix}U^H}$。</p>
</li>
</ol>
<blockquote>
<p>📌性质<br>- $rank(A) &#x3D; rank(A^+)$<br>- $rank(A^+A) &#x3D; rank(AA^+)&#x3D;rank(A)$</p>
</blockquote>
<hr>
<p>（5）<strong>投影变换</strong></p>
<blockquote>
<p><strong>定义</strong>：$C^n &#x3D; L \oplus M, \quad x&#x3D;y+z, \quad y \in L, z \in M$，投影变换$\sigma$就是把$C^n$映射成子空间$L$，称$\sigma$是从$C^n$沿子空间$M$到子空间$L$的投影变换，在一组基下对应的矩阵称为<strong>投影矩阵</strong>，子空间$L$称为<strong>投影子空间</strong>。显然有，子空间$L$就是$\sigma$的像空间$R(\sigma)$，$M$就是$\sigma$的核空间$N(\sigma)$，于是$C^n &#x3D; R(\sigma) \oplus N(\sigma)$。</p>
</blockquote>
<blockquote>
<p>📌$\sigma$是投影变换的充要条件是$\sigma$关于某组基下的矩阵$A$是<strong>幂等矩阵</strong>，即$A^2&#x3D;A$。</p>
</blockquote>
<p><em>求法：</em></p>
<ul>
<li><p>找出像空间$L$的一组基$y_1,y_2,…,y_r$，得到矩阵$B &#x3D; (y_1 ; y_2 ; … ; y_r)$；找出$M$的一组基$z_{r+1}, …., z_n$，得到矩阵$C&#x3D;(z_{r+1} ; … ; z_n)$；</p>
</li>
<li><p>于是有投影矩阵$\color{red}{A &#x3D; (B | 0)(B|C)^{-1}}$。</p>
</li>
</ul>
<hr>
<p>（6）<strong>正交投影变换</strong></p>
<blockquote>
<p><strong>定义</strong>：若$C^n &#x3D; R(\sigma) \oplus N(\sigma)$，$R(\sigma)$的<strong>正交补空间</strong>是$R(\sigma)^{\perp} &#x3D; N(\sigma)$，称$\sigma$是<strong>正交投影变换</strong>，其在<strong>标准正交基</strong>下对应的矩阵称为正交投影矩阵。</p>
</blockquote>
<blockquote>
<p>正交投影变换：$\color{red}P(X)&#x3D;X-(X,u)u$，$u$便是零空间的基。</p>
</blockquote>
<blockquote>
<p>📌$\sigma$是正交投影变换的充要条件是$A$是<strong>幂等Hermite矩阵</strong>，即$A^2&#x3D;A, ;A^H&#x3D;A$。</p>
</blockquote>
<p><em>求法：</em></p>
<p>$A &#x3D; (B | 0)(B|C)^{-1} &#x3D; (B|0)((B|C)^H(B|C))^{-1}(B|C)^H &#x3D; {\color{red} {B(B^HB)^{-1}B^H}}$</p>
<hr>
<p>（7）<strong>最佳最小二乘解</strong></p>
<p>$A \in C^{m \times n}, ; b \in C^m$，则${\color{red} {x_0&#x3D;A^+b}}$是线性方程组$Ax&#x3D;b$的最佳最小二乘解。</p>
<p>$A \in C^{m \times n}, ; B \in C^{m \times k}$，则${\color{red}{X_0 &#x3D; A^+B}}$是$AX&#x3D;B$的最佳最小二乘解。</p>
<hr>
<h1 id="5-矩阵分析"><a href="#5-矩阵分析" class="headerlink" title="5 矩阵分析"></a>5 矩阵分析</h1><hr>
<p>（1）<strong>向量范数</strong>满足<strong>正定性、齐次性和三角不等式</strong>，定义了范数的内积空间称为<strong>赋范空间</strong>。</p>
<hr>
<p>（2）重要的<strong>向量范数</strong>：</p>
<p>对于复向量$x &#x3D; (x_1 ;; x_2 ;; … ;; x_n)$，有：</p>
<ul>
<li><p><strong>2-范数****：</strong> ​${\color{red}{|x|| &#x3D; \sqrt{|x_1|^2 + |x_2|^2 + … + |x_n|^2}}}$</p>
</li>
<li><p><strong>1-范数****：</strong> ​${\color{red}{||x||_1 &#x3D; |x_1| + |x_2| + … + |x_n|}}$</p>
</li>
<li><p><strong>∞范数****：</strong> ​${\color{red}{||x||_{\infty} &#x3D; \underset{i}{\max} |x_i|}}$</p>
</li>
</ul>
<blockquote>
<p>📌有限维线性空间的任意两种向量范数都是<strong>等价</strong>的。</p>
</blockquote>
<hr>
<p>（3）<strong>矩阵范数</strong>满足<strong>正定性、齐次性、三角不等式以及相容性</strong>。</p>
<hr>
<p>（4）重要的<strong>矩阵范数</strong>和<strong>诱导范数</strong></p>
<ul>
<li><p><strong>F范数</strong>：${\color{red}{||A||_F &#x3D; [tr(A^HA)]^{\frac{1}{2}}}}$</p>
</li>
<li><p><strong>列和范数</strong>： ${\color{red}{||A||<em>1 &#x3D; \underset{j}{\max}(\sum</em>{i&#x3D;1}^n |a_{ij}|)}}$，即<strong>每一列各元素模相加其中的最大值</strong></p>
</li>
<li><p><strong>谱范数</strong>：${\color{red}{||A||_2 &#x3D; \sqrt{\lambda_1}}}$，其中$\lambda_1$是$A^HA$的<strong>最大特征值</strong></p>
</li>
<li><p><strong>行和范数</strong>：${\color{red}{||A||<em>{\infty} &#x3D; \underset{i}{\max}(\sum</em>{j&#x3D;1}^n |a_{ij}|)}}$，即<strong>每一行各元素模相加其中的最大值</strong></p>
</li>
</ul>
<hr>
<p>（5）<strong>向量收敛和矩阵收敛</strong>必须其中的每一个元素都收敛。</p>
<blockquote>
<p>📌向量按分量收敛的充要条件是<strong>它按任意一个向量范数收敛</strong>。</p>
</blockquote>
<blockquote>
<p>📌当$k \rightarrow \infty$时，$||A^{(k)}-A|| \rightarrow 0$，称<strong>矩阵序列按矩阵范数收敛于</strong>$A$</p>
</blockquote>
<hr>
<p>（6）<strong>谱半径</strong></p>
<blockquote>
<p><strong>定义</strong>：$\lambda_1, \lambda_2, …, \lambda_n$是矩阵$A \in C^{n \times n}$的全部特征值，称${\color{red}{\rho(A)&#x3D;\underset{i}{\max}|\lambda_i|}}$为$A$的<strong>谱半径</strong>。</p>
</blockquote>
<blockquote>
<p>📌$A^k \rightarrow 0(k \rightarrow \infty)$的充要条件是$\rho(A) &lt; 1$</p>
</blockquote>
<blockquote>
<p>📌$A$的谱半径是$A$的任意一种矩阵范数的下确界。</p>
</blockquote>
<hr>
<p>（7）<strong>矩阵幂级数</strong></p>
<p>若复变量$z$的幂级数$\sum_{k&#x3D;0}^{\infty}a_kz^k$的<strong>收敛半径为</strong>$R$，而方阵$A \in C^{n \times n}$的<strong>谱半径为</strong>$\rho(A)$，则</p>
<ul>
<li><p>当${\color{red} {\rho(A) &lt; R}}$时，矩阵幂级数$\sum_{k&#x3D;0}^{\infty}a_kA^k$<strong>收敛</strong>；</p>
</li>
<li><p>当${\color{red} {\rho(A) &gt; R}}$时，矩阵幂级数$\sum_{k&#x3D;0}^{\infty}a_k A^k$<strong>发散</strong></p>
</li>
</ul>
<blockquote>
<p>📌当求解$A$的特征值比较困难时，由于$A$的每个范数都是谱半径$\rho(A)$的上界，只需要找到一种特殊的矩阵范数$||A||$，使得$||A|| &lt; R$，就能说明矩阵幂级数收敛。（优先考虑行和、列和范数）</p>
</blockquote>
<hr>
<p>（8）<strong>常用的幂级数</strong></p>
<ul>
<li><strong>收敛域是整个复平面的幂级数</strong></li>
</ul>
<p>$e^A &#x3D; \sum_{k&#x3D;0}^{\infty} \frac{1}{k!}A^k$</p>
<p>$\cos A &#x3D; \sum_{k&#x3D;0}^{\infty}\frac{(-1)^k}{(2k)!}A^{2k}$</p>
<p>$\sin A &#x3D; \sum_{k&#x3D;0}^{\infty}\frac{(-1)^k}{(2k+1)!}A^{2k+1}$</p>
<ul>
<li><strong>收敛域为复平面</strong>$|z| &lt; 1$<strong>的幂级数</strong></li>
</ul>
<p>$(I-A)^{-1} &#x3D; \sum_{k&#x3D;0}^{\infty}A^k, \quad \rho(A) &lt; 1$</p>
<p>$\ln(I+A) &#x3D; \sum_{k&#x3D;1}^{\infty}\frac{(-1)^{k-1}}{k}A^k, \quad \rho(A) &lt; 1$</p>
<hr>
<p>（9）<strong>矩阵函数的两种求法</strong></p>
<ul>
<li><em><strong>方法一：Jordan标准形法</strong></em></li>
</ul>
<ol>
<li><p>求矩阵$A$的Jordan标准形$J_A$，得到${\color{red} {A &#x3D; PJ_AP^{-1}}}$</p>
</li>
<li><p>设解析函数为$f(z)$，则对每一个Jordan块有$f(J_i)&#x3D; \begin{bmatrix}f(\lambda_i) &amp; \frac{f’(\lambda_i)}{1!} &amp; \frac{f’’(\lambda_i)}{2!} &amp; … \ &amp; f(\lambda_i) &amp; \frac{f’(\lambda_i)}{1!} &amp; …\ &amp; &amp; … &amp; \ &amp; &amp; &amp; f(\lambda_i)\end{bmatrix}$，得到$f(J_A)$</p>
</li>
<li><p>最后得到$f(A) &#x3D; Pf(J_A)P^{-1}$</p>
</li>
</ol>
<blockquote>
<p>📌这种方法的难点在于<strong>需要求Jordan链</strong>，过程中可以会遇到麻烦。<strong>如果不同特征值个数较多，建议使用第一种；而如果特征值比较单一，并且 代数重数 - 几何重数 &gt; 2，建议使用第二种</strong></p>
</blockquote>
<ul>
<li><em><strong>方法二：最小多项式法</strong></em></li>
</ul>
<ol>
<li><p>先计算$A$的Jordan标准形，由此得到最小多项式$m_A(\lambda)&#x3D;(\lambda -\lambda_1)^{n_1}(\lambda-\lambda_2)^{n_2}…(\lambda-\lambda_s)^{n_s}$，其中幂次和有$\sum_{i&#x3D;1}^s n_i &#x3D;m$；</p>
</li>
<li><p>得到$g(\lambda)&#x3D;c_0+c_1\lambda+…+c_{m-1}\lambda^{m-1}$，并令$g^{(j)}(\lambda_i)&#x3D;f^{(j)}(\lambda_i)$，解得系数$c_0,c_1,…,c_{m-1}$；</p>
</li>
<li><p>最后得到$f(A) &#x3D; c_0I + c_1A+…+c_{m-1}A^{m-1}$</p>
</li>
</ol>
<blockquote>
<p>📌当<strong>不同特征值的个数比较多或者最小多项式幂次较高</strong>时，计算起来比较复杂，建议使用第一种。</p>
</blockquote>
<hr>
<p>（10）两个知识点：</p>
<ul>
<li><p>重要的<strong>导数：</strong>$\color{red}{\frac{d A^{-1}(t)}{dt} &#x3D; - A^{-1}(t) \big( \frac{d}{dt}A(t)\big)A^{-1}(t)}$</p>
</li>
<li><p>矩阵指数函数的<strong>行列式：</strong>$|e^A| &#x3D; e^{trA}$</p>
</li>
</ul>
<blockquote>
<p>📌上式证明：矩阵函数的特征值是让原矩阵的特征值做函数参数的结果，即 $A$的特征值是$\lambda$，则$f(A)$的特征值是$f(\lambda)$ 由于A相似于Jordan标准型，所以$|e^{A}|&#x3D;|P||e^{J_A}||P^{-1}|$，由于行列式等于特征值之积， 所以$|e^A|&#x3D;|e^{J_A}|&#x3D;e^{\lambda_1}e^{\lambda_2}…&#x3D;e^{\lambda_1+\lambda_2+…}&#x3D;e^{trA}$</p>
</blockquote>
<hr>
<p>（11）矩阵函数应用</p>
<blockquote>
<p><strong>一阶常系数齐次微分方程组</strong>： $\begin{cases}\dot{x}(t) &#x3D; Ax(t)\x(t_0) &#x3D; C_{n \times 1}\end{cases}$</p>
</blockquote>
<p>解为：${\color{red}{x(t) &#x3D; e^{A(t-t_0)}x(t_0)}}$</p>
<blockquote>
<p><strong>一阶线性常系数非齐次线性方程组</strong>：$\begin{cases}\dot{x}(t) &#x3D; Ax(t) + f(t)\x(t_0) &#x3D; C\end{cases}$</p>
</blockquote>
<p>解为：${\color{red} {x(t) &#x3D; e^{A(t-t_0)}x(t_0) + \int_{t_0}^t e^{A(t-\tau)}f(\tau)d \tau}}$</p>
<hr>
<h1 id="6-Kronecker积"><a href="#6-Kronecker积" class="headerlink" title="6 Kronecker积"></a>6 Kronecker积</h1><hr>
<p>（1）对于矩阵$A&#x3D;(a_{ij}) \in C^{m \times n}, ;B&#x3D;(b_{ij}) \in C^{s \times t}$，则<strong>K积</strong>为：</p>
<p>$$<br>A \otimes B &#x3D; \begin{bmatrix}a_{11}B &amp; a_{12}B &amp; … &amp; a_{1n}B\ a_{21}B &amp; a_{22}B &amp; … &amp; a_{2n}B\ … &amp; … &amp;  &amp; …\ a_{n1}B &amp; a_{n2}B &amp; … &amp; a_{nn}B\end{bmatrix}<br>$$</p>
<blockquote>
<p>📌K积不具有交换律，即$A \otimes B \neq B \otimes A$</p>
</blockquote>
<hr>
<p>（2）重要性质</p>
<ul>
<li><p>$I \otimes I &#x3D; I$</p>
</li>
<li><p>$(A \otimes B)(C \otimes D) &#x3D; (AC) \otimes (BD)$</p>
</li>
<li><p>$(A \otimes B)^k &#x3D; A^k \otimes B^k$</p>
</li>
<li><p>$(A \otimes B) &#x3D; (I_m \otimes B)(A \otimes I_n)$</p>
</li>
<li><p>$(A \otimes B)^{-1} &#x3D; A^{-1} \otimes B^{-1}$</p>
</li>
<li><p>$|A \otimes B| &#x3D; |B \otimes A| &#x3D; |A|^n|B|^m$（<strong>这里的</strong><strong><strong><strong>表示</strong></strong>的阶数，</strong><strong><strong><strong>表示</strong></strong></strong><strong>的阶数</strong>）</p>
</li>
<li><p>$rank(A \otimes B) &#x3D; rank(A)rank(B)$</p>
</li>
<li><p>酉矩阵的K积也是酉矩阵</p>
</li>
<li><p>Hermite矩阵的K积也是Hermite矩阵</p>
</li>
</ul>
<hr>
<p>（3）<strong>K和</strong>：设$A \in F^{m \times m}, ;B \in F^{n \times n}$，$A \oplus B &#x3D; A \otimes I_n + I_m \otimes B$</p>
<hr>
<p>（4）若$A$的特征值是$\lambda_i$，相应的特征向量是$x_i$；$B$的特征值是$\mu_i$，相应的特征向量为$y_i$；则：</p>
<ul>
<li><p>$**A \otimes B$的特征值是$\color{red}{\lambda_i \mu_i}$，对应的特征向量是$\color{red}{x_i \otimes y_i}$**</p>
</li>
<li><p>$**A \oplus B$的特征值是$\color{red}{\lambda_i + \mu_i}$，对应的特征向量是$\color{red}{x_i \otimes y_i}$**</p>
</li>
</ul>
<blockquote>
<p>📌K积下的奇异值也和特征值有一样的结论</p>
</blockquote>
<hr>
<p>（5）设$f(z)$是解析函数，$A \in F^{n \times n}$，$f(A)$存在，则</p>
<ul>
<li><p>$f(I_m \otimes A) &#x3D; I_m \otimes f(A)$</p>
</li>
<li><p>$f(A \otimes I_m) &#x3D; f(A) \otimes I_m$</p>
</li>
</ul>
<hr>
<p>（6）设矩阵$A \in F^{m \times n}, \quad A&#x3D;(A_1, A_2,…,A_n)$，则$Vec(A) &#x3D; \begin{bmatrix}A_1\ A_2\ …\ A_n\end{bmatrix} \in F^{nm}$</p>
<blockquote>
<p>📌${\color{red}{Vec(ABC) &#x3D; (C^T \otimes A)Vec(B)}}$</p>
</blockquote>
<ul>
<li><p>$Vec(AX) &#x3D; (I_s \otimes A)Vec(X)$</p>
</li>
<li><p>$Vec(XC) &#x3D; (C^T \otimes I_k) Vec(X)$</p>
</li>
</ul>
<hr>
<p>（7）求解矩阵方程$AX+XB&#x3D;D$，将两边同时取<strong>向量化算子</strong>，得到${\color{red}{(I_m \otimes A + B^T \otimes I_n)Vec(X) &#x3D; Vec(D)}}$，最后通过常规的求非齐次线性方程组的方法求解。</p>
<hr>
<p>（8）求微分方程：$\begin{cases}\dot{X}(t) &#x3D; AX(t) + X(t)B\X(0) &#x3D; C\end{cases}$</p>
<ul>
<li><p>用向量化算子作用在方程两边，得到$Vec(\dot{X}(t)) &#x3D; (I_n \otimes A + B^T \otimes I_m)Vec(X(t))$和$Vec(X(0)) &#x3D; Vec(C)$</p>
</li>
<li><p>令$Y(t) &#x3D; Vec(X(t)), \quad C_1 &#x3D; Vec(C), \quad G &#x3D; I_n \otimes A + B^T \otimes I_m$，通过求解普通微分方程的方法得到$Y(t) &#x3D; e^{Gt}C_1$；</p>
</li>
<li><p>将$Y(t), ; G, ; C_1$带入化简求得$X(t)$。</p>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学方法</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式（C++）</title>
    <url>/2022/06/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><blockquote>
<p>参考资料：</p>
<p><a href="https://github.com/liu-jianhao/Cpp-Design-Patterns">https://github.com/liu-jianhao/Cpp-Design-Patterns</a></p>
<p><a href="http://service.qbjavawa.top/time/beautyOfDesignPatterns.html" title="极客时间《设计模式之美》">极客时间《设计模式之美》</a></p>
<p><a href="https://zhulao.gitee.io/blog/2019/03/31/23%E7%A7%8D%E7%BB%8F%E5%85%B8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E9%99%84c++%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81)/index.html">https://zhulao.gitee.io/blog/2019/03/31/23种经典设计模式(附c++实现代码)/index.html</a></p>
<p><a href="https://design-patterns.readthedocs.io/zh_CN/latest/index.html">https://design-patterns.readthedocs.io/zh_CN/latest/index.html</a></p>
</blockquote>
<p><strong>面向对象、设计原则、设计模式、编程规范、代码重构五者之间的关系：</strong></p>
<ul>
<li><p>面向对象：因其丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式等编码实现的基础。</p>
</li>
<li><p>设计原则：代码设计的经验总结，指导对于某些场景下，是否应该使用某种设计模式。（比如，“开闭原则”是如策略、模板等设计模式的指导原则）</p>
</li>
<li><p>设计模式：针对软件开发中遇到的设计问题，而总结出来的一套解决方案或者设计思路。主要目的是提高代码的可扩展性。</p>
</li>
<li><p>编程规范：<br>解决代码可读性问题。相比于设计原则、设计模式，更加具体、更偏重代码细节。</p>
</li>
<li><p>重构技巧：<br>是保持代码质量不下降的有效手段，利用的就是面向对象、设计原则、设计模式、编码规范这些理论。</p>
</li>
</ul>
<p><img src="/design_pattern-image/image_LDUVW8iNHp.png"></p>
<h1 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h1><blockquote>
<p>画图工具：draw.io</p>
</blockquote>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p>考虑给动物园建一个模。动物园里有很多动物，均可以属于动物类型，因此可以建立一个比较大的Animal类。每个该类的实例就是一个特定动物。可以通过属性以区分不同实例，因此加上name、id、age属性。属性名后面可以接上期望的基础类型，比如是整数，还是字符。同时加上方法来设置这些属性，或者描述实例的动作。比如添加<code>setName()</code>方法，（也可以给方法加上参数和返回类型<code>setName(var1, var2):string</code>）</p>
<p>UML类图中对可见性的表达与C++中一致：减号表示private，加号表示public，#表示protected。此外，还有一个波浪线~表示package&#x2F;default，其含义是可以被同一package内的任何类所访问。</p>
<p><img src="/design_pattern-image/image_CYbCbwv9cS.png"></p>
<ul>
<li><p>继承关系（Inheritance）：</p>
<p>现在Animal类中的方法和属性都是private的。动物也是有具体类型的，比如乌龟、水獭和懒猴。因此，再为这三个类型制定新的class，他们继承自Animal类，有动物的共有属性方法，又有自己的独特行为。同时，Animal类还需要是一个抽象类。抽象类可以用：加尖括号&lt;&lt;Animal&gt;&gt;或者斜体<em>Animal</em>来表示。<strong>继承用空心箭头来表示</strong>。</p>
<p><img src="/design_pattern-image/image_XUXXAJ9ezw.png"></p>
</li>
<li><p>关联关系（Association）：</p>
<p>比如水獭和海胆都属于动物，而水獭吃海胆，因此这两个类型之间出现了关联关系，关联行为就是eat。关联关系用一条普通直线就可以表示。</p>
<p><img src="/design_pattern-image/image_XWGnxcAC0A.png"></p>
<p>除了这样的普通直线表示，还可以用带箭头的直线来表示。</p>
<p><img src="/design_pattern-image/image_Ya565F9o_R.png"></p>
<p>比如图中表示，A知道B，但B不知道A。</p>
</li>
<li><p>聚合关系（Aggregation）：</p>
<p>聚合关系比较抽象，其描述整体与部分的关系。部分归属于整体，但二者并非强依赖，整体没了，部分依然可以在。</p>
<p>动物除却具体类型外，也可以按纲目划分。比如可以有一个水生动物类，而乌龟也可以属于水生动物。但是二者的关系并非那么强烈，即使水生动物类在代码中没有了，乌龟类依然可以存在。因此二者属于聚合关系，可用<strong>空心菱形直线</strong>表示。</p>
<p><img src="/design_pattern-image/image__mx-L3DfW4.png"></p>
</li>
<li><p>组合关系（Composition）：</p>
<p>&amp;#x20;组合关系不同于聚合，其描述了比较强的依赖关系。比如有一个类A和类B，前者与后者强关联，有前者就会有后者，而且类A没了，类B也不复存在。此为组合关系，组合关系使用<strong>实心菱形直线</strong>表示。而且可以用数字表示，在这样的依赖关系中，每个类可以有几个实例。</p>
<p>当是1对1的关系时，也可以注解当前为has a还是is a关系。</p>
<p>比如在动物园中，每个懒猴都需要制定窝，一个猴可以有一个窝也可以有多个窝，当猴子不在了，与其绑定的窝也就拆毁了。</p>
<p><img src="/design_pattern-image/image_EChel9f6VJ.png"></p>
</li>
</ul>
<p>因此，整体的类图如下所示：</p>
<p><img src="/design_pattern-image/class_test_y7PGig-rKD.png"></p>
<ul>
<li><p>依赖关系：</p>
<p>上面的例子中没有提到依赖关系。依赖关系用一套带箭头的虚线表示，用于描述一个对象在运行期间会用到另一个对象的关系。</p>
<p><img src="/design_pattern-image/image_KyqJhsbeTU.png"></p>
<p>如图表示A依赖于B。依赖有方向，而双向依赖是一种非常糟糕的结构，应总是保持单向依赖，杜绝双向依赖的产生。</p>
</li>
</ul>
<h2 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h2><p>用例图可以分为四个主体：Systems、Actors、Use Cases、Relationships</p>
<ul>
<li><p>Systems：系统就是正在开发的东西，可以是app，可以是软件组件、网站等等。用一个长方形表示。比如下面的例子中，要开发一个银行应用，那么就画一个长方形，命名为Banking app</p>
<p><img src="/design_pattern-image/image_JkMI5Bfiix.png"></p>
</li>
<li><p>Actors：用户就是使用系统来达成目标的人或物（比如一个组织、或外部设备）。</p>
<p>Actor在实际代码中要被视为类型。</p>
<p>在此例子中，可以分析出有两个Actor。首先是顾客，其下载App并进行现金存取。而另一个则是银行自己，银行向app提供信息，比如交易流水或账户余额。</p>
<blockquote>
<p>📌需要注意的是：<br>1. Actor永远是外部对象，也就是说要始终置于描述System的方框外。<br>2. Actor的定义不要太具体，比如不要把Bank这个Actor命名为建行。</p>
</blockquote>
<p>既然存在多个Actor，那么就引申出了Primary Actors和Secondary Actors的概念。前者主动启用系统，而后者则较为被动。在本例中，顾客为Primary Actor，他们会拿出手机，打开app再进行相关操作。而银行则是Secondary Actor，银行只会在顾客采取行动之后再行动。比如顾客在app上查询账户余额，此事银行才会参与系统提供信息。</p>
<p>Primary Actor放在System的左边，而Secondary Actor放在System的右边。</p>
<p><img src="/design_pattern-image/image_4PEEOGeed7.png"></p>
</li>
<li><p>Use Cases：</p>
<p>用例用于描述系统的若干功能，用椭圆表示。它们被放在System中，因为用例是系统内部的动作。本例中，银行app有这么几项功能：顾客登录、查账、转账、付款。</p>
<blockquote>
<p>📌不同于Actor，Use Case需要具体。比如转账写成了Transfer Funds，但如果仅写Transfer，就会让人摸不着头脑。</p>
</blockquote>
<p><img src="/design_pattern-image/image_NcXLfHbvGQ.png"></p>
</li>
<li><p>Relationships：</p>
<p>Relationship反映了actor与use case之间，以及use case与use case之间的关系、交流或互动。</p>
<ol>
<li><p>关联（Association）：用于描述Actor与Use Case之间的交互</p>
<p><img src="/design_pattern-image/image_pKnmoRy7CD.png"></p>
</li>
<li><p>包含（Include）与扩展（Extend）：</p>
<ul>
<li><p>包含：包含关系显示了基本用例和包含用例之间的<strong>依赖关系</strong>。</p>
<p>每次执行基本用例（Base Use Case）时，包含用例（Included Use Case）也会被执行。为了表示包含关系，需要由基本用例向包含用例拉一条&lt;&lt;include&gt;&gt;的线。</p>
<p><img src="/design_pattern-image/image__0BMljJHon.png"></p>
</li>
<li><p>扩展：基本用例和扩展用例之间没有太严格的依赖关系。只有在执行基本用例，满足某些条件时，扩展用例才会被执行。因此可以理解为，<strong>扩展用例用于扩展基本用例的行为</strong>。为了表示扩展关系，需要由扩展用例向基本用例拉一条&lt;&lt;extend&gt;&gt;的线。</p>
<p><img src="/design_pattern-image/image_0KgZ9eRCub.png"></p>
</li>
</ul>
<p>当顾客要登录app时，系统会验证顾客输入的密码，密码正确则登录成功，不正确则返回一条登录失败的信息。因此可以在系统中加上两个use case：验证密码、和打印登录错误信息。</p>
<p>每次执行Log in用例，都必须执行Verify Password用例，因此，二者间存在包含关系，前者包含后者。</p>
<p>而且，当执行Log in用例时，Display Login Error用例并不会总是执行，只有一种情况：密码错误时，才会得以执行。因此，二者间存在扩展关系。</p>
<p><img src="/design_pattern-image/image_vAbbVjx40d.png"></p>
<blockquote>
<p>📌多个基本用例可以同时与某一个用例，产生包含或扩展关系。</p>
</blockquote>
<p>当顾客要转账时，系统也需要首先查看账户是否有足够的余额。因此还需要添加验证余额是否充足的用例。同时，用户要付款时（make payment），也需要用到查询余额是否充足的用例。因此可以让这两个基本用例，同时指向一个包含用例。</p>
<p><img src="/design_pattern-image/image_ibUD6jaxfN.png"></p>
</li>
<li><p>泛化（Generalization）：</p>
<p>泛化，也可称为继承（inheritance），与面向对象中类的继承很相似。子用例（Specialized Use Cases）继承父用例（General Use Cases）的行为，但同时又可以添加自身的独特行为。从子用例向父用例拉一个下面这样的箭头表示继承关系。</p>
<p><img src="/design_pattern-image/image_0y67h-mcvx.png"></p>
<p>比如本例中，付款可以分为从支票账户付款，也可以从储蓄账户付款。二者属于付款的子用例。</p>
<p><img src="/design_pattern-image/image_f8r81cnzno.png"></p>
<p>除了对Use Case进行继承外，还可以让Actor之间有继承关系。比如顾客中可以分为老顾客和新顾客。而不管新老，它们都是顾客，但是可能具备独特的行为和属性，如果设计成类，可以有这样的继承关系：</p>
<p><img src="/design_pattern-image/image_ZR-aggSc9b.png"></p>
</li>
<li><p>带扩展点的用例（Use Cases with extension points）</p>
<p>一个带扩展点的用例如下图所示，上面是用例名，下面是扩展点。扩展点详细描述了扩展关系。</p>
<p><img src="/design_pattern-image/image_J6ROHGk-HQ.png"></p>
<p>比如用户可以在app中设置配置文件，因此可以有Set up Profile用例，而拓展点表示，当用户进入Set up Profile时，可以导航到几个不同的界面。如果顾客不知道该如何导航，可以访问配置文件帮助，如果顾客需要询问私人信息，可以去隐私信息界面去查看。扩展点指向对应的扩展用例。同时还可以设置<strong>注释</strong>，注明当满足什么条件时会引导到相应的扩展点。</p>
<p><img src="/design_pattern-image/image_UX7gfhHr6j.png"></p>
</li>
</ol>
</li>
</ul>
<p>最终就得到了这样一个银行app的用例图示例：</p>
<p><img src="/design_pattern-image/use_case_TSxykT_OIm.png"></p>
<h2 id="时序-x2F-序列图"><a href="#时序-x2F-序列图" class="headerlink" title="时序&#x2F;序列图"></a>时序&#x2F;序列图</h2><blockquote>
<p>时序图显示了代码中的类&#x2F;对象在其执行顺序过程中的相互作用，换言之，其显示了序列事件。</p>
</blockquote>
<p>下面以一个ATM机存取，导致的银行系统执行流程来理解时序图。</p>
<ul>
<li><p>objects（对象）&amp; actor（参与者）：</p>
<p>一个人去ATM机取钱，ATM机将于银行服务器通信，之后那个人的账户就会被存取。ATM机、银行服务器和银行账户，三者均属于银行系统。因此这三项可以算作objects。而那个人不属于银行系统，而且他来引发的事件，因此他是一名actor。</p>
<p>画图时actor放在系统左边，在其右陆续画对象，按照与actor的远近画（比如ATM机与人的关系最近，因此右边的第一个对象是ATM机）</p>
<p><img src="/design_pattern-image/image_trdsYDdxEi.png"></p>
</li>
<li><p>lifelines（生命线）</p>
<p>生命线是位于对象下方垂直的虚线，显示着一个对象或者参与者存在的时间。沿着生命线向下代表着时间的流逝。</p>
<p><img src="/design_pattern-image/image_W5xw_j8CIc.png"></p>
</li>
<li><p>messages（信息）</p>
<p>messages在对象之间传递，以表示相互作用时的动作或信息。各对象的message沿着生命线向下挪动，表示事件的前后发生关系。</p>
<p>考虑整个系统的执行顺序，actor来到ATM机前的第一件事就是插入银行卡；接着ATM机与银行服务器通信来核对此卡是否有效；银行服务器将查询并向ATM机返回核对结果。</p>
<p>插入卡片，通信要求核对，均属于信息，由实线箭头表示。而返回核对结果，则属于<strong>返回信息</strong>（return&#x2F;reply message），由虚线箭头表示。</p>
<blockquote>
<p>📌需注意，返回信息并没有明确的方向，可以从右指向左，也可以从左指向右，需要视具体情况而定。</p>
</blockquote>
<p><img src="/design_pattern-image/image_-cM53juFhs.png"></p>
<p>但是在返回信息的时候，问题出现了。有两种可能的回复信息，卡可用，或者不可用。那么如何在同一张图描述两种可能情况的发生呢，UML的解决方案是alternative frame。</p>
</li>
<li><p>Alternative Frame（选项）</p>
<p>当银行服务器反馈，此时卡有效时，ATM机就会要求actor输入卡密码；而当反馈卡无效时，就会将卡弹出。</p>
<p>由于要求输入密码这一事件，并不是在回应，因此不归属于返回信息，要用实线箭头画。Alternative frame中，左边写条件，并用虚线划分两个条件对应的行为。</p>
<p><img src="/design_pattern-image/image_LTFo_mo471.png"></p>
<p>剩下的操作就是顺理成章的银行取钱操作。卡有效后，用户会输入密码，银行服务器反馈密码是否正确。密码正确后，用户输入需要取钱的金额，银行服务器会向银行账户核实是否有足够多的钱。</p>
<p><img src="/design_pattern-image/image_kP5-Yda8Cq.png"></p>
</li>
<li><p>Activation Boxes（激活框）：</p>
<p>Activation boxes显示对象进程的开始时间和结束时间。通过激活框可以轻松看到对象何时处于活动状态，何时处于空闲状态。下面根据messages来给各个对象加上激活框。</p>
<p><img src="/design_pattern-image/sequence_test.drawio_PZeOtyidOi.png"></p>
<p>通过激活框可以看出，银行账户对象显然比另外两个对象更不活跃。</p>
<blockquote>
<p>📌激活框只能作用于objects，不能作用于actors。</p>
</blockquote>
</li>
</ul>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><ul>
<li><p>相比于面向过程，为什么项目开发使用面向对象？</p>
<p>古早的程序需求足够简单，整个程序的处理流程只有一条主线，很容易被划分成顺序执行的几个步骤，很适合面向过程风格。</p>
<p>但对于大规模复杂程序的开发来说，整个程序的处理流程错综复杂，画出来的话会是一个网状结构，再用面向过程来思考会比较吃力，此时面向对象的思维将更具优势。即，将需求翻译为类，并且在类之间建立交互关系。</p>
<p>除此之外，面向对象也强制程序员将代码的组织方式更清晰、更模块化。</p>
</li>
</ul>
<h2 id="四大特性"><a href="#四大特性" class="headerlink" title="四大特性"></a>四大特性</h2><blockquote>
<p>四大特性：封装、抽象、继承、多态。这四大特性使得程序相比于面向过程风格的代码，更加易扩展、易复用、易维护。</p>
</blockquote>
<ol>
<li><p>封装：信息隐藏&#x2F;数据访问保护，类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（比如方法）来访问内部信息或者数据。</p>
<p>如果对类中的属性不做限制，任何代码都能访问、修改的话，意味着不可控。即属性可能被随意地以各种方式修改，而且修改逻辑可能散落在代码中的各个角落，影响代码的可读性、可维护性。</p>
<p>另一方面，仅暴露必要的操作，也能提高类的易用性。调用者只需使用api就好，不必过于细致的了解业务逻辑，减少心智负担。而且用错的概率会减少。</p>
</li>
<li><p>抽象：抽象通常由接口、抽象类来实现。其隐藏方法的具体实现，让调用者只需关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。</p>
<p>通过抽象，一方面降低调用者的操作难度，另一方面可以保持兼容能力，即使具体类的具体实现更改了，也不会影响到上层代码。</p>
</li>
<li><p>继承：继承表示类之间的is-a关系，比如猫是一种哺乳动物。</p>
<p>继承的主要作用在于代码复用，可以避免代码重复写很多遍。但是继承层次过深也会导致代码可读性差、可维护性变差。</p>
</li>
<li><p>多态：子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。</p>
<p>多态代码的作用在于提高代码的可扩展性和复用性。比如一个<code>print(Animal var)</code>就可以打印所有类型动物的信息。多态是众多设计模式实现的基石。</p>
</li>
</ol>
<h2 id="基于接口而非实现编程"><a href="#基于接口而非实现编程" class="headerlink" title="基于接口而非实现编程"></a>基于接口而非实现编程</h2><blockquote>
<p>Program to an interface, not an implementation</p>
</blockquote>
<p>从本质上来看，“接口”就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”。这条原则希望，实际代码中，上层代码多用抽象出来的接口，而非具体实现了功能的类。这样可以带来好处：</p>
<ul>
<li><p><strong>接口与实现相分离</strong>。封装不稳定的实现，暴露稳定的接口。这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此降低耦合性，提高扩展性。</p>
<p><strong>好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对</strong>。</p>
</li>
</ul>
<h2 id="多用组合少用继承"><a href="#多用组合少用继承" class="headerlink" title="多用组合少用继承"></a>多用组合少用继承</h2><p>继承的弊端不仅局限于简单继承的层次过深问题。考虑“鸟”这个类：</p>
<ol>
<li><p>方法选择受限：</p>
<p>大部分鸟都会飞，那么可不可以在AbstractBird抽象类中，定义一个fly方法呢？</p>
<ul>
<li><p>如果定义了，依然有一些鸟是不会飞的，比如鸵鸟，但是鸵鸟类中却仍然有fly方法，即使将鸵鸟类中的fly内部写抛出异常的代码，也不会强制程序员在写代码时避免让 鸵鸟等鸟类fly，在后续扩展中难免有漏网之鱼，导致错误。</p>
</li>
<li><p>如果不定义，那么当会飞的鸟类想fly时，就要多写很多实现他们fly方法的代码，有悖于“继承提高代码复用”的目的。</p>
</li>
</ul>
</li>
<li><p>派生关系复杂：</p>
<p>那么是否可以给AbstractBird派生两个类，一个会飞鸟类，一个不会飞鸟类，再在会飞类里派生具体的鸟类，不会飞鸟类里派生鸵鸟类。</p>
<p>表面上这样可以解决问题，但是在后面的扩展中，这样的设计可能会带来更为严重的问题。比如此时需求变更，还想加上Tweet方法，即让鸟儿叫出来。沿袭刚才的思路，AbstractBird派生出来了四个类：会飞会叫、会飞不会叫、不会飞会叫、不会飞不会叫。两个功能衍生出了四种组合。也就是n个功能会有$2^n$种组合，呈指数形式变化。</p>
<p>那么后面还要加下蛋（判断是否会下蛋）等功能，将会组合爆炸。这样继承的关系越来越复杂，可读性极差，而且极难维护。</p>
</li>
</ol>
<blockquote>
<p>📌继承主要有三个作用：表示is-a关系，支持多态特性，代码复用。而这三个作用都可以通过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题。</p>
</blockquote>
<ul>
<li><p>组合、接口、委托的实现方案：</p>
<p>针对不同需求，定义不同的接口，之后每个鸟类将这些接口组合在一起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Tweetable</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">tweet</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EggLayable</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">layEgg</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ostrich</span> <span class="keyword">implements</span> <span class="title class_">Tweetable</span>, EggLayable &#123;<span class="comment">//鸵鸟</span></span><br><span class="line">  <span class="comment">//... 省略其他属性和方法...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tweet</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">layEgg</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sparrow</span> impelents Flayable, Tweetable, EggLayable &#123;<span class="comment">//麻雀</span></span><br><span class="line">  <span class="comment">//... 省略其他属性和方法...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tweet</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">layEgg</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口只声明方法，不定义实现。也就是说，每个会下蛋的鸟都要实现一遍layEgg()方法，并且实现逻辑是一样的，这就会导致代码重复的问题。可以通过组合+委托的方式来消除代码重复。针对三个接口再定义三个实现类，它们分别是：实现了fly()方法的FlyAbility类、实现了tweet()方法的TweetAbility类、实现了layEgg()方法的EggLayAbility类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlyAbility</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//省略Tweetable/TweetAbility/EggLayable/EggLayAbility</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ostrich</span> <span class="keyword">implements</span> <span class="title class_">Tweetable</span>, EggLayable &#123;<span class="comment">//鸵鸟</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">TweetAbility</span> <span class="variable">tweetAbility</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TweetAbility</span>(); <span class="comment">//组合</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">EggLayAbility</span> <span class="variable">eggLayAbility</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EggLayAbility</span>(); <span class="comment">//组合</span></span><br><span class="line">  <span class="comment">//... 省略其他属性和方法...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tweet</span><span class="params">()</span> &#123;</span><br><span class="line">    tweetAbility.tweet(); <span class="comment">// 委托</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">layEgg</span><span class="params">()</span> &#123;</span><br><span class="line">    eggLayAbility.layEgg(); <span class="comment">// 委托</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是组合+接口+委托，达成了代码重复少、也不必再有复杂继承关系的目的。</p>
</li>
</ul>
<h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><blockquote>
<p>SOLID原则：由5个设计原则组成，分别是，单一职责原则、开闭原则、里氏替换原则、接口隔离原则和依赖反转原则，对应S、O、L、I、D 5个英文字母</p>
</blockquote>
<h2 id="单一职责原则（Single-Responsibility-Principle-SRP）"><a href="#单一职责原则（Single-Responsibility-Principle-SRP）" class="headerlink" title="单一职责原则（Single Responsibility Principle, SRP）"></a>单一职责原则（Single Responsibility Principle, SRP）</h2><blockquote>
<p>一个类&#x2F;模块只负责完成一个职责（或者功能）</p>
</blockquote>
<p>一个类只负责完成一个职责或者功能。也就是说，不要设计大而全的类，要设计粒度小、功能单一的类。换个角度就是，一个类包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一，应该将它拆分成多个功能更加单一、粒度更细的类。</p>
<p>&amp;#x20;以下几点可以辅助判断类的职责是否足够单一：</p>
<ul>
<li><p>类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分；</p>
</li>
<li><p>类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分；</p>
</li>
<li><p>私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为public方法，供更多的类使用，从而提高代码的复用性；</p>
</li>
<li><p>比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的Manager、Context之类的词语来命名，这就说明类的职责定义得可能不够清晰；</p>
</li>
<li><p>类中大量的方法都是集中操作类中的某几个属性，比如，在UserInfo例子中，如果一半的方法都是在操作address信息，那就可以考虑将这几个属性和对应的方法拆分出来。</p>
</li>
</ul>
<h2 id="开闭原则：对扩展开放、修改关闭（Open-Closed-Principle）"><a href="#开闭原则：对扩展开放、修改关闭（Open-Closed-Principle）" class="headerlink" title="开闭原则：对扩展开放、修改关闭（Open Closed Principle）"></a>开闭原则：对扩展开放、修改关闭（Open Closed Principle）</h2><p>添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。</p>
<p>体现在C++代码的话，用父类指针去指向子类，体现了这样的开闭原则：</p>
<p>比如定义一个Calculator抽象类，通过子类继承的方式扩展出加减乘除的功能：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算器类  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//抽象接口类，子类实现</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">getompute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">getParam</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//除</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Division</span> : <span class="keyword">public</span> Calculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">getompute</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mA / mB;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">getParam</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    mA = a;</span><br><span class="line">    mB = b;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">double</span> mA;</span><br><span class="line">  <span class="type">double</span> mB;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//乘</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Multiplication</span> : <span class="keyword">public</span> Calculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">getompute</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mA * mB;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">getParam</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    mA = a;</span><br><span class="line">    mB = b;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">double</span> mA;</span><br><span class="line">  <span class="type">double</span> mB;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//减</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subtraction</span> : <span class="keyword">public</span> Calculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">getompute</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mA - mB;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">getParam</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    mA = a;</span><br><span class="line">    mB = b;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">double</span> mA;</span><br><span class="line">  <span class="type">double</span> mB;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//加</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Addition</span> : <span class="keyword">public</span> Calculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">getompute</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mA + mB;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">getParam</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    mA = a;</span><br><span class="line">    mB = b;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">double</span> mA;</span><br><span class="line">  <span class="type">double</span> mB;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Calculator* Add = <span class="keyword">new</span> Addition;</span><br><span class="line">  Add-&gt;<span class="built_in">getParam</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">  <span class="type">double</span> c = Add-&gt;<span class="built_in">getompute</span>();</span><br><span class="line">  cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么此时，还想添加一个求根的功能，就只需再添加一个求根运算的子类即可。</p>
<h2 id="里式替换原则（Liskov-Substitution-Principle）"><a href="#里式替换原则（Liskov-Substitution-Principle）" class="headerlink" title="里式替换原则（Liskov Substitution Principle）"></a>里式替换原则（Liskov Substitution Principle）</h2><p>子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。也就是子类对象替换了父类对象的内在实现，但是对外的接口保持与父类对象一致。</p>
<p>明显违背LSP的代码：</p>
<ul>
<li><p>子类违背父类声明要实现的功能</p>
<p>比如父类中提供的sortByAmount()函数，是按照类中的金额属性进行从小到大的排序，而子类重写此函数时，是按照日期属性进行排序的。那么子类的设计就违背了里式替换原则。</p>
</li>
<li><p>子类违背父类对输入、输出、异常的约定</p>
<p>比如父类中的某个函数约定了：</p>
<ol>
<li><p>运行出错时返回null；获取数据为空时返回空集合。而子类重载函数之后，实现变了，运行出错返回异常，获取不到数据返回null；</p>
</li>
<li><p>输入数据可以是任意整数，但子类实现的时候，只允许输入数据是正整数，负数就抛出；</p>
</li>
<li><p>约定只会抛出A异常，子类实现时却只允许抛出B异常</p>
</li>
</ol>
<p>这些都导致子类违背里式替换原则。</p>
</li>
<li><p>子类违背父类注释中所罗列的任何特殊说明</p>
</li>
</ul>
<blockquote>
<p>📌理解LSP，最核心就是理解“按照协议设计”，即父类定义了函数的“协议”，那么子类可以改变函数的内部实现逻辑，但不能改变函数原有的“协议”。</p>
</blockquote>
<h2 id="接口隔离原则（Interface-Segregation-Principle）"><a href="#接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="接口隔离原则（Interface Segregation Principle）"></a>接口隔离原则（Interface Segregation Principle）</h2><p>接口的调用者&#x2F;使用者，不应该被强迫去依赖它不需要的接口。</p>
<p>这里的接口Interface不局限于编程语言里的类似于抽象类的接口，而是可理解为：</p>
<ol>
<li><p>一组API接口集合</p>
<p>如果部分接口只被部分调用者使用，就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。</p>
</li>
<li><p>单个API接口或函数</p>
<p>部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。</p>
</li>
<li><p>OOP中的接口概念</p>
<p>接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。</p>
</li>
</ol>
<blockquote>
<p>📌单一职责原则针对的是模块、类、接口的设计。接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面也是为单一职责的判定提供了一种新思路。<br>可以通过调用者如何使用接口来间接判定设计是否够职责单一。</p>
</blockquote>
<h2 id="依赖反转原则（Dependency-Inversoin-Principle）"><a href="#依赖反转原则（Dependency-Inversoin-Principle）" class="headerlink" title="依赖反转原则（Dependency Inversoin Principle）"></a>依赖反转原则（Dependency Inversoin Principle）</h2><p><a href="https://www.cnblogs.com/yyxt/p/5141577.html">https://www.cnblogs.com/yyxt/p/5141577.html</a></p>
<h3 id="依赖反转"><a href="#依赖反转" class="headerlink" title="依赖反转"></a>依赖反转</h3><p>应用程序依赖于类库，那么一旦类库发生变化，应用程序也要相应改变。为了破除这种依赖关系，可以使用依赖反转。</p>
<p>在类库中抽象出一个接口，具体的实现类派生自接口，应用程序也调用接口，这样做：</p>
<ol>
<li><p>应用程序调用类库的抽象接口，依赖于类库的抽象接口；具体的实现类派生自类库的抽象接口，也依赖于类库的抽象接口。</p>
</li>
<li><p>应用程序和具体的类库实现完全独立，相互之间没有直接的依赖关系，只要保持接口类的稳定，应用程序和类库的具体实现都可以独立地发生变化。</p>
</li>
<li><p>类库完全可以独立重用，应用程序可以和任何一个实现了相同抽象接口的类库协同工作。</p>
</li>
</ol>
<p><img src="/design_pattern-image/image_ETQzqXUn8L.png"></p>
<h3 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h3><p>框架系统与类库：</p>
<ul>
<li><p>框架是一个“半成品”的应用程序，而类库只包含一系列可被应用程序调用的类。</p>
</li>
<li><p>类库给用户提供了一系列可复用的类，用户使用时，可以创建这些类的实例，或者从这些类中继承出新的派生类，然后调用类中相应的功能。在这过程中，类库总是被动地响应用户的调用请求。</p>
</li>
<li><p>框架则会为某一特定目的实现一个基本的、可执行的架构。框架中已经包含了应用程序从启动到运行的主要流程，流程中那些无法预先确定的步骤留给用户来实现。程序运行时框架系统会自动调用用户实现的功能组件。这个过程中，框架的行为是主动的。</p>
</li>
</ul>
<p>设计框架是控制反转的典型应用场景。以一个GUI框架为例，最简单的方式如左图，应用程序通过框架中的CreateWindow函数创建窗口，但是GUI框架并不知道窗口接收到消息以后该如何处理，所以接收到消息时会调用应用程序中的窗口函数。而这形成了双向依赖关系。</p>
<p>这种双向依赖关系缺陷较严重：换一个新的应用程序，甚至可能需要修改GUI框架。</p>
<p><img src="/design_pattern-image/image_VVVa9OaJk4.png"></p>
<p>使用<strong>控制反转</strong>可以消除这样的依赖，也就是将主控权从应用程序转移到框架。在调用CreateWindow时，其接收一个函数指针参数，该函数指针指向用户实现的消息处理函数。因此，当GUI框架接收到消息时，通过该指针自动处理消息。这就是<strong>动态调用机制</strong>，也被称为<strong>回调函数</strong>。此时改变应用程序，只会改变自定义行为，GUI框架无需更改。</p>
<p><img src="/design_pattern-image/image__fRxSpewKb.png"></p>
<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>不通过new()的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。</p>
<p>比如上面实现控制反转的方式：向CreateWindow中注入消息处理的函数指针，就可以理解为一种特殊的，面向过程的依赖注入。</p>
<blockquote>
<p>📌<strong>控制反转</strong>是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导框架层面的设计。<br><strong>依赖注入</strong>是实现控制反转的一种具体的编码技巧。<br><strong>依赖反转</strong>也是一种设计思想，指导框架层面的设计。高层模块不依赖低层模块，而是二者共同依赖同一个抽象。</p>
</blockquote>
<h2 id="KISS原则"><a href="#KISS原则" class="headerlink" title="KISS原则"></a>KISS原则</h2><blockquote>
<p>Keep It Simple and Stupid<br>Keep It Short and Simple<br>Keep It Simple and Straightforward</p>
</blockquote>
<p>尽量把代码写得简单，虽然“简单”的定义很模糊。</p>
<ul>
<li><p>不要使用同事可能不懂的技术来实现代码。</p>
</li>
<li><p>不要重复造轮子，要善于使用已经有的工具类库。</p>
</li>
<li><p>不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。</p>
</li>
</ul>
<h3 id="YAGNI原则"><a href="#YAGNI原则" class="headerlink" title="YAGNI原则"></a>YAGNI原则</h3><blockquote>
<p>You Ain’t Gonna Need It</p>
</blockquote>
<p>不要去设计当前用不到的功能；不要去编写当前用不到的代码——不要做过度设计。</p>
<p>比如，系统暂时只用Redis存储配置信息，以后可能会用到zookeeper。根据YAGNI原则，在未用到ZooKeeper之前，没必要提前编写这部分代码。</p>
<p>再比如，不要在项目中提前引入不需要依赖的开发包。</p>
<h2 id="DRY原则（Don’t-Repeat-Yourself）"><a href="#DRY原则（Don’t-Repeat-Yourself）" class="headerlink" title="DRY原则（Don’t Repeat Yourself）"></a>DRY原则（Don’t Repeat Yourself）</h2><blockquote>
<p>不要写重复的代码</p>
</blockquote>
<p>有三种代码重复的情况：实现逻辑重复、功能语义重复、代码执行重复。出现这三种情况后，需要去进一步优化。</p>
<p>但是“实现逻辑重复，功能语义不重复的代码”并不违反DRY原则。</p>
<h2 id="迪米特法则（Law-of-Demeter）"><a href="#迪米特法则（Law-of-Demeter）" class="headerlink" title="迪米特法则（Law of Demeter）"></a>迪米特法则（Law of Demeter）</h2><blockquote>
<p>别名：最小知识原则（The Least Knowlwdge Principle）</p>
</blockquote>
<ul>
<li><p>何为“高内聚、松耦合”？</p>
<ul>
<li><p>高内聚：</p>
<p>相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护。单一职责原则是实现代码高内聚非常有效的设计原则。</p>
</li>
<li><p>松耦合：</p>
<p>在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动。</p>
<p>依赖注入、接口隔离、基于接口而非实现编程，以及迪米特法则，都是为了实现代码的松耦合。</p>
</li>
</ul>
</li>
<li><p>最小知识：</p>
<p>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。</p>
</li>
</ul>
<h1 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h1><h3 id="1-命名的长度"><a href="#1-命名的长度" class="headerlink" title="1. 命名的长度"></a>1. 命名的长度</h3><p>命名一定要准确达意。对于一些默认的、大家都比较熟知的词，比较推荐用缩写。这样一方面能让命名短一些，另一方面又不影响阅读理解，比如，sec表示second、str表示string、num表示number、doc表示document。除此之外，对于作用域比较小的变量，可以使用相对短的命名，比如一些函数内的临时变量。相反，对于类名这种作用域比较大的，更推荐用长的命名方式。</p>
<h3 id="2-利用上下文简化命名"><a href="#2-利用上下文简化命名" class="headerlink" title="2. 利用上下文简化命名"></a>2. 利用上下文简化命名</h3><p>比如下面的代码，成员变量和成员方法都借助了User这样的类名上下文，省去了命名时重复添加前缀“user”的麻烦。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  string name;       <span class="comment">//string userName;借助User类这个上下文</span></span><br><span class="line">  string password;   <span class="comment">//string userPassword;</span></span><br><span class="line">  string avatarUrl;  <span class="comment">//string userAvatarUrl;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">string <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">string <span class="title">getPassword</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">string <span class="title">getAvatarUrl</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  User user = <span class="keyword">new</span> <span class="built_in">User</span>();</span><br><span class="line">  user.<span class="built_in">getName</span>();   <span class="comment">//借助user对象这个上下文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-命名要可读、可搜索"><a href="#3-命名要可读、可搜索" class="headerlink" title="3. 命名要可读、可搜索"></a>3. 命名要可读、可搜索</h3><h3 id="4-命名接口和抽象类"><a href="#4-命名接口和抽象类" class="headerlink" title="4. 命名接口和抽象类"></a>4. 命名接口和抽象类</h3><ul>
<li><p>接口：有两种常见的方式</p>
<ul>
<li><p>加前缀“I”表示一个Interface，比如IUserService，对应的实现类命名为UserService。</p>
</li>
<li><p>不加前缀，比如UserService，对应的实现类加后缀“Impl”，比如UserServiceImpl。</p>
</li>
</ul>
</li>
<li><p>抽象类：有两种常见的方式</p>
<ul>
<li><p>加前缀“Abstract”，比如AbstractConfiguration。</p>
</li>
<li><p>不带前缀，让对应类加后缀“Impl”或者其他与功能相关的命名。</p>
</li>
</ul>
</li>
</ul>
<h3 id="5-注释写什么"><a href="#5-注释写什么" class="headerlink" title="5. 注释写什么"></a>5. 注释写什么</h3><p>注释的内容主要需要包含三方面：做什么、为什么、怎么做。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* (what) Bean factory to create beans. </span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* (why) The class likes Spring IOC framework, but is more lightweight. </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* (how) Create objects from different sources sequentially:</span></span><br><span class="line"><span class="comment">* user specified object &gt; SPI &gt; configuration &gt; default object.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BeansFactory</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-注释的多少"><a href="#6-注释的多少" class="headerlink" title="6. 注释的多少"></a>6. 注释的多少</h3><p>类和函数一定要写注释，而且要写得尽可能全面、详细，而函数内部的注释要相对少一些。一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码的可读性。</p>
<h3 id="7-类、函数多大才合适"><a href="#7-类、函数多大才合适" class="headerlink" title="7. 类、函数多大才合适"></a>7. 类、函数多大才合适</h3><p>事实上很难界定，太多或太少都不合适。</p>
<ul>
<li><p>函数：有一种说法是函数代码的行数，最好不要超过一个显示屏的垂直高度。</p>
</li>
<li><p>类：主要主观来判断，当一个类的代码读起来让你感觉头大了，实现某个功能时不知道该用哪个函数了，想用哪个函数翻半天都找不到了，只用到一个小功能要引入整个类（类中包含很多无关此功能实现的函数）的时候，这就说明类的行数过多了</p>
</li>
</ul>
<h3 id="8-一行代码多长最合适"><a href="#8-一行代码多长最合适" class="headerlink" title="8. 一行代码多长最合适"></a>8. 一行代码多长最合适</h3><p>Google Java Style Guide文档中，一行代码最长限制为100个字符。遵循的原则是：最长最好不要超过IDE显示的宽度。</p>
<h3 id="9-善用空行分割单元块"><a href="#9-善用空行分割单元块" class="headerlink" title="9. 善用空行分割单元块"></a>9. 善用空行分割单元块</h3><p>对于比较长的函数，如果逻辑上可以分为几个独立的代码块，在不方便将这些独立的代码块抽取成小函数的情况下，使得逻辑更加清晰。</p>
<p>除此之外，在类的成员变量与函数之间、静态成员变量与普通成员变量之间、各函数之间、甚至各成员变量之间，我们都可以通过添加空行的方式，让这些不同模块的代码之间，界限更加明确。</p>
<h3 id="10-四格缩进还是两格缩进"><a href="#10-四格缩进还是两格缩进" class="headerlink" title="10. 四格缩进还是两格缩进"></a>10. 四格缩进还是两格缩进</h3><p>不固定，最好和业内推荐的风格统一、跟著名开源项目统一。</p>
<p>缩进时尽量别用tab键。因为在不同的IDE下，tab键的显示宽度不同，有的显示为四格缩进，有的显示为两格缩进。如果在同一个项目中，不同的同事使用不同的缩进方式（空格缩进或tab键缩进），有可能会导致有的代码显示为两格缩进、有的代码显示为四格缩进。</p>
<h3 id="11-大括号是否要另起一行"><a href="#11-大括号是否要另起一行" class="headerlink" title="11. 大括号是否要另起一行"></a>11. 大括号是否要另起一行</h3><p>只要团队统一、业内统一、跟开源项目看齐就好了，没有绝对的优劣之分。</p>
<h3 id="12-把代码分割成更小的单元块"><a href="#12-把代码分割成更小的单元块" class="headerlink" title="12. 把代码分割成更小的单元块"></a>12. 把代码分割成更小的单元块</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重构前的代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invest</span><span class="params">(<span class="type">long</span> userId, <span class="type">long</span> financialProductId)</span> &#123;</span><br><span class="line">  <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">  calendar.setTime(date);</span><br><span class="line">  calendar.set(Calendar.DATE, (calendar.get(Calendar.DATE) + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span> (calendar.get(Calendar.DAY_OF_MONTH) == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重构后的代码：提炼函数之后逻辑更加清晰</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invest</span><span class="params">(<span class="type">long</span> userId, <span class="type">long</span> financialProductId)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (isLastDayOfMonth(<span class="keyword">new</span> <span class="title class_">Date</span>())) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLastDayOfMonth</span><span class="params">(Date date)</span> &#123;</span><br><span class="line">  <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">  calendar.setTime(date);</span><br><span class="line">  calendar.set(Calendar.DATE, (calendar.get(Calendar.DATE) + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span> (calendar.get(Calendar.DAY_OF_MONTH) == <span class="number">1</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-避免函数参数过多"><a href="#13-避免函数参数过多" class="headerlink" title="13. 避免函数参数过多"></a>13. 避免函数参数过多</h3><p>函数包含3、4个参数的时候还是能接受的，大于等于5个的时候，会认为参数有点多了，影响代码的可读性，使用起来也不方便。针对参数过多，一般有2种处理方法：</p>
<ul>
<li><p>考虑函数是否职责单一，是否能通过拆分成多个函数的方式来减少参数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">User <span class="title">getUser</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拆分成多个函数</span></span><br><span class="line"><span class="function">User <span class="title">getUserByUsername</span><span class="params">(string username)</span></span>;</span><br><span class="line"><span class="function">User <span class="title">getUserByTelephone</span><span class="params">(string telephone)</span></span>;</span><br><span class="line"><span class="function">User <span class="title">getUserByEmail</span><span class="params">(string email)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将函数的参数封装成对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postBlog</span><span class="params">(string title, string summary, string keywords, string content, string category, <span class="type">long</span> authorId)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将参数封装成对象</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Blog</span>&#123;</span><br><span class="line">  string title;</span><br><span class="line">  string summary;</span><br><span class="line">  string keywords;</span><br><span class="line">  string content;</span><br><span class="line">  string category;</span><br><span class="line">  <span class="type">long</span> authorId;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postBlog</span><span class="params">(Blog blog)</span></span>;</span><br></pre></td></tr></table></figure>

<p>函数参数封装成对象还可以带来一个好处：如果函数是对外暴露的抽象接口，将参数封装成对象，可以提高接口的兼容性。当有需要往接口中添加新的参数时，老的接口调用者就不需要修改代码来兼容新的接口了。</p>
</li>
</ul>
<h3 id="14-勿用函数参数来控制逻辑"><a href="#14-勿用函数参数来控制逻辑" class="headerlink" title="14. 勿用函数参数来控制逻辑"></a>14. 勿用函数参数来控制逻辑</h3><ul>
<li><p>函数参数为布尔类型，控制了内部逻辑，true的时候走这块逻辑，false的时候走另一块逻辑。这违背了单一职责原则和接口隔离原则，因此建议拆分成两个函数，可读性上也要更好。</p>
</li>
<li><p>上面这条并不是必须要遵守的。如果函数是private私有函数，影响范围有限，或者拆分后的两函数经常被同时调用，可以酌情考虑保留该标识参数。</p>
</li>
<li><p>有一种“根据参数是否为null”来控制逻辑的情况。和布尔类型类似，有该参数的函数也可以通过判断条件进行函数拆分。</p>
</li>
</ul>
<h3 id="15-函数设计要职责单一"><a href="#15-函数设计要职责单一" class="headerlink" title="15. 函数设计要职责单一"></a>15. 函数设计要职责单一</h3><p>函数和类的设计均要满足单一职责原则。</p>
<h3 id="16-移除过深的嵌套层次"><a href="#16-移除过深的嵌套层次" class="headerlink" title="16. 移除过深的嵌套层次"></a>16. 移除过深的嵌套层次</h3><p>代码嵌套层次过深往往是因为if-else、switch-case、for循环过度嵌套导致的，建议嵌套不超过两层。</p>
<p>有下面4种常见的解决嵌套过深的思路：</p>
<ul>
<li><p>去掉多余的if或else语句</p>
</li>
<li><p>使用continue、break、return关键字，提前退出嵌套</p>
</li>
<li><p>调整执行顺序来减少嵌套</p>
</li>
<li><p>将部分嵌套逻辑封装成函数调用，以此来减少嵌套</p>
</li>
</ul>
<h3 id="17-学会使用解释性变量"><a href="#17-学会使用解释性变量" class="headerlink" title="17. 学会使用解释性变量"></a>17. 学会使用解释性变量</h3><p>常用的用解释性变量来提高代码可读性的情况有下面 2种：</p>
<ul>
<li><p>常量取代魔法数字：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">CalculateCircularArea</span><span class="params">(<span class="type">double</span> radius)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">3.1415</span>) * radius * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解释性变量来解释复杂表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">const <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.1415</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">CalculateCircularArea</span><span class="params">(<span class="type">double</span> radius)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> PI * radius * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="GoF——23种设计模式"><a href="#GoF——23种设计模式" class="headerlink" title="GoF——23种设计模式"></a>GoF——23种设计模式</h1><p><img src="/design_pattern-image/image_wZCYDEcI8Y.png"></p>
<ul>
<li><p>创建型模式：用于描述“怎样创建对象”，其主要特点是“将对象的创建与使用分离”。</p>
</li>
<li><p>结构型模式：用于描述如何将类或对象按某种布局组成更大的结构。</p>
</li>
<li><p>行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。</p>
</li>
</ul>
<h2 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h2><blockquote>
<p>📌工厂(5) &gt; 单例(4) &gt; 原型(3) &gt; 建造者(2)</p>
</blockquote>
<h3 id="1-单例模式（Singleton）"><a href="#1-单例模式（Singleton）" class="headerlink" title="1 单例模式（Singleton）"></a>1 单例模式（Singleton）</h3><p>单例模式表示一个类只会有一个对象，当程序想创建新的对象时，创建的新对象其实和之前创建的对象在一个地址，即名义上的多个对象实际只有一个。单例模式分为懒汉式和饿汉式两种：</p>
<ul>
<li><p>懒汉式：类加载时没有生成单例。第一次调用getInstance方法时才去创建；</p>
</li>
<li><p>饿汉式：类一旦加载就创建一个单例，相比于懒汉式更加线程安全，但是也会丢失延迟实例化所带来的节约资源的好处。</p>
</li>
</ul>
<h4 id="栈上单例（懒汉式）"><a href="#栈上单例（懒汉式）" class="headerlink" title="栈上单例（懒汉式）"></a>栈上单例（懒汉式）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ~<span class="built_in">Singleton</span>()&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;~Singleton() destruct&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">CreateObject</span><span class="params">()</span></span>&#123; <span class="comment">//用户只能通过此函数构造对象</span></span><br><span class="line">    <span class="type">static</span> Singleton obj;           <span class="comment">//静态以单例</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Singleton</span>(Singleton&amp; obj) = <span class="keyword">delete</span>;             <span class="comment">//禁用拷贝构造函数</span></span><br><span class="line">  Singleton* <span class="keyword">operator</span>= (Singleton&amp; obj) = <span class="keyword">delete</span>; <span class="comment">//禁用拷贝构造函数，与上一行二者择一</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">Singleton</span>() &#123;                     <span class="comment">//封闭构造函数，不让用户有接触到构造函数的机会</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Singleton() construct&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Singleton&amp; pObj1 = Singleton::<span class="built_in">CreateObject</span>();</span><br><span class="line">  Singleton&amp; pObj2 = Singleton::<span class="built_in">CreateObject</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>CreateObject是static函数：</p>
<p>避开无对象时没法调用构造函数创建对象的死结，直接用静态函数构造对象</p>
</li>
<li><p>CreateObject返回的是引用而不是指针：</p>
<p>虽说也可以用指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> Singleton* m_pObject = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function"><span class="type">static</span> Singleton* <span class="title">CreateObject</span><span class="params">()</span></span>&#123; <span class="comment">//用户只能通过此函数构造对象</span></span><br><span class="line">    <span class="keyword">if</span>(m_pObject == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">      m_pObject = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_pObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这么写存在的问题是，因为是指针，因为用了new，所以可能存在内存泄露问题。即使用户可以在main函数里<code>delete pObj1</code>，而且编译不会报错，但此时Singleton不再是线程安全的了。</p>
</li>
<li><p>禁用拷贝构造函数：</p>
<p>传回的是引用，但若允许拷贝构造函数，这么写时仍不会报错</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Singleton pObj2 = Singleton::<span class="built_in">CreateObject</span>();</span><br></pre></td></tr></table></figure>

<p>此时的pObj2是通过拷贝构造函数，新创建的Singleton对象，并把obj的内容拷贝了过来。那么此时pObj2和pObj1的地址不再相同，二者成为了两个对象，打破了单例模式。</p>
<p>因此，此处禁用拷贝构造，强迫用户必须用引用来接对象。</p>
</li>
</ul>
<h4 id="堆上单例（懒汉式）"><a href="#堆上单例（懒汉式）" class="headerlink" title="堆上单例（懒汉式）"></a>堆上单例（懒汉式）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>();</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; other);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="type">static</span> Singleton* m_instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::m_instance=<span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程非安全版本</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        m_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程安全版本，但锁的代价过高</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Lock lock;</span><br><span class="line">    <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        m_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双检查锁，但由于内存读写reorder不安全（编译器优化时可能把第二个检查优化掉）</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_instance==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        Lock lock;</span><br><span class="line">        <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            m_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++ 11版本之后的跨平台实现 (volatile)</span></span><br><span class="line">std::atomic&lt;Singleton*&gt; Singleton::m_instance;</span><br><span class="line">std::mutex Singleton::m_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Singleton* tmp = m_instance.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_acquire);<span class="comment">//获取内存fence</span></span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        tmp = m_instance.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            tmp = <span class="keyword">new</span> Singleton;</span><br><span class="line">            std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_release);<span class="comment">//释放内存fence</span></span><br><span class="line">            m_instance.<span class="built_in">store</span>(tmp, std::memory_order_relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="堆上单例（饿汉式）"><a href="#堆上单例（饿汉式）" class="headerlink" title="堆上单例（饿汉式）"></a>堆上单例（饿汉式）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> singleton &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">HungrySingleton</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function">HungrySingleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> instance_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="built_in">HungrySingleton</span>() &#123;&#125;</span><br><span class="line">      <span class="type">static</span> HungrySingleton* instance_;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  HungrySingleton* HungrySingleton::instance_ = <span class="keyword">new</span> <span class="built_in">HungrySingleton</span>();</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace singleton</span></span><br></pre></td></tr></table></figure>

<h3 id="2-工厂模式（Factory）"><a href="#2-工厂模式（Factory）" class="headerlink" title="2 工厂模式（Factory）"></a>2 工厂模式（Factory）</h3><blockquote>
<p>工厂模式中，创建对象时不会对客户端暴露创建逻辑，而是通过使用一个共同的接口来指向新创建的对象</p>
</blockquote>
<h4 id="2-1-简单工厂"><a href="#2-1-简单工厂" class="headerlink" title="2.1 简单工厂"></a>2.1 简单工厂</h4><p>以炒鞋为例。鞋厂可以指定生产耐克、阿迪达斯和李宁牌子的鞋。</p>
<ul>
<li><p>工厂类：工厂模式的核心类，会定义一个用于创建指定的具体实例对象的接口。</p>
</li>
<li><p>抽象产品类：是具体产品类的继承的父类或实现的接口。</p>
</li>
<li><p>具体产品类：工厂类所创建的对象就是此具体产品实例。</p>
</li>
</ul>
<p><img src="/design_pattern-image/image_pIG1eoG7w-.png"></p>
<p>特点在于封装了创建具体产品对象的函数。</p>
<p>缺点在于扩展性非常差，新增产品的时候，需要去修改工厂类。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 鞋子抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shoes</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shoes</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耐克鞋子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NiKeShoes</span> : <span class="keyword">public</span> Shoes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是耐克球鞋，我的广告语：Just do it&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阿迪达斯鞋子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AdidasShoes</span> : <span class="keyword">public</span> Shoes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是阿迪达斯球鞋，我的广告语:Impossible is nothing&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 李宁鞋子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LiNingShoes</span> : <span class="keyword">public</span> Shoes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是李宁球鞋，我的广告语：Everything is possible&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SHOES_TYPE</span></span><br><span class="line">&#123;</span><br><span class="line">    NIKE,</span><br><span class="line">    LINING,</span><br><span class="line">    ADIDAS</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总鞋厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShoesFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 根据鞋子类型创建对应的鞋子对象</span></span><br><span class="line">    <span class="function">Shoes *<span class="title">CreateShoes</span><span class="params">(SHOES_TYPE type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> NIKE:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">NiKeShoes</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LINING:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">LiNingShoes</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ADIDAS:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">AdidasShoes</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>main函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 构造工厂对象</span></span><br><span class="line">    ShoesFactory shoesFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从鞋工厂对象创建阿迪达斯鞋对象</span></span><br><span class="line">    Shoes *pNikeShoes = shoesFactory.<span class="built_in">CreateShoes</span>(NIKE);</span><br><span class="line">    <span class="keyword">if</span> (pNikeShoes != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 耐克球鞋广告喊起</span></span><br><span class="line">        pNikeShoes-&gt;<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="keyword">delete</span> pNikeShoes;</span><br><span class="line">        pNikeShoes = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从鞋工厂对象创建阿迪达斯鞋对象</span></span><br><span class="line">    Shoes *pLiNingShoes = shoesFactory.<span class="built_in">CreateShoes</span>(LINING);</span><br><span class="line">    <span class="keyword">if</span> (pLiNingShoes != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 李宁球鞋广告喊起</span></span><br><span class="line">        pLiNingShoes-&gt;<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="keyword">delete</span> pLiNingShoes;</span><br><span class="line">        pLiNingShoes = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从鞋工厂对象创建阿迪达斯鞋对象</span></span><br><span class="line">    Shoes *pAdidasShoes = shoesFactory.<span class="built_in">CreateShoes</span>(ADIDAS);</span><br><span class="line">    <span class="keyword">if</span> (pAdidasShoes != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 阿迪达斯球鞋广告喊起</span></span><br><span class="line">        pAdidasShoes-&gt;<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="keyword">delete</span> pAdidasShoes;</span><br><span class="line">        pAdidasShoes = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-工厂方法"><a href="#2-2-工厂方法" class="headerlink" title="2.2 工厂方法"></a>2.2 工厂方法</h4><p>简单工厂的缺点在于，调用工厂来创建对象时，是传入产品类别的。每当增加一个类别时，就需要修改一次工厂类。这违反了开闭原则，而工厂方法是对这种行为的补救。使用工厂方法，每次需要增加一个类别时，只需要再实现两个具体类就行，不必再去修改工厂类的内容。</p>
<p>工厂方法相比于简单工厂，添加了一个具体工厂类，每一个具体工厂类和相应的具体产品类是一一对应的，由具体工厂类来生产（创建）相应的具体产品类对象。</p>
<ul>
<li><p>抽象工厂类：工厂方法模式的核心类，提供创建具体产品的接口，由具体工厂类实现。</p>
</li>
<li><p>具体工厂类：继承于抽象工厂，实现创建对应具体产品对象的方式。</p>
</li>
<li><p>抽象产品类：它是具体产品继承的父类（基类）。</p>
</li>
<li><p>具体产品类：具体工厂所创建的对象，就是此类。</p>
</li>
</ul>
<p><img src="/design_pattern-image/image_psTux_rw_R.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 总鞋厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShoesFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Shoes *<span class="title">CreateShoes</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ShoesFactory</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耐克生产者/生产链</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NiKeProducer</span> : <span class="keyword">public</span> ShoesFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Shoes *<span class="title">CreateShoes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">NiKeShoes</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阿迪达斯生产者/生产链</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AdidasProducer</span> : <span class="keyword">public</span> ShoesFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Shoes *<span class="title">CreateShoes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">AdidasShoes</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 李宁生产者/生产链</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LiNingProducer</span> : <span class="keyword">public</span> ShoesFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Shoes *<span class="title">CreateShoes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">LiNingShoes</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>main函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ================ 生产耐克流程 ==================== //</span></span><br><span class="line">    <span class="comment">// 鞋厂开设耐克生产线</span></span><br><span class="line">    ShoesFactory *niKeProducer = <span class="keyword">new</span> <span class="built_in">NiKeProducer</span>();</span><br><span class="line">    <span class="comment">// 耐克生产线产出球鞋</span></span><br><span class="line">    Shoes *nikeShoes = niKeProducer-&gt;<span class="built_in">CreateShoes</span>();</span><br><span class="line">    <span class="comment">// 耐克球鞋广告喊起</span></span><br><span class="line">    nikeShoes-&gt;<span class="built_in">Show</span>();</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">delete</span> nikeShoes;</span><br><span class="line">    <span class="keyword">delete</span> niKeProducer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ================ 生产阿迪达斯流程 ==================== //</span></span><br><span class="line">    <span class="comment">// 鞋厂开设阿迪达斯生产者</span></span><br><span class="line">    ShoesFactory *adidasProducer = <span class="keyword">new</span> <span class="built_in">AdidasProducer</span>();</span><br><span class="line">    <span class="comment">// 阿迪达斯生产线产出球鞋</span></span><br><span class="line">    Shoes *adidasShoes = adidasProducer-&gt;<span class="built_in">CreateShoes</span>();</span><br><span class="line">    <span class="comment">// 阿迪达斯球鞋广喊起</span></span><br><span class="line">    adidasShoes-&gt;<span class="built_in">Show</span>();</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">delete</span> adidasShoes;</span><br><span class="line">    <span class="keyword">delete</span> adidasProducer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-抽象工厂"><a href="#2-3-抽象工厂" class="headerlink" title="2.3 抽象工厂"></a>2.3 抽象工厂</h4><ul>
<li><p>与工厂方法的不同：具体工厂类不再生产唯一的产品，而是生产多个产品。也就是抽象工厂类将不仅仅提供对某一种产品的创建方法，还提供多种产品的创建方法。</p>
</li>
<li><p>应用场景：当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的具体产品时需要使用抽象工厂模式。</p>
<p>遇到此类场景时，抽象工厂模式比工厂方法模式更为简单、有效率。</p>
</li>
</ul>
<p><img src="/design_pattern-image/image_aZYjDQ9kcg.png"></p>
<p>考虑上面的例子。此时厂家不再局限于生产鞋子，还想生产耐克、阿迪达斯、李宁的衣服。那么就可以应用抽象工厂来替代工厂方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基类 衣服</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clothe</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Clothe</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耐克衣服</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NiKeClothe</span> : <span class="keyword">public</span> Clothe</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是耐克衣服，时尚我最在行！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 鞋子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shoes</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shoes</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耐克鞋子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NiKeShoes</span> : <span class="keyword">public</span> Shoes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是耐克球鞋，让你酷起来！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 总厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Shoes *<span class="title">CreateShoes</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Clothe *<span class="title">CreateClothe</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Factory</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耐克生产者/生产链</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NiKeProducer</span> : <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Shoes *<span class="title">CreateShoes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">NiKeShoes</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Clothe *<span class="title">CreateClothe</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">NiKeClothe</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>main函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ================ 生产耐克流程 ==================== //</span></span><br><span class="line">    <span class="comment">// 鞋厂开设耐克生产线</span></span><br><span class="line">    Factory *niKeProducer = <span class="keyword">new</span> <span class="built_in">NiKeProducer</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 耐克生产线产出球鞋</span></span><br><span class="line">    Shoes *nikeShoes = niKeProducer-&gt;<span class="built_in">CreateShoes</span>();</span><br><span class="line">  <span class="comment">// 耐克生产线产出衣服</span></span><br><span class="line">    Clothe *nikeClothe = niKeProducer-&gt;<span class="built_in">CreateClothe</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 耐克球鞋广告喊起</span></span><br><span class="line">    nikeShoes-&gt;<span class="built_in">Show</span>();</span><br><span class="line">  <span class="comment">// 耐克衣服广告喊起</span></span><br><span class="line">    nikeClothe-&gt;<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">delete</span> nikeShoes;</span><br><span class="line">  <span class="keyword">delete</span> nikeClothe;</span><br><span class="line">    <span class="keyword">delete</span> niKeProducer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-模板工厂（C-）"><a href="#2-4-模板工厂（C-）" class="headerlink" title="2.4 模板工厂（C++）"></a>2.4 模板工厂（C++）</h4><p><a href="https://zhuanlan.zhihu.com/p/83537599">https://zhuanlan.zhihu.com/p/83537599</a></p>
<p>模板工厂相当于在工厂方法的基础上进行优化，使其能够获得抽象工厂的效果。而且比起抽象工厂来，当需要新添加类别时（比如在鞋和衣服的基础上，还要添加裤子），扩展性更强，符合开闭原则。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基类 鞋子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shoes</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shoes</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耐克鞋子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NiKeShoes</span> : <span class="keyword">public</span> Shoes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是耐克球鞋，我的广告语：Just do it&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 衣服</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clothe</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Clothe</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优衣库衣服</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UniqloClothe</span> : <span class="keyword">public</span> Clothe</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是优衣库衣服，我的广告语：I am Uniqlo&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象模板工厂类</span></span><br><span class="line"><span class="comment">// 模板参数：AbstractProduct_t 产品抽象类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">AbstractProduct_t</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> AbstractProduct_t *<span class="title">CreateProduct</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractFactory</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体模板工厂类</span></span><br><span class="line"><span class="comment">// 模板参数：AbstractProduct_t 产品抽象类，ConcreteProduct_t 产品具体类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">AbstractProduct_t</span>, <span class="keyword">class</span> <span class="title class_">ConcreteProduct_t</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory</span> : <span class="keyword">public</span> AbstractFactory&lt;AbstractProduct_t&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">AbstractProduct_t *<span class="title">CreateProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteProduct_t</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>main函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 构造耐克鞋的工厂对象</span></span><br><span class="line">    ConcreteFactory&lt;Shoes, NiKeShoes&gt; nikeFactory;</span><br><span class="line">    <span class="comment">// 创建耐克鞋对象</span></span><br><span class="line">    Shoes *pNiKeShoes = nikeFactory.<span class="built_in">CreateProduct</span>();</span><br><span class="line">    <span class="comment">// 打印耐克鞋广告语</span></span><br><span class="line">    pNiKeShoes-&gt;<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造优衣库衣服的工厂对象</span></span><br><span class="line">    ConcreteFactory&lt;Clothe, UniqloClothe&gt; uniqloFactory;</span><br><span class="line">    <span class="comment">// 创建优衣库衣服对象</span></span><br><span class="line">    Clothe *pUniqloClothe = uniqloFactory.<span class="built_in">CreateProduct</span>();</span><br><span class="line">    <span class="comment">// 打印优衣库广告语</span></span><br><span class="line">    pUniqloClothe-&gt;<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">delete</span> pNiKeShoes;</span><br><span class="line">    pNiKeShoes = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pUniqloClothe;</span><br><span class="line">    pUniqloClothe = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-建造者模式（Builder）"><a href="#3-建造者模式（Builder）" class="headerlink" title="3 建造者模式（Builder）"></a>3 建造者模式（Builder）</h3><blockquote>
<p>将一个<strong>复杂对象</strong>分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。<br>Builder侧重“零部件的组装过程”。</p>
</blockquote>
<p><img src="/design_pattern-image/image_YPbrcpWDP5.png"></p>
<ul>
<li><p>应用场景：建造者模式主要用于“分步骤构建一个复杂的对象”。在这其中“分步骤”是一个稳定的算法，而复杂对象的各个部分经常变化。</p>
</li>
<li><p>缺点：这里的“组装过程”，或者说“步骤”，是固定的，无法修改。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">House</span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HouseBuilder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">House* <span class="title">GetResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> pHouse;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">HouseBuilder</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  House* pHouse;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart1</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart2</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart3</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart4</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart5</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StoneHouse</span>: <span class="keyword">public</span> House&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StoneHouseBuilder</span>: <span class="keyword">public</span> HouseBuilder&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart1</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//pHouse-&gt;Part1 = ...;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart3</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart4</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart5</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">///@brief：Director，组装各个part，“步骤”是由它制定并实现的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HouseDirector</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  HouseBuilder* pHouseBuilder;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">HouseDirector</span>(HouseBuilder* pHouseBuilder)&#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;pHouseBuilder=pHouseBuilder;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">House* <span class="title">Construct</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    pHouseBuilder-&gt;<span class="built_in">BuildPart1</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">        pHouseBuilder-&gt;<span class="built_in">BuildPart2</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> flag=pHouseBuilder-&gt;<span class="built_in">BuildPart3</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        pHouseBuilder-&gt;<span class="built_in">BuildPart4</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pHouseBuilder-&gt;<span class="built_in">BuildPart5</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pHouseBuilder-&gt;<span class="built_in">GetResult</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-原型模式（Prototype）"><a href="#4-原型模式（Prototype）" class="headerlink" title="4 原型模式（Prototype）"></a>4 原型模式（Prototype）</h3><blockquote>
<p>将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</p>
</blockquote>
<ul>
<li><p>应用场景：</p>
<p>针对<strong>结构复杂的对象结构</strong>，由于需求变化，对象内部也会发生变化，但是对外暴露的接口仍然是稳定的。原型模式负责应对这种变化，从客户程序隔离出易变对象，从而使得依赖这些对象的客户程序不必随着需求改变而改变。</p>
</li>
<li><p>实现方式：</p>
<p>定义抽象类，原型为派生出来的具体类的一个实例，需要其他（发生了变化的）实例时，从原型拷贝。</p>
</li>
</ul>
<p><img src="/design_pattern-image/image_vGYSLsjdRm.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// @brief 抽象原型类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractPrototype</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">AbstractPrototype</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">AbstractPrototype</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> AbstractPrototype* <span class="title">clone</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 具体原型类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcretePrototype</span> : <span class="keyword">public</span> AbstractPrototype &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ConcretePrototype</span>() = <span class="keyword">default</span>;</span><br><span class="line">  ~<span class="built_in">ConcretePrototype</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">AbstractPrototype* <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcretePrototype</span>(*<span class="keyword">this</span>);<span class="comment">//调用拷贝构造</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">ConcretePrototype</span>(<span class="type">const</span> ConcretePrototype&amp; other) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;ConcretePrototype copy construct!\n&quot;</span>);</span><br><span class="line">        <span class="comment">// ......拷贝操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test_02_prototype_impl_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-------------------- %s --------------------\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    prototype::AbstractPrototype* ptr_a = <span class="keyword">new</span> prototype::<span class="built_in">ConcretePrototype</span>();</span><br><span class="line">    prototype::AbstractPrototype* ptr_b = ptr_a-&gt;<span class="built_in">clone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> ptr_a;</span><br><span class="line">    <span class="keyword">delete</span> ptr_b; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h2><blockquote>
<p>📌门面(5) &gt; 适配器(4) &#x3D; 组合(4) &#x3D; 代理(4) &gt; 桥接(3) &#x3D; 装饰(3) &gt; 享元(1)</p>
</blockquote>
<h3 id="5-代理模式（Proxy）"><a href="#5-代理模式（Proxy）" class="headerlink" title="5 代理模式（Proxy）"></a>5 代理模式（Proxy）</h3><p>在某些情况下，一个客户不想或者不能直接引用一个对象，此时可以通过一个称之为“代理”的第三方来实现 间接引用。代理对象可以在客户端和目标对象之间起到“中介”的作用，并且可以通过代理对象去掉客户不允许看到的内容，或者添加客户需要的额外服务。</p>
<blockquote>
<p>事实上，代理模式和科学上网时所配置的代理是异曲同工的。无法直接访问到海外的机器，此时可以使用一个代理来访问海外，而客户端调用代理即可。</p>
</blockquote>
<p><img src="/design_pattern-image/image_LaOkWgxP2d.png"></p>
<p><img src="/design_pattern-image/image_Bl0RbJxcRV.png"></p>
<ul>
<li><p>subject：抽象角色</p>
</li>
<li><p>Proxy：代理角色</p>
</li>
<li><p>RealSubject：真实角色</p>
</li>
</ul>
<!---->

<ul>
<li><p>应用场景：</p>
<ol>
<li><p>远程代理：为一个处于不同地址空间的对象提供一个本地的代理，这个不同地址空间可以在同一台主机中，也可在另一台主机中，远程代理又叫做大使。</p>
</li>
<li><p>虚拟代理：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。</p>
</li>
<li><p>写时拷贝代理：虚拟代理的一种，把复制（克隆）操作延迟到只有在客户端真正需要时才执行。</p>
</li>
<li><p>保护代理：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</p>
</li>
<li><p>缓冲代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</p>
</li>
<li><p>防火墙代理：保护目标不让恶意用户接近。</p>
</li>
<li><p>同步化代理：使几个用户能够同时使用一个对象而没有冲突。</p>
</li>
<li><p>智能引用代理：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来等。</p>
</li>
</ol>
</li>
<li><p>优点：</p>
<ol>
<li><p>代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。</p>
</li>
<li><p>远程代理使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。</p>
</li>
<li><p>虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度。</p>
</li>
<li><p>保护代理可以控制对真实对象的使用权限。</p>
</li>
</ol>
</li>
<li><p>缺点：</p>
<p>客户端和真实对象之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，而且增加了系统实现的复杂度。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Proxy</span> : <span class="keyword">public</span> Subject&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Proxy</span>()&#123;</span><br><span class="line">    m_pRealSubject = <span class="keyword">new</span> <span class="built_in">RealSubject</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Proxy</span>()&#123;</span><br><span class="line">    <span class="keyword">delete</span> m_pReakSubject;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">request</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">preRequest</span>();</span><br><span class="line">    m_pRealSubject-&gt;<span class="built_in">request</span>();</span><br><span class="line">    <span class="built_in">afterRequest</span>();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">afterRequest</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">preRequest</span><span class="params">()</span></span>;  </span><br><span class="line">  RealSubject *m_pRealSubject;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int main()&#123;</span></span><br><span class="line"><span class="comment">  Proxy proxy;</span></span><br><span class="line"><span class="comment">  proxy.request();</span></span><br><span class="line"><span class="comment">  return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="6-桥接模式（Bridge）"><a href="#6-桥接模式（Bridge）" class="headerlink" title="6 桥接模式（Bridge）"></a>6 桥接模式（Bridge）</h3><p>桥接模式同时使用了“<strong>接口与实现相分离</strong>”和“<strong>组合代替继承</strong>”的思想。</p>
<ul>
<li><p>应用场景：</p>
<p>某些类型的固有实现逻辑，使得它们具有两个变化的维度，甚至多个变化的维度。比如说图形既可按形状分，又可按颜色分。而Photoshop这样的软件，能画不同形状和不同颜色的图形，该如何实现呢？<br>此时可以使用桥接模式，可以参考前文“组合代替继承”中鸟类的例子。</p>
</li>
<li><p>桥接模式结构：</p>
<p><img src="/design_pattern-image/image_mczjtZsYoT.png"></p>
<p>Abstraction：抽象类</p>
<p>RefinedAbstraction：扩充抽象类，即扩充Abstraction所定义的接口，他同时连接Abstraction和Implementor，是“桥接”中的那座桥。</p>
<p>Implementor：实现类接口</p>
<p>ConcreteImplementor：具体实现类</p>
<p>扩充抽象类构造时接收具体实现类为参数，从而让扩充抽象类组合了若干具体实现类的功能。</p>
</li>
</ul>
<p>当然，扩充抽象类不一定是必需的，由此衍生出两种桥接模式的实现方式。</p>
<h4 id="简单的抽象与实现相分离"><a href="#简单的抽象与实现相分离" class="headerlink" title="简单的抽象与实现相分离"></a>简单的抽象与实现相分离</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// @brief 抽象类接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractInterface</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AbstractInterface</span>();</span><br><span class="line">    ~<span class="built_in">AbstractInterface</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Request</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Impl</span>;</span><br><span class="line">    Impl* impl_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 实现类接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractInterface</span>::Impl &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is AbstractInterface::Impl::Request!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 抽象类接口的实现 - 调用实现类接口</span></span><br><span class="line">AbstractInterface::<span class="built_in">AbstractInterface</span>() &#123;</span><br><span class="line">    impl_ = <span class="keyword">new</span> <span class="built_in">Impl</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AbstractInterface::~<span class="built_in">AbstractInterface</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span> impl_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AbstractInterface::Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    impl_-&gt;<span class="built_in">Request</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="复杂的抽象与实现相分离"><a href="#复杂的抽象与实现相分离" class="headerlink" title="复杂的抽象与实现相分离"></a>复杂的抽象与实现相分离</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// @brief 实现化角色, 定义实现化角色的接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractImplementor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractImplementor</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Request</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 具体实现化角色, 给出实现化角色接口的具体实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteImplementorA</span> : <span class="keyword">public</span> AbstractImplementor &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this ConcreteImplementorA::Request!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteImplementorB</span> : <span class="keyword">public</span> AbstractImplementor &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this ConcreteImplementorB::Request!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 抽象类角色, 对实现化对象的引用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractRole</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AbstractRole</span>(AbstractImplementor* impl) : <span class="built_in">impl_</span>(impl) &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractRole</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Request</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    AbstractImplementor* impl_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 扩展抽象化角色, 实现父类中的业务方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExtendRole</span> : <span class="keyword">public</span> AbstractRole &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ExtendRole</span>(AbstractImplementor* impl) : <span class="built_in">AbstractRole</span>(impl) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        impl_-&gt;<span class="built_in">Request</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test_08_bridge_impl_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AbstractImplementor* ptr_implA = <span class="keyword">new</span> <span class="built_in">ConcreteImplementorA</span>();</span><br><span class="line">    AbstractImplementor* ptr_implB = <span class="keyword">new</span> <span class="built_in">ConcreteImplementorB</span>();</span><br><span class="line"></span><br><span class="line">    AbstractRole* ptr_role_1 = <span class="keyword">new</span> <span class="built_in">ExtendRole</span>(ptr_implA);</span><br><span class="line">    ptr_role_1-&gt;<span class="built_in">Request</span>();</span><br><span class="line"></span><br><span class="line">    AbstractRole* ptr_role_2 = <span class="keyword">new</span> <span class="built_in">ExtendRole</span>(ptr_implB);</span><br><span class="line">    ptr_role_2-&gt;<span class="built_in">Request</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> ptr_role_1, ptr_role_2;</span><br><span class="line">    <span class="keyword">delete</span> ptr_implA, ptr_implB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>📌桥接模式的“桥”体现在什么地方？<br>比如说Photoshop的例子，颜色和形状被组合在了一起。再比如鸟的例子，飞属性和叫属性也被组合在了一起。<strong>桥接就像架起了一座桥一样，连接了两个不同的类型，从而进行组合</strong>。<br>体现在代码上的话，就是RefineAbstraction的构造函数中，传入了不同Implementor类型的指针，于是在RefineAbstraction对象内部，就可以组合不同类型的对象。<br>同时，用户仅需要调用抽象接口Abstraction即可。</p>
</blockquote>
<h3 id="7-装饰器模式（Decorator）"><a href="#7-装饰器模式（Decorator）" class="headerlink" title="7 装饰器模式（Decorator）"></a>7 装饰器模式（Decorator）</h3><p>装饰器动态的给对象增加一些职责，即增加额外的功能。采用了“<strong>组合代替继承</strong>”的原则，用组合关系创建一个包装对象来包裹真实对象，并在保持真实对象的类结构不变的前提下，提供额外的功能。</p>
<ul>
<li><p>应用场景：</p>
</li>
<li><p>优点：</p>
<ol>
<li><p>装饰模式可以提供比继承更多的灵活性。</p>
</li>
<li><p>可以通过动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的装饰器，从而实现不同的行为。</p>
</li>
<li><p>通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。</p>
</li>
<li><p>使用时进行组合即可，原有代码无须改变，符合“开闭原则”。</p>
</li>
</ol>
</li>
<li><p>缺点：</p>
<ol>
<li><p>装饰类和小对象的产生将增加系统的复杂度，加大学习与理解的难度。</p>
</li>
<li><p>装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。</p>
</li>
</ol>
</li>
</ul>
<p><img src="/design_pattern-image/image_KLc8axDXNy.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// @brief 抽象组件 - 被装饰的接口基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractComponent</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractComponent</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Request</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 具体组件 - 被装饰的接口派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteComponent</span> : <span class="keyword">public</span> AbstractComponent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is ConcreteComponent::Request!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// @brief 抽象装饰</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractDecorator</span> : <span class="keyword">public</span> AbstractComponent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AbstractDecorator</span>(AbstractComponent* comp) : <span class="built_in">comp_</span>(comp) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (comp_) comp_-&gt;<span class="built_in">Request</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    AbstractComponent* comp_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 具体装饰</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteDecoratorA</span> : <span class="keyword">public</span> AbstractDecorator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteDecoratorA</span>(AbstractComponent* comp) : <span class="built_in">AbstractDecorator</span>(comp) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">PreRequest</span>();</span><br><span class="line">        AbstractDecorator::<span class="built_in">Request</span>();</span><br><span class="line">        <span class="built_in">PostRequest</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PreRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ConcreteDecoratorA::PreRequest!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PostRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ConcreteDecoratorA::PostRequest!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>📌代码中的这行操作<code>ConcreteDecoratorA(AbstractComponent* comp):AbstractDecorator(comp)</code>是C++11的新特性：委托构造函数(delegating constructor)，即一个构造函数可以在初始化成员列表中，调用另一个构造函数。<br>委托构造函数的成员初始值列表<strong>只能有唯一的参数，就是构造函数</strong>。<br>上面的例子中，就是创建ConcreteDecoratorA对象时，会先将被对象创建为AbstractDecorator对象的内容，如果{ }中有内容，就继续执行{ }中的内容。<br>但是委托构造函数易发生死锁的问题，考虑下面代码：<br>class B{<br>private:<br>&amp;#x20;   int *a;<br>&amp;#x20;   std::string *s;<br>public:<br>&amp;#x20;   B(int a) : B(“Test”) {<br>&amp;#x20;       _*a &#x3D; a;<br>&amp;#x20;   }<br>&amp;#x20;   B(std::string s) : B(100){<br>&amp;#x20;      *_s &#x3D; “Test”;<br>&amp;#x20;   }<br>};<br>这一份代码可以编译，但是却无法运行。因为一旦初始化，无论执行哪一个函数，一定会陷入无穷无尽的循环调用中。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  AbstractComponent* ptr_comp = <span class="keyword">new</span> <span class="built_in">ConcreteComponent</span>();</span><br><span class="line">  ptr_comp-&gt;<span class="built_in">Request</span>(); <span class="comment">//原有组件该有的功能不变</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//对现有组件的功能进行扩展</span></span><br><span class="line">  AbstractDecorator* ptr_decorator = <span class="keyword">new</span> <span class="built_in">ConcreteDecoratorA</span>(ptr_comp);</span><br><span class="line">  ptr_decorator-&gt;<span class="built_in">Request</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-适配器模式（Adapter）"><a href="#8-适配器模式（Adapter）" class="headerlink" title="8 适配器模式（Adapter）"></a>8 适配器模式（Adapter）</h3><ul>
<li><p>适配器模式中的角色：</p>
<p>Target（目标接口）、Adapter（适配器类）、Adaptee（适配者类）、Client（客户类）。</p>
</li>
<li><p>应用场景：</p>
<p>现有的类可以满足客户类的功能需要，但是它所提供的接口不一定是客户类所期望的。适配器模式就是在二者之间添加一个类进行接口的转化。而添加的用于转化接口的类就是适配器类，被包装的类即适配者类。</p>
<p>适配器模式，通过适配器类，在适配者类外部包装，包装成目标接口。</p>
</li>
</ul>
<p>适配器模式有两种实现方式：</p>
<ol>
<li><p>对象适配器</p>
<p>Adapter只继承Target以提供接口的实现，接收Adaptee的对象作为参数。</p>
</li>
<li><p>类适配器</p>
<p>多重继承，Adapter类同时继承Target和Adaptee。</p>
</li>
</ol>
<p>二者均能获得Adaptee功能的同时向客户提供目标接口。两种实现方式的类图如下：</p>
<p><img src="/design_pattern-image/image_-s6OMPY2i6.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//目标接口（新接口）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ITarget</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遗留接口（老接口）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IAdaptee</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> data)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">bar</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遗留类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OldClass</span>: <span class="keyword">public</span> IAdaptee&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象适配器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adapter</span>: <span class="keyword">public</span> ITarget&#123; <span class="comment">//继承</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    IAdaptee* pAdaptee;<span class="comment">//组合</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Adapter</span>(IAdaptee* pAdaptee)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pAdaptee=pAdaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> data=pAdaptee-&gt;<span class="built_in">bar</span>();</span><br><span class="line">        pAdaptee-&gt;<span class="built_in">foo</span>(data);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//类适配器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adapter</span>: <span class="keyword">public</span> ITarget,</span><br><span class="line">               <span class="keyword">protected</span> OldClass&#123; <span class="comment">//多继承</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> data = <span class="keyword">this</span>-&gt;<span class="built_in">bar</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">foo</span>(data);</span><br><span class="line">  &#125;            </span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IAdaptee* pAdaptee=<span class="keyword">new</span> <span class="built_in">OldClass</span>();</span><br><span class="line"></span><br><span class="line">    ITarget* pTarget=<span class="keyword">new</span> <span class="built_in">Adapter</span>(pAdaptee);<span class="comment">//使用对象适配器</span></span><br><span class="line"></span><br><span class="line">    ITarget* pTarget=<span class="keyword">new</span> <span class="built_in">Adapter</span>();<span class="comment">//使用类适配器</span></span><br><span class="line"></span><br><span class="line">    pTarget-&gt;<span class="built_in">process</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-门面-x2F-外观模式（Facade）"><a href="#9-门面-x2F-外观模式（Facade）" class="headerlink" title="9 门面&#x2F;外观模式（Facade）"></a>9 门面&#x2F;外观模式（Facade）</h3><p>客户端想同时调用多个复杂的子系统，而外观模式为这些子系统提供一个一致的接口，使它们更容易被访问。</p>
<blockquote>
<p>现实生活的类比：如办房产证或注册一家公司，有时要同多个部门联系，这时要是有一个综合部门能解决一切手续问题就好了。外观模式就是在软件层面做这样的事</p>
</blockquote>
<ul>
<li><p>优点：</p>
<ol>
<li><p>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类</p>
</li>
<li><p>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易</p>
</li>
<li><p>降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象</p>
</li>
</ol>
</li>
<li><p>缺点：</p>
<p>增加新的子系统可能需要修改外观类或客户端的代码，违背了“开闭原则”。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// @brief 具体实现子模块</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubModuleImplementorA</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PreRequest</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SubModuleImplementorA::PreRequest!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubModuleImplementorB</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RealRequest</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SubModuleImplementorB::RealRequest!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubModuleImplementorC</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PostRequest</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SubModuleImplementorC::PostRequest!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 外观角色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Facade</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Facade</span>() &#123;</span><br><span class="line">        implA_.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">SubModuleImplementorA</span>());<span class="comment">//reset会使引用计数-1</span></span><br><span class="line">        implB_.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">SubModuleImplementorB</span>());</span><br><span class="line">        implC_.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">SubModuleImplementorC</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        implA_-&gt;<span class="built_in">PreRequest</span>();</span><br><span class="line">        implB_-&gt;<span class="built_in">RealRequest</span>();</span><br><span class="line">        implC_-&gt;<span class="built_in">PostRequest</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;SubModuleImplementorA&gt; implA_;</span><br><span class="line">    std::shared_ptr&lt;SubModuleImplementorB&gt; implB_;</span><br><span class="line">    std::shared_ptr&lt;SubModuleImplementorC&gt; implC_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test_10_facade_impl_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-------------------- %s --------------------\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Facade&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> Facade())</span></span>;</span><br><span class="line">    ptr-&gt;<span class="built_in">Request</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>📌shared_ptr的reset(new class())用法，先new出来对象，再将shared_ptr引用计数-1。因此，若之前指针只指向一个对象，-1后为0，自动析构，指针悬空，就可以指向新new出来的对象。</p>
</blockquote>
<h3 id="10-组合模式（Composite）"><a href="#10-组合模式（Composite）" class="headerlink" title="10 组合模式（Composite）"></a>10 组合模式（Composite）</h3><p>组合模式将对象<strong>组合成树状层次结构</strong>，使用户<strong>对单个对象和组合对象具有一致的访问性</strong>。</p>
<ul>
<li><p>应用场景：</p>
<p>软件开发中存在很多“部分-整体”的关系，如文件系统中的文件与文件夹等等。对这些简单对象与复合对象的处理，用组合模式来实现会比较方便。</p>
</li>
<li><p>优点：</p>
<ul>
<li><p>客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的单个对象还是组合对象，简化了客户端代码的设计；</p>
</li>
<li><p>更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源码，满足“开闭原则”。</p>
</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li><p>设计较复杂，客户端需要花更多时间理清类之间的层次关系；</p>
</li>
<li><p>不容易用继承的方法增加功能。</p>
</li>
</ul>
</li>
</ul>
<h4 id="透明式"><a href="#透明式" class="headerlink" title="透明式"></a>透明式</h4><p>抽象组件声明子类中的全部方法，所以客户端无需区别叶子对象和中间的树枝对象，对客户端透明。</p>
<blockquote>
<p>缺点在于，叶子类本不必有Add()、Remove()这样的方法，却要实现它们，从而有安全问题。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Component</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树枝节点 &amp; 叶子节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Composite</span> : <span class="keyword">public</span> Component&#123;</span><br><span class="line"></span><br><span class="line">    string name;</span><br><span class="line">    list&lt;Component*&gt; elements;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Composite</span>(<span class="type">const</span> string &amp; s) : <span class="built_in">name</span>(s) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(Component* element)</span> </span>&#123;</span><br><span class="line">        elements.<span class="built_in">push_back</span>(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(Component* element)</span></span>&#123;</span><br><span class="line">        elements.<span class="built_in">remove</span>(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. process current node</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. process leaf nodes</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : elements)</span><br><span class="line">            e-&gt;<span class="built_in">process</span>(); <span class="comment">//多态调用</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对组合对象和单个对象执行一致处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Invoke</span><span class="params">(Component &amp; c)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    c.<span class="built_in">process</span>();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="安全式"><a href="#安全式" class="headerlink" title="安全式"></a>安全式</h4><p>将管理子component的方法移到树枝component中，抽象component和叶子component没有对子component的管理方法，从而避免上一种方式的安全性问题。</p>
<blockquote>
<p>由于叶子和分支有不同的接口，因此客户端在调用时要知道叶子对象和树枝对象的存在，不再严格透明。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Component</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Composite</span> : <span class="keyword">public</span> Component&#123;</span><br><span class="line"></span><br><span class="line">    string name;</span><br><span class="line">    list&lt;Component*&gt; elements;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Composite</span>(<span class="type">const</span> string &amp; s) : <span class="built_in">name</span>(s) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(Component* element)</span> </span>&#123;</span><br><span class="line">        elements.<span class="built_in">push_back</span>(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(Component* element)</span></span>&#123;</span><br><span class="line">        elements.<span class="built_in">remove</span>(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. process current node</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. process leaf nodes</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : elements)</span><br><span class="line">            e-&gt;<span class="built_in">process</span>(); <span class="comment">//多态调用</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//叶子节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Leaf</span> : <span class="keyword">public</span> Component&#123;</span><br><span class="line">    string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Leaf</span>(string s) : <span class="built_in">name</span>(s) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//process current node</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对组合对象和单个对象执行一致处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Invoke</span><span class="params">(Component &amp; c)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    c.<span class="built_in">process</span>();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Composite <span class="title">root</span><span class="params">(<span class="string">&quot;root&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Composite <span class="title">treeNode1</span><span class="params">(<span class="string">&quot;treeNode1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Composite <span class="title">treeNode2</span><span class="params">(<span class="string">&quot;treeNode2&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Leaf <span class="title">leat1</span><span class="params">(<span class="string">&quot;left1&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    root.<span class="built_in">add</span>(&amp;treeNode1);</span><br><span class="line">    treeNode1.<span class="built_in">add</span>(&amp;treeNode2);</span><br><span class="line">    treeNode2.<span class="built_in">add</span>(&amp;leaf1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">process</span>(root);</span><br><span class="line">    <span class="built_in">process</span>(leaf1);</span><br><span class="line">    <span class="built_in">process</span>(treeNode2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-享元模式（Flyweight）"><a href="#11-享元模式（Flyweight）" class="headerlink" title="11 享元模式（Flyweight）"></a>11 享元模式（Flyweight）</h3><p>很多情况下，需要在系统中增加类和对象的个数，当对象数量太多时，将导致运行代价过高，带来性能下降等问题。享元模式针对此问题诞生，其使得相同或相似对象在重用时，共享某一个对象的内容。</p>
<p>在享元模式中可以共享的相同内容称为内部状态，而那些需要外部环境来设置的不能共享的内容称为外部状态。享元模式中通常会出现工厂模式，需创建一个享元工厂来维护一个享元池，用于存储具有相同内部状态的享元对象。</p>
<p>享元模式的优点在于，<strong>可以极大减少内存中对象的数量</strong>，使得相同对象或相似对象在内存中只保存一份</p>
<p>（Flyweight其实就是轻量级）</p>
<p><img src="/design_pattern-image/image_NoWKqwuRPL.png"></p>
<ul>
<li><p>Flyweight：抽象享元类，描述一个接口，通过这个接口Flyweight可以接受并作用于外部状态</p>
</li>
<li><p>ConcreteFlyweight：具体享元类，定义了一些内部状态。ConcreteFlyweight对象必须是可共享的</p>
</li>
<li><p>UnsharedConcreteFlyweight：非共享具体享元类</p>
</li>
<li><p>FlyweightFactory：享元工厂类，创建并管理FlyWeight。当用户请求一个Flyweight时，FlyweightFactory对象提供一个已创建的实例，如果请求的实例不存在，就新创建一个实例。</p>
</li>
</ul>
<p><img src="/design_pattern-image/image_Qpd2kj70i2.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// @brief 非享元类, 以参数的形式注入具体享元的相关方法中</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnsharableConcreteFlyweight</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnsharableConcreteFlyweight</span>(<span class="type">const</span> std::string&amp; content) : <span class="built_in">content_</span>(content) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">GetContent</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> content_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string content_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 抽象享元类, 为具体享元规范需要实现的公共接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFlyweight</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractFlyweight</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Run</span><span class="params">(UnsharableConcreteFlyweight* unsharable_content_ptr)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 具体享元类, 实现抽象享元角色中所规定的接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFlyweightA</span> : <span class="keyword">public</span> AbstractFlyweight &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Run</span><span class="params">(UnsharableConcreteFlyweight* unsharable_content_ptr)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteFlyweightA::Run!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; unsharable_content_ptr-&gt;<span class="built_in">GetContent</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFlyweightB</span> : <span class="keyword">public</span> AbstractFlyweight &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Run</span><span class="params">(UnsharableConcreteFlyweight* unsharable_content_ptr)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteFlyweightB::Run!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; unsharable_content_ptr-&gt;<span class="built_in">GetContent</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 享元工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyweightFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">FlyweightType</span> &#123;</span><br><span class="line">        ConcreteA = <span class="number">0</span>,</span><br><span class="line">        ConcreteB,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">FlyweightFactory</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = fly_weights_.<span class="built_in">begin</span>(); it != fly_weights_.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (it-&gt;second) <span class="keyword">delete</span> it-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">        fly_weights_.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">AbstractFlyweight* <span class="title">GetFlyweight</span><span class="params">(<span class="type">const</span> std::string&amp; key, <span class="type">const</span> FlyweightType&amp; type = ConcreteA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = fly_weights_.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (fly_weights_.<span class="built_in">end</span>() == it) &#123;</span><br><span class="line">            AbstractFlyweight* ptr = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span> (ConcreteA == type) &#123;</span><br><span class="line">                ptr = <span class="keyword">new</span> <span class="built_in">ConcreteFlyweightA</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ConcreteB == type) &#123;</span><br><span class="line">                ptr = <span class="keyword">new</span> <span class="built_in">ConcreteFlyweightB</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            fly_weights_[key] = ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fly_weights_[key];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::map&lt;std::string, AbstractFlyweight*&gt; fly_weights_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>main函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;UnsharableConcreteFlyweight&gt; <span class="title">unsharable_content_ptr_1</span><span class="params">(<span class="keyword">new</span> UnsharableConcreteFlyweight(<span class="string">&quot;unsharable_content_ptr_1&quot;</span>))</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;UnsharableConcreteFlyweight&gt; <span class="title">unsharable_content_ptr_2</span><span class="params">(<span class="keyword">new</span> UnsharableConcreteFlyweight(<span class="string">&quot;unsharable_content_ptr_2&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;FlyweightFactory&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> FlyweightFactory())</span></span>;</span><br><span class="line">    AbstractFlyweight* flyweight_ptr_A_red = ptr-&gt;<span class="built_in">GetFlyweight</span>(<span class="string">&quot;Red&quot;</span>);</span><br><span class="line">    AbstractFlyweight* flyweight_ptr_A_point = ptr-&gt;<span class="built_in">GetFlyweight</span>(<span class="string">&quot;Point&quot;</span>);</span><br><span class="line"></span><br><span class="line">    flyweight_ptr_A_red-&gt;<span class="built_in">Run</span>(unsharable_content_ptr_1.<span class="built_in">get</span>());</span><br><span class="line">    flyweight_ptr_A_point-&gt;<span class="built_in">Run</span>(unsharable_content_ptr_2.<span class="built_in">get</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ConcreteFlyweightA::Run!</span></span><br><span class="line"><span class="comment">// unsharable_content_ptr_1</span></span><br><span class="line"><span class="comment">// ConcreteFlyweightA::Run!</span></span><br><span class="line"><span class="comment">// unsharable_content_ptr_2</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>📌享元模式在编辑器软件中大量使用，如在一个文档中多次出现相同的图片，则只需要创建一个图片对象，通过在应用程序中设置该图片出现的位置，可以实现该图片在不同地方多次重复显示。</p>
</blockquote>
<h2 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h2><blockquote>
<p>📌迭代器(5) &#x3D; 观察者(5) &gt; 命令(4) &#x3D; 策略(4) &gt; 职责链(3) &#x3D; 状态(3) &#x3D; 模板(3) &gt; 中介(2) &#x3D; 备忘录(2) &gt; 访问者(1) &#x3D; 解释器(1)&amp;#x20;</p>
</blockquote>
<h3 id="12-观察者模式（Observer）"><a href="#12-观察者模式（Observer）" class="headerlink" title="12 观察者模式（Observer）"></a>12 观察者模式（Observer）</h3><p>观察者模式建立对象与对象之间的一对多依赖关系。一个对象发生改变时，将自动通知其他对象，其他对象会做出相应的反应（如被自动更新）。</p>
<p>发生改变的对象称为观察目标，而被通知的对象称为观察者。</p>
<blockquote>
<p>观察者模式又被称作发布-订阅模式(Publish&#x2F;Subscribe)、模型-视图模式(Model&#x2F;View)、源-监听器模式(Source&#x2F;Listener)、从属者模式(Dependents)。</p>
</blockquote>
<p><img src="/design_pattern-image/image_zETtFplPnQ.png"></p>
<ul>
<li><p>优点：支持广播通信，符合开闭原则。可以实现表示层和数据逻辑层的分离，在观察目标和观察者之间建立一个抽象的耦合。</p>
</li>
<li><p>缺点：</p>
<ul>
<li><p>如果一个观察目标对象有很多直接和间接的观察者的话，将所有观察者都通知到会花费很多时间</p>
</li>
<li><p>如果观察者和观察目标之间有循环依赖，观察目标会触发它们之间循环调用，可能系统崩溃</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// @brief 抽象观察者, 包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractObserver</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">AbstractObserver</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被告知时做出响应</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Response</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 具体观察者, 实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteObserverA</span> : <span class="keyword">public</span> AbstractObserver &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Response</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is ConcreteObserverA::Response!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteObserverB</span> : <span class="keyword">public</span> AbstractObserver &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Response</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is ConcreteObserverB::Response!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 抽象主题类, 它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractSubject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractSubject</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">NotifyObserver</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddObserver</span><span class="params">(AbstractObserver* observer)</span> </span>&#123;</span><br><span class="line">        observers_.<span class="built_in">emplace_back</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RemoveObserver</span><span class="params">(AbstractObserver* observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = observers_.<span class="built_in">begin</span>(); it != observers_.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it) == observer) &#123;</span><br><span class="line">                observers_.<span class="built_in">erase</span>(it++);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::vector&lt;AbstractObserver*&gt; observers_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 具体主题类, 它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> : <span class="keyword">public</span> AbstractSubject &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">NotifyObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>* observer : observers_) &#123;</span><br><span class="line">            observer-&gt;<span class="built_in">Response</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;-------------------- %s --------------------\n&quot;</span>, __FUNCTION__);</span><br><span class="line">  <span class="function">std::shared_ptr&lt;AbstractSubject&gt; <span class="title">ptr_subject</span><span class="params">(<span class="keyword">new</span> ConcreteSubject())</span></span>;</span><br><span class="line">  <span class="function">std::shared_ptr&lt;AbstractObserver&gt; <span class="title">ptr_observer_A</span><span class="params">(<span class="keyword">new</span> ConcreteObserverA())</span></span>;</span><br><span class="line">  <span class="function">std::shared_ptr&lt;AbstractObserver&gt; <span class="title">ptr_observer_B</span><span class="params">(<span class="keyword">new</span> ConcreteObserverB())</span></span>;</span><br><span class="line"></span><br><span class="line">  ptr_subject-&gt;<span class="built_in">AddObserver</span>(ptr_observer_A.<span class="built_in">get</span>());</span><br><span class="line">  ptr_subject-&gt;<span class="built_in">AddObserver</span>(ptr_observer_B.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">  ptr_subject-&gt;<span class="built_in">NotifyObserver</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-模板方法（Template）"><a href="#13-模板方法（Template）" class="headerlink" title="13 模板方法（Template）"></a>13 模板方法（Template）</h3><blockquote>
<p>定义一个操作中的算法的骨架（稳定），而将一些步骤延迟（变化）到子类中</p>
</blockquote>
<p>其实模板方法顾名思义，就是定义一个抽象类，在该类中将一个算法的大致框架写好，而细节则由其派生的具体类来实现。</p>
<ul>
<li><p>应用场景：</p>
<p>在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。</p>
<p>对应于生活中的例子，可以类比写论文的过程。写论文需要提前写出提纲，确定各段的标题和整体结构，但是每小段的文字可以后面再具体写。</p>
</li>
<li><p>实现方式：</p>
<p><img src="/design_pattern-image/image_wg36lPjQXx.png"></p>
<p>抽象类负责给出一个算法的轮廓和骨架，定义两种类型的方法</p>
<ol>
<li><p>模板方法：定义在抽象类中的，把基本操作方法组合在一起形成总算法或总行为的方法。</p>
<p>子类会不加修改地完全继承这个方法。</p>
</li>
<li><p>基本方法：</p>
<ul>
<li><p>抽象方法（延迟的内容）：在抽象类中声明，由具体子类实现</p>
</li>
<li><p>具体方法（骨架）：在抽象类中已实现，具体子类中可以继承或重写它</p>
</li>
<li><p>钩子方法：抽象类中已实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> template_method &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 抽象类, 给出一个算法的轮廓和骨架</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractClass</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// @brief 模板方法, 定义了算法的骨架，按某种顺序调用其包含的基本方法</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">TemplateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">SpecificMethodA</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">HookMethodB</span>()) &#123;</span><br><span class="line">            <span class="built_in">HookMethodA</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">AbstractMethod</span>();</span><br><span class="line">        <span class="built_in">SpecificMethodB</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">/// @brief 基本方法, 可以有三种</span></span><br><span class="line">    <span class="comment">///             - 抽象方法：在抽象类中申明，由具体子类实现</span></span><br><span class="line">    <span class="comment">///             - 具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它</span></span><br><span class="line">    <span class="comment">///             - 钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AbstractMethod</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SpecificMethodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is AbstractClass::SpecificMethodA!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SpecificMethodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is AbstractClass::SpecificMethodB!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">HookMethodA</span><span class="params">()</span> </span>&#123;    <span class="comment">// 通常为空实现</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is AbstractClass::HookMethodA!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">HookMethodB</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 具体类, 实现抽象类中所定义的抽象方法和钩子方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteClass</span> : <span class="keyword">public</span> AbstractClass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AbstractMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is ConcreteClass::AbstractMethod!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SpecificMethodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is ConcreteClass::SpecificMethodB!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">HookMethodA</span><span class="params">()</span> </span>&#123;    <span class="comment">// 通常为空实现</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is ConcreteClass::HookMethodA!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">HookMethodB</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace template_method</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test_13_composite_impl_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-------------------- %s --------------------\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    template_method::AbstractClass* ptr = <span class="keyword">new</span> template_method::<span class="built_in">ConcreteClass</span>();</span><br><span class="line">    ptr-&gt;<span class="built_in">TemplateMethod</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>优点：</p>
<ol>
<li><p><strong>封装了不变部分，扩展可变部分</strong>。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。</p>
</li>
<li><p>在父类中提取了公共的部分代码，便于代码复用。</p>
</li>
<li><p>部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，<strong>符合开闭原则</strong>。</p>
</li>
</ol>
</li>
<li><p>缺点：</p>
<ol>
<li>对每个不同的实现都需要定义一个子类，这会导致<strong>类的个数增加</strong>，系统更加庞大，设计也更加抽象</li>
</ol>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>📌一般推荐将三种基本方法设置为protected<br>模板方法中，存在由子类影响父类的反向控制，是“控制反转”的典型应用</p>
</blockquote>
<h3 id="14-策略模式（Strategy-x2F-Policy）"><a href="#14-策略模式（Strategy-x2F-Policy）" class="headerlink" title="14 策略模式（Strategy&#x2F;Policy）"></a>14 策略模式（Strategy&#x2F;Policy）</h3><p>软件开发中往往会遇到这样的情况：实现某一个功能有多个途径。而这些不同的方式均被称为策略，每一种方式就是一个策略。</p>
<p>比如实现一个负责查找任务的类，而查找有若干种算法，在类中每一个方法对应着一种算法。或者将所有的算法都封装进一个方法中，通过输入参数和if…else…来判定具体使用何种查找算法。这两种方式都属于硬编码（hard coding），是不推荐的。</p>
<p>原因在于，每增加一种新的查找算法，就需要修改封装算法类的源代码；而且更换查找算法时，也需要修改客户端的调用代码。如果算法类中封装了大量算法，那么该类的代码会比较复杂，维护较为困难。</p>
<p>策略模式旨在解决这样的问题（可以记忆为，解决代码中的大量if…else…），其将众多策略都写成一个类，利用抽象策略类为用户提供接口。同时，让一个Context类（环境类）来耦合客户端和算法类，提供setStrategy用于更换算法，并进行统一语义的执行</p>
<p><img src="/design_pattern-image/image_6PaWAnTsVZ.png"></p>
<ul>
<li><p>Context：环境类</p>
</li>
<li><p>Strategy：抽象策略类</p>
</li>
<li><p>ConcreteStrategy：具体策略类</p>
</li>
</ul>
<p><img src="/design_pattern-image/image_OPxig-n88x.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// @brief 抽象策略类, 定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractStrategy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractStrategy</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">StrategyMethod</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 具体策略类, 实现了抽象策略定义的接口，提供具体的算法实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span> : <span class="keyword">public</span> AbstractStrategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">StrategyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is ConcreteStrategyA::StrategyMethod!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyB</span> : <span class="keyword">public</span> AbstractStrategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">StrategyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is ConcreteStrategyB::StrategyMethod!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 环境类, 持有一个策略类的引用，最终给客户端调用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetStrategy</span><span class="params">(AbstractStrategy* strategy)</span> </span>&#123;</span><br><span class="line">        strategy_ = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">StrategyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strategy_) strategy_-&gt;<span class="built_in">StrategyMethod</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    AbstractStrategy* strategy_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    AbstractStrategy* ptr_strategy_A = <span class="keyword">new</span> <span class="built_in">ConcreteStrategyA</span>();</span><br><span class="line">    AbstractStrategy* ptr_strategy_B = <span class="keyword">new</span> <span class="built_in">ConcreteStrategyB</span>();</span><br><span class="line"></span><br><span class="line">    Context env_;</span><br><span class="line">    env_.<span class="built_in">SetStrategy</span>(ptr_strategy_A);</span><br><span class="line">    env_.<span class="built_in">StrategyMethod</span>();</span><br><span class="line"></span><br><span class="line">    env_.<span class="built_in">SetStrategy</span>(ptr_strategy_B);</span><br><span class="line">    env_.<span class="built_in">StrategyMethod</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> ptr_strategy_A;</span><br><span class="line">    <span class="keyword">delete</span> ptr_strategy_B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>优点：</p>
<ul>
<li><p>符合开闭原则，用户可以在不修改原有系统的基础上选择算法行为，也可以灵活地增加新的算法或行为</p>
</li>
<li><p>避免多重条件语句</p>
</li>
<li><p>提供了管理相关的算法族的办法</p>
</li>
</ul>
</li>
<li><p>缺点：</p>
<p>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</p>
</li>
</ul>
<h3 id="15-职责链模式（Chain-of-Responsibility）"><a href="#15-职责链模式（Chain-of-Responsibility）" class="headerlink" title="15 职责链模式（Chain of Responsibility）"></a>15 职责链模式（Chain of Responsibility）</h3><p>考虑这样的例子：企业的采购审批是一般是分级进行的，即根据采购金额的不同由不同层次的主管人员来审批。主任可以审批5万元以下的采购单，副董事长可以审批5万元至10万元的采购单，董事长可以审批10万元至50万元的采购单，50万元及以上的采购单就需要开董事会讨论决定。</p>
<p>那么一个自动化的审批类可以写成如下形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PurchaseRequestHandler</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handlePurchaseRequest</span><span class="params">(<span class="type">const</span> PurchaseRequest&amp; request)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> amount = request.<span class="built_in">getAmount</span>();</span><br><span class="line">        <span class="keyword">if</span>(amount &lt; <span class="number">50000</span>) &#123; <span class="keyword">this</span>-&gt;<span class="built_in">handleByDirector</span>(request); &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(amount &lt; <span class="number">100000</span>) &#123; <span class="keyword">this</span>-&gt;<span class="built_in">handleByVicePresident</span>(request); &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(amount &lt; <span class="number">500000</span>) &#123; <span class="keyword">this</span>-&gt;<span class="built_in">handleByPresident</span>(request); &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="keyword">this</span>-&gt;<span class="built_in">handleByCongress</span>(request); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 主任审批采购单</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleByDirector</span><span class="params">(<span class="type">const</span> PurchaseRequest&amp; request)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 副董事长审批采购单</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleByVicePresident</span><span class="params">(<span class="type">const</span> PurchaseRequest&amp; request)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 董事长审批采购单</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleByPresident</span><span class="params">(<span class="type">const</span> PurchaseRequest&amp; request)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 董事会审批采购单</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleByCongress</span><span class="params">(<span class="type">const</span> PurchaseRequest&amp; request)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是仔细审视这段代码的话，首先，它违反了单一职责原则，各个级别的审批方法都集中在一个类中，测试和维护难度大。同时不够灵活，现有审批流程从“主任→副董→董事长→董事会”改为“主任→董事长→董事会”，就必须修改类的源代码。</p>
<blockquote>
<p>职责链模式面向的场景：一个请求有多个对象可以处理，但是每个对象的处理条件或权限不同。</p>
</blockquote>
<p>职责链负责解决这样的问题，将每一级写成对象后，排成一个链表。而每一级的执行顺序，交由客户端来管理。</p>
<p><img src="/design_pattern-image/image_764XUH49fC.png"></p>
<p><img src="/design_pattern-image/image_XcWdMEsFCy.png"></p>
<ul>
<li><p>Handler：抽象处理者，successor负责对下一级的引用，通过successor，处理者们可以连成一条链</p>
</li>
<li><p>ConcreteHandler：具体处理者，继承抽象处理者，负责具体实现对请求的响应。</p>
</li>
</ul>
<p>职责链模式代码模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象处理者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSuccessor</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;Handler&gt;&amp; successor)</span> </span>&#123;</span><br><span class="line">        successor_ = successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handleRequest</span><span class="params">(<span class="type">const</span> Request&amp; request)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::shared_ptr&lt;Handler&gt; successor_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体处理者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteHandler</span> : <span class="keyword">public</span> Handler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleRequest</span><span class="params">(<span class="type">const</span> Request&amp; request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="comment">/*满足某个条件*/</span>) &#123; </span><br><span class="line">            <span class="comment">// TO DO </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; successor_-&gt;<span class="built_in">handleRequest</span>(request); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>📌职责链模式更细分的话也有两种：纯职责链和非纯职责链<br>纯职责链中，每一级直接完全承担对请求的响应；<br>非纯职责链中，每一级承担部分响应工作。</p>
</blockquote>
<p>针对上面的例子，使用职责链模式修改的结果如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 采购请求处理类：抽象处理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PurchaseRequestHandler</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSuccessor</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;PurchaseRequestHandler&gt;&amp; successor)</span> </span>&#123;</span><br><span class="line">        successor_ = successor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handlePurchaseRequest</span><span class="params">(<span class="type">const</span> PurchaseRequest&amp; request)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::shared_ptr&lt;PurchaseRequestHandler&gt; successor_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主任类：具体处理者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DirectorHandler</span> : <span class="keyword">public</span> PurchaseRequestHandler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handlePurchaseRequest</span><span class="params">(<span class="type">const</span> PurchaseRequest&amp; request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(request.<span class="built_in">getAmount</span>() &lt; <span class="number">50000</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; successor_-&gt;<span class="built_in">handlePurchaseRequest</span>(request); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">... ...</span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line">PurchaseRequest request;</span><br><span class="line">request.<span class="built_in">setAmount</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;PurchaseRequestHandler&gt; director = std::<span class="built_in">make_shared</span>&lt;DirectorHandler&gt;();</span><br><span class="line">std::shared_ptr&lt;PurchaseRequestHandler&gt; vicePresident = std::<span class="built_in">make_shared</span>&lt;VicePresidentHandler&gt;();</span><br><span class="line">std::shared_ptr&lt;PurchaseRequestHandler&gt; president = std::<span class="built_in">make_shared</span>&lt;PresidentHandler&gt;();</span><br><span class="line">std::shared_ptr&lt;PurchaseRequestHandler&gt; congress = std::<span class="built_in">make_shared</span>&lt;CongressHandler&gt;();</span><br><span class="line">director-&gt;<span class="built_in">setSuccessor</span>(vicePresident);</span><br><span class="line">vicePresident-&gt;<span class="built_in">setSuccessor</span>(president);</span><br><span class="line">president-&gt;<span class="built_in">setSuccessor</span>(congress);</span><br><span class="line"></span><br><span class="line">director-&gt;<span class="built_in">handlePurchaseRequest</span>(request);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>优点：</p>
<ul>
<li><p>由客户端负责职责链的创建，链中对象不需要知道链的结构，降低了系统耦合度</p>
</li>
<li><p>灵活性更强，添加一个新的具体请求处理者时无需更改原有系统的代码，只需要在客户端重新建链即可，符合开闭原则。</p>
</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li><p>可能会出现循环引用的问题，导致系统进入死循环</p>
</li>
<li><p>系统性能受到一定影响，代码调试时不太方便</p>
</li>
<li><p>由于一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理。</p>
</li>
</ul>
</li>
</ul>
<h3 id="16-状态模式（State）"><a href="#16-状态模式（State）" class="headerlink" title="16 状态模式（State）"></a>16 状态模式（State）</h3><p>状态模式将各种可能的行为构建成了状态机，每次请求时自动切换状态（更改行为）。</p>
<ul>
<li><p>应用场景：</p>
<p>在软件开发过程中，<strong>应用程序中的有些对象可能会根据不同的情况做出不同的行为</strong>，我们把这种对象称为有状态的对象，而把影响对象行为的一个或多个动态变化的属性称为状态。当有状态的对象与外部事件产生互动时，其内部状态会发生改变，从而使得其行为也随之发生改变。如人的情绪有高兴的时候和伤心的时候，不同的情绪有不同的行为，当然外界也会影响其情绪变化。</p>
</li>
<li><p>状态模式流程：</p>
<p>传统方案可能会选择用if…else…来进行分支，涵盖所有的行为。这样的话不符合开闭原则不易维护扩展。状态模式将每种状态及其行为封装成了具体状态类ConcreteState，而所有的具体状态类继承自抽象状态类。用户与Context类交互，Context记录着当前系统的状态，当用户请求时，Context对象将根据当前状态调用具体状态类的行为，同时根据发生的行为更改自己维护的状态，以供下一次请求使用。本质上，在类之间建立状态机，而状态转换的规则维护在了各个具体状态类中。</p>
</li>
</ul>
<p><img src="/design_pattern-image/image_hN2yH2ASOc.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Context</span>()&#123;</span><br><span class="line">    m_pState = ConcreteStateA::<span class="built_in">Instance</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Context</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">changeState</span><span class="params">(State * st)</span></span>&#123;</span><br><span class="line">    m_pState = st;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">request</span><span class="params">()</span></span>&#123;</span><br><span class="line">    m_pState-&gt;<span class="built_in">handle</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  State *m_pState;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStateA</span> : <span class="keyword">public</span> State</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">ConcreteStateA</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> State * <span class="title">Instance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="literal">NULL</span> == m_pState)</span><br><span class="line">    &#123;</span><br><span class="line">      m_pState = <span class="keyword">new</span> <span class="built_in">ConcreteStateA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_pState;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handle</span><span class="params">(Context * c)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;doing something in State A.\n done,change state to B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    c-&gt;<span class="built_in">changeState</span>(ConcreteStateB::<span class="built_in">Instance</span>());</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">ConcreteStateA</span>();</span><br><span class="line">  <span class="type">static</span> State * m_pState;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> a = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="string">&#x27;0&#x27;</span> == a)</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;no&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  Context * c = <span class="keyword">new</span> <span class="built_in">Context</span>();</span><br><span class="line">  c-&gt;<span class="built_in">request</span>();</span><br><span class="line">  c-&gt;<span class="built_in">request</span>();</span><br><span class="line">  c-&gt;<span class="built_in">request</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> c;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>优点：</p>
<p>相比于if…else…进行状态变更与判断，状态模式符合单一职责原则，而且开闭原则也支持得更好一些。</p>
</li>
<li><p>缺点：</p>
<p>对开闭原则仍然不是很友好，想扩展新状态就必须修改若干具体状态类的源码，修改行为也需要修改对应的源码。因此需要开发者尽可能事先考虑到所有的可能状态。</p>
</li>
</ul>
<h3 id="17-迭代器模式（Iterator）"><a href="#17-迭代器模式（Iterator）" class="headerlink" title="17 迭代器模式（Iterator）"></a>17 迭代器模式（Iterator）</h3><p>迭代器提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</p>
<p><img src="/design_pattern-image/image_LPlCPfrZ0o.png"></p>
<ul>
<li><p>优点：</p>
<ul>
<li><p>访问一个聚合对象的内容而无需暴露它的内部表示</p>
</li>
<li><p>遍历任务交由迭代器完成，简化了聚合类（聚合类可以不用操心实现迭代的功能）</p>
</li>
<li><p>支持以不同的方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历</p>
</li>
<li><p>增加新的聚合类和迭代器类都很方便，无需修改原有代码</p>
</li>
<li><p>封装性良好，为遍历不同的聚合结构提供一个统一的接口</p>
</li>
</ul>
</li>
</ul>
<p>C++的STL自带了Iterator，无需再手动实现。然而为了能够更直观的看迭代器模式是怎么操作的，这里简单写了一下：</p>
<ul>
<li>Aggregate</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Aggregate</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">count</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> std::string&amp; strValue)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">virtual</span> std::string <span class="keyword">operator</span>[](<span class="type">int</span> nIndex) = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Iterator* <span class="title">createIterator</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteAggregate</span> :</span><br><span class="line">  <span class="keyword">public</span> Aggregate</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ~<span class="built_in">ConcreteAggregate</span>();</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> std::string&amp; strValue)</span><span class="keyword">override</span></span>;</span><br><span class="line">  <span class="comment">//重载下标运算符，只重载了取值功能</span></span><br><span class="line">  std::string <span class="keyword">operator</span>[](<span class="type">int</span> nIndex);</span><br><span class="line">  <span class="function">Iterator* <span class="title">createIterator</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::vector&lt;std::string&gt; m_vecItems;</span><br><span class="line">  Iterator* m_pIterator&#123; <span class="literal">nullptr</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ConcreteAggregate::~<span class="built_in">ConcreteAggregate</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nullptr</span> != m_pIterator)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">delete</span> m_pIterator;</span><br><span class="line">    m_pIterator = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ConcreteAggregate::count</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> m_vecItems.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConcreteAggregate::push</span><span class="params">(<span class="type">const</span> std::string&amp; strValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  m_vecItems.<span class="built_in">push_back</span>(strValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::string ConcreteAggregate::<span class="keyword">operator</span>[](<span class="type">int</span> nIndex)</span><br><span class="line">&#123;</span><br><span class="line">  std::string strRet;</span><br><span class="line">  <span class="keyword">if</span> (nIndex &lt; <span class="built_in">count</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    strRet = m_vecItems[nIndex];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> strRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Iterator* <span class="title">ConcreteAggregate::createIterator</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nullptr</span> == m_pIterator)</span><br><span class="line">  &#123;</span><br><span class="line">    m_pIterator = <span class="keyword">new</span> <span class="built_in">ConcreteIterator</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> m_pIterator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Iterator</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Iterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::string <span class="title">first</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::string <span class="title">next</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">isDone</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::string <span class="title">currentItem</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteIterator</span> :</span><br><span class="line">  <span class="keyword">public</span> Iterator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ConcreteIterator</span>(Aggregate* pAggregate);</span><br><span class="line">  <span class="function">std::string <span class="title">first</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">std::string <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">std::string <span class="title">currentItem</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Aggregate* m_pAggregate&#123; <span class="literal">nullptr</span> &#125;;</span><br><span class="line">  <span class="type">int</span> m_nCurrent&#123; <span class="number">0</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ConcreteIterator::<span class="built_in">ConcreteIterator</span>(Aggregate* pAggregate)</span><br><span class="line">  :<span class="built_in">Iterator</span>(), <span class="built_in">m_pAggregate</span>(pAggregate)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">ConcreteIterator::first</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (*m_pAggregate)[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">ConcreteIterator::next</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::string strRet;</span><br><span class="line">  m_nCurrent++;</span><br><span class="line">  <span class="keyword">if</span> (m_nCurrent &lt; m_pAggregate-&gt;<span class="built_in">count</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    strRet = (*m_pAggregate)[m_nCurrent];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> strRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ConcreteIterator::isDone</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (m_nCurrent &gt;= m_pAggregate-&gt;<span class="built_in">count</span>()) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">ConcreteIterator::currentItem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (*m_pAggregate)[m_nCurrent];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>client</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">client</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ConcreteAggregate* pName = <span class="keyword">new</span> <span class="built_in">ConcreteAggregate</span>();</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nullptr</span> != pName)</span><br><span class="line">  &#123;</span><br><span class="line">    pName-&gt;<span class="built_in">push</span>(<span class="string">&quot;墨白&quot;</span>);</span><br><span class="line">    pName-&gt;<span class="built_in">push</span>(<span class="string">&quot;金戈铁马&quot;</span>);</span><br><span class="line">    pName-&gt;<span class="built_in">push</span>(<span class="string">&quot;气吞万里如虎&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Iterator* iter = pName-&gt;<span class="built_in">createIterator</span>();</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nullptr</span> != iter)</span><br><span class="line">  &#123;</span><br><span class="line">    std::string strItem = iter-&gt;<span class="built_in">first</span>();</span><br><span class="line">    <span class="keyword">while</span> (!iter-&gt;<span class="built_in">isDone</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      std::cout &lt;&lt; iter-&gt;<span class="built_in">currentItem</span>() &lt;&lt; std::endl;</span><br><span class="line">      iter-&gt;<span class="built_in">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;================================&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pName-&gt;<span class="built_in">count</span>(); ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; (*pName)[i] &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18-访问者模式（Visitor）"><a href="#18-访问者模式（Visitor）" class="headerlink" title="18 访问者模式（Visitor）"></a>18 访问者模式（Visitor）</h3><blockquote>
<p>访问者模式表示一个作用于某对象结构中各元素的操作，它使我们可以在不改变各元素的类的前提下，定义作用于这些元素的新操作。</p>
</blockquote>
<ul>
<li><p>应用场景：</p>
<p>某对象结构中，各元素的类型可能不一致，而上层需要一个对各元素具体操作的统一接口。</p>
</li>
</ul>
<p><img src="/design_pattern-image/image_MkjMugjdg_.png"></p>
<ul>
<li><p>Visitor：抽象访问者，为ObjectStructure类中每一个元素声明一个访问操作。</p>
</li>
<li><p>ConcreteVisitor：具体访问者，针对集合中的各具体类型，定义具体访问操作。</p>
</li>
<li><p>Element：抽象元素，即集合中的所有具体元素均继承自该抽象元素类，定义了一个accpet( )方法，方法以一个抽象访问者作为参数。</p>
</li>
<li><p>ConcreteElement：具体元素，实现了Accpet( )方法。接收不同的ConcreteVisitor对象作为参数，就表示在使用不同的集合元素操作方式。</p>
</li>
<li><p>ObjectStructure：元素的集合，各元素可能属于不同类型，类提供了遍历其内部元素的方法。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteElementA</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteElementB</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*抽象访问者  声明了访问元素对象的方法，通常为每一种类型的元素对象都提供一个访问方法*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Visitor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">VisitConcreteElementA</span><span class="params">(ConcreteElementA *pElementA)</span> </span>= <span class="number">0</span>;</span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">VisitConcreteElementB</span><span class="params">(ConcreteElementB *pElementB)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*具体访问者 用于定义对不同类型元素对象的操作*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteVisitor1</span> : <span class="keyword">public</span> Visitor</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">VisitConcreteElementA</span><span class="params">(ConcreteElementA *pElementA)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 现在根据传进来的pElementA，可以对ConcreteElementA中的element进行操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">VisitConcreteElementB</span><span class="params">(ConcreteElementB *pElementB)</span></span>&#123;</span><br><span class="line">         <span class="comment">// 现在根据传进来的pElementB，可以对ConcreteElementB中的element进行操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*具体访问者2*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteVisitor2</span> : <span class="keyword">public</span> Visitor</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">VisitConcreteElementA</span><span class="params">(ConcreteElementA *pElementA)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">VisitConcreteElementB</span><span class="params">(ConcreteElementB *pElementB)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*抽象元素类 声明accept()方法，用于接受访问者的访问*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Element</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Accept</span><span class="params">(Visitor *pVisitor)</span> </span>= <span class="number">0</span>;<span class="comment">//accept用于接受访问者的访问</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*具体元素类 通过调用Visitor类的visit()方法实现对元素的访问*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteElementA</span> : <span class="keyword">public</span> Element</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">Accept</span><span class="params">(Visitor *pVisitor)</span><span class="comment">//通过调用visitor对象的 visit()方法实现对元素对象的访问</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pVisitor-&gt;<span class="built_in">VisitConcreteElementA</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*具体元素类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteElementB</span> : <span class="keyword">public</span> Element</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">Accept</span><span class="params">(Visitor *pVisitor)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">     pVisitor-&gt;<span class="built_in">VisitConcreteElementB</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ObjectStructure类(对象结构类)，能枚举它的元素，可以提供一个高层的接口以允许访问者访问它的元素</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectStructure</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">Attach</span><span class="params">(Element *pElement)</span></span>&#123;</span><br><span class="line">         elements.<span class="built_in">push_back</span>(pElement);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">Detach</span><span class="params">(Element *pElement)</span>   </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">         vector&lt;Element *&gt;::iterator it = <span class="built_in">find</span>(elements.<span class="built_in">begin</span>(), elements.<span class="built_in">end</span>(), pElement);</span><br><span class="line">         <span class="keyword">if</span> (it != elements.<span class="built_in">end</span>())</span><br><span class="line">         &#123;</span><br><span class="line">              elements.<span class="built_in">erase</span>(it);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">Accept</span><span class="params">(Visitor *pVisitor)</span></span>&#123;</span><br><span class="line">     <span class="comment">// 为每一个element设置visitor，进行对应的操作</span></span><br><span class="line">         <span class="keyword">for</span> (vector&lt;Element *&gt;::const_iterator it = elements.<span class="built_in">begin</span>(); it != elements.<span class="built_in">end</span>(); ++it)</span><br><span class="line">         &#123;</span><br><span class="line">              (*it)-&gt;<span class="built_in">Accept</span>(pVisitor);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">//实例化对象结构，用于存放元素对象，提供遍历其内部元素的方法</span></span><br><span class="line">     ObjectStructure *pObject = <span class="keyword">new</span> ObjectStructure;</span><br><span class="line">      <span class="comment">//实例化具体元素 并将创建好的元素放入对象结构中</span></span><br><span class="line">     ConcreteElementA *pElementA = <span class="keyword">new</span> ConcreteElementA;</span><br><span class="line">     ConcreteElementB *pElementB = <span class="keyword">new</span> ConcreteElementB;</span><br><span class="line">     pObject-&gt;<span class="built_in">Attach</span>(pElementA);</span><br><span class="line">     pObject-&gt;<span class="built_in">Attach</span>(pElementB);</span><br><span class="line">     <span class="comment">//实例化访问者</span></span><br><span class="line">     ConcreteVisitor1 *pVisitor1 = <span class="keyword">new</span> ConcreteVisitor1;</span><br><span class="line">     ConcreteVisitor2 *pVisitor2 = <span class="keyword">new</span> ConcreteVisitor2;</span><br><span class="line">     <span class="comment">//调用accept方法 来接受访问者对象的访问</span></span><br><span class="line">     pObject-&gt;<span class="built_in">Accept</span>(pVisitor1);</span><br><span class="line">     pObject-&gt;<span class="built_in">Accept</span>(pVisitor2);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (pVisitor2) <span class="keyword">delete</span> pVisitor2;</span><br><span class="line">     <span class="keyword">if</span> (pVisitor1) <span class="keyword">delete</span> pVisitor1;</span><br><span class="line">     <span class="keyword">if</span> (pElementB) <span class="keyword">delete</span> pElementB;</span><br><span class="line">     <span class="keyword">if</span> (pElementA) <span class="keyword">delete</span> pElementA;</span><br><span class="line">     <span class="keyword">if</span> (pObject) <span class="keyword">delete</span> pObject;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>优点：</p>
<p>将数据结构和作用于数据结构之上的操作之间的耦合解开，使得操作数据结构集合可以相对自由的演化。换言之，如果系统的数据结构稳定的话，使用访问者模式使得算法更改或者增加变得很容易，只需添加新的具体访问者类即可。</p>
<p>符合单一职责原则，访问者模式把相关的行为封装在一起，使每一个访问者的功能都比较单一。</p>
</li>
<li><p>缺点：</p>
<p>虽然扩展面向数据结构的算法会比较容易，但是增加新的元素类会变得困难。每增加一个新的元素类都意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者中增加相应的具体操作，违背了开闭原则。</p>
<p>违反了依赖倒置原则，访问者模式依赖了具体类，而没有依赖抽象类。</p>
</li>
</ul>
<h3 id="19-备忘录模式（Memento）"><a href="#19-备忘录模式（Memento）" class="headerlink" title="19 备忘录模式（Memento）"></a>19 备忘录模式（Memento）</h3><blockquote>
<p><code>Memento</code> 在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它</p>
</blockquote>
<p>以打游戏为例，当通过一关时往往会选择存档，下次再玩时就可以从存档的地方开始，而不需要从头开玩。这里就用到了备忘录模式，通过记录状态，而避免不必要的重复劳动。</p>
<p>很多应用软件都提供了这项功能，如 Word、记事本、Photoshop、Eclipse 等软件在编辑时按 Ctrl+Z 组合键时能撤销当前操作，使文档恢复到之前的状态；还有在 IE 中的后退键、数据库事务管理中的回滚操作、玩游戏时的中间结果存档功能、数据库与操作系统的备份操作、棋类游戏中的悔棋功能等都属于这类。</p>
<p><img src="/design_pattern-image/image_E09UNJ-ffJ.png"></p>
<ul>
<li>实现代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memento</span> &#123; <span class="comment">// 备忘录</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string state;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Memento</span>(string s) &#123; state = s; &#125;</span><br><span class="line">    <span class="function">string <span class="title">GetState</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> state; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetState</span><span class="params">(string s)</span> </span>&#123; state = s; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Caretaker</span> &#123; <span class="comment">// 管理者</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Memento* menento;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Caretaker(Memento* m) &#123; menento = m; &#125;</span></span><br><span class="line">    <span class="function">Memento* <span class="title">GetMemento</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> menento; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetMemento</span><span class="params">(Memento* m)</span> </span>&#123; menento = m; &#125;</span><br><span class="line">    ~<span class="built_in">Caretaker</span>() &#123; <span class="keyword">delete</span> menento; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Originator</span> &#123; <span class="comment">// 发起人</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string state; <span class="comment">// 需要保存的属性</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">GetState</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> state; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetState</span><span class="params">(string s)</span> </span>&#123; state = s; &#125;</span><br><span class="line">    <span class="function">Memento* <span class="title">CreateMemento</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Memento</span>(state); &#125; <span class="comment">// 创建备忘录对象，保存信息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetMemento</span><span class="params">(Memento* m)</span> </span>&#123; state = m-&gt;<span class="built_in">GetState</span>(); &#125;  <span class="comment">// 恢复备忘录</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;state: &quot;</span> &lt;&lt; state &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Originator* o = <span class="keyword">new</span> <span class="built_in">Originator</span>();</span><br><span class="line">    o-&gt;<span class="built_in">SetState</span>(<span class="string">&quot;On&quot;</span>);</span><br><span class="line">    o-&gt;<span class="built_in">Show</span>();   <span class="comment">// state: On</span></span><br><span class="line"></span><br><span class="line">    Caretaker* c = <span class="keyword">new</span> <span class="built_in">Caretaker</span>();</span><br><span class="line">    c-&gt;<span class="built_in">SetMemento</span>(o-&gt;<span class="built_in">CreateMemento</span>());   <span class="comment">// 保存状态</span></span><br><span class="line"></span><br><span class="line">    o-&gt;<span class="built_in">SetState</span>(<span class="string">&quot;Off&quot;</span>);</span><br><span class="line">    o-&gt;<span class="built_in">Show</span>();   <span class="comment">// state: Off</span></span><br><span class="line"></span><br><span class="line">    o-&gt;<span class="built_in">SetMemento</span>(c-&gt;<span class="built_in">GetMemento</span>()); <span class="comment">// 恢复初始状态</span></span><br><span class="line">    o-&gt;<span class="built_in">Show</span>();   <span class="comment">// state: On</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> o;</span><br><span class="line">    <span class="keyword">delete</span> c;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>优点：</p>
<ul>
<li><p>提供了一种可以恢复状态的机制。<strong>当用户需要时能够比较方便地将数据恢复到某个历史的状态</strong>。</p>
</li>
<li><p>实现了内部状态的封装。<strong>除了创建它的发起人之外，其他对象都不能够访问这些状态信息</strong>。</p>
</li>
<li><p><strong>发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合</strong>。</p>
</li>
</ul>
</li>
<li><p>缺点：</p>
<p>资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。</p>
</li>
</ul>
<h3 id="20-命令模式（Command）"><a href="#20-命令模式（Command）" class="headerlink" title="20 命令模式（Command）"></a>20 命令模式（Command）</h3><blockquote>
<p>将一个请求封装成一个对象，使<strong>发出请求的责任和执行请求的责任分割开</strong>。</p>
</blockquote>
<p>以12306应用为例：</p>
<ul>
<li><p>紧耦合：老版本的12306网站，买票时可以不停地用鼠标点击12306网站上的购票按钮来抢票。对于每一次点击，服务器都要进行处理，做出响应，来告诉用户有没有买到票，这样的话会出现很多次无效的点击，增加了服务器的负担。</p>
<p>此时，发出请求和执行请求，二者进入了紧耦合的状态。用户（命令发送者）通过按钮（具体命令）来买票（12306网站服务器成为命令接收者）。</p>
</li>
<li><p>松耦合：新版本的12306网站引入了购票队列机制。当点击购票按钮后，购票请求就进入了相应的购票队列，进入后再次鼠标点击购票时，12306会拒绝新的购票请求，并且告诉用户已经进入了购票队列。处于购票队列的用户也可以选择退出购票队列去购买其他车次的车票。这样就可以有效地减少购票者发送多次无效购票请求的情况。</p>
<p>观察这样的改进方案，可以发现，将前面的发出请求和执行请求解耦了。用户点击按钮后发出请求，请求进入了队列中，此时<strong>队列成为了后面流程下具体的请求发送者</strong>，不同的请求对应了不同的命令。不同命令需要采取不同的动作，动作是由接收者（服务器）做出的，因此将这些动作都封装成类之后，就可以与相应的命令类绑定。而队列发出请求后，先找到相应的命令，再由命令执行绑定的接收者的动作。命令中可以结合备忘录模式记录状态，而队列里可以实现消除无效点击的代码。</p>
<p>也就是说，核心在请求的发送者和请求的执行者之间增加了“命令”和新的“请求管理者”，以解耦二者。命令便于对功能进行扩展。如果想有新的按钮功能，实现新的具体命令类即可，同时具体命令类中可以记录状态，这样请求管理者就方便做撤销、重做等操作。</p>
</li>
</ul>
<p><strong>应用场景</strong>：</p>
<p>软件开发系统中，常常出现“方法的请求者”与“方法的实现者”之间存在紧密的耦合关系，不利于软件功能的扩展与维护。比如，想对行为进行“撤销、重做、记录”等处理都不方便。</p>
<p>命令模式旨在将“请求者”和“实现者”解耦，通过在二者之间增加“命令”。命令中可以记录状态，进行撤销等操作。想要扩展功能，也就可以实现新的具体命令类或新的具体接收者类。</p>
<p><img src="/design_pattern-image/image_FzbBrhJfAw.png"></p>
<ul>
<li><p>Command：抽象命令类，声明响应请求时待执行操作的接口。</p>
</li>
<li><p>ConcreteCommand：具体命令类，绑定一个接收者，通过让接收者做出动作来执行命令。</p>
<p>&amp;#x20;Execute方法来调用相应的Receiver对象，从而响应请求。也可以实现其他方法来扩展此命令下的可选操作。</p>
</li>
<li><p>Invoker：与客户端直接相关，请求的发送者或者请求的管理者。</p>
</li>
<li><p>Receiver：真正的接收者，实现响应请求需要做的动作。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// @brief 抽象命令类, 声明执行命令的接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractCommand</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractCommand</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Execute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 命令接收者, 执行命令功能的相关操作，是具体命令对象业务的真正实现者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Receiver</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is Receiver::Action!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 具体命令类, 它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCommand</span> : <span class="keyword">public</span> AbstractCommand &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteCommand</span>() &#123;</span><br><span class="line">        receiver_.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Receiver</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver_-&gt;<span class="built_in">Action</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;Receiver&gt; receiver_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 命令请求者, 请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Invoker</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Invoker</span>(AbstractCommand* cmd) : <span class="built_in">cmd_</span>(cmd) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetCommand</span><span class="params">(AbstractCommand* cmd)</span> </span>&#123;</span><br><span class="line">        cmd_ = cmd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cmd_-&gt;<span class="built_in">Execute</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    AbstractCommand* cmd_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>main函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">std::shared_ptr&lt;AbstractCommand&gt; <span class="title">cmd</span><span class="params">(<span class="keyword">new</span> ConcreteCommand())</span></span>;</span><br><span class="line">  <span class="function">Invoker <span class="title">client</span><span class="params">(cmd.get())</span></span>;</span><br><span class="line">  client.<span class="built_in">Request</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>优点：</p>
<ul>
<li><p><strong>降低系统的耦合度</strong>，将调用操作的对象与实现该操作的对象解耦。</p>
</li>
<li><p><strong>增加或删除命令非常方便</strong>。增加或删除操作不会影响其他类，满足开闭原则。</p>
</li>
<li><p>可以实现宏命令。命令模式可以与组合模式结合，<strong>将多个命令装配成一个组合命令，即宏命令</strong>。</p>
</li>
<li><p><strong>方便实现Undo和Redo操作</strong>。命令模式可以与备忘录模式结合，实现命令的撤销与恢复。</p>
</li>
</ul>
</li>
</ul>
<h4 id="宏命令"><a href="#宏命令" class="headerlink" title="宏命令"></a>宏命令</h4><p>前面提到，命令模式可以与组合模式相结合，从而让多个命令共同组装为一个组合命令，即宏命令。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// @brief 抽象命令类, 声明执行命令的接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractMacroCommand</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractMacroCommand</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Execute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 命令接收者, 执行命令功能的相关操作，是具体命令对象业务的真正实现者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CompositeReceiver</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ActionA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is CompositeReceiver::ActionA!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ActionB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is CompositeReceiver::ActionB!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 具体命令类, 它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCommandA</span> : <span class="keyword">public</span> AbstractMacroCommand &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteCommandA</span>() &#123;</span><br><span class="line">        receiver_.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">CompositeReceiver</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver_-&gt;<span class="built_in">ActionA</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;CompositeReceiver&gt; receiver_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCommandB</span> : <span class="keyword">public</span> AbstractMacroCommand &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteCommandB</span>() &#123;</span><br><span class="line">        receiver_.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">CompositeReceiver</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver_-&gt;<span class="built_in">ActionB</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;CompositeReceiver&gt; receiver_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 命令请求者, 请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CompositeInvoker</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddCommand</span><span class="params">(AbstractMacroCommand* cmd)</span> </span>&#123;</span><br><span class="line">        cmds_.<span class="built_in">emplace_back</span>(cmd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RemoveCommand</span><span class="params">(AbstractMacroCommand* cmd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = cmds_.<span class="built_in">begin</span>(); it != cmds_.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cmd == (*it)) &#123;</span><br><span class="line">                cmds_.<span class="built_in">erase</span>(it++);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>* cmd : cmds_) &#123;</span><br><span class="line">            cmd-&gt;<span class="built_in">Execute</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;AbstractMacroCommand*&gt; cmds_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;AbstractMacroCommand&gt; <span class="title">cmd_A</span><span class="params">(<span class="keyword">new</span> ConcreteCommandA())</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;AbstractMacroCommand&gt; <span class="title">cmd_B</span><span class="params">(<span class="keyword">new</span> ConcreteCommandB())</span></span>;</span><br><span class="line"></span><br><span class="line">    CompositeInvoker client;</span><br><span class="line">    client.<span class="built_in">AddCommand</span>(cmd_A.<span class="built_in">get</span>());</span><br><span class="line">    client.<span class="built_in">AddCommand</span>(cmd_B.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">    client.<span class="built_in">Request</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="21-解释器模式（Interpreter）"><a href="#21-解释器模式（Interpreter）" class="headerlink" title="21 解释器模式（Interpreter）"></a>21 解释器模式（Interpreter）</h3><p>以大数据统计为例：在大数据统计中，通常需要按照计算模型对现有数据统计、分析、预测。由于计算模型有很多，而且总是在更新，因此系统设计时需要具备高扩展性。</p>
<p>一般计算模型中包含两类符号：数据和计算符，可以将二者解耦，同时让各个计算符均为一个类，继承自抽象运算符类。这样，当需要更改一个运算符的行为时，仅更改该类的实现即可。而且想要扩展计算模型，增加新的具体计算符类即可。</p>
<blockquote>
<p>解释器模式：定义一个语法，定义一个解释器，该解释器处理该语法句子。</p>
</blockquote>
<p>类比到上面的例子，众多运算符操作的集合就是解释器，而语法就是在运算符类中实现的。解释器模式的结构如下：客户端给出表达式（算法模型），Context类将表达式分解为各种符号的组合。而抽象表达式类提供interpret的统一接口，其下分为终结符号和非终结符号两种。终结符号一般是数值、数据，而非终结符号一般为运算符，比如加减乘除四则运算。</p>
<p>当然，终结符号也可以扩展，比如从实数改为复数，那么仅需该TerminalExpression的具体实现即可，由于调用该类对象时会使用→interpret方法，因此NonterminalExpression可以改动很小甚至不改。</p>
<p><img src="/design_pattern-image/image_Vfisq6ZU80.png"></p>
<p>举一个更具体的例子——计算器。计算器的算法模型是逆波兰式，Calculator就相当于Context，在运算符实现时仅需针对数据类型实现四则运算即可。</p>
<p><img src="/design_pattern-image/image_vFZ9_EcmBy.png"></p>
<p>（下面的代码实现并不好，可用职责链模式进一步优化）</p>
<p><strong>抽象表达式类Node（抽象节点）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象表达式类Node（抽象节点）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">interpret</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><strong>终结符表达式类ValueNode（值节点类）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//终结符表达式类ValueNode（值节点类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ValueNode</span> : <span class="keyword">public</span> Node &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ValueNode</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">interpret</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>抽象非终结符表达式类SymbolNode（符号节点类）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象非终结符表达式类SymbolNode（符号节点类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SymbolNode</span> : <span class="keyword">public</span> Node &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SymbolNode</span>(shared_ptr&lt;Node&gt; left,shared_ptr&lt;Node&gt; right) &#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;left = left;</span><br><span class="line">      <span class="keyword">this</span>-&gt;right = right;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    shared_ptr&lt;Node&gt; left;</span><br><span class="line">    shared_ptr&lt;Node&gt; right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>非终结符表达式类MulNode（乘法节点类）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非终结符表达式类MulNode（乘法节点类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MulNode</span> : <span class="keyword">public</span> SymbolNode &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MulNode</span>(shared_ptr&lt;Node&gt; left,shared_ptr&lt;Node&gt; right) : <span class="built_in">SymbolNode</span>(left,right) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">interpret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> left-&gt;<span class="built_in">interpret</span>()*right-&gt;<span class="built_in">interpret</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>&amp;#x20;<strong>非终结符表达式类DivNode（除法节点类）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非终结符表达式类DivNode（除法节点类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DivNode</span> : <span class="keyword">public</span> SymbolNode &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DivNode</span>(shared_ptr&lt;Node&gt; left,shared_ptr&lt;Node&gt; right) : <span class="built_in">SymbolNode</span>(left,right) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">interpret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> left-&gt;<span class="built_in">interpret</span>()/right-&gt;<span class="built_in">interpret</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>非终结符表达式类ModNode（求模节点类）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非终结符表达式类ModNode（求模节点类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModNode</span> : <span class="keyword">public</span> SymbolNode &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ModNode</span>(shared_ptr&lt;Node&gt; left,shared_ptr&lt;Node&gt; right) : <span class="built_in">SymbolNode</span>(left,right) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">interpret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> left-&gt;<span class="built_in">interpret</span>()%right-&gt;<span class="built_in">interpret</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>解析器封装类Calculator（计算器类）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解析器封装类Calculator（计算器类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bulid</span><span class="params">(string statement)</span> </span>&#123;</span><br><span class="line">      shared_ptr&lt;Node&gt; left,right;</span><br><span class="line">      stack&lt;shared_ptr&lt;Node&gt; &gt; s;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//分割语义 </span></span><br><span class="line">      vector&lt;string&gt; statementArr = <span class="built_in">split</span>(statement,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//处理语义</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; statementArr.<span class="built_in">size</span>() ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(statementArr[i] == <span class="string">&quot;*&quot;</span>)&#123;</span><br><span class="line">          left = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">          <span class="type">int</span> val = <span class="built_in">atoi</span>(statementArr[++i].<span class="built_in">c_str</span>());</span><br><span class="line">          right = <span class="built_in">make_shared</span>&lt;ValueNode&gt;(val);</span><br><span class="line">          s.<span class="built_in">push</span>(<span class="built_in">make_shared</span>&lt;MulNode&gt;(left,right));</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(statementArr[i] == <span class="string">&quot;/&quot;</span>)&#123;</span><br><span class="line">          left = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">          <span class="type">int</span> val = <span class="built_in">atoi</span>(statementArr[++i].<span class="built_in">c_str</span>());</span><br><span class="line">          right = <span class="built_in">make_shared</span>&lt;ValueNode&gt;(val);</span><br><span class="line">          s.<span class="built_in">push</span>(<span class="built_in">make_shared</span>&lt;DivNode&gt;(left,right));</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(statementArr[i] == <span class="string">&quot;%&quot;</span>)&#123;</span><br><span class="line">          left = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">          <span class="type">int</span> val = <span class="built_in">atoi</span>(statementArr[++i].<span class="built_in">c_str</span>());</span><br><span class="line">          right = <span class="built_in">make_shared</span>&lt;ValueNode&gt;(val);</span><br><span class="line">          s.<span class="built_in">push</span>(<span class="built_in">make_shared</span>&lt;ModNode&gt;(left,right));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          s.<span class="built_in">push</span>(<span class="built_in">make_shared</span>&lt;ValueNode&gt;(<span class="built_in">atoi</span>(statementArr[i].<span class="built_in">c_str</span>())));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>-&gt;node = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">compute</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> node-&gt;<span class="built_in">interpret</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    string statement;</span><br><span class="line">    shared_ptr&lt;Node&gt; node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>客户端测试&amp;#x20;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户端测试 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//需要解析的语句 </span></span><br><span class="line">  string statement = <span class="string">&quot;3 * 4 / 2 % 4&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//解析器 </span></span><br><span class="line">  Calculator calculator;</span><br><span class="line">  calculator.<span class="built_in">bulid</span>(statement);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//计算结果 </span></span><br><span class="line">  <span class="type">int</span> result = calculator.<span class="built_in">compute</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//输出 </span></span><br><span class="line">  cout &lt;&lt; statement &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>优点：</p>
<ul>
<li><p>扩展性好：由于在解释器模式中使用类来表示语言的文法规则，因此可以<strong>通过继承等机制来改变或扩展文法</strong>。</p>
</li>
<li><p>容易实现： 在语法树中的<strong>每个表达式节点类都是相似的</strong>，所以实现其文法较为容易。</p>
</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li><p>执行效率较低：解释器模式中<strong>通常使用大量的循环和递归调用</strong>，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。</p>
</li>
<li><p>可应用的场景比较少：<strong>在软件开发中，需要定义语言文法的应用实例非常少</strong>，所以这种模式很少被使用到。</p>
</li>
</ul>
</li>
</ul>
<h3 id="22-中介模式（Mediator）"><a href="#22-中介模式（Mediator）" class="headerlink" title="22 中介模式（Mediator）"></a>22 中介模式（Mediator）</h3><p>一个由很多对象组成的模块，其对象间可能存在错综复杂的关联性。以P2P聊天为例，用户对象之间构成了网状结构，将会导致如下问题：</p>
<ul>
<li><p>系统结构复杂：对象之间存在大量的相互关联和调用，若有一个对象发生变化，则需要跟踪和该对象关联的其他所有对象，并进行适当处理。</p>
</li>
<li><p>对象可重用性差：由于一个对象和其他对象具有很强的关联，若没有其他对象的支持，一个对象很难被另一个系统或模块重用，这些对象表现出来更像一个不可分割的整体，职责较为混乱。</p>
</li>
<li><p>系统扩展性低：增加一个新的对象需要在原有相关对象上增加引用，增加新的引用关系也需要调整原有对象，系统耦合度很高，对象操作很不灵活，扩展性差。</p>
</li>
</ul>
<p>中介者模式旨在<strong>利用一个中介对象来封装一系列的对象交互</strong>，使得各对象间不需要显式地相互引用，从而将耦合松散。</p>
<p><img src="/design_pattern-image/image_BJw7swbIke.png"></p>
<ol>
<li><p>Mediator：抽象中介者</p>
</li>
<li><p>ConcreteMediator：具体中介者</p>
</li>
<li><p>Colleague：抽象同事类，也就是那些相互关联的对象的父类</p>
</li>
<li><p>ConcreteColleague：具体同事类，相互关联的对象</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// @brief 抽象同事类, 定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractMediator</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractColleague</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractColleague</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// @brief 抽象接口</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Receive</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Send</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// @brief 设置中介对象</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetMedium</span><span class="params">(AbstractMediator* mediator)</span> </span>&#123;</span><br><span class="line">        mediator_ = mediator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    AbstractMediator* mediator_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 具体同事类, 抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteColleagueA</span> : <span class="keyword">public</span> AbstractColleague &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Receive</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteColleagueB</span> : <span class="keyword">public</span> AbstractColleague &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Receive</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 抽象中介类, 中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractMediator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractMediator</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// @brief 注册</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Register</span><span class="params">(AbstractColleague* colleague)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/// @brief 转发</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Relay</span><span class="params">(AbstractColleague* colleague)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 具体中介类, 实现中介者接口. 管理同事对象，协调各个同事角色之间的交互关系，依赖于同事角色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteMediator</span> : <span class="keyword">public</span> AbstractMediator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Register</span><span class="params">(AbstractColleague* colleague)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>* c : colleagues_) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == colleague) <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        colleagues_.<span class="built_in">emplace_back</span>(colleague);</span><br><span class="line">        colleague-&gt;<span class="built_in">SetMedium</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Relay</span><span class="params">(AbstractColleague* colleague)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>* c : colleagues_) &#123;</span><br><span class="line">            <span class="comment">// 转发给除自己外的同事</span></span><br><span class="line">            <span class="keyword">if</span> (c != colleague) c-&gt;<span class="built_in">Receive</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::list&lt;AbstractColleague*&gt; colleagues_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////// 同事类实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConcreteColleagueA::Receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;this is ConcreteColleagueA::Receive!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConcreteColleagueA::Send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;this is ConcreteColleagueA::Send!\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 请中介者转发</span></span><br><span class="line">    mediator_-&gt;<span class="built_in">Relay</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConcreteColleagueB::Receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;this is ConcreteColleagueB::Receive!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConcreteColleagueB::Send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;this is ConcreteColleagueB::Send!\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 请中介者转发</span></span><br><span class="line">    mediator_-&gt;<span class="built_in">Relay</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-------------------- %s --------------------\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="function">std::shared_ptr&lt;AbstractMediator&gt; <span class="title">ptr_md</span><span class="params">(<span class="keyword">new</span> ConcreteMediator())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;AbstractColleague&gt; <span class="title">ptr_c1</span><span class="params">(<span class="keyword">new</span> ConcreteColleagueA())</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;AbstractColleague&gt; <span class="title">ptr_c2</span><span class="params">(<span class="keyword">new</span> ConcreteColleagueB())</span></span>;</span><br><span class="line"></span><br><span class="line">    ptr_md-&gt;<span class="built_in">Register</span>(ptr_c1.<span class="built_in">get</span>());</span><br><span class="line">    ptr_md-&gt;<span class="built_in">Register</span>(ptr_c2.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">    ptr_c1-&gt;<span class="built_in">Send</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-----------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ptr_c2-&gt;<span class="built_in">Send</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>优点：</p>
<ul>
<li><p>简化了对象之间的交互；</p>
</li>
<li><p>将各同事解耦。</p>
</li>
</ul>
</li>
<li><p>缺点：</p>
<p>具体中介者类中包含了同事之间的交互细节，可能会导致具体中介者类非常复杂，让系统难维护。</p>
</li>
</ul>
<h2 id="设计模式思维导图"><a href="#设计模式思维导图" class="headerlink" title="设计模式思维导图"></a>设计模式思维导图</h2><p><img src="/design_pattern-image/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_bWnBly4dT4.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础知识</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker使用方法详解</title>
    <url>/2020/04/05/Docker/Docker/</url>
    <content><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p><a href="https://docs.docker.com/reference/" title="官方手册">官方手册</a></p>
<p><a href="https://yeasy.gitbook.io/docker_practice/" title="电子书：docker从入门到实践">电子书：docker从入门到实践</a></p>
<h2 id="1-docker简介"><a href="#1-docker简介" class="headerlink" title="1 docker简介"></a>1 docker简介</h2><h3 id="1-1-docker与虚拟机"><a href="#1-1-docker与虚拟机" class="headerlink" title="1.1 docker与虚拟机"></a>1.1 docker与虚拟机</h3><h3 id="1-2-镜像"><a href="#1-2-镜像" class="headerlink" title="1.2 镜像"></a>1.2 镜像</h3><h2 id="2-docker基本命令"><a href="#2-docker基本命令" class="headerlink" title="2 docker基本命令"></a>2 docker基本命令</h2><h3 id="2-1-docker基本命令概览"><a href="#2-1-docker基本命令概览" class="headerlink" title="2.1 docker基本命令概览"></a>2.1 docker基本命令概览</h3><p><img src="/image/docker%E5%91%BD%E4%BB%A4_mHG9nKYq_l.png"></p>
<h3 id="2-2-docker-run详解"><a href="#2-2-docker-run详解" class="headerlink" title="2.2 docker run详解"></a>2.2 docker run详解</h3><blockquote>
<p>📌若之前未下载对应镜像，会从docker hub拉取；若下载过，直接用镜像创建</p>
</blockquote>
<ul>
<li><p>若直接输入docker run ubuntu，会发现创建了容器之后便退出了，并没有运行</p>
<p>这是因为docker是用来运行进程或任务的，进程一旦完成，容器便会退出。而ubuntu只是一个其它服务依托的基础镜像，本身并没有进程，所以创建新容器后就会退出。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#----------------- 解决这种问题的几种方式 ---------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式一：启动容器时指定运行命令</span></span><br><span class="line">docker run ubuntu <span class="built_in">sleep</span> 5 <span class="comment"># 此命令会启动容器时执行sleep 5，睡眠5秒后应用停止，容器退出</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二：交互模式，连接到终端</span></span><br><span class="line">docker run -it kodekloud/simple-prompt-docker </span><br></pre></td></tr></table></figure>

<p>若容器化应用既包括标准输入又有标准输出，那run容器时默认只会输出，并不会监听标准输入</p>
<p>-i ：交互模式，可以监听标准输入</p>
<p>-t：即使是交互模式，由于终端不一致，有标准输入的app仍不会完整实现，所以用-t选项连接终端</p>
<ul>
<li>docker run还有attach和detach的选项</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -d选项，使容器在后台运行</span></span><br><span class="line">docker run -d kodekloud/simple-webapp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想重新连接到正在后台运行的容器，可以使用attach命令</span></span><br><span class="line">docker attach 容器ID/容器名</span><br></pre></td></tr></table></figure>

<ul>
<li><p>此外还可以用tag指定run的版本，如docker run redis:4.0（默认tag是latest）</p>
</li>
<li><p>端口映射：-p选项</p>
</li>
</ul>
<p>docker容器的IP地址以及端口均属于内部，可以从容器内部访问localhost，但是外部默认无法访问</p>
<p>此时需要将容器的端口映射到主机的端口，之后便可以通过主机IP访问容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># simple-webapp程序监听容器的5000端口</span></span><br><span class="line">docker run -p 80:5000 kodekloud/simple-webapp <span class="comment">#容器的5000端口被映射到主机的80端口</span></span><br></pre></td></tr></table></figure>

<p><img src="/image/network_XM4cj9dlTB.png"></p>
<p>通过把不同容器映射到主机的不同端口上，可以同时实现多个实例</p>
<ul>
<li>目录映射</li>
</ul>
<p>容器有自己的隔离的文件系统，任何对文件的修改都发生在容器内部，如果用rm命令删除容器，数据也会消失。如果想删除容器但是保留数据，可以将容器内的卷挂载到主机中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -v选项负责目录映射</span></span><br><span class="line">docker run -v /opt/datadir:/var/lib/mysql mysql</span><br><span class="line"><span class="comment"># 将主机的/opt/datadir映射到mysql容器内的/var/lib/mysql目录</span></span><br><span class="line"><span class="comment"># mysql容器删除后/opt/datadir中的内容仍在</span></span><br></pre></td></tr></table></figure>

<ul>
<li>设置并查看环境变量</li>
</ul>
<p>可以在run的时候指定容器的环境变量，从而使调用该环境变量的程序得到自定义数值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用-e选项，将simple-webapp-color容器中的APP_COLOR环境变量赋值为blue</span></span><br><span class="line">docker run -e APP_COLOR=blue simple-webapp-color</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用inspect可以查看环境变量的值</span></span><br><span class="line">docker inspect simple-webapp-color</span><br><span class="line"><span class="comment"># 输出中的Config中会有环境变量列表</span></span><br></pre></td></tr></table></figure>

<h2 id="3-docker构建镜像"><a href="#3-docker构建镜像" class="headerlink" title="3 docker构建镜像"></a>3 docker构建镜像</h2><h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><ul>
<li>创建Dockerfile（dockerfle中的每一行都是命令+参数）</li>
</ul>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> Ubuntu</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install flask</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install flask-mysql</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /opt/source-code</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> FLASK_APP=/opt/source-code/app.py flask run</span></span><br></pre></td></tr></table></figure>

<pre><code>Layer1. Base Ubuntu Layer

Layer2. Changes in apt packages

Layer3. Changes in pip packages

Layer4. Source Code

Layer5. Update Entrypoint with &quot;flask command&quot;
</code></pre>
<blockquote>
<p>📌关于docker分层结构：<br>- 每一层只存储与前一层之间的变化，所以往往层数很高时，该层大小也很小<br>- docker history+镜像名：可查看每一层执行的命令和大小<br>- docker build会在构建期间缓存已经成功的层，这样如果构建失败或者需要修改镜像时，可以从中间的某一层开始重新构建，节省时间</p>
</blockquote>
<pre><code># dockerfile基本指令
FROM :       指定基础镜像，在其上构建当前镜像
RUN :        在基础镜像容器中运行命令
COPY :       从本地指定目录复制内容到容器的指定目录
CMD :        指定在容器初始阶段运行的默认程序（有参数）
             如Ubuntu镜像的dockerfile中有CMD &#123;&quot;bash&quot;&#125;
             如果在docker run后追加命令，该命令会覆盖默认CMD
             有两种书写格式： CMD command param1   |  CMD [&quot;command&quot;,&quot;param1&quot;]
                             CMD sleep 5             CMD [&quot;sleep&quot;,&quot;5&quot;] 
ENTRYPOINT : 指定在容器初始阶段运行的默认程序（可以无参数）
             docker run后追加参数，相当于执行ENTRYPOINT中的命令+参数

ENTRYPOINT+CMD组合 : 
             默认执行ENTRYPOINT命令+CMD参数，此时二者必须是JSON格式
             ENTRYPOINT [&quot;sleep&quot;]
             CMD [&quot;5&quot;]
ADD :        相当于COPY，有自动解压缩功能，但会令镜像构建缓存失效，使镜像构建缓慢
ENV :        设置环境变量，格式有两种
             ENV &lt;key&gt; &lt;value&gt;
             ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;
ARG :        设置构建镜像时的环境变量，容器运行时环境变量不复存在，即相当于dockerfile的宏
             有作用域，若在FROM指令之前指定，那么只能用于该FROM指令中，后续指令无法再用
             参数值在docker build中可用--build-arg &lt;参数名&gt;=&lt;值&gt;来覆盖
WORKDIR :    相当于dockerfile中的cd
</code></pre>
<blockquote>
<p>📌注：若要在容器运行时改变入口点，如从sleep改成bash，可以docker run - - entrypoint bash  ubuntu-sleeper 10</p>
</blockquote>
<p>更多dockerfile指令可查看<a href="https://vuepress.mirror.docker-practice.com/image/dockerfile/" title="https://vuepress.mirror.docker-practice.com/image/dockerfile/">https://vuepress.mirror.docker-practice.com/image/dockerfile/</a></p>
<ul>
<li>使用docker build构建镜像</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用URL github.com/creack/docker-firefox 的 Dockerfile 创建镜像</span></span><br><span class="line">docker build github.com/creack/docker-firefox</span><br><span class="line"><span class="comment"># 通过-f选项指定Dockerfile的位置</span></span><br><span class="line">docker build -f /path/to/Dockerfile</span><br><span class="line"><span class="comment"># 使用当前目录的 Dockerfile 创建镜像（注意最后那个点），标签为 runoob/ubuntu:v1</span></span><br><span class="line">docker build -t runoob/ubuntu:v1 .</span><br></pre></td></tr></table></figure>

<ul>
<li>使用docker push将镜像推到docker hub</li>
</ul>
<h2 id="4-docker-registry"><a href="#4-docker-registry" class="headerlink" title="4 docker registry"></a>4 docker registry</h2><blockquote>
<p>docker registry是镜像存储的地方，中央仓库</p>
</blockquote>
<p>如nginx镜像名全称为nginx&#x2F;nginx，前者是用户名，若不提供则默认用户名与镜像名相同</p>
<p>默认的docker registry是dockerhub，其它的还有谷歌gcr(提供k8s镜像)等等，AWS等公司也提供私有registry方便于不想共享镜像的时候</p>
<ul>
<li><p>dockerhub提供的私有仓库：docker login <a href="http://private-registry.io/" title="private-registry.io">private-registry.io</a></p>
<p>使用私有仓库需要保证在登录状态</p>
</li>
</ul>
<h3 id="本地Registry创建与使用"><a href="#本地Registry创建与使用" class="headerlink" title="本地Registry创建与使用"></a>本地Registry创建与使用</h3><p>Registry本身就是一个应用程序，且已经ss被做成了镜像，其容器开放端口5000，利用该容器可以在局域网内与团队共享所创建的镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运行registry容器，也可以加上-v选项将镜像存于本地</span></span><br><span class="line">docker run -d -p 5000:5000 --name registry registry:2</span><br><span class="line"><span class="comment"># 使用tag将镜像标记为可被本地Registry接受的镜像名</span></span><br><span class="line">docker image tag my-image localhost:5000/my-image</span><br><span class="line"><span class="comment"># 向本地registry推送镜像</span></span><br><span class="line">docker push localhost:5000/my-image</span><br><span class="line"><span class="comment"># 从本地registry拉取镜像</span></span><br><span class="line">docker pull localhost:5000/my-image</span><br><span class="line"><span class="comment"># 从局域网内其它主机的registry拉取镜像</span></span><br><span class="line">docker pull 192.168.56.100:5000/my-image</span><br></pre></td></tr></table></figure>

<blockquote>
<p>📌注：可以通过curl localhost:5000&#x2F;v2&#x2F;_catalog命令查看镜像是否上传成功</p>
</blockquote>
<p>上述方法适用于docker 1.3.x之前的版本，交互全部使用http服务。然而该版本之后，docker搭建私有镜像默认使用https，若从registry里pull镜像会报错。</p>
<p><strong>解决办法一</strong>：配置SSL证书</p>
<ul>
<li>官方文档（难，因为很难建立证书）</li>
</ul>
<ol>
<li>创建certs文件夹</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p certs</span><br></pre></td></tr></table></figure>

<p>从CA拷贝.crt和.key文件到certs文件夹（例中采用名字domain.crt和domain.key）</p>
<p>假设域名为https:&#x2F;&#x2F;myregistry.domain.com&#x2F;</p>
<p>&amp;#x20;2. 启动registry容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --restart=always \</span><br><span class="line">  --name registry \</span><br><span class="line">  -v <span class="string">&quot;<span class="subst">$(pwd)</span>&quot;</span>/certs:/certs \</span><br><span class="line">  -e REGISTRY_HTTP_ADDR=0.0.0.0:443 \</span><br><span class="line">  -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/domain.crt \</span><br><span class="line">  -e REGISTRY_HTTP_TLS_KEY=/certs/domain.key \</span><br><span class="line">  -p 443:443 \</span><br><span class="line">  registry:2</span><br></pre></td></tr></table></figure>

<p>此命令将容器中的certs文件夹挂载到宿主机的certs文件夹，通过环境变量告知容器该到哪里找domain.crt和domain.key。registry将在443端口（默认HTTPS端口）运行。</p>
<p>新registry通过myregistry.domain.com访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull ubuntu:16.04</span><br><span class="line">docker tag ubuntu:16.04 myregistry.domain.com/my-ubuntu</span><br><span class="line">docker push myregistry.domain.com/my-ubuntu</span><br><span class="line">docker pull myregistry.domain.com/my-ubuntu</span><br></pre></td></tr></table></figure>

<ul>
<li>使用中间证书(intermediate certificate)</li>
</ul>
<p>证书发放者往往会提供的是中间证书，需要利用该证书创建domain.crt</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> domain.crt intermediate-certificates.pem &gt; certs/domain.crt</span><br></pre></td></tr></table></figure>

<p><strong>解决方法2</strong>：需要pull的机器添加信任registry列表</p>
<p>打开&#x2F;etc&#x2F;docker&#x2F;daemon.json</p>
<p>添加私有registry</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;insecure-registries&quot;</span>:[<span class="string">&quot;myregistry.example.com:5000&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;insecure-registries&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;registry:5000&quot;</span>, </span><br><span class="line">    <span class="string">&quot;registry2:5000&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="5-docker存储"><a href="#5-docker存储" class="headerlink" title="5 docker存储"></a>5 docker存储</h2><p>docker容器被创建后，就会创建以下目录</p>
<pre><code>docker文件系统
/var/lib/docker
         -- aufs
         -- containers
         -- image
         -- volumes
</code></pre>
<p>一般容器内的数据在容器删除后便被删除，要想避免这种情况可以采用外部存储挂载到容器内的方法</p>
<p>主要有两种挂载方式，卷挂载(volume)和绑定挂载(binding)</p>
<h3 id="5-1-卷挂载"><a href="#5-1-卷挂载" class="headerlink" title="5.1 卷挂载"></a>5.1 卷挂载</h3><p>卷挂载是在docker主机内创建一个独立于容器的卷，卷内的内容与宿主机无关</p>
<ul>
<li>创建卷</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker volume create my-vol       <span class="comment"># 创建卷</span></span><br><span class="line">$ docker volume <span class="built_in">ls</span>                  <span class="comment"># 列出所有卷</span></span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>               my-vol</span><br><span class="line">$ docker volume inspect my-vol      <span class="comment"># 查看卷的信息</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/my-vol/_data&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;my-vol&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>挂载卷</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">旧写法：-v my-vol:/usr/share/nginx/html <span class="comment">#后者是容器内目录</span></span><br><span class="line">新写法：--mount <span class="built_in">source</span>=my-vol,target=/usr/share/nginx/html</span><br></pre></td></tr></table></figure>

<ul>
<li>删除卷</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker volume <span class="built_in">rm</span> my-vol</span><br><span class="line">docker volume prune        <span class="comment">#删除无主卷</span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-绑定挂载"><a href="#5-2-绑定挂载" class="headerlink" title="5.2 绑定挂载"></a>5.2 绑定挂载</h3><p>绑定挂载是将宿主机的目录指定为容器内的目录，即该目录的修改是对宿主机目录的直接修改</p>
<ul>
<li><p>旧写法：-v选项</p>
</li>
<li><p>新写法：- - mount选项</p>
</li>
</ul>
<h2 id="6-docker网络"><a href="#6-docker网络" class="headerlink" title="6 docker网络"></a>6 docker网络</h2><blockquote>
<p>docker自动创建Bridge、 none、 host三种网络<br>可通过network选项修改当前模式：docker run Ubuntu - -network&#x3D;host</p>
</blockquote>
<ul>
<li><p>none模式：完全没有网络，容器彼此隔绝，容器与主机隔绝</p>
</li>
<li><p>host模式：容器使用主机的网络，容器的端口就是主机的端口，注意此时，不同容器再不能在内部使用相同的端口运行程序</p>
</li>
</ul>
<h3 id="Bridge模式详解"><a href="#Bridge模式详解" class="headerlink" title="Bridge模式详解"></a>Bridge模式详解</h3><h2 id="7-docker-compose"><a href="#7-docker-compose" class="headerlink" title="7 docker compose"></a>7 docker compose</h2><p><a href="https://docs.docker.com/compose/compose-file/compose-file-v3/" title="Compose-file官方文档">Compose-file官方文档</a></p>
<h2 id="8-docker-swarm"><a href="#8-docker-swarm" class="headerlink" title="8 docker swarm"></a>8 docker swarm</h2><p><a href="https://docs.docker.com/engine/swarm/" title="官方文档">官方文档</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.7&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">minio1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">minio/minio:RELEASE.2020-11-19T23-48-16Z</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">minio1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">minio1-data:/export</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9001:9000&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">minio_distributed</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">restart_policy:</span></span><br><span class="line">        <span class="attr">delay:</span> <span class="string">10s</span></span><br><span class="line">        <span class="attr">max_attempts:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">window:</span> <span class="string">60s</span></span><br><span class="line">      <span class="attr">placement:</span></span><br><span class="line">        <span class="attr">constraints:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">node.labels.minio1==true</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">server</span> <span class="string">http://minio&#123;1...4&#125;/export</span></span><br><span class="line">    <span class="attr">secrets:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">secret_key</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">access_key</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;http://localhost:9000/minio/health/live&quot;</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">20s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">minio2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">minio/minio:RELEASE.2020-11-19T23-48-16Z</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">minio2</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">minio2-data:/export</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9002:9000&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">minio_distributed</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">restart_policy:</span></span><br><span class="line">        <span class="attr">delay:</span> <span class="string">10s</span></span><br><span class="line">        <span class="attr">max_attempts:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">window:</span> <span class="string">60s</span></span><br><span class="line">      <span class="attr">placement:</span></span><br><span class="line">        <span class="attr">constraints:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">node.labels.minio2==true</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">server</span> <span class="string">http://minio&#123;1...4&#125;/export</span></span><br><span class="line">    <span class="attr">secrets:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">secret_key</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">access_key</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;http://localhost:9000/minio/health/live&quot;</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">20s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">minio3:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">minio/minio:RELEASE.2020-11-19T23-48-16Z</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">minio3</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">minio3-data:/export</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9003:9000&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">minio_distributed</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">restart_policy:</span></span><br><span class="line">        <span class="attr">delay:</span> <span class="string">10s</span></span><br><span class="line">        <span class="attr">max_attempts:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">window:</span> <span class="string">60s</span></span><br><span class="line">      <span class="attr">placement:</span></span><br><span class="line">        <span class="attr">constraints:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">node.labels.minio3==true</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">server</span> <span class="string">http://minio&#123;1...4&#125;/export</span></span><br><span class="line">    <span class="attr">secrets:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">secret_key</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">access_key</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;http://localhost:9000/minio/health/live&quot;</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">20s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">minio4:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">minio/minio:RELEASE.2020-11-19T23-48-16Z</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">minio4</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">minio4-data:/export</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9004:9000&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">minio_distributed</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">restart_policy:</span></span><br><span class="line">        <span class="attr">delay:</span> <span class="string">10s</span></span><br><span class="line">        <span class="attr">max_attempts:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">window:</span> <span class="string">60s</span></span><br><span class="line">      <span class="attr">placement:</span></span><br><span class="line">        <span class="attr">constraints:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">node.labels.minio4==true</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">server</span> <span class="string">http://minio&#123;1...4&#125;/export</span></span><br><span class="line">    <span class="attr">secrets:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">secret_key</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">access_key</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;http://localhost:9000/minio/health/live&quot;</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">20s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">minio1-data:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">minio2-data:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">minio3-data:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">minio4-data:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">minio_distributed:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">overlay</span></span><br><span class="line"></span><br><span class="line"><span class="attr">secrets:</span></span><br><span class="line">  <span class="attr">secret_key:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">minio_secret_key</span></span><br><span class="line">  <span class="attr">access_key:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">minio_access_key</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>分式优化求解利器——Dinkelbach</title>
    <url>/2022/01/03/Dinkelbach%20Approach/Dinkelbach%20Approach/</url>
    <content><![CDATA[<h1 id="Dinkelbach-Approach"><a href="#Dinkelbach-Approach" class="headerlink" title="Dinkelbach Approach"></a>Dinkelbach Approach</h1><blockquote>
<p>问题描述：<br>给定两个连续函数$ f:\mathbf R^n\rightarrow\mathbf R  $和$g:\mathbf R^n\rightarrow \mathbf R$。二者定义域为多面体(polyhedral)集合$S\subset\mathbf R^n$使得对于所有$x\in S$都有$g(x)&gt;0$。需要找到一个分式规划问题的最优解$x^*$满足$\frac{f(x^*)}{g(x^*)}&#x3D;\max\limits_{x\in S}\frac{f(x)}{g(x)}$ (P)。</p>
</blockquote>
<p>Dinkelbach方法，简言之，将原问题P简化为一个全局优化问题(GP)：$\max\limits_{x\in S}(f(x)-\lambda g(x))$。</p>
<h2 id="朴素Dinkelbach"><a href="#朴素Dinkelbach" class="headerlink" title="朴素Dinkelbach"></a>朴素Dinkelbach</h2><blockquote>
<p>📌定理1：<br>$ x^*  $是分式规划问题(P)的解，当且仅当其是全局优化问题(GP)有约束$\lambda^*&#x3D;\frac{f(x^*)}{g(x^*)}$时的解。</p>
</blockquote>
<ul>
<li><p>朴素Dinkelbach算法流程：</p>
<ol>
<li><p>选取$x^{(0)}\in S$。设置$\lambda^{(0)}:&#x3D;f(x^{(0)})&#x2F;g(x^{(0)}),\ k:&#x3D;0$；</p>
</li>
<li><p>求解全局优化问题：$\max\limits_{x\in S}(f(x)-\lambda^{(k)}g(x))$，得到当前解$x^{(k+1)}$；</p>
</li>
<li><p>若$f(x^{(k+1)})-\lambda^{(k)}g(x^{(k+1)})&#x3D;0$，那么最优解产生$ x^*&#x3D;x^{(k+1)},\ \lambda^*:&#x3D;\lambda^{(k)}  $，算法停止；</p>
</li>
<li><p>若$f(x^{(k+1)})-\lambda^{(k)}g(x^{(k+1)})&gt;0$，那么设置$\lambda^{(k+1)}:&#x3D;f(x^{(k+1)})&#x2F;g(x^{(k+1)}),\ k:k+1$后，回到步骤2。</p>
</li>
</ol>
</li>
</ul>
<p>注：不需要验证$f(x^{(k+1)})-\lambda^{(k)}g(x^{(k+1)})&lt;0$的情况。（可以用反证法证明）对所有$k$都有</p>
<p>$$<br>f(x^{(k+1)})-\lambda^{(k)}g(x^{(k+1)})&#x3D;\max\limits_{x\in S}f((x)-\lambda^{(k)}g(x))\ge f(x^{(k)})-\lambda^{(k)}g(x^{(k)})&#x3D;0<br>$$</p>
<h3 id="算法有效性分析"><a href="#算法有效性分析" class="headerlink" title="算法有效性分析"></a>算法有效性分析</h3><p>考虑函数$M(\lambda)&#x3D;\max\limits_{x\in S}(f(x)-\lambda g(x))$。可以知道其符合以下性质：</p>
<ol>
<li><p>对于所有$\lambda&lt;\lambda^*$有$M(\lambda)&gt;0$且对于所有$\lambda&gt;\lambda^*$有$M(\lambda)&lt;0$；</p>
</li>
<li><p>$M(\lambda)$是凸函数。</p>
</li>
</ol>
<blockquote>
<p>超线性收敛(converge superlinearly)：<br>若序列$\alpha^{(0)},\alpha^{(1)},\cdots$满足$\lim\limits_{n\rightarrow\infty}\frac{|\alpha^*-\alpha^{(n+1)}|}{\theta^{n+1}}&#x3D;0$，其中$\theta\in(0,1]$，则称该序列超线性收敛于$\alpha^*$。</p>
</blockquote>
<p>（超线性收敛意味着，序列会收敛，而且以越来越快的速度收敛）</p>
<blockquote>
<p>📌引理1：<br>$x^<em>\in S$是问题(P)的最优解，且$x’$是$M(\lambda’)$的解满足$\lambda’&lt;\lambda^</em>$，那么：<br>$\lambda^*-\frac{f(x’)}{g(x’)}\le(\lambda^*-\lambda’)(1-\frac{g(x^*)}{g(x’)})$<br>其中$0\le1-g(x^*)&#x2F;g(x’)&lt;1$。</p>
<p>Schaible S. Fractional programming: applications and algorithms[J]. European Journal of Operational Research, 1981, 7(2): 111-120.</p>
</blockquote>
<p>对于引理1，令$\lambda’&#x3D;\lambda^{(n)}$且$x’&#x3D;x^{(n+1)}$，则$x^{(n+1)}$是$M(\lambda^{(n)})$的解，那么可以得到每次迭代的误差满足：</p>
<p>$$<br>(\lambda^*-\lambda^{(n+1)})\le(\lambda^*-\lambda^{(n)})(1-\frac{g(x^*)}{g(x^{(n+1)})})<br>$$</p>
<p>令$\epsilon_i&#x3D;(1-g(x^*)&#x2F;g(x^{(i)})),\ i&#x3D;1,2,\cdots$，Schaible的理论表明$\epsilon_1\ge\epsilon_2\ge\cdots\ge0$。序列误差的级联关系可以表示为：</p>
<p>$$<br>(\lambda^*-\lambda^{(n+1)})\le(\lambda^*-\lambda^{(0)})\prod_{i&#x3D;1}^{n+1}(1-\frac{g(x^*)}{g(x^{(i)})})&#x3D;(\lambda^*-\lambda^{(0)})\prod_{i&#x3D;1}^{n+1}\epsilon_i<br>$$</p>
<p>此时可以使用第二个引理。</p>
<blockquote>
<p>📌引理2：<br>存在一个$x^*\in S$作为问题P的最优解，使得$\lim\limits_{n\rightarrow\infty}\epsilon_n&#x3D;0$</p>
<p>Schaible S. Fractional Programming: Transformations, Duality and Algorithmic Aspects[R]. STANFORD UNIV CALIF DEPT OF OPERATIONS RESEARCH, 1973.</p>
</blockquote>
<p>因此，对于任意$\theta\in(0,1]$，存在一个整数$n_{\theta}\ge0$使得对于所有的$i \ge n_{\theta}$，有$\epsilon_i&lt;\theta$。</p>
<p>定义常数$\beta_\theta&#x3D;\prod_{i&#x3D;1}^{n_\theta-1}(\frac{\epsilon_i}{\theta})$，可以有</p>
<p>$$<br>\frac{\lambda^*-\lambda^{(n+1)}}{\theta^{n+1}}\le(\lambda^*-\lambda^{(0)})\beta_\theta\prod_{i&#x3D;n_\theta}^{n+1}(\frac{\epsilon_i}\theta)<br>$$</p>
<p>因此$\lim_{n\rightarrow\infty}\frac{\lambda^*-\lambda^{(n+1)}}{\theta^{n+1}}&#x3D;0$。</p>
<p>综上所述，序列的下界$\lambda^{(n+1)}$将会以一个超线性的速率收敛到$\lambda^*&#x3D;f(x^*)&#x2F;g(x^*)$。</p>
<h2 id="有上界论证的改进Dinkelbach"><a href="#有上界论证的改进Dinkelbach" class="headerlink" title="有上界论证的改进Dinkelbach"></a>有上界论证的改进Dinkelbach</h2><p>从上面的推导可看出，朴素的Dinkelbach提供了下界的逼近，并没有提供上界的论证。这样可能会导致一个问题。如下图所示。</p>
<p><img src="/image/image_rjrcmXIOqK.png"></p>
<p>直线是$M(\lambda)$（实际情况可能不一定是直线哈，应该是个凸函数，这里只是为了演示方便），目标是最后逼近到$\lambda^*$。但是朴素Dinkelbach是类似于左边的下界线逼近的，现实情况里，可能很难迭代到$M(\lambda’)&#x3D;0$，往往都是小于一个$\delta$就表明收敛。但是其超线性则使$\lambda^{(n+1)}$有可能在离$\lambda^*$很远时就已经得到一个足够小的$M(\lambda^{(n+1)})$，导致最后的结果不够准确。那么如果能够<strong>再求得一条上界线从右边逼近，两条线同时逼近</strong>时，各自求的$\lambda$相差足够小，就可以更加精确地找到$\lambda^*$。</p>
<p>这便是改进版Dinkelbach的思路。</p>
<p>初始上界：分别解$\max\limits_{x\in S}f(x)$和$\min\limits_{x\in S}g(x)$得到$ x’  $和$x’’$，从而得到初始上界$\gamma^{(-1)}&#x3D;f(x’)&#x2F;g(x’’)$。这必然是一个比$\lambda^*$大的数，且由于之前所提的$M(\lambda)$的两条性质，每次迭代的上界都应该满足$M(\gamma)&lt;0$。定义每一轮的上界为：</p>
<p>$$<br>\gamma^{(k)}:&#x3D;\gamma^{(k-1)}-M(\gamma^{(k-1)})\left(\frac{\gamma^{(k-1)}-\lambda^{(k)}}{M(\gamma^{(k-1)})-M(\lambda^{(k)})}\right)<br>$$</p>
<p><img src="/image/image__Kmw3gOGVl.png"></p>
<p>这个式子的含义如上图所示。接着就可以得到如下改进版Dinkelbach。</p>
<ul>
<li><p>改进版Dinkelbach：</p>
<ol>
<li><p>选取$x^{(0)}\in S$。设置$\lambda^{(0)}:&#x3D;f(x^{(0)})&#x2F;g(x^{(0)})$；</p>
</li>
<li><p>求解问题$\max\limits_{x\in S}f(x)$得到$x’$，求解问题$\min\limits_{x\in S}g(x)$得到$x’’$。设置$\gamma^{(-1)}:&#x3D;f(x’)&#x2F;g(x’’)$以及$k:&#x3D;0$。若$\gamma^{(-1)}-\lambda^{(0)}\le\delta$，那么$\lambda^*:&#x3D;\lambda^{(0)}$且$x^*:&#x3D;x^{(0)}$，算法停止；</p>
</li>
<li><p>求解全局优化问题$M(\lambda^{(k)})&#x3D;\max\limits_{x\in S}(f(x)-\lambda^{(k)}g(x))$，得到$x^{(k+1)}$；</p>
</li>
<li><p>若$M(\lambda^{(k)})&#x3D;0$，那么$ x^*:&#x3D;x^{(k+1)},\quad\lambda^*&#x3D;\lambda^{(k)}  $，算法停止；</p>
</li>
<li><p>求解全局优化问题$M(\gamma^{(k-1)})&#x3D;\max\limits_{x\in S}(f(x)-\gamma^{(k-1)}g(x))$，得到$y^{(k)}$；</p>
</li>
<li><p>若$M(\gamma^{(k-1)})&#x3D;0$，那么$x^*:&#x3D;y^{(k)},\quad\lambda^*&#x3D;\gamma^{(k-1)}$，算法停止；</p>
</li>
<li><p>设置$\gamma^{(k)}:&#x3D;\gamma^{(k-1)}-M(\gamma^{(k-1)})\left(\frac{\gamma^{(k-1)}-\lambda^{(k)}}{M(\gamma^{(k-1)})-M(\lambda^{(k)})}\right)$；</p>
</li>
<li><p>若$\gamma^{(k)}-\lambda^{(k)}\le\delta$，那么$ x^*:&#x3D;x^{(k+1)},\quad\lambda^*&#x3D;\lambda^{(k)}  $，算法停止；</p>
</li>
<li><p>设置$\lambda^{(k+1)}:&#x3D;f(x^{(k+1)})&#x2F;g(x^{(k+1)}),\ k:&#x3D;k+1$，返回步骤3。</p>
</li>
</ol>
</li>
</ul>
<h3 id="算法有效性分析-1"><a href="#算法有效性分析-1" class="headerlink" title="算法有效性分析"></a>算法有效性分析</h3><blockquote>
<p>📌定理2：<br>$ \lambda^<em>\le\gamma^{(i+1)}&lt;\gamma^{(i)},\quad i&#x3D;-1,0,1,\cdots  $<br>（这个定理强调的是每个迭代的$\gamma^{(i)}$都大于等于$\lambda^</em>$，不会越过$\lambda^*$）</p>
</blockquote>
<blockquote>
<p>证明：（其实或许不需要证明，看上面的图即可体会此定理，但写论文还需要严格证明一下）<br>定义连接$(\lambda^{(n)},M(\lambda^{(n)}))$和$(\gamma^{n-1},M(\gamma^{(n-1)}))$的直线的函数为$L$。<br>由上面可知$\gamma^{(n)}&#x3D;q\lambda^{(n)}+(1-q)\gamma^{(n-1)},\quad q\in(0,1)$<br>所以有<br>$<br>\begin{aligned}<br>&amp;M\left(\gamma^{(n)}\right)&#x3D;M\left(q \lambda^{(n)}+(1-q) \gamma^{(n-1)}\right) \leqslant q M\left(\lambda^{(n)}\right)+(1-q) M\left(\gamma^{(n-1)}\right) \<br>&amp;\quad&#x3D;q L\left(\lambda^{(n)}\right)+(1-q) L\left(\gamma^{(n-1)}\right) \<br>&amp;\quad&#x3D;L\left(q \lambda^{(n)}+(1-q) \gamma^{(n-1)}\right)&#x3D;L\left(\gamma^{(n)}\right)&#x3D;0<br>\end{aligned}<br> $<br>所以$M(\gamma^{(n)})\le0$，由$M()$函数性质可知$\lambda^*\le\gamma^{(n)}$</p>
</blockquote>
<p>接下来论证上界序列$\gamma^{(n)}$也是以超线性的速率收敛到$\lambda^*$的。</p>
<blockquote>
<p><strong>拉格朗日中值定理</strong>：<br>$f(x)$在闭区间$[a,b]$内连续，在开区间$(a,b)$内可导，则在$(a,b)$内至少有一点$\epsilon(a&lt;\epsilon&lt;b)$，使等式$f(b)-f(a)&#x3D;f’(\epsilon)(b-a)$成立。<br><strong>罗尔中值定理</strong>：<br>$f(x)$在闭区间$[a,b]$上连续，在开区间$(a,b)$内可导，且在区间端点处的函数值相等，即$f(a)&#x3D;f(b)$，则在$(a,b)$内至少存在一点$\epsilon(a&lt;\epsilon&lt;b)$，使得$f’(\epsilon)&#x3D;0$。<br><strong>柯西中值定理</strong>：<br>如果函数$f(x),g(x)$满足：<br>(1)在闭区间$[a,b]$上连续<br>(2)在开区间$(a,b)$内可导<br>(3)对任意$x\in(a,b),\ g’(x)\notin0$<br>那么在$(a,b)$内至少有一点$\xi\in(a,b)$，使得$\frac{f(b)-f(a)}{g(b)-g(a)}&#x3D;\frac{f’(\xi)}{g’(\xi)}$成立。</p>
</blockquote>
<p>考虑第$(n+1)$次迭代时，还没有求出结果，根据定义可知</p>
<p>$$<br>\begin{equation}<br>\gamma^{(n+1)}&#x3D;\gamma^{(n)}-M\left(\gamma^{(n)}\right)\left(\frac{\gamma^{(n)}-\lambda^{(n+1)}}{M\left(\gamma^{(n)}\right)-M\left(\lambda^{(n+1)}\right)}\right)<br>\end{equation}<br>$$</p>
<p>经过一些代数运算，可得</p>
<p>$$<br>\begin{equation}<br>\begin{aligned}<br>&amp;\left(\lambda^{<em>}-\gamma^{(n+1)}\right)&#x3D;\left(\lambda^{</em>}-\gamma^{(n)}\right)+M\left(\gamma^{(n)}\right)\left(\frac{\gamma^{(n)}-\lambda^{(n+1)}}{M\left(\gamma^{(n)}\right)-M\left(\lambda^{(n+1)}\right)}\right) \<br>&amp;\quad&#x3D;\frac{(\lambda^*-\gamma^{(n)})(M(\gamma^{(n)})-M(\lambda^{(n+1)}))+M(\gamma^{(n)})\gamma^{(n)}-M(\gamma^{(n)})\lambda^{(n+1)}}{M(\gamma^{(n)})-M(\lambda^{(n+1)})}\<br>&amp;\quad&#x3D;\frac{M(\gamma^{(n)})(\lambda^{<em>}-\lambda^{(n+1)})+M(\lambda^{(n+1)})(\gamma^{(n)}-\lambda^{</em>})}{M(\gamma^{(n)})-M(\lambda^{(n+1)})}\<br>&amp;\quad&#x3D;-(\lambda^*-\lambda^{(n+1)})(\lambda^*-\gamma^{(n)})\frac{\frac{M(\gamma^{(n)})-M(\lambda^*)}{\gamma^{(n)}-\lambda^*}-\frac{M(\lambda^{(n+1)})-M(\lambda^*)}{\lambda^{(n+1)}-\lambda^*}}{M(\gamma^{(n)})-M(\lambda^{(n+1)})}\<br>&amp;\quad&#x3D;-(\lambda^*-\lambda^{(n+1)})(\lambda^*-\gamma^{(n)})\frac{M’(\alpha)-M’(\beta)}{M’(\zeta_{n+1})[\gamma^{(n)}-\lambda^{(n+1)}]}\<br>&amp;\quad&#x3D;-(\lambda^*-\lambda^{(n+1)})(\lambda^*-\gamma^{(n)})\frac{M’’(\xi_{n+1})[\alpha-\beta]}{M’(\zeta_{n+1})[\gamma^{(n)}-\lambda^{(n+1)}]}\<br>&amp;\quad\le-\left(\lambda^{<em>}-\lambda^{(n+1)}\right)\left(\lambda^{</em>}-\gamma^{(n)}\right) \frac{M^{\prime \prime}\left(\xi_{n+1}\right)}{M^{\prime}\left(\zeta_{n+1}\right)}<br>\end{aligned}<br>\end{equation}<br>$$</p>
<p>其中，$\xi_{n+1},\zeta_{n+1}\in[\lambda^{(n+1)},\gamma^{(n)}]$，令$\kappa&#x3D;\frac{\max\limits_{\xi\in I}|M’’(\xi)|}{\min\limits_{\zeta\in I}|M’(\zeta)|}$，$I&#x3D;[\lambda^{(0)},\gamma^{(-1)}]$且$I_{n+1}&#x3D;[\lambda^{(n+1)},\gamma^{(n)}]\subset I$，也就是说$ \kappa  $是分式$\frac{M^{\prime \prime}\left(\xi_{n+1}\right)}{M^{\prime}\left(\zeta_{n+1}\right)}$的上界，因此有</p>
<p>$|\lambda^*-\gamma^{(n+1)}|\le|\lambda^*-\lambda^{(n+1)}||\lambda^*-\gamma^{(n)}|\kappa$，逐级推导，有</p>
<p>$$<br>\begin{equation}<br>\left|\lambda^{<em>}-\gamma^{(n+1)}\right| \leqslant \kappa^{n+2}\left|\lambda^{</em>}-\gamma^{(-1)}\right| \prod_{i&#x3D;0}^{n+1}\left|\lambda^{*}-\lambda^{(i)}\right|<br>\end{equation}<br>$$</p>
<p>前面提到$(\lambda^*-\lambda^{(n+1)})\le(\lambda^*-\lambda^{(n)})(1-\frac{g(x^*)}{g(x^{(n+1)})})$，因此可以将不等式进一步拆解成</p>
<p>$$<br>\begin{equation}<br>\left|\lambda^{<em>}-\gamma^{(n+1)}\right| \leqslant \kappa^{n+2}\left|\lambda^{</em>}-\gamma^{(-1)} | \lambda^{*}-\lambda^{(0)}\right|^{n+2} \prod_{i&#x3D;1}^{n+1} \varepsilon_{i}^{n-i+2}<br>\end{equation}<br>$$</p>
<p>引理2说明，$\epsilon$收敛到0。因此对于任意$\theta\in(0,1]$，存在整数$n_{\theta}\ge0$使得对于所有$i\ge n_\theta$都有$ \kappa|\lambda^*-\lambda^{(0)}|\epsilon_i&lt;\theta  $，因此定义$<br>\alpha_{\theta}&#x3D;\kappa\left|\lambda^{<em>}-\lambda^{(0)}\right| \prod_{i&#x3D;1}^{n_{\theta}-1}\left(\frac{\kappa\left|\lambda^{</em>}-\lambda^{(0)}\right| \varepsilon_{i}^{n-i+2}}{\theta}\right)<br> $，我们有</p>
<p>$$<br>\begin{equation}<br>\frac{\left|\lambda^{<em>}-\gamma^{(n+1)}\right|}{\theta^{n+1}} \leqslant\left|\lambda^{</em>}-\gamma^{(-1)}\right| \alpha_{\theta} \prod_{i&#x3D;n_{\theta}}^{n+1}\left(\frac{\kappa\left|\lambda^{*}-\lambda^{(0)}\right| \varepsilon_{i}^{n-i+2}}{\theta}\right)<br>\end{equation}<br>$$</p>
<p>因此，可以得到$\lim\limits_{n\rightarrow\infty}\frac{|\lambda^*-\gamma^{(-1)}|}{\theta^{n+1}}&#x3D;0$，也就是说序列上界$\gamma^{(n+1)}$同样将以超线性的速率收敛到$\lambda^*$。</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学方法</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划（基础）</title>
    <url>/2021/10/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%9F%BA%E7%A1%80/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="动态规划-基础"><a href="#动态规划-基础" class="headerlink" title="动态规划-基础"></a>动态规划-基础</h1><h1 id="1-背包模型"><a href="#1-背包模型" class="headerlink" title="1 背包模型"></a>1 背包模型</h1><p><strong>背包模型各子问题特征</strong></p>
<table>
<thead>
<tr>
<th>问题</th>
<th>特征</th>
</tr>
</thead>
<tbody><tr>
<td>零一背包</td>
<td>背包中每件物品最多仅用一次</td>
</tr>
<tr>
<td>完全背包</td>
<td>每件物品有无限个</td>
</tr>
<tr>
<td>多重背包</td>
<td>每种物品最多Si个</td>
</tr>
<tr>
<td>分组背包</td>
<td>N组，每一组里最多只能选一个物品</td>
</tr>
</tbody></table>
<h2 id="1-1-零一背包问题"><a href="#1-1-零一背包问题" class="headerlink" title="1.1 零一背包问题"></a>1.1 零一背包问题</h2><blockquote>
<p>📌有N个物品和一个容量为V的背包，每个物品的体积是Vi，价值是Wi，每件物品仅用一次。要挑选一些物品，使总体积小于等于V，目标让塞进背包的物品总价值最大，求问最大价值</p>
</blockquote>
<ul>
<li><p>通过01背包可以引出求解DP问题的一般思路</p>
<p><img src="/image/Fig1_xe6xHotGq9.png"></p>
</li>
</ul>
<p>i表示不同的物品，j表示不同容量的背包的体积。f(i,j)就表示满足：从前i个物品中选且总体积小于等于j的所有选法中（集合），价值的最大值（属性）。</p>
<p>状态计算就是一种集合的划分，将当前的集合划分成若干个更小的集合，使得当前集合可以通过更小的集合算出来。而且更小的集合是之前已经算过的。对应到01背包，就是把所有选法分成两大类：不包含第i个物品，和包含第i个物品。</p>
<blockquote>
<p>子集划分原则：不重复（不严格要求） &amp; 不漏掉（严格要求）</p>
</blockquote>
<p>这里的第2类：包含第i个物品，直接求并不好求，因为可能的情况太多了。这里要曲线救国，先把每种选法里的第i个物品都去掉，此时全部可包含第i物品的选法数是不变的，这些选法的最大价值为f(i-1, j-Vi)，那么再加上W_i，其实就是包含第i个物品的所有选法的最大值。</p>
<p>最终，f(i,j)就是两个子集的最大值，再取一次最大值。</p>
<p>总结一下的话：动态规划的状态就是<strong>集合的某种属性</strong>（此处是所有选法的最大价值），状态计算的核心就是对集合进行划分。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//朴素算法代码：二维状态</span></span><br><span class="line"><span class="comment">//01背包的状态转移方程：f(i,j) = Max( f(i-1, j), f(i-1, j-Vi)+Wi )</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;                                 <span class="comment">//n物品数, m最大体积</span></span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;           <span class="comment">//i从1开始，因为f[0][...]必然是0</span></span><br><span class="line">    cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)&#123;</span><br><span class="line">      f[i][j] = f[i<span class="number">-1</span>][j];               <span class="comment">//不含i的子集是必然存在的</span></span><br><span class="line">      <span class="keyword">if</span>(j &gt;= v[i])                      <span class="comment">//判断含i的子集是否可以存在</span></span><br><span class="line">        f[i][j] = <span class="built_in">max</span>(f[i][j], f[i<span class="number">-1</span>][j-v[i]] + w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在朴素二维状态的基础上还可以优化成一维状态，有两个前提：</p>
<ol>
<li><p>f(i)层只用到了f(i-1)层 —&gt; 滚动数组(迭代器)</p>
</li>
<li><p>两个子集的元素的体积永远小于等于j，而不是在j两侧</p>
</li>
</ol>
<p>所以使用一维数组不同次数的值可以有相当于二维数组不同层的效果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优化算法代码：一维状态</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;                                 <span class="comment">//n物品数, m最大体积</span></span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;           <span class="comment">//i从1开始，因为f[0][...]必然是0</span></span><br><span class="line">    cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    <span class="comment">//如果下面for遍历从前向后，相当于使用了f[i][j-v[i]]而非f[i-1][j-v[i]]</span></span><br><span class="line">    <span class="comment">//因为后一个数用到了前一个数，但前一个数已经在上次迭代中被从i-1更新i</span></span><br><span class="line">    <span class="comment">//如果反向遍历，后一个数还是会用到前一个数，但此时前一个数未被更新</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= v[i]; j--)       <span class="comment">//注意这里和朴素算法的顺序是反的</span></span><br><span class="line">        f[j] = <span class="built_in">max</span>(f[j], f[j-v[i]] + w[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-完全背包问题"><a href="#1-2-完全背包问题" class="headerlink" title="1.2 完全背包问题"></a>1.2 完全背包问题</h2><blockquote>
<p>📌有N件物品和一个容量为V的背包，每个物品的体积是Vi，价值是Wi，每件物品可用无限次。挑选一些物品，使总体积小于等于V，让塞进背包的物品总价值最大，求问最大价值</p>
</blockquote>
<ul>
<li>完全背包和01背包解法很相似，集合的划分分为两类：不包含第i个物品，和包含第i个物品。只是第2个类别中的曲线救国改成了f( i-1, j-k*Vi)+k*Wi，k是物品i的使用次数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//朴素算法代码：二维状态</span></span><br><span class="line"><span class="comment">//完全背包的状态转移方程：f(i,j) = Max( f(i-1, j), f(i-1, j-k*Vi)+k*Wi )</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;                                 <span class="comment">//n物品数, m最大体积</span></span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;           <span class="comment">//i从1开始，因为f[0][...]必然是0</span></span><br><span class="line">    cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k*v[i] &lt;= j; k++)   <span class="comment">//k从0开始，所以其实f[i-1][j]是不需要的</span></span><br><span class="line">        f[i][j] = <span class="built_in">max</span>(f[i][j], f[i<span class="number">-1</span>][j-k*v[i]] + k*w[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于上述朴素算法用到三种循环，时间复杂度还是相当高的，可以通过状态转移方程对其优化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原状态转移方程：f(i,j) = Max( f(i-1,j), f(i-1,j-Vi)+Wi, f(i-1,j-2Vi)+2Wi, ... )</span></span><br><span class="line"><span class="comment">//考虑j-Vi：   f(i,j-Vi)= Max(           f(i-1,j-Vi),    f(i-1,j-2Vi)+Wi,  ... )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一次优化：二维状态</span></span><br><span class="line"><span class="comment">//优化后的状态转移方程：f(i,j) = Max( f(i-1,j), f(i,j-Vi)+Wi )</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;                                 <span class="comment">//n物品数, m最大体积</span></span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;           <span class="comment">//i从1开始，因为f[0][...]必然是0</span></span><br><span class="line">    cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)&#123;</span><br><span class="line">      f[i][j] = f[i<span class="number">-1</span>][j];               <span class="comment">//不含i的子集是必然存在的</span></span><br><span class="line">      <span class="keyword">if</span>(j &gt;= v[i])                      <span class="comment">//判断含i的子集是否可以存在</span></span><br><span class="line">        f[i][j] = <span class="built_in">max</span>(f[i][j], f[i][j-v[i]] + w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在还可以按照01背包的优化方式，进行进一步优化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最终优化：一维状态</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;                                 <span class="comment">//n物品数, m最大体积</span></span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;           <span class="comment">//i从1开始，因为f[0][...]必然是0</span></span><br><span class="line">    cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = v[i]; j &lt;= m; j++)       <span class="comment">//这里遍历是正向的，因为符合状态转移方程</span></span><br><span class="line">        f[j] = <span class="built_in">max</span>(f[j], f[j-v[i]] + w[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>📌Tip：动态规划中如果状态转移用到了上一层的内容，就按体积从小到大的顺序遍历；如果用到本层内容，则反过来，使用体积从大到小的顺序</p>
</blockquote>
<h2 id="1-3-多重背包问题"><a href="#1-3-多重背包问题" class="headerlink" title="1.3 多重背包问题"></a>1.3 多重背包问题</h2><ul>
<li><p>多重背包是有限情景下的完全背包，二者的朴素写法几乎是一样的</p>
</li>
<li><p>不能使用完全背包的优化方法来优化多重背包</p>
<p>原方程：f(i,j) &#x3D; Max( f(i-1,j), f(i-1,j-Vi)+Wi, f(i-1,j-2Vi)+2Wi, … , f(i-1,j-Si<em>Vi)+Si</em>Vi )</p>
<p>j-Vi： f(i,j-Vi) &#x3D; Max(           f(i-1,j-Vi),        f(i-1,j-2Vi)+Wi, … ,   f(i-1,j-Si<em>Vi)+(Si-1)</em> Vi,</p>
<p>&amp;#x20;                                       f(i-1,j-(Si+1)*Vi)+Si*Vi  )</p>
<p>完全背包问题中的k是受背包容量限制的，不会多红字那一项，但多重背包同时受背包容量和Si限制，如果可虑所有情况，就有可能出现红字那一项。那么完全背包所用的优化方法不再适用</p>
</li>
</ul>
<blockquote>
<p>📌有N种物品和一个容量为V的背包，每种物品中一件的体积是Vi，价值是Wi，每种物品最多可用Si次。挑选一些物品，使总体积小于等于V，让塞进背包的物品总价值最大，求问最大价值</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//朴素算法代码：二维状态</span></span><br><span class="line"><span class="comment">//多重背包的状态转移方程：f(i,j) = Max( f(i-1, j), f(i-1, j-k*Vi)+k*Wi )</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;                                 <span class="comment">//n物品数, m最大体积</span></span><br><span class="line"><span class="type">int</span> v[N],w[N],s[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k*v[i] &lt;= j &amp;&amp; k &lt;= s[i]; k++)<span class="comment">//多重和完全的朴素写法不同之处为此处条件</span></span><br><span class="line">        <span class="comment">//k从0开始，所以其实f[i-1][j]是不需要的</span></span><br><span class="line">        f[i][j] = <span class="built_in">max</span>(f[i][j], f[i<span class="number">-1</span>][j-k*v[i]] + k*w[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>优化方法：二进制优化！！！</li>
</ul>
<p>(其实还可以使用单调队列优化，后面的内容)</p>
<p>对于任意大小s[i]，里面所有的数都可以由一系列“二的整数次方”组成，比如s&#x3D;1023</p>
<p>则所有比1023小的数都可以用{1,2,4,8,…,512}组合出来。</p>
<p>又比如200：1,2,4,8,16,32,64,73</p>
<p>那么k的遍历那一环其实就变成了01背包问题，不再需要遍历全部Si次，只需设置log2Si个背包</p>
<p>时间复杂度从NVS到NVlog2S</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25000</span>, M = <span class="number">2010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;<span class="comment">//建立新背包</span></span><br><span class="line">    <span class="type">int</span> a,b,s;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k &lt;= s)&#123;</span><br><span class="line">      cnt++;</span><br><span class="line">      v[cnt] = a * k;</span><br><span class="line">      w[cnt] = b * k;</span><br><span class="line">      s -= k;</span><br><span class="line">      k *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      cnt ++;</span><br><span class="line">      v[cnt] = a * s;</span><br><span class="line">      w[cnt] = b * s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  n = cnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= v[i]; j-- )</span><br><span class="line">      f[j] = <span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; f[m] &lt;&lt;endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-分组背包问题"><a href="#1-4-分组背包问题" class="headerlink" title="1.4 分组背包问题"></a>1.4 分组背包问题</h2><blockquote>
<p>📌有N组物品和一个容量为V的背包，每件物品的体积是Vij，价值是Wij，i是组号，j是组内编号，同一组内的物品最多选一个。挑选一些物品，使总体积小于等于V，让塞进背包的物品总价值最大，求问最大价值</p>
</blockquote>
<ul>
<li>热狗划分法(状态计算)：</li>
</ul>
<p><img src="/image/Fig2_Kc0B6M3H-a.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> v[N][N],w[N][N],s[N];                 <span class="comment">//s[i]表示第i组有多少物品</span></span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ;i &lt;= n; i++)&#123;</span><br><span class="line">    cin &gt;&gt; s[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; s[i]; j++ )</span><br><span class="line">      cin&gt;&gt;v[i][j]&gt;&gt;w[i][j];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j--)           <span class="comment">//因为要用到i-1，所以逆序遍历</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; s[i]; k++ )</span><br><span class="line">        <span class="keyword">if</span>(v[i][k] &lt;= j)</span><br><span class="line">          f[j] = <span class="built_in">max</span>(f[j],f[j-v[i][k]]+w[i][k]);</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-线性DP"><a href="#2-线性DP" class="headerlink" title="2 线性DP"></a>2 线性DP</h1><blockquote>
<p>线性DP就是在线性结构上转移状态，完成线性空间上的递推</p>
</blockquote>
<h2 id="2-1-例题1：数字三角形"><a href="#2-1-例题1：数字三角形" class="headerlink" title="2.1 例题1：数字三角形"></a>2.1 例题1：数字三角形</h2><blockquote>
<p>📌给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大<br>&amp;#x20;           7<br>&amp;#x20;        3    8<br>&amp;#x20;     8    1    0<br>&amp;#x20;  2    7    4    4<br>4    5    2    6    5</p>
</blockquote>
<ul>
<li>求解思路：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 状态表示：</span><br><span class="line">f(i,j)：走到(i,j)位置的所有路径的集合的max</span><br><span class="line">                  集合              属性</span><br><span class="line">               第一列</span><br><span class="line">第一行         7  第二列</span><br><span class="line">第二行       3   8  第三列</span><br><span class="line">第三行     8   1   0  第四列</span><br><span class="line">第四行   2   7   4   4  第五列</span><br><span class="line">第五行 4   5   2   6   5</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 状态计算(令a(i,j)表示(i,j)位置元素的值)</span><br><span class="line">分类：左上来的路径    和   右上来的路径 </span><br><span class="line">   f(i-1,j-1)+a(i,j)    f(i-1,j)+a(i,j)</span><br><span class="line"></span><br><span class="line">⇒状态转移方程：</span><br><span class="line">f(i,j) = Max( f(i-1,j-1)+a(i,j) , </span><br><span class="line">              f(i-1,j)+a(i,j)) )</span><br></pre></td></tr></table></figure>

<ul>
<li>代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">512</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);                    <span class="comment">//一共有几行几列</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)         <span class="comment">//获取三角形</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i + <span class="number">1</span>; j++)   <span class="comment">//这里的列需要从0开始，到i+1结束，补全边缘数字两侧</span></span><br><span class="line">      f[i][j] = -INF;                 <span class="comment">//防止求和为负数时，初值为0的误判</span></span><br><span class="line"></span><br><span class="line">  f[<span class="number">1</span>][<span class="number">1</span>] = a[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">      f[i][j] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j], f[i<span class="number">-1</span>][j]+a[i][j]);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> res = -INF;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)res = <span class="built_in">max</span>(res,f[n][i]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, res);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-例题2：最大上升子序列"><a href="#2-2-例题2：最大上升子序列" class="headerlink" title="2.2 例题2：最大上升子序列"></a>2.2 例题2：最大上升子序列</h2><blockquote>
<p>📌给定一个长度为N的数列，求数值严格单调递增的子序列的长度最长是多少，并记录子序列<br>输入样例：<br>7&amp;#x20;<br>3 1 2 1 8 5 6<br>结果：<br>4<br>1 2 5 6</p>
</blockquote>
<ul>
<li>朴素方法求解思路：</li>
</ul>
<!---->

<pre><code>- 状态表示：
f[i]：到第i个位置的子序列集合的max
</code></pre>
<!---->

<pre><code>- 状态计算：
f[i] = f[j]+1, j = 1,2,...,i-1 &amp;&amp; a[j]&lt;a[i]
</code></pre>
<ul>
<li>朴素方法代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>; <span class="comment">// 只有a[i]一个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[i])</span><br><span class="line">                f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优化</strong></li>
</ul>
<p><strong>求解思路：</strong></p>
<p>对于像</p>
<pre><code>7
3 1 2 1 8 5 6
</code></pre>
<p>这样的序列，在走到i时，可以存储i之前的各个长度里的上升子序列中末尾最小值，比如8之前，长度为1的上升子序列的末尾值可以有3和1，但是3是没必要存的，能接在3后也必然能接在1后</p>
<p>而且各个长度的上升子序列的末尾最小值必然严格单调递增</p>
<p><img src="/image/Fig3_tLiUPdQcXh.png"></p>
<p>可以用反证法证明这一性质：</p>
<p>若q6比q5小，那么q6所在子序列的第5个值也比q5小，那么q5就不是长度为5的子序列中的最小末尾值，矛盾</p>
<p>于是当走到第i个字符a[i]时，可以查找a[i]之前所有长度子序列中，小于a[i]的最大的末尾最小值。</p>
<p>比如说，q4&lt;a[i]，而q5&gt;a[i]，那么q4就是那个最大的末尾最小值，而且q5将被替换成a[i]</p>
<p>查找最大的末尾最小值时可以使用二分查找。时间复杂度较之前大大减少。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = len;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (q[mid] &lt; a[i]) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        len = <span class="built_in">max</span>(len, r + <span class="number">1</span>);</span><br><span class="line">        q[r + <span class="number">1</span>] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-例题3：-最长公共子序列"><a href="#2-3-例题3：-最长公共子序列" class="headerlink" title="2.3 例题3： 最长公共子序列"></a>2.3 例题3： 最长公共子序列</h2><blockquote>
<p>📌给定两个长度分别为N和M的字符串A和B，求既是A的子序列又是B的子序列的字符串长度最长是多少<br>输入案例：<br>4 5<br>acbd<br>abedc<br>输出：3(abd)</p>
</blockquote>
<ul>
<li>求解思路：</li>
</ul>
<p><strong>状态表示</strong>：</p>
<p>f(i,j)：所有在A序列的前i个字母中出现，并在B序列的前j个字母中出现的子序列的集合中的Max</p>
<p><strong>状态计算：</strong></p>
<p><img src="/image/Fig4_ujvYujEOup.png"></p>
<p>上述四者分别是 f(i-1, j-1) 、f(i-1, j) 、f(i, j-1) 、f(i-1, j-1)+1</p>
<p>需要注意中间二者，f(i-1, j)并不是严格的01情况，f(i, j-1)也不是严格的10情况</p>
<pre><code>f(i-1,j)是：
所有在A序列的前i-1个字母中出现
并在B序列的前j个字母中出现的子序列集合

01是：
不包含A序列的第i个字母，
但是包含B序列的第j个字母的子序列的集合

前者包含后者，二者并不相等
</code></pre>
<!---->

<pre><code>f(i,j-1)是：
所有在A序列的前i个字母中出现
并在B序列的前j-1个字母中出现的子序列集合

10是：
包含A序列的第i个字母，
但是不包含B序列的第j个字母的子序列的集合

前者包含后者，二者并不相等
</code></pre>
<p>求最大值时重复是没有关系的，只要保证不漏就行</p>
<p>事实上第一项f(i-1, j-1)也没有必要写，因为它被f(i-1, j)和f(i, j-1)包含了</p>
<ul>
<li>代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, a + <span class="number">1</span>, b + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (a[i] == b[j]) f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n][m]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-例题4：最短编辑距离"><a href="#2-4-例题4：最短编辑距离" class="headerlink" title="2.4 例题4：最短编辑距离"></a>2.4 例题4：最短编辑距离</h2><blockquote>
<p>📌给定两个字符串A和B，现在要将A经过若干操作变为B，可进行的操作有：<br>- 删除：将字符串A中的某个字符删除。<br>- 插入：在字符串A的某个位置插入某个字符。<br>- 替换：将字符串A中的某个字符替换为另一个字符。<br>现在请你求出，将A变为B至少需要进行多少次操作。</p>
</blockquote>
<ul>
<li>求解思路：</li>
</ul>
<p><strong>状态表示：</strong></p>
<p>f(i,j)：所有从A[1~i]变到B[1~j]的操作方式的集合的min</p>
<p><strong>状态计算：</strong></p>
<p><img src="/image/Fig5_7BHn4a-NxW.png"></p>
<p>→ 状态转移方程：</p>
<p>f(i, j) &#x3D; min( f(i-1, j) + 1, f(i, j-1) + 1, f(i-1, j-1) + 1&#x2F;0 )</p>
<p>删的前提是A[1~i-1]&#x3D;&#x3D;B[1~j]</p>
<p>增的前提是A[1~i]&#x3D;&#x3D;B[1~j-1]</p>
<p>改的前提是A[1~i-1]&#x3D;&#x3D;B[1~j-1]，如果A[i]&#x3D;&#x3D;B[j]，加0，否则加1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;n, a+<span class="number">1</span>);<span class="comment">//接收a字符串</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;m, b+<span class="number">1</span>);<span class="comment">//接收b字符串</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) f[<span class="number">0</span>][j] = j;<span class="comment">//a为空时，只能增，增加b的长度</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) f[i][<span class="number">0</span>] = i;<span class="comment">//b为空时，只能删，删除a的长度</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">      f[i][j] = <span class="built_in">min</span>(f[i<span class="number">-1</span>][j]+<span class="number">1</span>, f[i][j<span class="number">-1</span>]+<span class="number">1</span>);<span class="comment">//前两种情况直接比较</span></span><br><span class="line">      <span class="keyword">if</span>(a[i] == b[j])f[i][j] = <span class="built_in">min</span>(f[i][j], f[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">      <span class="keyword">else</span> f[i][j] = <span class="built_in">min</span>(f[i][j], f[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, f[n][m]);  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>例题变形：</strong></p>
</li>
<li></li>
</ul>
<blockquote>
<p>📌给定n个长度不超过10的字符串以及m次询问，每次询问给出一个字符串和一个操作次数上限。<br>对于每次询问，请你求出给定的n个字符串中有多少个字符串可以在上限操作次数内经过操作变成询问给出的字符串。<br>每个对字符串进行的单个字符的插入、删除或替换算作一次操作。</p>
</blockquote>
<p>其实就是将刚刚的过程操作n*m次</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">15</span>, M = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">char</span> str[M][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">edit_distance</span><span class="params">(<span class="type">char</span> a[], <span class="type">char</span> b[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> la = <span class="built_in">strlen</span>(a + <span class="number">1</span>), lb = <span class="built_in">strlen</span>(b + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= lb; i ++ ) f[<span class="number">0</span>][i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= la; i ++ ) f[i][<span class="number">0</span>] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= la; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= lb; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i - <span class="number">1</span>][j] + <span class="number">1</span>, f[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + (a[i] != b[j]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f[la][lb];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);                                     <span class="comment">//n个字符串，m次询问</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str[i] + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> s[N];</span><br><span class="line">        <span class="type">int</span> limit;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, s + <span class="number">1</span>, &amp;limit);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">edit_distance</span>(str[i], s) &lt;= limit)</span><br><span class="line">                res ++ ;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-区间DP"><a href="#3-区间DP" class="headerlink" title="3 区间DP"></a>3 区间DP</h1><blockquote>
<p>区间dp就是在区间上进行动态规划，求解一段区间上的最优解。<br>主要是通过合并小区间的最优解，进而得出整个大区间上最优解的dp算法</p>
</blockquote>
<h2 id="3-1-例题1：石子合并"><a href="#3-1-例题1：石子合并" class="headerlink" title="3.1 例题1：石子合并"></a>3.1 例题1：石子合并</h2><blockquote>
<p>📌设有N堆石子排成一排，其编号为1，2，3，…，N。<br>每堆石子有一定的质量，可以用一个整数来描述，现在要将这N堆石子合并成为一堆。</p>
<p>每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。</p>
<p>例如有4堆石子分别为 1 3 5 2， 我们可以先合并1、2堆，代价为4，得到4 5 2， 又合并 1，2堆，代价为9，得到9 2 ，再合并得到11，总代价为4+9+11&#x3D;24；</p>
<p>如果第二步是先合并2，3堆，则代价为7，得到4 7，最后一次合并代价为11，总代价为4+7+11&#x3D;22。</p>
<p>问题是：找出一种合理的方法，使总的代价最小，输出最小代价。</p>
</blockquote>
<ul>
<li>求解思路：</li>
</ul>
<p><strong>状态表示</strong>：</p>
<p>f(i,j)：所有将第i堆石子~第j堆石子合并成一堆石子的合并方式的集合中的Min</p>
<p><strong>状态计算</strong>：</p>
<ol>
<li>状态划分：</li>
</ol>
<p><img src="/image/Fig6_txs_Inikl4.png"></p>
<p>&amp;#x20;2.  状态转移：f(i, j) &#x3D; Min( f(i, m) + f(m+1, j) + sum(j)-sum(i-1) ), m &#x3D; i,i+1,…,j-1</p>
<p>蓝字是前缀和，用于计算当前两堆的代价</p>
<p>最终状态就是f(1,n)</p>
<p>状态转移的图解：</p>
<p><img src="/image/Fig7_XQbN7O-acE.png"></p>
<ul>
<li>代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">310</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//一共多少石堆</span></span><br><span class="line"><span class="type">int</span> s[N];<span class="comment">//每堆的重量</span></span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) s[i] += s[i - <span class="number">1</span>];<span class="comment">//求前缀和</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i ++ )&#123;</span><br><span class="line">            <span class="type">int</span> l = i, r = i + len - <span class="number">1</span>;</span><br><span class="line">            f[l][r] = <span class="number">1e8</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = l; k &lt; r; k ++ )</span><br><span class="line">                f[l][r] = <span class="built_in">min</span>(f[l][r], f[l][k] + f[k + <span class="number">1</span>][r] + s[r] - s[l - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[<span class="number">1</span>][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-计数类DP"><a href="#4-计数类DP" class="headerlink" title="4 计数类DP"></a>4 计数类DP</h1><blockquote>
<p>将DP算法应用在计数类问题</p>
</blockquote>
<h2 id="4-1-例题1：整数划分"><a href="#4-1-例题1：整数划分" class="headerlink" title="4.1 例题1：整数划分"></a>4.1 例题1：整数划分</h2><blockquote>
<p>📌一个正整数n可以表示成若干个正整数之和，形如：n&#x3D;n1+n2+…+nk，其中n1≥n2≥…≥nk,k≥1。</p>
<p>我们将这样的一种表示称为正整数n的一种划分。</p>
<p>现在给定一个正整数n，请你求出n共有多少种不同的划分方法。<br>由于答案可能很大，输出结果请对109+7取模。</p>
</blockquote>
<ul>
<li><strong>思路一：背包问题</strong></li>
</ul>
<p><strong>状态表示：</strong></p>
<p>f(i, j)：从1~i中选取数值后，求和正好是j的集合中的数值数量</p>
<p><strong>状态计算：</strong></p>
<p><img src="/image/Fig8_WIbazbZy8S.png"></p>
<p><strong>优化：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当前状态转移方程：f(i,j) = f(i-1,j) + f(i-1,j-i) + f(i-1,j-2*i)+...+f(i-1,j-s*i)</span><br><span class="line">               f(i,j-i)=           f(i-1,j-i) + f(i-1,j-2*i)+...+f(i-1,j-s*i)</span><br><span class="line">优化后转移方程：  f(i,j) = f(i-1,j) + f(i,j-i)</span><br><span class="line">优化到一维：     f(j) = f(j) + f(j-i)       </span><br></pre></td></tr></table></figure>

<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; j ++ )</span><br><span class="line">            f[j] = (f[j] + f[j - i]) % mod;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>思路二：</strong></li>
</ul>
<!---->

<pre><code>- 状态表示：
所有总和为i，并且恰好表示成j个数的和的方案
的集合中的
数值数量(也就是j)
</code></pre>
<!---->

<pre><code>- 状态计算：
f(i,j) = f(i-1,j-1) + f(i-j,j)
曲线救国
f(i-1,j-1)是f(i,j)中包含最小值1的方案
f(i-j,j)是f(i,j)中不包含最小值1的方案
                  (j个数都减1)
</code></pre>
<p>注意：这种思路最后结果是f(n,1)+f(n,2)+f(n,3)……</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j ++ )</span><br><span class="line">            f[i][j] = (f[i - <span class="number">1</span>][j - <span class="number">1</span>] + f[i - j][j]) % mod;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) res = (res + f[n][i]) % mod;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-数位统计DP"><a href="#5-数位统计DP" class="headerlink" title="5 数位统计DP"></a>5 数位统计DP</h1><blockquote>
<p>竞赛中有这样一类问题：求给定区间中，满足给定条件的某个D进制数或此类数的数量。所求的限定条件往往与数位有关，例如数位之和、指定数码个数、数的大小顺序分组等等。题目给定的区间往往很大，无法采用朴素的方法求解。</p>
</blockquote>
<h1 id="6-状态压缩DP"><a href="#6-状态压缩DP" class="headerlink" title="6 状态压缩DP"></a>6 状态压缩DP</h1><blockquote>
<p>将状态表示成二进制数，每一位都与状态一一对应</p>
</blockquote>
<h2 id="6-1-例题1：蒙德里安的梦想"><a href="#6-1-例题1：蒙德里安的梦想" class="headerlink" title="6.1 例题1：蒙德里安的梦想"></a>6.1 例题1：蒙德里安的梦想</h2><blockquote>
<p>📌求把N*M的棋盘分割成若干个1*2的的长方形，有多少种方案。<br>例如当N&#x3D;2，M&#x3D;4时，共有5种方案。<br>如下图所示：</p>
</blockquote>
<p><img src="/image/Fig9_6Qdw3BuZTK.png"></p>
<ul>
<li><p><strong>思路：</strong></p>
<p><img src="/image/Fig10_UIwbppcb7E.png"></p>
</li>
</ul>
<p>举例说明，一旦某一个方案所有横向1*2的长方形放完了，那么该方案的所有纵向2*1也就只能填充，无法再做改变。所以只需要排列横向1*2长方形即可，而通过列来检查排列是否可行：</p>
<ol>
<li><p>排完横向后，第i列不可以有连续奇数个空格</p>
</li>
<li><p>从第i-2到第i-1列的横向长方形和从第i-1列到第i列的横向长方形不能有重合</p>
</li>
</ol>
<ul>
<li><strong>状态表示：</strong></li>
</ul>
<p>f(i, j)：i表示目前排到第i列，j表示从第i-1列伸过来的横向长方形的状态</p>
<p>&amp;#x20;     f(i, j)表示排到第i列的(满足约束的)方案的个数</p>
<p>举例来说，上图中，目前第i列的 j1 &#x3D; 0010(二进制)</p>
<p>目前第i-1列的 j2 &#x3D; 1001(二进制)</p>
<p>一共有m列，从0到m-1</p>
<p>那么上述两个约束条件变成了：</p>
<ol>
<li><p>(j1&amp;j2) 必须等于0</p>
</li>
<li><p>j1中不可以有连续奇数个0</p>
</li>
</ol>
<ul>
<li><strong>状态计算：</strong></li>
</ul>
<p>f(i, j) &#x3D; f(i-1, k1) + f(i-1, k2)+ …….</p>
<p>其中k1,k2……是排到第i-1列时满足约束的方案的 j</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*------最终结果是f(m,0)，也就是第m列，没有捅出来的横格时的所有方案-------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">12</span>, M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[N][M];</span><br><span class="line"><span class="type">bool</span> st[M];<span class="comment">//标志第i列的j是否可行</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//逗号运算符分隔两个表达式，但是最终结果是后一个表达式的结果</span></span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m, n || m)<span class="comment">//当n或m有一个数为0意味着终止测试</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//做约束条件2的检查，检查一下，一列的所有横向排法中，有哪些排法会有连续奇数个0，用st记录</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i ++ )<span class="comment">//有n行，j就有n位</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">                <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>)<span class="comment">//先右移再与，判断第j位是不是1</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>) st[i] = <span class="literal">false</span>;</span><br><span class="line">                    cnt = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> cnt ++ ;</span><br><span class="line">            <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>) st[i] = <span class="literal">false</span>;<span class="comment">//cnt用来记录连续0的个数，如果是奇数个则此方案不可行</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//啥都没放是一种合法的初始状态，方案数为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; n; j ++ )</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">1</span> &lt;&lt; n; k ++ )</span><br><span class="line">                    <span class="comment">//st[j | k]而不是st[j]&amp;st[k],为什么？</span></span><br><span class="line">                    <span class="keyword">if</span> ((j &amp; k) == <span class="number">0</span> &amp;&amp; st[j | k])<span class="comment">//判断两个约束</span></span><br><span class="line">                        f[i][j] += f[i - <span class="number">1</span>][k];</span><br><span class="line">        cout &lt;&lt; f[m][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-2-例题2：最短Hamilton路径"><a href="#6-2-例题2：最短Hamilton路径" class="headerlink" title="6.2 例题2：最短Hamilton路径"></a>6.2 例题2：最短Hamilton路径</h2><blockquote>
<p>📌给定一张 n 个点的带权无向图，点从 0~n-1 标号，求起点 0 到终点 n-1 的最短Hamilton路径。 Hamilton路径的定义是从 0 到 n-1 不重不漏地经过每个点恰好一次。<br>(此问题就是大名鼎鼎的旅行商问题)</p>
<p><strong>输入格式</strong><br>第一行输入整数n。<br>接下来n行每行n个整数，其中第i行第j个整数表示点i到j的距离（记为a[i,j]）。<br>对于任意的x,y,z，数据保证 a[x,x]&#x3D;0，a[x,y]&#x3D;a[y,x] 并且 a[x,y]+a[y,z]&gt;&#x3D;a[x,z]。</p>
<p><strong>输出格式</strong><br>输出一个整数，表示最短Hamilton路径的长度。</p>
</blockquote>
<ul>
<li><strong>思路：</strong></li>
</ul>
<p><strong>状态表示</strong>：f(i, j)表示为从0走到 j的所有路径是 i的加权和集合的Min</p>
<p>比如i &#x3D; 110001 表示为从0到 j，走了点1、5、6，没走2、3、4</p>
<p><strong>状态计算</strong>：</p>
<p>通过看走到 j之前的倒数第二个点来做状态转移</p>
<p>如果倒数第二个点是k，则 f(i, j) &#x3D; f(i-{j}, k) + a[k, j]</p>
<p>所以也就是f(i, j) &#x3D; min( f(i-{j}, k) + a[k, j] )，k是所有从0到 j所经过的倒数第二个点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>, M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> w[N][N];</span><br><span class="line"><span class="type">int</span> f[M][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            cin &gt;&gt; w[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k ++ )</span><br><span class="line">                    <span class="keyword">if</span> (i &gt;&gt; k &amp; <span class="number">1</span>)</span><br><span class="line">                        f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - (<span class="number">1</span> &lt;&lt; j)][k] + w[k][j]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-树形DP"><a href="#7-树形DP" class="headerlink" title="7 树形DP"></a>7 树形DP</h1><blockquote>
<p>一般来说树形dp在设状态转移方程时都可以用f[i][]表示i这颗子树怎么怎么样的最优解，实现时一般都是用子树更新父亲（即从下向上更新）</p>
</blockquote>
<h2 id="7-1-例题1：没有上司的舞会"><a href="#7-1-例题1：没有上司的舞会" class="headerlink" title="7.1 例题1：没有上司的舞会"></a>7.1 例题1：没有上司的舞会</h2><blockquote>
<p>📌(树形DP最经典问题)<br>Ural大学有N名职员，编号为1~N。<br>他们的关系就像一棵以校长为根的树，父节点就是子节点的直接上司。<br>每个职员有一个快乐指数，用整数 Hi 给出，其中 1≤i≤N。<br>现在要召开一场周年庆宴会，不过，没有职员愿意和直接上司一起参会。<br>在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所有参会职员的快乐指数总和最大，求这个最大值。</p>
<p><strong>输入格式</strong><br>第一行一个整数N。<br>接下来N行，第 i 行表示 i 号职员的快乐指数Hi。<br>接下来N-1行，每行输入一对整数L, K,表示K是L的直接上司。</p>
<p><strong>输出格式</strong><br>输出最大的快乐指数。</p>
</blockquote>
<ul>
<li>思路：</li>
</ul>
<p><strong>状态表示</strong>：</p>
<p>每个节点都有两种状态：</p>
<p>f(u, 0)：以u为根节点，但是不选择u的所有方案的集合中的最大快乐指数</p>
<p>f(u, 1)：以u为根节点，同时选择u的所有方案的集合中的最大快乐指数</p>
<p><strong>状态计算</strong>：</p>
<p><img src="/image/Fig11_KKKIaBvA7b.png"></p>
<p>对于f(u, 0)：由于u未被选择，所以u的子节点可有可无，即对于每个u的子节点Si，f(Si, 0)和f(Si, 1)都可以选择，取其中有最大快乐指数的方案。</p>
<p>对于f(u, 1)：由于u已选，u的子节点不能再选，所以对于每个u的子节点Si，只能有 f(Si, 0)。</p>
<ol>
<li><p>f(u, 0) &#x3D; $\sum_i{max(f(Si,0),f(S_i,1))}$</p>
</li>
<li><p>f(u, 1) &#x3D; $\sum_i{f(S_i,0)}+A[u]$</p>
</li>
</ol>
<p><strong>代码</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;<span class="comment">//邻接表</span></span><br><span class="line"><span class="type">int</span> happy[N];</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">bool</span> has_fa[N];<span class="comment">//判断各个节点是否有父节点，没有父节点的节点就是根节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span><span class="comment">//邻接表中插入一条边，模板</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[u][<span class="number">1</span>] = happy[u];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])<span class="comment">//~i即为判断 i!=-1，按位取反，模板</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="built_in">dfs</span>(j);</span><br><span class="line"></span><br><span class="line">        f[u][<span class="number">1</span>] += f[j][<span class="number">0</span>];</span><br><span class="line">        f[u][<span class="number">0</span>] += <span class="built_in">max</span>(f[j][<span class="number">0</span>], f[j][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;happy[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(b, a);</span><br><span class="line">        has_fa[a] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> root = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (has_fa[root]) root ++ ;<span class="comment">//找到根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">max</span>(f[root][<span class="number">0</span>], f[root][<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8-记忆化搜索"><a href="#8-记忆化搜索" class="headerlink" title="8 记忆化搜索"></a>8 记忆化搜索</h1><blockquote>
<p>记忆化搜索  &#x3D; 搜索的形式 + 动态规划的思想<br>搜索：动态规划数组记录上一层计算结果，当要使用时直接从数组中获取<br>避免过多的重复计算，往往具有较低的空间复杂度</p>
</blockquote>
<h2 id="8-1-例题1：滑雪"><a href="#8-1-例题1：滑雪" class="headerlink" title="8.1 例题1：滑雪"></a>8.1 例题1：滑雪</h2><blockquote>
<p>📌给定一个R行C列的矩阵，表示一个矩形网格滑雪场。<br>矩阵中第 i 行第 j 列的点表示滑雪场的第 i 行第 j 列区域的高度。<br>一个人从滑雪场中的某个区域内出发，每次可以向上下左右任意一个方向滑动一个单位距离。<br>当然，一个人能够滑动到某相邻区域的前提是该区域的高度低于自己目前所在区域的高度。<br>下面给出一个矩阵作为例子：<br>&amp;#x20;1   2   3   4  5<br>16 17 18 19 6<br>15 24 25 20 7<br>14 23 22 21 8<br>13 12 11 10 9<br>在给定矩阵中，一条可行的滑行轨迹为24-17-2-1。<br>在给定矩阵中，最长的滑行轨迹为25-24-23-…-3-2-1，沿途共经过25个区域。<br>现在给定你一个二维矩阵表示滑雪场各区域的高度，请你找出在该滑雪场中能够完成的最长滑雪轨迹，并输出其长度(可经过最大区域数)。</p>
</blockquote>
<ul>
<li>思路：<strong>递归</strong></li>
</ul>
<p><strong>状态表示</strong>：</p>
<p>f(i, j)：以第i行第j列为起点的所有轨迹的集合中的最大长度</p>
<p><strong>状态计算</strong>：</p>
<p><img src="/image/Fig12_RDU4u9SWDq.png"></p>
<p>f(i, j)即为这四种状态在不出界且严格低于(i, j)位置的高度时，取max的结果</p>
<p>由于状态转移方程中，中心区域的状态依托于外圈的状态，直至边缘，所以可用递归的形式来写。</p>
<p><strong>代码</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">310</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N];<span class="comment">//矩阵</span></span><br><span class="line"><span class="type">int</span> f[N][N];<span class="comment">//状态</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;<span class="comment">//上下左右</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> &amp;v = f[x][y];                       <span class="comment">//在返回值的同时，更新f数组</span></span><br><span class="line">    <span class="keyword">if</span> (v != <span class="number">-1</span>) <span class="keyword">return</span> v;                  <span class="comment">//如果算过了，直接返回值</span></span><br><span class="line"></span><br><span class="line">    v = <span class="number">1</span>;                                  <span class="comment">//初始化，最差情况是只走了自己本身这一步</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span> (a &gt;= <span class="number">1</span> &amp;&amp; a &lt;= n &amp;&amp; b &gt;= <span class="number">1</span> &amp;&amp; b &lt;= m &amp;&amp; g[x][y] &gt; g[a][b])</span><br><span class="line">            v = <span class="built_in">max</span>(v, <span class="built_in">dp</span>(a, b) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);                  <span class="comment">//n行m列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;g[i][j]);          <span class="comment">//获取矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">dp</span>(i, j));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言基础</title>
    <url>/2019/12/21/Golang/Golang/</url>
    <content><![CDATA[<h1 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h1><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="1-Workspace"><a href="#1-Workspace" class="headerlink" title="1. Workspace"></a>1. Workspace</h2><ul>
<li><p>go(workspace)</p>
<p>-bin        存放二进制</p>
<p>-src         存放源文件</p>
<p><a href="http://github.com/" title="github.com">github.com</a></p>
<p>username</p>
<p>go_project_1</p>
<p>file_1</p>
<p>……</p>
<p>go_project_2</p>
<p>file_1</p>
<p>……</p>
<p>-pkg       存放安装的包</p>
</li>
<li><p>建立go语言的workspace前提是将GOPATH设置成了环境变量，可用go env查看GOPATH</p>
</li>
<li><p>go语言的工程结构比较严格，参见上面的文件树</p>
</li>
<li><p>可通过<a href="http://godoc.org/" title="godoc.org">godoc.org</a>查看可安装包，利用go get安装</p>
</li>
</ul>
<h2 id="2-Hello-World"><a href="#2-Hello-World" class="headerlink" title="2. Hello World !"></a>2. Hello World !</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件结构：包声明 → 导入包 → 函数</p>
<ul>
<li><p>包声明：指明文件属于哪个包，package main执行入口，每个应用程序都有package main</p>
</li>
<li><p>导入包需双引号，单引号会报错</p>
</li>
<li><p>无需分号</p>
</li>
</ul>
<h2 id="3-变量与数据类型"><a href="#3-变量与数据类型" class="headerlink" title="3. 变量与数据类型"></a>3. 变量与数据类型</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//MAIN TYPES</span></span><br><span class="line">  <span class="comment">//string</span></span><br><span class="line">  <span class="comment">//bool</span></span><br><span class="line">  <span class="comment">//int(对应CPU平台字长) int8 int16 int32 int64</span></span><br><span class="line">  <span class="comment">//uint(对应CPU平台字长) uint8 uint16 uint32 uint64 uintptr</span></span><br><span class="line">  <span class="comment">//byte - alias for uint8</span></span><br><span class="line">  <span class="comment">//rune - alias for int32</span></span><br><span class="line">  <span class="comment">//float32 float64</span></span><br><span class="line">  <span class="comment">//complex64 complex128</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*---------定义变量 第一种方法：var关键字---------*/</span></span><br><span class="line">  <span class="comment">/*格式：var + 变量名 + 数据类型 = 赋值*/</span></span><br><span class="line">  <span class="keyword">var</span> name_1 <span class="type">string</span> = <span class="string">&quot;oliver&quot;</span><span class="comment">//这里的string可省略，编译器可推断出它是string类型</span></span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">32</span><span class="comment">//编译器推断出是int类型</span></span><br><span class="line">  name_1 = <span class="string">&quot;Peter&quot;</span><span class="comment">//使用var关键字定义后可修改变量值</span></span><br><span class="line">  <span class="comment">/*使用const关键字*/</span></span><br><span class="line">  <span class="keyword">const</span> isCool = <span class="literal">true</span><span class="comment">//省略bool</span></span><br><span class="line">  <span class="comment">//isCool = false 不注释会报错</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*---------定义变量 第二种方法：冒号---------*/</span></span><br><span class="line">  <span class="comment">/*格式：变量名 := 赋值*/</span></span><br><span class="line">  name_2 := <span class="string">&quot;Pai&quot;</span></span><br><span class="line">  <span class="comment">/*多变量定义的简便写法*/</span></span><br><span class="line">  name_3,email := <span class="string">&quot;oliverPai&quot;</span>,<span class="string">&quot;oliver@gmail.com&quot;</span></span><br><span class="line"></span><br><span class="line">  fmt.Println(name_1,name_2,name_3,age,isCool,email)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>go语言中，变量声明不使用会报错</p>
</li>
<li><p>获取类型方法：fmt.Printf(“%T”,variables)</p>
</li>
<li><p>第一种方法可以在函数外声明变量，第二种方法只能用于函数内，且无法指定类型</p>
</li>
<li><p>go语言中没有专门的字符类型，字符串由一个个字节构成</p>
</li>
<li><p>注意，go语言不支持隐式做int和bool类型间的转换，需要自己写btoi或itob函数</p>
</li>
<li><p>go、string与float64之间的转换</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//-------------------------- int转string ------------------------------</span></span><br><span class="line">i := <span class="built_in">int64</span>(<span class="number">123</span>)</span><br><span class="line">s := strconv.<span class="built_in">Itoa</span>(i)</span><br><span class="line">s := strconv.<span class="built_in">FormatInt</span>(i, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------- string转int ------------------------------</span></span><br><span class="line">i, err := strconv.<span class="built_in">Atoi</span>(s)</span><br><span class="line">i, err := strconv.<span class="built_in">ParseInt</span>(s, <span class="number">10</span>, <span class="number">64</span>)<span class="comment">//转int64</span></span><br><span class="line"><span class="comment">//第二个参数为基数，第三个参数位大小表示期望转换的结果类型，其值可以为0, 8, 16, 32和64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//float转string</span></span><br><span class="line">v := <span class="number">3.1415926535</span></span><br><span class="line">s1 := strconv.<span class="built_in">FormatFloat</span>(v, <span class="string">&#x27;E&#x27;</span>, <span class="number">-1</span>, <span class="number">32</span>)</span><br><span class="line"><span class="comment">//&#x27;e&#x27;&amp;&#x27;E&#x27;: 表示10进制指数</span></span><br><span class="line"><span class="comment">//&#x27;b&#x27;: 表示2进制指数</span></span><br><span class="line"><span class="comment">//&#x27;f&#x27;: 无指数，正常形式</span></span><br><span class="line"><span class="comment">//&#x27;g&#x27;&amp;&#x27;G&#x27;: 大数用&#x27;e&#x27;表示，否则用&#x27;f&#x27;</span></span><br><span class="line"><span class="comment">//&#x27;x&#x27;&amp;&#x27;X&#x27;: 16进制表示的二进制指数</span></span><br><span class="line"><span class="comment">//-1是精度</span></span><br><span class="line">float32s2 := strconv.<span class="built_in">FormatFloat</span>(v, <span class="string">&#x27;E&#x27;</span>, <span class="number">-1</span>, <span class="number">64</span>)<span class="comment">//float64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//string转float</span></span><br><span class="line">s := <span class="string">&quot;3.1415926535&quot;</span></span><br><span class="line">v1, err := strconv.<span class="built_in">ParseFloat</span>(v, <span class="number">32</span>)</span><br><span class="line">v2, err := strconv.<span class="built_in">ParseFloat</span>(v, <span class="number">64</span>)</span><br></pre></td></tr></table></figure>

<h2 id="4-包package"><a href="#4-包package" class="headerlink" title="4. 包package"></a>4. 包package</h2><ul>
<li>导入多个包：包之间无需逗号，空格间隔即可。不同包需写在不同行，需要圆括号</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>新建自己的包</p>
<ol>
<li><p>新建文件夹，新建函数的文件</p>
</li>
<li><p>在文件顶部声明包名（不需要与文件夹同名）</p>
</li>
<li><p>在文件内写函数</p>
</li>
</ol>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建strutil文件夹，新建reverse.go文件</span></span><br><span class="line"><span class="keyword">package</span> strutil</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  runes := []<span class="type">rune</span>(s)</span><br><span class="line">  <span class="keyword">for</span> i,j := <span class="number">0</span>,<span class="built_in">len</span>(runes)<span class="number">-1</span> ; i&lt;j ; i,j = i+<span class="number">1</span>, j<span class="number">-1</span>&#123;</span><br><span class="line">    runes[i],runes[j] = runes[j],runes[i]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">string</span>(runes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建后，导入包路径需从src开始，如reverse.go存在&#x2F;src&#x2F;github.com&#x2F;oliverPai&#x2F;strutil&#x2F;reverse.go，则导入包时为import “<a href="http://github.com/oliverPai/strutil" title="github.com/oliverPai/strutil">github.com&#x2F;oliverPai&#x2F;strutil</a>“</p>
<ul>
<li><p>导入go get获取的包，与导入自己的包一样操作，如aws包</p>
<p>import “<a href="http://github.com/aws" title="github.com/aws">github.com&#x2F;aws</a>“</p>
</li>
</ul>
<h2 id="5-数组array-amp-slice"><a href="#5-数组array-amp-slice" class="headerlink" title="5 数组array&amp;slice"></a>5 数组array&amp;slice</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*------Array 定长数组------*/</span></span><br><span class="line"><span class="comment">/*先声明后赋值*/</span></span><br><span class="line"><span class="keyword">var</span> fruitArr [<span class="number">2</span>] <span class="type">string</span></span><br><span class="line">fruitArr[<span class="number">0</span>] = <span class="string">&quot;Apple&quot;</span></span><br><span class="line">fruitArr[<span class="number">1</span>] = <span class="string">&quot;Orange&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*声明并赋值*/</span></span><br><span class="line">fruitArr_1 := [<span class="number">2</span>]<span class="type">string</span>&#123;<span class="string">&quot;Apple&quot;</span>,<span class="string">&quot;Orange&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*------Slice 不定长数组------*/</span></span><br><span class="line">fruitSlice := []<span class="type">string</span>&#123;<span class="string">&quot;Apple&quot;</span>,<span class="string">&quot;Orange&quot;</span>,<span class="string">&quot;Grape&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>统计数组元素个数可用len函数</p>
</li>
<li><p>数组支持切片操作，如fmt.Println(fruitSlice[1:2])输出Orange，从索引1开始，在索引2之前结束</p>
</li>
<li><p>make函数构造slice</p>
</li>
</ul>
<p>slice本质上是引用类型，可用make构造</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//格式：make([]T, size, cap)</span></span><br><span class="line"><span class="comment">//T:切片的元素类型</span></span><br><span class="line"><span class="comment">//size:切片中元素的数量</span></span><br><span class="line"><span class="comment">//cap:切片的容量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line">  fmt.Println(a)      <span class="comment">//[0 0]</span></span><br><span class="line">  fmt.Println(<span class="built_in">len</span>(a)) <span class="comment">//2</span></span><br><span class="line">  fmt.Println(<span class="built_in">cap</span>(a)) <span class="comment">//10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是make([]int,2),则len为2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>slice元素的增删</li>
</ul>
<p>append函数可以用来在slice末尾追加元素</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">  s = <span class="built_in">append</span>(s, <span class="number">1</span>)        <span class="comment">// [1]</span></span><br><span class="line">  s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)  <span class="comment">// [1 2 3 4]</span></span><br><span class="line">  s2 := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;  </span><br><span class="line">  <span class="comment">//对一个slice添加另一个slice的元素时，需要加上...</span></span><br><span class="line">  s = <span class="built_in">append</span>(s, s2...)    <span class="comment">// [1 2 3 4 5 6 7]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>go语言中没有专门的删减slice元素的函数，但是可以通过赋值完成这一目标</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对a中删掉索引为index的元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:index], a[index+<span class="number">1</span>:]...)</span><br></pre></td></tr></table></figure>

<ul>
<li>slice的拷贝</li>
</ul>
<p>slice的拷贝分为两种情况，一种是两个slice共享一片内存区域，二者完全相同，修改一个会更改另一个的值；另一种情况是二者只是数值相同而已，修改一个不会对另一个造成影响</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种情况，直接赋值拷贝，二者共享内存</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  s1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>) <span class="comment">//[0 0 0]</span></span><br><span class="line">  s2 := s1             <span class="comment">//将s1直接赋值给s2，s1和s2共用一个底层数组</span></span><br><span class="line">  s2[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">  fmt.Println(s1) <span class="comment">//[100 0 0]</span></span><br><span class="line">  fmt.Println(s2) <span class="comment">//[100 0 0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第二种情况，使用copy函数，不共享内存</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// copy()复制切片</span></span><br><span class="line">  a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">  c := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">  <span class="built_in">copy</span>(c, a)     <span class="comment">//使用copy()函数将切片a中的元素复制到切片c</span></span><br><span class="line">  fmt.Println(a) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">  fmt.Println(c) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">  c[<span class="number">0</span>] = <span class="number">1000</span></span><br><span class="line">  fmt.Println(a) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">  fmt.Println(c) <span class="comment">//[1000 2 3 4 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>判断slice为空应该通过len(slice)&#x3D;&#x3D;0判断，而不是slice&#x3D;&#x3D;nil</li>
</ul>
<h2 id="6-函数-异常"><a href="#6-函数-异常" class="headerlink" title="6 函数+异常"></a>6 函数+异常</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*格式：func 函数名(参数1 参数1类型, 参数2 参数2类型,...)(返回值1类型, 返回值2类型 ,...)&#123;&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greeting</span><span class="params">(name <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span>+name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*某些参数若同类型，可写在一起，只保留一个数据类型*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plus</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*可给返回值命名，也可不命名*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumAndProduct</span><span class="params">(A, B <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> A+B, A*B</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(a, b <span class="type">int</span>)</span></span> (x, y <span class="type">int</span>) &#123;<span class="comment">//命名可使代码阅读和书写更清晰</span></span><br><span class="line">  x = a + <span class="number">100</span><span class="comment">//101</span></span><br><span class="line">  y = b + <span class="number">100</span><span class="comment">//102</span></span><br><span class="line">  <span class="keyword">return</span><span class="comment">//101 102</span></span><br><span class="line">  <span class="comment">//return x, y  //同上</span></span><br><span class="line">  <span class="comment">//return y, x  //102 101</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*匿名函数*/</span></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(a,b <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//直接执行匿名函数——加括号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Anonymous&quot;</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<ul>
<li>匿名函数可以用来做异常处理，通过defer+recover</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;function a\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//仅用panic做异常处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">&quot;panic in b&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">c</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;function c\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  a()</span><br><span class="line">  b()</span><br><span class="line">  c()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出 function a</span></span><br><span class="line"><span class="comment">//     panic: panic in b</span></span><br><span class="line"><span class="comment">//由于在b函数终止，因此未全部执行完</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用匿名函数+defer+recover的异常处理</span></span><br><span class="line"><span class="comment">//defer+recover可暂时跳过出错地方</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    err := <span class="built_in">recover</span>()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;<span class="comment">//检测到错误</span></span><br><span class="line">      fmt.Println(<span class="string">&quot;function b error&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">&quot;panic in b&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出 function a</span></span><br><span class="line"><span class="comment">//     function b error</span></span><br><span class="line"><span class="comment">//     function c</span></span><br><span class="line"><span class="comment">//defer会在函数要退出前执行，所以在执行到</span></span><br><span class="line"><span class="comment">//panic时，由于出错即将退出，触发匿名函数</span></span><br><span class="line"><span class="comment">//执行匿名函数后，不再执行panic、</span></span><br><span class="line"><span class="comment">//defer必须写在可能引发panic的语句之前,</span></span><br><span class="line"><span class="comment">//否则未注册defer，无法执行匿名函数</span></span><br><span class="line"><span class="comment">//如果多个defer函数，它们会逆序执行</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>📌除了匿名函数+defer+recover做异常处理，还可以使用go内置的error类型</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//error类型定义</span></span><br><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span>&#123;</span><br><span class="line">  Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用errors.New可返回一个错误信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrt</span><span class="params">(f <span class="type">float64</span>)</span></span> (<span class="type">float64</span>,<span class="type">error</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span> f &lt; <span class="number">0</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;math: square root of negative number&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-条件"><a href="#7-条件" class="headerlink" title="7 条件"></a>7 条件</h2><ul>
<li>if语句</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go里面的if不需要圆括号</span></span><br><span class="line"><span class="keyword">if</span> color == <span class="string">&quot;red&quot;</span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;color is red&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> color == <span class="string">&quot;blue&quot;</span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;color is blue&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;color is not red or blue&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>switch语句</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go语言在每个case会自动加上一个break，即go里switch不需要break，同时无法控制执行case的数量</span></span><br><span class="line"><span class="keyword">switch</span> color&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;red&quot;</span>:</span><br><span class="line">  fmt.Println(<span class="string">&quot;color is red&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;blue&quot;</span>:</span><br><span class="line">  fmt.Println(<span class="string">&quot;color is blue&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  fmt.Println(<span class="string">&quot;color is not red or blue&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-循环"><a href="#8-循环" class="headerlink" title="8 循环"></a>8 循环</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//写法1</span></span><br><span class="line">i := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i &lt;= <span class="number">10</span> &#123;</span><br><span class="line">  fmt.Println(i)</span><br><span class="line">  i++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写法2</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++&#123;</span><br><span class="line">  fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//无限循环</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"> <span class="comment">//content</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>for是go语言提供的唯一循环方式</p>
</li>
<li><p>go语言也可以在循环中用continue和break</p>
</li>
</ul>
<h2 id="9-Map"><a href="#9-Map" class="headerlink" title="9 Map"></a>9 Map</h2><p>go语言的Map是键-值对，类似于python的字典</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*-------先声明后赋值-------*/</span></span><br><span class="line"><span class="comment">/*格式：make(map[键数据类型][值数据类型])*/</span></span><br><span class="line">emails := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">emails[<span class="string">&quot;Bob&quot;</span>] = <span class="string">&quot;bob@gmail.com&quot;</span></span><br><span class="line">emails[<span class="string">&quot;Sharon&quot;</span>] = <span class="string">&quot;sharon@gmail.com&quot;</span></span><br><span class="line">emails[<span class="string">&quot;Mike&quot;</span>] = <span class="string">&quot;mike@gmail.com&quot;</span></span><br><span class="line"><span class="comment">//从map中删除</span></span><br><span class="line"><span class="built_in">delete</span>(emails,<span class="string">&quot;Bob&quot;</span>)<span class="comment">//格式：delete(map名，键名)</span></span><br><span class="line"><span class="comment">//索引</span></span><br><span class="line">fmt.Println(emails[<span class="string">&quot;Sharon&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------声明的同时赋值-------*/</span></span><br><span class="line"><span class="comment">/*格式：:=map[键数据类型]值数据类型&#123;键1:值1,键2:值2,...&#125;*/</span></span><br><span class="line">emails := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;Bob&quot;</span>:<span class="string">&quot;bob@gmail.com&quot;</span>,<span class="string">&quot;Sharon&quot;</span>:<span class="string">&quot;sharon@gmail.com&quot;</span>&#125;</span><br><span class="line"><span class="comment">//依然可以添加东西</span></span><br><span class="line">emails[<span class="string">&quot;Mike&quot;</span>] = <span class="string">&quot;mike@gmail.com&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="10-范围range"><a href="#10-范围range" class="headerlink" title="10 范围range"></a>10 范围range</h2><p>range用于遍历数组、map、channel等，能够使for循环成为foreach</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*-------遍历数组-------*/</span></span><br><span class="line">ids := []<span class="type">int</span>&#123;<span class="number">33</span>,<span class="number">76</span>,<span class="number">25</span>,<span class="number">89</span>,<span class="number">14</span>,<span class="number">71</span>&#125;</span><br><span class="line"><span class="comment">//range需要传入两个变量，第一项是index，第二项是index对应的元素</span></span><br><span class="line"><span class="keyword">for</span> i,id := <span class="keyword">range</span> ids &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%d - ID: %d&quot;</span>, i, id)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当不想要index时，可用_代替</span></span><br><span class="line"><span class="keyword">for</span> _,id := <span class="keyword">range</span> ids &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;ID: %d&quot;</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------遍历Map-------*/</span></span><br><span class="line">emails := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;Bob&quot;</span>:<span class="string">&quot;bob@gmail.com&quot;</span>,<span class="string">&quot;Sharon&quot;</span>:<span class="string">&quot;sharon@gmail.com&quot;</span>&#125;</span><br><span class="line"><span class="comment">//range需要传入两个变量，第一项是键，第二项是值</span></span><br><span class="line"><span class="keyword">for</span> k,v := <span class="keyword">range</span> emails&#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%s: %s&quot;</span>,k,v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当只想要键不想要值时，可以省略第二项</span></span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> emails&#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Name: &quot;</span> + k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>range对数组的操作同样可以应用到字符串上，第一项index，第二项字符</li>
</ul>
<h2 id="11-指针"><a href="#11-指针" class="headerlink" title="11 指针"></a>11 指针</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  a := <span class="number">5</span></span><br><span class="line">  b := &amp;a<span class="comment">//b是指向a的指针</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;%T&quot;</span>,b)<span class="comment">//输出*int</span></span><br><span class="line">  <span class="comment">//取值</span></span><br><span class="line">  fmt.Println(*b)<span class="comment">//输出5</span></span><br><span class="line">  <span class="comment">//改值</span></span><br><span class="line">  *b = <span class="number">10</span></span><br><span class="line">  fmt.Println(a)<span class="comment">//输出10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>go语言中指针的好处在于，对于操作某连续地址的一大片数据，使用指针可以提高执行效率</p>
</li>
<li><p>可以利用指针对特殊地址修改数值</p>
</li>
</ul>
<h2 id="12-闭包closure"><a href="#12-闭包closure" class="headerlink" title="12 闭包closure"></a>12 闭包closure</h2><p>闭包是函数作为返回值时，匿名函数内部访问外层变量的行为</p>
<ul>
<li>核心在于，被访问的外层变量相当于被访问了引用，其修改后的值被一直保留</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*------例1------*/</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">//..(..1...).(....2.......)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  sum := <span class="number">0</span><span class="comment">//被访问的外层变量</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    sum += x</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//将函数赋给变量时，需和1处一致</span></span><br><span class="line">  sum := adder()</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt; <span class="number">10</span>; i++&#123;</span><br><span class="line">    <span class="comment">//调用函数变量时，需和2处一致</span></span><br><span class="line">    fmt.Println(sum(i))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//0 1 3 6 10 15 21 28 36 45</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*------例2------*/</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(base <span class="type">int</span>)</span></span>(<span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span><span class="type">int</span>,</span><br><span class="line">                    <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span><span class="type">int</span>)&#123;</span><br><span class="line">  add := <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span><span class="type">int</span>&#123;</span><br><span class="line">    base += i</span><br><span class="line">    <span class="keyword">return</span> base</span><br><span class="line">  &#125;</span><br><span class="line">  sub := <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span><span class="type">int</span>&#123;</span><br><span class="line">    base -= i</span><br><span class="line">    <span class="keyword">return</span> base</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  x,y := calc(<span class="number">100</span>)</span><br><span class="line">  ret1 := x(<span class="number">200</span>)</span><br><span class="line">  <span class="comment">//base已被改成300</span></span><br><span class="line">  fmt.Println(ret1)<span class="comment">//输出100+200=300</span></span><br><span class="line">  <span class="comment">//由于base得以保留，此处base是300</span></span><br><span class="line">  ret2 := y(<span class="number">200</span>)</span><br><span class="line">  fmt.Println(ret2)<span class="comment">//输出300-200=100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>闭包的用处</li>
</ul>
<blockquote>
<p>📌A代码： func (o *Once) Do2(f func()) {}<br>B代码： func Do1（参数）<br>需求：   B要调用A写的o对象里的方法Do2，并把自己的Do1当作参数传到Do2   中，但是B写的Do1有传参，而A写的Do2中传入的方法参数是不能带参数的<br>解决办法：闭包<br>编写一个func Do3（参数）（func (o *Once) Do2(f func())），也就是新的Do3函数中的参数是Do1中要传入的参数，返回值是Do2，那么在Do2中就能调用Do3中传入的参数，也就是Do1中期望的参数，Do3返回的是一个函数，那这个函数调用了这个函数之外的一个变量，所以形成了一个闭包。</p>
</blockquote>
<h2 id="13-结构体"><a href="#13-结构体" class="headerlink" title="13 结构体"></a>13 结构体</h2><p>go里没有类，结构体可以有属性和方法，结构体就是类</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个结构体</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">  firstName <span class="type">string</span></span><br><span class="line">  lastName <span class="type">string</span></span><br><span class="line">  city <span class="type">string</span></span><br><span class="line">  gender <span class="type">string</span></span><br><span class="line">  age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//初始化结构体</span></span><br><span class="line">  person1:=Person&#123;firstName:<span class="string">&quot;Samantha&quot;</span>,</span><br><span class="line">  lastName:<span class="string">&quot;Smith&quot;</span>,</span><br><span class="line">  city:<span class="string">&quot;Boston&quot;</span>,</span><br><span class="line">  gender:<span class="string">&quot;f&quot;</span>,</span><br><span class="line">  age:<span class="number">25</span>&#125;</span><br><span class="line">  fmt.Println(person1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//左边代码的简便写法</span></span><br><span class="line"><span class="comment">//同类型可以写一起</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">  firstName,lastName,city,gender <span class="type">string</span></span><br><span class="line">  age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//不需要指定属性名</span></span><br><span class="line">  person1 := Person&#123;<span class="string">&quot;Samantha&quot;</span>,<span class="string">&quot;Smith&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Boston&quot;</span>,<span class="string">&quot;f&quot;</span>,<span class="number">25</span>&#125;</span><br><span class="line">  fmt.Println(person1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取属性</span></span><br><span class="line">fmt.Println(person1.firstName)</span><br><span class="line"><span class="comment">//改变属性\</span></span><br><span class="line">person1.age++</span><br><span class="line">fmt.Println(person1.age)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*-------value receiver方法：不改变任何数值-------*/</span></span><br><span class="line"><span class="comment">//格式：func (identifier 结构体名) 函数名 返回值类型&#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> greet() <span class="type">string</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hello, my name is &quot;</span>+p.firstName+<span class="string">&quot; &quot;</span>+p.lastName+<span class="string">&quot; and I am &quot;</span>+strconv.Itoa(p.age)</span><br><span class="line">  <span class="comment">//这里的strconv.Itoa用来int转字符串，否则会报错，需事先导入strconv包</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------pointer receiver方法：改变数值-------*/</span></span><br><span class="line"><span class="comment">//格式：func (identifier *结构体名) 函数名 返回值类型&#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> hasBirthday() &#123;</span><br><span class="line">  p.age++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>identifier相当于this指针，go语言没有- &gt;</p>
</li>
<li><p>结构体的方法不能写在结构体内，要写在外面</p>
</li>
<li><p>匿名字段——实现结构体的“继承”</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">  Province <span class="type">string</span></span><br><span class="line">  City     <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name    <span class="type">string</span></span><br><span class="line">  Gender  <span class="type">string</span></span><br><span class="line">  Address <span class="comment">//匿名字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当需要访问User中的Address中的Province时可有两种方式</span></span><br><span class="line"><span class="keyword">var</span> user1 User</span><br><span class="line"><span class="comment">//方式1：匿名字段默认按类型名索引</span></span><br><span class="line">user1.Address.Province = Hubei</span><br><span class="line"><span class="comment">//方式2：继承，直接索引，go的struct查找属性顺序：自身属性-&gt;匿名字段属性</span></span><br><span class="line">user1.Province = Hubei</span><br></pre></td></tr></table></figure>

<ul>
<li><p>一个结构体包含多个匿名字段时，若这些匿名字段包含同名属性，会导致访问报错</p>
</li>
<li><p>方法也可以被继承，包含匿名字段结构体时，可选类型为指针</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">/Animal 动物</span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Animal)</span></span> move() &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%s会动！\n&quot;</span>, a.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dog 狗</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">  Feet    <span class="type">int8</span></span><br><span class="line">  *Animal <span class="comment">//通过嵌套匿名结构体实现继承</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span></span> wang() &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%s会汪汪汪~\n&quot;</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  d1 := &amp;Dog&#123;</span><br><span class="line">    Feet: <span class="number">4</span>,</span><br><span class="line">    Animal: &amp;Animal&#123; <span class="comment">//注意嵌套的是结构体指针</span></span><br><span class="line">      name: <span class="string">&quot;乐乐&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  d1.wang() <span class="comment">//乐乐会汪汪汪~</span></span><br><span class="line">  d1.move() <span class="comment">//乐乐会动！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>结构体内的标识符（变量名、函数名）首字母大写，则对外可见（别的包可以拿到），否则只能在当前包使用</p>
</li>
<li><p>对结构体中的slice赋值</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  name   <span class="type">string</span></span><br><span class="line">  age    <span class="type">int8</span></span><br><span class="line">  act []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  p1 := Person&#123;name: <span class="string">&quot;小王子&quot;</span>, age: <span class="number">18</span>&#125;</span><br><span class="line">  data := []<span class="type">string</span>&#123;<span class="string">&quot;吃饭&quot;</span>, <span class="string">&quot;睡觉&quot;</span>&#125;</span><br><span class="line">  p1.SetAct(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式1：指针赋值</span></span><br><span class="line"><span class="comment">//main中data和p.act共同变化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(p *Person)</span></span>SetAct(dreams[]<span class="type">string</span>)&#123;</span><br><span class="line">  p.act = dreams</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式2：拷贝赋值</span></span><br><span class="line"><span class="comment">//改变data不会改变p.act</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(p *Person)</span></span>SetAct(dreams[]<span class="type">string</span>)&#123;</span><br><span class="line">  p.dreams = <span class="built_in">make</span>([]<span class="type">string</span>,<span class="built_in">len</span>(dreams))</span><br><span class="line">  <span class="built_in">copy</span>(p.act, dreams)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-接口interface"><a href="#14-接口interface" class="headerlink" title="14 接口interface"></a>14 接口interface</h2><p>interface是多种结构体共性方法的集合</p>
<p>interface定义命名一个类型，使得不管最初是什么类型的struct，只要实现了interface中的方法，都可以被算作被interface命名的类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//格式</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  type 接口名 interface&#123;</span></span><br><span class="line"><span class="comment">    方法名1(参数列表1)返回值列表1</span></span><br><span class="line"><span class="comment">    ......</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义interface</span></span><br><span class="line"><span class="keyword">type</span> Shape <span class="keyword">interface</span> &#123;</span><br><span class="line">  area() <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现Circle结构体的area方法</span></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">  x, y, radius <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span></span> area() <span class="type">float64</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> math.Pi * c.radius * c.radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现Rectangle结构体的area方法</span></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">  width, height <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span></span> area() <span class="type">float64</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> r.width * r.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为实现了area方法，Rectangle和Circle都是Shape类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getArea</span><span class="params">(s Shape)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> s.area()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  circle := Circle&#123;x: <span class="number">0</span>, y: <span class="number">0</span>, radius: <span class="number">5</span>&#125;</span><br><span class="line">  rectangle := Rectangle&#123;width: <span class="number">10</span>, height: <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">  fmt.Printf(<span class="string">&quot;Circle Area: %f\n&quot;</span>, getArea(circle))</span><br><span class="line">  fmt.Printf(<span class="string">&quot;Rectangle Area: %f\n&quot;</span>, getArea(rectangle))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>interface是一种类型，一种抽象的类型</p>
</li>
<li><p>利用slice和interface可以实现函数参数可变，格式：变量名…类型</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//同类型可变参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">functest1</span><span class="params">(values ...<span class="type">int</span>)</span></span>(sum <span class="type">int</span>)&#123;</span><br><span class="line">  sum = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> _,i:=<span class="keyword">range</span> values&#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">    sum += i</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//参数传入方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//参数可以为空</span></span><br><span class="line">  fmt.Println(functest1())</span><br><span class="line">  <span class="comment">//参数可以是1个</span></span><br><span class="line">  fmt.Println(functest1(<span class="number">1</span>))</span><br><span class="line">  <span class="comment">//参数可以是多个</span></span><br><span class="line">  fmt.Println(functest1(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">  <span class="comment">//参数可以是slice，必须有...</span></span><br><span class="line">  <span class="keyword">var</span> tmp []<span class="type">int</span> = []<span class="type">int</span>&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">  fmt.Println(functest1(tmp...))</span><br><span class="line">  <span class="comment">//**可变参函数和以slice为参数的函数不一样**</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不同类型可变参数</span></span><br><span class="line"><span class="comment">//类型必须是空的interface</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">functest2</span><span class="params">(values ... <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> _,i := <span class="keyword">range</span> values&#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;function test2:Type %T,</span></span><br><span class="line"><span class="string">    i %v\n&quot;</span>,i,i)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数传入方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//**方式1：传入interface的slice**</span></span><br><span class="line">  <span class="keyword">var</span> d[] <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  d = <span class="built_in">append</span>(d,<span class="number">1</span>)</span><br><span class="line">  d = <span class="built_in">append</span>(d,<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">  d = <span class="built_in">append</span>(d,<span class="number">3.14</span>)</span><br><span class="line">  functest2(d...)<span class="comment">//一定要有...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//**方式2：直接传不同类型参数**</span></span><br><span class="line">  functest2(<span class="string">&quot;hello&quot;</span>,<span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>go认为，任何类型都实现了空接口，所以空接口可接受任何类型值，也可用于函数参数，接收任何类型。同时可用于map的value，扩展map功能</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var m = make(map[string]interface&#123;&#125;)</span><br><span class="line">m[&#x27;name&#x27;] = &#x27;oliver&#x27;</span><br><span class="line">m[&#x27;age&#x27;] = age</span><br><span class="line">m[&#x27;hobby&#x27;] = []string&#123;&quot;篮球&quot;,&quot;羽毛球&quot;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>数值接收与指针接收实现接口的区别</li>
</ul>
<p>值接收实现的接口，即可用实现接口的结构体，也可以用该结构体的指针调用接口方法</p>
<p>指针接收实现的接口，只能用结构体的指针调用接口方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现Mover接口</span></span><br><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">  move()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结构体dog，将会使用dog实现值接收接口，也将使用&amp;dog实现指针接收接口</span></span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//值实现的接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span></span> move() &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;狗会动&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> x Mover</span><br><span class="line">  <span class="keyword">var</span> val_rec = dog&#123;&#125; <span class="comment">// dog类型</span></span><br><span class="line">  x = val_rec         </span><br><span class="line">  <span class="comment">// x可以接收dog类型</span></span><br><span class="line">  <span class="keyword">var</span> poi_rec = &amp;dog&#123;&#125;<span class="comment">// *dog类型</span></span><br><span class="line">  x = poi_rec         </span><br><span class="line">  <span class="comment">// x可以接收*dog类型</span></span><br><span class="line">  x.move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指针实现的接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *dog)</span></span> move() &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;狗会动&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> x Mover</span><br><span class="line">  <span class="keyword">var</span> poi_rec = &amp;dog&#123;&#125; <span class="comment">// *dog类型</span></span><br><span class="line">  x = poi_rec         </span><br><span class="line">  <span class="comment">// x只能接收*dog类型</span></span><br><span class="line">  x.move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>接口类型变量</li>
</ul>
<p>接口类型变量可以接收任何实现了该接口的类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果有一个Sayer接口，其内部有say方法</span></span><br><span class="line"><span class="comment">//cat结构体和dog结构体都实现了say方法</span></span><br><span class="line"><span class="keyword">var</span> x Sayer</span><br><span class="line">a := cat&#123;&#125; </span><br><span class="line">b := dog&#123;&#125;</span><br><span class="line">x = a       <span class="comment">// 可以把cat实例直接赋值给x</span></span><br><span class="line">x.say()   </span><br><span class="line">x = b       <span class="comment">// 可以把dog实例直接赋值给x</span></span><br><span class="line">x.say()    </span><br></pre></td></tr></table></figure>

<ul>
<li>接口嵌套</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sayer 接口</span></span><br><span class="line"><span class="keyword">type</span> Sayer <span class="keyword">interface</span> &#123;</span><br><span class="line">  say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mover 接口</span></span><br><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">  move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口嵌套，生成新的animal接口</span></span><br><span class="line"><span class="keyword">type</span> animal <span class="keyword">interface</span> &#123;</span><br><span class="line">  Sayer</span><br><span class="line">  Mover</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让一个结构体同时实现say()方法和move()方法，即为实现animal接口</p>
<ul>
<li>接口类型断言</li>
</ul>
<p>接口类型断言用于空接口存储变量时，推断出变量的类型，格式x.(T)：x是空接口变量，T是推断类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//x.(T)返回两个变量，第一个是x转换为T类型后的值，第二个是bool值，反映是否推断正确</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  x = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">  v, ok := x.(<span class="type">string</span>)</span><br><span class="line">  <span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;类型断言失败&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-反射"><a href="#15-反射" class="headerlink" title="15 反射"></a>15 反射</h2><blockquote>
<p>📌补充知识：结构体标签(tag)，只用于反射机制，格式为 <code>key1:&quot;value1&quot; key2:&quot;value2&quot;</code></p>
</blockquote>
<ul>
<li>静态编译语言在编译时，会将变量转换成内存地址，关于变量的信息将消失不见，也无从获取；</li>
</ul>
<p>但是go语言引入了反射机制，可以将变量的信息(变量名、变量类型等)整合到可执行文件中，从而能够实现在程序运行时对变量信息的访问。采用reflect包的API进行反射操作！</p>
<p><img src="/image/image_-v0q2QWlX3.png"></p>
<ul>
<li>reflect.TypeOf()：获取变量类型</li>
</ul>
<p>返回的变量是reflect.Type实例，该实例含有两个重要方法Name和Kind，前者返回类型名(包括自定义类型名)，后者是更加底层的类型，比如Name会返回结构体名，而Kind则是struct</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> myInt <span class="type">int64</span></span><br><span class="line"><span class="comment">//获取类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectType</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  t := reflect.TypeOf(x)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;type:%v kind:%v\n&quot;</span>, t.Name(), t.Kind())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a *<span class="type">float32</span> <span class="comment">// 指针</span></span><br><span class="line">  <span class="keyword">var</span> b myInt    <span class="comment">// 自定义类型</span></span><br><span class="line">  <span class="keyword">var</span> c <span class="type">rune</span>     <span class="comment">// 类型别名</span></span><br><span class="line">  reflectType(a) <span class="comment">// type:      kind:ptr</span></span><br><span class="line">  reflectType(b) <span class="comment">// type:myInt kind:int64</span></span><br><span class="line">  reflectType(c) <span class="comment">// type:int32 kind:int32</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age  <span class="type">int</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> d = person&#123;</span><br><span class="line">    name: <span class="string">&quot;Oliver&quot;</span>,</span><br><span class="line">    age:  <span class="number">18</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  reflectType(d) <span class="comment">// type:person kind:struct</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组、切片、Map、指针等类型的变量，Name都是返回空</p>
<ul>
<li>reflect.ValueOf()：获取值信息，即可读值，又可改值</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectValue</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  v := reflect.ValueOf(x)</span><br><span class="line">  k := v.Kind()</span><br><span class="line">  <span class="keyword">switch</span> k &#123;</span><br><span class="line">  <span class="keyword">case</span> reflect.Int64:</span><br><span class="line">    <span class="comment">// v.Int()从反射中获取整型的原始值，然后通过int64()强制类型转换</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;type is int64, value is %d\n&quot;</span>, <span class="type">int64</span>(v.Int()))</span><br><span class="line">  <span class="keyword">case</span> reflect.Float32:</span><br><span class="line">    <span class="comment">// v.Float()从反射中获取浮点型的原始值，然后通过float32()强制类型转换</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;type is float32, value is %f\n&quot;</span>, <span class="type">float32</span>(v.Float()))</span><br><span class="line">  <span class="keyword">case</span> reflect.Float64:</span><br><span class="line">    <span class="comment">// v.Float()从反射中获取浮点型的原始值，然后通过float64()强制类型转换</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;type is float64, value is %f\n&quot;</span>, <span class="type">float64</span>(v.Float()))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a <span class="type">float32</span> = <span class="number">3.14</span></span><br><span class="line">  <span class="keyword">var</span> b <span class="type">int64</span> = <span class="number">100</span></span><br><span class="line">  reflectValue(a) <span class="comment">// type is float32, value is 3.140000</span></span><br><span class="line">  reflectValue(b) <span class="comment">// type is int64, value is 100</span></span><br><span class="line">  <span class="comment">// 将int类型的原始值转换为reflect.Value类型</span></span><br><span class="line">  c := reflect.ValueOf(<span class="number">10</span>)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;type c :%T\n&quot;</span>, c) <span class="comment">// type c :reflect.Value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>reflect.Value可用转换类型方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Int() int64</td>
<td>将值以 int 类型返回，所有有符号整型均可以此方式返回</td>
</tr>
<tr>
<td>Uint() uint64</td>
<td>将值以 uint 类型返回，所有无符号整型均可以此方式返回</td>
</tr>
<tr>
<td>Float() float64</td>
<td>将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回</td>
</tr>
<tr>
<td>Bool() bool</td>
<td>将值以 bool 类型返回</td>
</tr>
<tr>
<td>Bytes() []byts</td>
<td>将值以字节数组 []bytes 类型返回</td>
</tr>
<tr>
<td>String() string</td>
<td>将值以字符串类型返回</td>
</tr>
<tr>
<td>Interface() interface{}</td>
<td>将值以 interface{} 类型返回，可以通过类型断言转换为指定类型</td>
</tr>
</tbody></table>
<p>修改值的时候需要注意！</p>
<p>必须用Elem才能修改地址对应的值，不用Elem最后只能修改拷贝值，会引起panic！</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//改值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectSetValue1</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  v := reflect.ValueOf(x)</span><br><span class="line">  <span class="keyword">if</span> v.Kind() == reflect.Int64 &#123;</span><br><span class="line">    v.SetInt(<span class="number">200</span>) <span class="comment">//修改的是副本，reflect包会引发panic</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectSetValue2</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  v := reflect.ValueOf(x)</span><br><span class="line">  <span class="comment">// 反射中使用 Elem()方法获取指针对应的值</span></span><br><span class="line">  <span class="keyword">if</span> v.Elem().Kind() == reflect.Int64 &#123;</span><br><span class="line">    v.Elem().SetInt(<span class="number">200</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a <span class="type">int64</span> = <span class="number">100</span></span><br><span class="line">  <span class="comment">// reflectSetValue1(a) //panic: reflect: reflect.Value.SetInt using unaddressable value</span></span><br><span class="line">  reflectSetValue2(&amp;a)</span><br><span class="line">  fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>结构体反射</li>
</ul>
<p>结构体反射可以用来在运行时获取结构体的属性和方法</p>
<p>reflect.Type可用结构体反射方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>NumField() int</td>
<td>返回结构体成员字段数量。</td>
</tr>
<tr>
<td>FieldByName(name string) (StructField, bool)</td>
<td>根据给定字符串返回字符串对应的结构体字段的信息。</td>
</tr>
<tr>
<td>FieldByIndex(index []int) StructField</td>
<td>多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息。</td>
</tr>
<tr>
<td>FieldByNameFunc(match func(string) bool) (StructField,bool)</td>
<td>根据传入的匹配函数匹配需要的字段。</td>
</tr>
<tr>
<td>NumMethod() int</td>
<td>返回该类型的方法集中方法的数目</td>
</tr>
<tr>
<td>Method(int) Method</td>
<td>返回该类型方法集中的第i个方法</td>
</tr>
</tbody></table>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用Field方法获取的是一个StructField实例，该结构体结构为</span></span><br><span class="line"><span class="keyword">type</span> StructField <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Name是字段的名字。PkgPath是非导出字段的包路径，对导出字段该字段为&quot;&quot;。</span></span><br><span class="line">    <span class="comment">// 参见http://golang.org/ref/spec#Uniqueness_of_identifiers</span></span><br><span class="line">    Name    <span class="type">string</span></span><br><span class="line">    PkgPath <span class="type">string</span></span><br><span class="line">    Type      Type      <span class="comment">// 字段的类型</span></span><br><span class="line">    Tag       StructTag <span class="comment">// 字段的标签</span></span><br><span class="line">    Offset    <span class="type">uintptr</span>   <span class="comment">// 字段在结构体中的字节偏移量</span></span><br><span class="line">    Index     []<span class="type">int</span>     <span class="comment">// 用于Type.FieldByIndex时的索引切片</span></span><br><span class="line">    Anonymous <span class="type">bool</span>      <span class="comment">// 是否匿名字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取方法</span></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name  <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">  Score <span class="type">int</span>    <span class="string">`json:&quot;score&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  stu1 := student&#123;</span><br><span class="line">    Name:  <span class="string">&quot;小王子&quot;</span>,</span><br><span class="line">    Score: <span class="number">90</span>,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  t := reflect.TypeOf(stu1)</span><br><span class="line">  fmt.Println(t.Name(), t.Kind()) <span class="comment">// student struct</span></span><br><span class="line">  <span class="comment">// 通过for循环遍历结构体的所有字段信息</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">    field := t.Field(i)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;name:%s index:%d type:%v json tag:%v\n&quot;</span>, field.Name, field.Index, field.Type, field.Tag.Get(<span class="string">&quot;json&quot;</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过字段名获取指定结构体字段信息</span></span><br><span class="line">  <span class="keyword">if</span> scoreField, ok := t.FieldByName(<span class="string">&quot;Score&quot;</span>); ok &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;name:%s index:%d type:%v json tag:%v\n&quot;</span>, scoreField.Name, scoreField.Index, scoreField.Type, scoreField.Tag.Get(<span class="string">&quot;json&quot;</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取方法</span></span><br><span class="line"><span class="comment">// 给student添加两个方法 Study和Sleep(注意首字母大写)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s student)</span></span> Study() <span class="type">string</span> &#123;</span><br><span class="line">  msg := <span class="string">&quot;好好学习，天天向上。&quot;</span></span><br><span class="line">  fmt.Println(msg)</span><br><span class="line">  <span class="keyword">return</span> msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s student)</span></span> Sleep() <span class="type">string</span> &#123;</span><br><span class="line">  msg := <span class="string">&quot;好好睡觉，快快长大。&quot;</span></span><br><span class="line">  fmt.Println(msg)</span><br><span class="line">  <span class="keyword">return</span> msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMethod</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  t := reflect.TypeOf(x)</span><br><span class="line">  v := reflect.ValueOf(x)</span><br><span class="line"></span><br><span class="line">  fmt.Println(t.NumMethod())</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumMethod(); i++ &#123;</span><br><span class="line">    methodType := v.Method(i).Type()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;method name:%s\n&quot;</span>, t.Method(i).Name)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;method:%s\n&quot;</span>, methodType)</span><br><span class="line">    <span class="comment">// 通过反射调用方法传递的参数必须是 []reflect.Value 类型</span></span><br><span class="line">    <span class="keyword">var</span> args = []reflect.Value&#123;&#125;</span><br><span class="line">    v.Method(i).Call(args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意上面右边的代码虽然获取了方法的信息，但也有陌生的调用方法的操作method.Call()</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用反射调用函数或方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn</span><span class="params">(p1, p2 <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> p1 + p2</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  valueFunc := reflect.ValueOf(fn)<span class="comment">//reflect.Value实例是函数，输入值和返回值都是[]reflect.Value类型</span></span><br><span class="line">  paramList := []reflect.Value&#123;</span><br><span class="line">    reflect.ValueOf(<span class="number">22</span>),<span class="comment">//设置第一个参数</span></span><br><span class="line">    reflect.ValueOf(<span class="number">20</span>),<span class="comment">//设置第二个参数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 反射调用函数</span></span><br><span class="line">  resultList := valueFunc.Call(paramList)</span><br><span class="line">  <span class="comment">// 获取第一个返回值, 取整数值</span></span><br><span class="line">  fmt.Println(resultList[<span class="number">0</span>].Int()) <span class="comment">// 42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>📌反射的优劣<br>优点：搭配接口实现泛型，代码更灵活<br>缺点：性能低下，使用反射的代码通常比正常代码慢一两个数量级<br>&amp;#x20;         代码脆弱，引起panic是真正运行时，代码写完很长时间后</p>
</blockquote>
<h2 id="16-并发"><a href="#16-并发" class="headerlink" title="16 并发"></a>16 并发</h2><ul>
<li>goroutine协程</li>
</ul>
<p>go调用协程只需要在被调用的函数前加上go即可</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span>&#123;</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;sync&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup                 <span class="comment">//信号量，计数器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Hello Goroutine!&quot;</span>, i)</span><br><span class="line">  wg.Done()                           <span class="comment">//每当一个协程执行完，需要计数器减一</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  wg.Add(<span class="number">10000</span>)                       <span class="comment">//因为有10000个协程，所以要给计数器加10000</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> hello(i)                       <span class="comment">//执行10000个协程</span></span><br><span class="line">  &#125;</span><br><span class="line">  wg.Wait()                           <span class="comment">// 等待所有登记的goroutine都结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>goroutine调用匿名函数，需要注意闭包情形</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*错误写法*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  wg.Add(<span class="number">10000</span>)                       </span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span>&#123;<span class="comment">//匿名函数</span></span><br><span class="line">      fmt.Println(<span class="string">&quot;Hello Goroutine!&quot;</span>,i)</span><br><span class="line">      wg.Done()                  </span><br><span class="line">    &#125;()<span class="comment">//此时形成了闭包</span></span><br><span class="line">  &#125;</span><br><span class="line">  wg.Wait()                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*正确写法*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  wg.Add(<span class="number">10000</span>)                       </span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">(i <span class="type">int</span>)</span></span>&#123;<span class="comment">//匿名函数</span></span><br><span class="line">      fmt.Println(<span class="string">&quot;Hello Goroutine!&quot;</span>,i)</span><br><span class="line">      wg.Done()                  </span><br><span class="line">    &#125;(i)<span class="comment">//将参数直接传入线程，避免闭包</span></span><br><span class="line">  &#125;</span><br><span class="line">  wg.Wait()                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面左边的写法构成了闭包，也就是i自增时，参数并未传入对应协程，而对应协程将要执行时 才从外部获取i的值，而此时i可能已经自增很多。所以左边的代码最后会输出大量的10000</p>
<p>此外，可以通过GOMAXPROCS参数设置要将协程分配给多少个OS线程，默认使用全部物理线程</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span>&#123;</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;sync&quot;</span></span><br><span class="line">  <span class="string">&quot;runtime&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;A:&quot;</span>, i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;B:&quot;</span>, i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  runtime.GOMAXPROCS(<span class="number">1</span>)<span class="comment">//只有一个物理核心，并行也串行</span></span><br><span class="line">  <span class="keyword">go</span> a()</span><br><span class="line">  <span class="keyword">go</span> b()</span><br><span class="line">  time.Sleep(time.Second)<span class="comment">//等待所有线程结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>channel</li>
</ul>
<p>channel就是消息队列(先入先出)，用于协程之间的通信，格式为：var 变量 chan 数据类型</p>
<p>或：make(chan 元素类型, [缓冲大小])</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新建channel</span></span><br><span class="line"><span class="keyword">var</span> ch1 <span class="keyword">chan</span> <span class="type">int</span>   <span class="comment">// 声明一个传递整型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch2 <span class="keyword">chan</span> <span class="type">bool</span>  <span class="comment">// 声明一个传递布尔型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch3 <span class="keyword">chan</span> []<span class="type">int</span> <span class="comment">// 声明一个传递int切片的通道</span></span><br><span class="line">ch4 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">ch5 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">ch6 := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p>对于channel，有发送、接收、关闭三种操作，前两者使用&lt; - 符号传递数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送</span></span><br><span class="line">ch &lt;- <span class="number">10</span>   <span class="comment">// 把10发送到ch中</span></span><br><span class="line"><span class="comment">//接收</span></span><br><span class="line">x := &lt;- ch <span class="comment">// 从ch中接收值并赋值给变量x</span></span><br><span class="line">&lt;-ch       <span class="comment">// 从ch中接收值，忽略结果</span></span><br><span class="line"><span class="comment">//关闭</span></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure>

<p>需要注意的是，当channel关闭后，不可再向channel关闭值，可以接收，如果全部接收完，再接收就是该类型的零值。channel不能重复关闭。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无缓冲channel</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="comment">//无缓冲channel如果没有接收操作时就执行发送，最后程序会进入死锁，所以对于无缓冲必须要有接收</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//有缓冲channel</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)<span class="comment">//指定缓冲区大小为1</span></span><br><span class="line"><span class="comment">//发送后无接收会阻塞下一次发送，直至接收完</span></span><br></pre></td></tr></table></figure>

<p>无缓冲可以实现goroutine同步</p>
<ul>
<li>channel被关闭后，若一直接收最后会无限接收零值，所以需要机制判断channel为空</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*******机制1：利用接收操作时返回的布尔值*******/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">  <span class="comment">// 开启goroutine将0~100的数发送到ch1中</span></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">      ch1 &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(ch1)</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    i, ok := &lt;-ch1 <span class="comment">// 通道关闭后再取值时，ok=false</span></span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*******机制2：使用for range*******/</span></span><br><span class="line"><span class="comment">// channel 练习</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">  <span class="comment">// 开启goroutine将0~100的数发送到ch1中</span></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">      ch1 &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(ch1)</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="comment">// 在主goroutine中从ch1中接收值打印</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="keyword">range</span> ch1 &#123; <span class="comment">// 通道关闭后会退出for range循环</span></span><br><span class="line">    fmt.Println(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>单向通道</li>
</ul>
<p>单向通道就是只能发送或接收，只有单项操作的通道，比如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">chan</span>&lt;- <span class="type">int</span> <span class="comment">//只写通道，只能向该通道输入int值</span></span><br><span class="line">&lt;-<span class="keyword">chan</span> <span class="type">int</span> <span class="comment">//只读通道，只能从该通道读取int值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">    out &lt;- i</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squarer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="type">int</span>, in &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="keyword">range</span> in &#123;</span><br><span class="line">    out &lt;- i * i</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="keyword">range</span> in &#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">  ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">  <span class="keyword">go</span> counter(ch1)</span><br><span class="line">  <span class="keyword">go</span> squarer(ch2, ch1)</span><br><span class="line">  printer(ch2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Select语句</li>
</ul>
<p>select类似于switch，有很多case和一个default，用来在一个语句块对多个channel进行收发操作，每个case对应一个收和发</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> x := &lt;-ch:</span><br><span class="line">      fmt.Println(x)</span><br><span class="line">    <span class="keyword">case</span> ch &lt;- i:</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次可处理一个case，若有多个case可执行操作，会随机选取一个执行</p>
<p>没有case的select会一直等待，阻塞程序</p>
<ul>
<li>同步</li>
</ul>
<p>当多个goroutine同时操作一个资源(临界区)时，就有竞态问题，此时需要利用锁实现同步</p>
<p>互斥锁sync.Mutex：当一个协程将资源锁住，进行操作时，其它协程必须等待解锁才能访问资源</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">int64</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">    lock.Lock() <span class="comment">// 加锁</span></span><br><span class="line">    x = x + <span class="number">1</span></span><br><span class="line">    lock.Unlock() <span class="comment">// 解锁</span></span><br><span class="line">  &#125;</span><br><span class="line">  wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  wg.Add(<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">go</span> add()</span><br><span class="line">  <span class="keyword">go</span> add()</span><br><span class="line">  wg.Wait()</span><br><span class="line">  fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读写互斥锁sync.RWMutex：资源被一个goroutine上了写锁后，其它协同都必须等待解锁才能进行读写操作；而被上了读锁时，其它要进行读操作的协同可以读，写操作的协程需要等待</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  x      <span class="type">int64</span></span><br><span class="line">  wg     sync.WaitGroup</span><br><span class="line">  lock   sync.Mutex</span><br><span class="line">  rwlock sync.RWMutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">()</span></span> &#123;</span><br><span class="line">  rwlock.Lock() <span class="comment">// 加写锁</span></span><br><span class="line">  x = x + <span class="number">1</span></span><br><span class="line">  time.Sleep(<span class="number">10</span> * time.Millisecond) <span class="comment">// 假设读操作耗时10毫秒</span></span><br><span class="line">  rwlock.Unlock()                   <span class="comment">// 解写锁</span></span><br><span class="line">  wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">()</span></span> &#123;</span><br><span class="line">  rwlock.RLock()               <span class="comment">// 加读锁</span></span><br><span class="line">  time.Sleep(time.Millisecond) <span class="comment">// 假设读操作耗时1毫秒</span></span><br><span class="line">  rwlock.RUnlock()             <span class="comment">// 解读锁</span></span><br><span class="line">  wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  start := time.Now()</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> write()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> read()</span><br><span class="line">  &#125;</span><br><span class="line">  wg.Wait()</span><br><span class="line">  end := time.Now()</span><br><span class="line">  fmt.Println(end.Sub(start))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用读写互斥锁执行上面代码要比用互斥锁快十倍</p>
<ul>
<li>并发中的单例：sync.Once</li>
</ul>
<p>针对高并发情形下只执行一次的操作，可以使用sync.Once避免一系列问题，比如下面例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="type">string</span>]image.Image</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">  icons = <span class="keyword">map</span>[<span class="type">string</span>]image.Image&#123;</span><br><span class="line">    <span class="string">&quot;left&quot;</span>:  loadIcon(<span class="string">&quot;left.png&quot;</span>),</span><br><span class="line">    <span class="string">&quot;up&quot;</span>:    loadIcon(<span class="string">&quot;up.png&quot;</span>),</span><br><span class="line">    <span class="string">&quot;right&quot;</span>: loadIcon(<span class="string">&quot;right.png&quot;</span>),</span><br><span class="line">    <span class="string">&quot;down&quot;</span>:  loadIcon(<span class="string">&quot;down.png&quot;</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Icon被多个goroutine调用不是并发安全的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="type">string</span>)</span></span> image.Image &#123;</span><br><span class="line">  <span class="keyword">if</span> icons == <span class="literal">nil</span> &#123;</span><br><span class="line">    loadIcons()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">  icons = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]image.Image)</span><br><span class="line">  icons[<span class="string">&quot;left&quot;</span>] = loadIcon(<span class="string">&quot;left.png&quot;</span>)</span><br><span class="line">  icons[<span class="string">&quot;up&quot;</span>] = loadIcon(<span class="string">&quot;up.png&quot;</span>)</span><br><span class="line">  icons[<span class="string">&quot;right&quot;</span>] = loadIcon(<span class="string">&quot;right.png&quot;</span>)</span><br><span class="line">  icons[<span class="string">&quot;down&quot;</span>] = loadIcon(<span class="string">&quot;down.png&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况下，可能会出现一个协程调用Icon时，写icons这个map只写到一半，还没写到right，就有另一个协程调用Icon了。</p>
<p>此时icons不是nil，但是要调用icons[“right”]，导致错误。</p>
<p>使用sync.Once的Do方法执行if里的操作可以解决这一问题</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/****************正确写法*****************/</span></span><br><span class="line"><span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="type">string</span>]image.Image</span><br><span class="line"><span class="keyword">var</span> loadIconsOnce sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">  icons = <span class="keyword">map</span>[<span class="type">string</span>]image.Image&#123;</span><br><span class="line">    <span class="string">&quot;left&quot;</span>:  loadIcon(<span class="string">&quot;left.png&quot;</span>),</span><br><span class="line">    <span class="string">&quot;up&quot;</span>:    loadIcon(<span class="string">&quot;up.png&quot;</span>),</span><br><span class="line">    <span class="string">&quot;right&quot;</span>: loadIcon(<span class="string">&quot;right.png&quot;</span>),</span><br><span class="line">    <span class="string">&quot;down&quot;</span>:  loadIcon(<span class="string">&quot;down.png&quot;</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Icon 是并发安全的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="type">string</span>)</span></span> image.Image &#123;</span><br><span class="line">  loadIconsOnce.Do(loadIcons)</span><br><span class="line">  <span class="keyword">return</span> icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sync.Once相当于有一个互斥锁和布尔值，前者上锁保护临界资源和布尔值，后者标记是否执行过</p>
<ul>
<li>面向并发的map：sync.Map</li>
</ul>
<p>多个协程同时写map是不被允许也是不安全的，若想不加锁的前提下使用map，可以用sync.Map</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = sync.Map&#123;&#125;</span><br><span class="line"><span class="comment">//sync.Map的读操作是Load方法，写操作是Store方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">      key := strconv.Itoa(n)</span><br><span class="line">      m.Store(key, n)</span><br><span class="line">      value, _ := m.Load(key)<span class="comment">//第二个返回值是布尔类型，判断是否被找到</span></span><br><span class="line">      fmt.Printf(<span class="string">&quot;k=:%v,v:=%v\n&quot;</span>, key, value)</span><br><span class="line">      wg.Done()</span><br><span class="line">    &#125;(i)</span><br><span class="line">  &#125;</span><br><span class="line">  wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得一提的是，sync.Map的键值都是空接口类型，也就是说可以在同一个sync.Map存储任意类型的键-值对，而不是像传统map要把类型写死</p>
<ul>
<li>原子操作</li>
</ul>
<p>原子操作操作数据时是不可被分割的，所以不会被其它协程抢占，并发安全，而且性能比互斥锁优异</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;sync&quot;</span></span><br><span class="line">  <span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Counter <span class="keyword">interface</span> &#123;</span><br><span class="line">  Inc()</span><br><span class="line">  Load() <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原子操作版</span></span><br><span class="line"><span class="keyword">type</span> AtomicCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">  counter <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AtomicCounter)</span></span> Inc() &#123;</span><br><span class="line">  atomic.AddInt64(&amp;a.counter, <span class="number">1</span>)<span class="comment">//原子方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AtomicCounter)</span></span> Load() <span class="type">int64</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> atomic.LoadInt64(&amp;a.counter)<span class="comment">//原子方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(c Counter)</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">  start := time.Now()</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      c.Inc()</span><br><span class="line">      wg.Done()</span><br><span class="line">    &#125;()</span><br><span class="line">  &#125;</span><br><span class="line">  wg.Wait()</span><br><span class="line">  end := time.Now()</span><br><span class="line">  fmt.Println(c.Load(), end.Sub(start))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c3 := AtomicCounter&#123;&#125; <span class="comment">// 并发安全且比互斥锁效率更高</span></span><br><span class="line">  test(&amp;c3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="17-IO编程"><a href="#17-IO编程" class="headerlink" title="17 IO编程"></a>17 IO编程</h2><h3 id="17-1-文件IO"><a href="#17-1-文件IO" class="headerlink" title="17.1 文件IO"></a>17.1 文件IO</h3><p>文件读和写分别至少有三种方式，并且读文件和写文件时文件的打开方式也是不同的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读---打开文件:os.Open(文件名)</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 只读方式打开当前目录下的main.go文件</span></span><br><span class="line">  file, err := os.Open(<span class="string">&quot;./main.go&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;open file failed!, err:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 关闭文件</span></span><br><span class="line">  <span class="keyword">defer</span> file.Close()<span class="comment">//用defer保证最后一定会关闭文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//写---打开文件：os.OpenFile(文件名,模式,权限设置)</span></span><br><span class="line"><span class="comment">//模式：os.O_WRONLY(只写)、os.O_CREATE(创建文件)、</span></span><br><span class="line"><span class="comment">//os.O_RDONLY(只读)、os.O_RDWR(读写)、os.O_TRUNC(清空)、os.O_APPEND(追加)</span></span><br><span class="line"><span class="comment">//权限：r（读）04，w（写）02，x（执行）01</span></span><br><span class="line"><span class="comment">//   owner   group   other</span></span><br><span class="line"><span class="comment">//0 - rwx  -  rwx  -  rwx</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  file, err := os.OpenFile(<span class="string">&quot;xx.txt&quot;</span>, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;open file failed, err:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> file.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>读文件的三种方式</li>
</ul>
<p>方式一：file.Read()，优势：原生读文件方式，可以精准把控读到的字节数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Read()函数会接收一个字节数组做参数</span></span><br><span class="line"><span class="comment">//返回字节数和error类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 只读方式打开当前目录下的main.go文件</span></span><br><span class="line">  file, err := os.Open(<span class="string">&quot;./main.go&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Failed!, err:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> file.Close()</span><br><span class="line">  <span class="comment">// 使用Read方法读取数据</span></span><br><span class="line">  <span class="keyword">var</span> tmp = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">128</span>)</span><br><span class="line">  n, err := file.Read(tmp)</span><br><span class="line">  <span class="keyword">if</span> err == io.EOF &#123;<span class="comment">//读取少于128字节，读完了</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;文件读完了&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Failed, err:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;读取了%d字节数据\n&quot;</span>, n)</span><br><span class="line">  fmt.Println(<span class="type">string</span>(tmp[:n]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//循环读取</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 只读方式打开当前目录下的main.go文件</span></span><br><span class="line">  file, err := os.Open(<span class="string">&quot;./main.go&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;open failed!, err:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> file.Close()</span><br><span class="line">  <span class="comment">// 循环读取文件</span></span><br><span class="line">  <span class="keyword">var</span> content []<span class="type">byte</span></span><br><span class="line">  <span class="keyword">var</span> tmp = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">128</span>)</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    n, err := file.Read(tmp)</span><br><span class="line">    <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;文件读完了&quot;</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;read failed, err:&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    content = <span class="built_in">append</span>(content, tmp[:n]...)</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="type">string</span>(content))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式二：bufio读取文件，优势：提供大量函数，读文件更加灵活，而且会先从磁盘读到缓存，然后使用时可直接从缓存取数据，减少了磁盘IO带来的瓶颈效应，速度快</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;bufio&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;io&quot;</span></span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// bufio按行读取示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  file, err := os.Open(<span class="string">&quot;./xx.txt&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;open file failed, err:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> file.Close()</span><br><span class="line">  reader := bufio.NewReader(file)<span class="comment">//需要new一个reader对象</span></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    line, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>) <span class="comment">//注意是字符</span></span><br><span class="line">    <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">len</span>(line) != <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Println(line)</span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Println(<span class="string">&quot;文件读完了&quot;</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;read file failed, err:&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Print(line)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式三：io&#x2F;ioutil包的ReadFile方法，优势：可以一次读取完整文件内容，不需要Open、Close</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ioutil.ReadFile读取整个文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  content, err := ioutil.ReadFile(<span class="string">&quot;./main.go&quot;</span>)<span class="comment">//返回的是字节数组</span></span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;read file failed, err:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="type">string</span>(content))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>写文件的三种方式</li>
</ul>
<p>方式一：os包的write和writeString函数，前者写字节数组，后者写字符串</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  file, err := os.OpenFile(<span class="string">&quot;xx.txt&quot;</span>, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;open file failed, err:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> file.Close()</span><br><span class="line">  str := <span class="string">&quot;hello 沙河&quot;</span></span><br><span class="line">  file.Write([]<span class="type">byte</span>(str))       <span class="comment">//写入字节切片数据</span></span><br><span class="line">  file.WriteString(<span class="string">&quot;hello 小王子&quot;</span>) <span class="comment">//直接写入字符串数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式二：bufio的writer对象，需要注意的是，这种方式先写到缓存里，再刷新到磁盘中，所以写完后，需要执行Flush函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  file, err := os.OpenFile(<span class="string">&quot;xx.txt&quot;</span>, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;open file failed, err:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> file.Close()</span><br><span class="line">  writer := bufio.NewWriter(file)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    writer.WriteString(<span class="string">&quot;hello沙河\n&quot;</span>) <span class="comment">//将数据先写入缓存</span></span><br><span class="line">  &#125;</span><br><span class="line">  writer.Flush() <span class="comment">//将缓存中的内容写入文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式三：io&#x2F;ioutil包的WriteFile方法，其最后一个参数与OpenFile的最后一个参数一致</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不需要OpenFile、Close</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  str := <span class="string">&quot;hello 沙河&quot;</span></span><br><span class="line">  err := ioutil.WriteFile(<span class="string">&quot;./xx.txt&quot;</span>, []<span class="type">byte</span>(str), <span class="number">0666</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;write file failed, err:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-2-log包输出日志"><a href="#17-2-log包输出日志" class="headerlink" title="17.2 log包输出日志"></a>17.2 log包输出日志</h3><p>go语言中的log包与python中的logging非常相似，都有logger，可以指定输出到控制台或文件，有fomatter，不同信息有不同等级。</p>
<p><a href="https://golang.org/pkg/log/" title="https://golang.org/pkg/log/">https://golang.org/pkg/log/</a></p>
<p><a href="https://www.bilibili.com/video/BV1QJ411X7CN?from=search&seid=2882714410354221537" title="https://www.bilibili.com/video/BV1QJ411X7CN?from=search&amp;seid=2882714410354221537">https://www.bilibili.com/video/BV1QJ411X7CN?from=search&amp;seid&#x3D;2882714410354221537</a></p>
<h3 id="17-3-fmt包"><a href="#17-3-fmt包" class="headerlink" title="17.3 fmt包"></a>17.3 fmt包</h3><h2 id="18-正则表达式"><a href="#18-正则表达式" class="headerlink" title="18 正则表达式"></a>18 正则表达式</h2><p>Go语言的正则表达式用到了”regexp”包，正则格式和python中的无异。</p>
<p>有两种方式进行正则表达式匹配，一种是正则字符串直接拿来匹配，另一种是将正则表达式字符串通过函数优化成go语言的regexp对象，再利用该对象的方法。后者是线程安全的！</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种方式：正则字符串直接匹配</span></span><br><span class="line">matched, err := regexp.MatchString(<span class="string">`a.b`</span>, <span class="string">&quot;aaxbb&quot;</span>)<span class="comment">//注意需要用反引号</span></span><br><span class="line">fmt.Println(matched) <span class="comment">// true</span></span><br><span class="line">fmt.Println(err)     <span class="comment">// nil (regexp is valid)</span></span><br><span class="line"></span><br><span class="line">matched, _ := regexp.MatchString(<span class="string">`^a.b$`</span>, <span class="string">&quot;aaxbb&quot;</span>)</span><br><span class="line">fmt.Println(matched) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第二种方式：正则字符串先编译成regexp对象</span></span><br><span class="line"><span class="comment">//两种编译方式</span></span><br><span class="line">re1, err := regexp.Compile(<span class="string">`regexp`</span>) <span class="comment">// error if regexp invalid</span></span><br><span class="line">re2 := regexp.MustCompile(<span class="string">`regexp`</span>)  <span class="comment">// panic if regexp invalid</span></span><br><span class="line"><span class="comment">//后者可直接配合defer recover</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Find：find有两种，一种用字符串，一种用字节数组，没有String字样的find方法都是字节数组</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找到第一个匹配的子串</span></span><br><span class="line"><span class="comment">//方法的参数是待匹配的字符串</span></span><br><span class="line">re := regexp.MustCompile(<span class="string">`foo.?`</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, re.FindString(<span class="string">&quot;seafood fool&quot;</span>)) <span class="comment">// &quot;food&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, re.FindString(<span class="string">&quot;meat&quot;</span>))         <span class="comment">// &quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//找到第一个匹配的子串的位置</span></span><br><span class="line">re := regexp.MustCompile(<span class="string">`ab?`</span>)</span><br><span class="line">fmt.Println(re.FindStringIndex(<span class="string">&quot;tablett&quot;</span>))    <span class="comment">// [1 3]</span></span><br><span class="line">fmt.Println(re.FindStringIndex(<span class="string">&quot;foo&quot;</span>) == <span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//找到所有匹配的子串</span></span><br><span class="line">re := regexp.MustCompile(<span class="string">`a.`</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, re.FindAllString(<span class="string">&quot;paranormal&quot;</span>, <span class="number">-1</span>)) <span class="comment">// [&quot;ar&quot; &quot;an&quot; &quot;al&quot;]</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, re.FindAllString(<span class="string">&quot;paranormal&quot;</span>, <span class="number">2</span>))  <span class="comment">// [&quot;ar&quot; &quot;an&quot;]</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, re.FindAllString(<span class="string">&quot;graal&quot;</span>, <span class="number">-1</span>))      <span class="comment">// [&quot;aa&quot;]</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, re.FindAllString(<span class="string">&quot;none&quot;</span>, <span class="number">-1</span>))       <span class="comment">// [] (nil slice)</span></span><br><span class="line"><span class="comment">//FindAllString方法最后一个参指定返回多少子串</span></span><br><span class="line"><span class="comment">//小于0：返回所有；等于0：不返回；大于0：返回这个数量的子串</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Replace：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">re := regexp.MustCompile(<span class="string">`ab*`</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, re.ReplaceAllString(<span class="string">&quot;-a-abb-&quot;</span>, <span class="string">&quot;T&quot;</span>)) <span class="comment">// &quot;-T-T-&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Split：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := regexp.MustCompile(<span class="string">`a`</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, a.Split(<span class="string">&quot;banana&quot;</span>, <span class="number">-1</span>)) <span class="comment">// [&quot;b&quot; &quot;n&quot; &quot;n&quot; &quot;&quot;]</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, a.Split(<span class="string">&quot;banana&quot;</span>, <span class="number">0</span>))  <span class="comment">// [] (nil slice)</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, a.Split(<span class="string">&quot;banana&quot;</span>, <span class="number">1</span>))  <span class="comment">// [&quot;banana&quot;]</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, a.Split(<span class="string">&quot;banana&quot;</span>, <span class="number">2</span>))  <span class="comment">// [&quot;b&quot; &quot;nana&quot;]</span></span><br><span class="line"></span><br><span class="line">zp := regexp.MustCompile(<span class="string">`z+`</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, zp.Split(<span class="string">&quot;pizza&quot;</span>, <span class="number">-1</span>)) <span class="comment">// [&quot;pi&quot; &quot;a&quot;]</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, zp.Split(<span class="string">&quot;pizza&quot;</span>, <span class="number">0</span>))  <span class="comment">// [] (nil slice)</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, zp.Split(<span class="string">&quot;pizza&quot;</span>, <span class="number">1</span>))  <span class="comment">// [&quot;pizza&quot;]</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, zp.Split(<span class="string">&quot;pizza&quot;</span>, <span class="number">2</span>))  <span class="comment">// [&quot;pi&quot; &quot;a&quot;]</span></span><br><span class="line"><span class="comment">//Split方法最后一个参数指定返回多少子串</span></span><br><span class="line"><span class="comment">//小于0：返回所有；等于0：不返回；大于0：返回这个数量的子串</span></span><br></pre></td></tr></table></figure>

<h2 id="19-go语言常用标准库"><a href="#19-go语言常用标准库" class="headerlink" title="19 go语言常用标准库"></a>19 go语言常用标准库</h2><h3 id="19-1-time"><a href="#19-1-time" class="headerlink" title="19.1 time"></a>19.1 time</h3><h3 id="19-2-flag"><a href="#19-2-flag" class="headerlink" title="19.2 flag"></a>19.2 flag</h3><h3 id="19-3-strconv"><a href="#19-3-strconv" class="headerlink" title="19.3 strconv"></a>19.3 strconv</h3><h1 id="Go语言底层原理"><a href="#Go语言底层原理" class="headerlink" title="Go语言底层原理"></a>Go语言底层原理</h1><p>《Go语言底层原理剖析》</p>
<p>Golang修养之路：<a href="https://www.kancloud.cn/aceld/golang" title="https://www.kancloud.cn/aceld/golang">https://www.kancloud.cn/aceld/golang</a></p>
<h2 id="GMP模型"><a href="#GMP模型" class="headerlink" title="GMP模型"></a>GMP模型</h2><h2 id="逃逸现象"><a href="#逃逸现象" class="headerlink" title="逃逸现象"></a>逃逸现象</h2><h2 id="make和new-的区别"><a href="#make和new-的区别" class="headerlink" title="make和new 的区别"></a>make和new 的区别</h2><ul>
<li><p>变量声明：</p>
<p><code>var</code>关键字，不指定变量默认值时，变量的默认值会是零值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="type">int</span>    <span class="comment">//int类型的零值是0</span></span><br><span class="line"><span class="keyword">var</span> s <span class="type">string</span> <span class="comment">//string类型的零值是&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>引用类型的零值是nil</p>
</li>
<li><p>new内存分配</p>
</li>
</ul>
<p>使用new时必须先分配内存</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> i *<span class="type">int</span></span><br><span class="line">   *i=<span class="number">10</span></span><br><span class="line">   fmt.Println(*i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> i *<span class="type">int</span></span><br><span class="line">   i=<span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">   *i=<span class="number">10</span></span><br><span class="line">   fmt.Println(*i)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>new()只接收一个参数，就是类型。<strong>返回的是类型指针</strong>，并且分配内存后会默认给指针指向的地址赋零值。</p>
<ul>
<li>make内存分配</li>
</ul>
<p>make只用于三种类型：<code>chan</code>，<code>map</code>，<code>slice</code>的内存创建。而且<strong>返回的</strong>不是指针，而<strong>就是这三种类型</strong>（不是指针，因为它们自身就是引用类型）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(t Type, size ...IntegerType)</span></span> Type</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*格式：make(map[键数据类型][值数据类型])*/</span></span><br><span class="line">emails := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T:切片的元素类型</span></span><br><span class="line"><span class="comment">//size:切片中元素的数量</span></span><br><span class="line"><span class="comment">//cap:切片的容量</span></span><br><span class="line">a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>make与new的异同：</p>
<ul>
<li><p>相同：均为堆空间分配</p>
</li>
<li><p>不同：</p>
<p>make：只用于slice、map和chan的初始化，无可替代；</p>
<p>new：用于类型内存分配（初始化值为0），不常用</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>📌new不常用：<br>现实代码通常采用短语句声明以及结构体的字面量达到分配内存目的，如：<br>i :&#x3D; 0<br>u :&#x3D; user{}</p>
</blockquote>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p><img src="/image/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86_tZ5L5K7RyB.jpg"></p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><blockquote>
<p>📌<strong>为什么需要垃圾回收？</strong><br>1. 减少错误和复杂性<br>手动分配、释放内存等可能会带来内存泄露、野指针等问题。虽然垃圾回收不保证完全不产生内存泄露，但其提供了重要的保障，即不再被引用的对象最终将被收集。<br>同时，可以避免悬空指针、多次释放等手动管理内存时会出现的问题。<br>垃圾回收功能屏蔽了内存管理的复杂性，开发者可更好地关注核心业务逻辑。<br>2. 解耦<br>现代软件工程崇尚模块化，而模块间只提供少量接口以交互。当多个模块同时维护一个内存时，释放内存将变得非常小心。<br>手动分配面临这样的问题：缺乏信息，难以在本地模块内做出全局的决定。<br>垃圾回收机制将此工作托管给了具有全局视野的运行时代码，从而使业务模块间真正解耦，从而有利于开发、调试，并开发出更大规模的、高并发的项目。</p>
</blockquote>
<blockquote>
<p>📌<strong>什么场景需要垃圾回收？</strong><br>垃圾回收带来了额外的成本，需要保存内存的状态信息并扫描内存，很多时候还需要中断整个程序来处理垃圾回收。<br>因此，垃圾回收<strong>对于要求极致的速度和内存要求极小的场景并不适用</strong>（嵌入式、系统级程序）；<br>却是开发大规模、分布式、微服务集群的极佳选择。</p>
</blockquote>
<h3 id="Go垃圾回收中的三色标记："><a href="#Go垃圾回收中的三色标记：" class="headerlink" title="Go垃圾回收中的三色标记："></a>Go垃圾回收中的三色标记：</h3><h3 id="Go执行垃圾回收具体流程："><a href="#Go执行垃圾回收具体流程：" class="headerlink" title="Go执行垃圾回收具体流程："></a>Go执行垃圾回收具体流程：</h3><h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><h3 id="defer的执行顺序"><a href="#defer的执行顺序" class="headerlink" title="defer的执行顺序"></a>defer的执行顺序</h3><p><img src="/image/image_klHnHNaXk-.png"></p>
<p>栈：先进后出</p>
<h3 id="函数的返回值初始化"><a href="#函数的返回值初始化" class="headerlink" title="函数的返回值初始化"></a>函数的返回值初始化</h3><p><img src="/image/image_Rjj_29L3So.png"></p>
<p>只要函数返回值有名字（例子中为t），这个<code>t</code>会在函数起始处被初始化为对应类型的零值并且作用域为整个函数。</p>
<h3 id="return和defer谁先谁后-amp-有名函数返回值遇见defer情况"><a href="#return和defer谁先谁后-amp-有名函数返回值遇见defer情况" class="headerlink" title="return和defer谁先谁后 &amp; 有名函数返回值遇见defer情况"></a>return和defer谁先谁后 &amp; 有名函数返回值遇见defer情况</h3><p><img src="/image/image_xlY7fDYo9I.png"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnButDefer</span><span class="params">()</span></span> (t <span class="type">int</span>) &#123;  <span class="comment">//t初始化0， 并且作用域为该函数全域</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        t = t * <span class="number">10</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(returnButDefer())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ go run test.go</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<p>本应返回1，但是return后进入了defer，所以<code>t=t*10</code>被执行，因此最后返回给main的结果为10。</p>
<h3 id="defer遇见panic"><a href="#defer遇见panic" class="headerlink" title="defer遇见panic"></a>defer遇见panic</h3><p><img src="/image/image__3aWsdTgIN.png"></p>
<h3 id="defer中包含panic"><a href="#defer中包含panic" class="headerlink" title="defer中包含panic"></a>defer中包含panic</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">       <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span>&#123;</span><br><span class="line">           fmt.Println(err)</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           fmt.Println(<span class="string">&quot;fatal&quot;</span>)</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;defer panic&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;panic&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">defer panic</span><br></pre></td></tr></table></figure>

<p>触发<code>panic(&quot;panic&quot;)</code>后defer顺序出栈执行，第一个被执行的defer中的<code>panic(&quot;defer panic&quot;)</code>异常，会覆盖掉main中的<code>panic(&quot;panic&quot;)</code>，最后这个异常被第二个执行的defer捕获到。</p>
<h3 id="defer下的函数参数包含子函数"><a href="#defer下的函数参数包含子函数" class="headerlink" title="defer下的函数参数包含子函数"></a>defer下的函数参数包含子函数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function</span><span class="params">(index <span class="type">int</span>, value <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    fmt.Println(index)</span><br><span class="line">    <span class="keyword">return</span> index</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> function(<span class="number">1</span>, function(<span class="number">3</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">defer</span> function(<span class="number">2</span>, function(<span class="number">4</span>, <span class="number">0</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>这里有四个函数，用第一个参数的值给它们标号为1\2\3\4。需要研究它们的先后执行顺序：</p>
<p>有两个defer，所以defer会压栈两次，先进栈1，后进栈2。压1时，由于需要连同函数地址、函数形参一同进栈，因此为了得到第二个参数的结果，需要先执行function3。同理在压2时，就需要先执行function4。</p>
<p>因此执行顺序为：3→4→2→1。</p>
<h1 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h1><h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h2><blockquote>
<p>gRPC允许</p>
</blockquote>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基础知识</title>
    <url>/2022/07/01/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="C-基础知识"><a href="#C-基础知识" class="headerlink" title="C++基础知识"></a>C++基础知识</h1><blockquote>
<p>参考资料：<br>- 《C++语言导学》（第一版）<br>- 《C++ primer》（第五版）<br>- 《C++新经典：对象模型》（第一版）<br>- 《C++并发编程实战》（第二版）</p>
<p>时间线：<br>2021&#x2F;10&#x2F;9：开始整理笔记，以《C++语言导学》为线索梳理<br>2022&#x2F;05&#x2F;24：初步整理完成，汇总《C++语言导学》，部分《C++ Primer》和少量《Effective Modern C++》<br>2022&#x2F;06&#x2F;20：开始在笔记中加入并发（《C++并发编程实战》第二版）知识<br>2022&#x2F;07&#x2F;07：学习极客时间“现代C++实战30讲”，添加type_traits相关内容</p>
</blockquote>
<h2 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h2><h3 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1 基础知识"></a>1 基础知识</h3><ul>
<li><p><strong>程序编译：</strong></p>
<p><img src="/image/image_C-0mU-M0rw.png"></p>
<p>ISO的C++标准定义了两种实体：</p>
<p>1.核心语言特性</p>
<p>比如内置类型（int, float）以及循环（for, while）；</p>
<p>2.标准库组件</p>
<p>比如容器（vector, map）以及I&#x2F;O操作（&lt;&lt;, getline）。</p>
</li>
<li><p><strong>预处理期编程：</strong></p>
<p>预处理编程的操作目标是“源码”，各种指令控制预处理器，实际上就是让预处理器改造源码，改造成其他形式。预处理指令以“#”开头，单独的“#”也是一个预处理指令，即空指令，相当于空行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#                              <span class="comment">// 预处理空行</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __linux__                  <span class="comment">// 预处理检查宏是否存在</span></span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> HAS_LINUX    1      <span class="comment">// 宏定义，有缩进</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>                         <span class="comment">// 预处理条件语句结束</span></span></span><br><span class="line">#                              <span class="comment">// 预处理空行</span></span><br></pre></td></tr></table></figure>

<p>预处理器改造后的代码可以让gcc用-E选项来展开。</p>
<ul>
<li><p>包含文件（#include）：</p>
<p>#include不仅可以包含头文件，理论上，只要想，源码、普通文本、图片、音频、视频都可以引进来（虽然可能出现无法处理的错误）。比如<code>#include &quot;a.out&quot;</code>。引用头文件时常用的技巧是“Include Guard”：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _XXX_H_INCLUDE_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _XXX_H_INCLUDE_</span></span><br><span class="line">... <span class="comment">//头文件内容</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> _XXX_H_INCLUDE_</span></span><br></pre></td></tr></table></figure>

<p>还有一种常用用法，使用“ *.inc”文件存放一些代码片段。比如有一个很大的用于数值计算的数组，直接放在源码文件里很占地方，不方便对源码的逻辑部分进行梳理查看。那么，便可以把此数组放在calc_values.inc中，通过#include加载它，从而替换原来的大批数字：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//calc_values.inc文件</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span>  calc_table[] = &#123;  <span class="comment">// 非常大的一个数组，有几十行</span></span><br><span class="line">    <span class="number">0x00000000</span>, <span class="number">0x77073096</span>, <span class="number">0xee0e612c</span>, <span class="number">0x990951ba</span>,</span><br><span class="line">    <span class="number">0x076dc419</span>, <span class="number">0x706af48f</span>, <span class="number">0xe963a535</span>, <span class="number">0x9e6495a3</span>,</span><br><span class="line">    <span class="number">0x0edb8832</span>, <span class="number">0x79dcb8a4</span>, <span class="number">0xe0d5e91e</span>, <span class="number">0x97d2d988</span>,</span><br><span class="line">    <span class="number">0x09b64c2b</span>, <span class="number">0x7eb17cbd</span>, <span class="number">0xe7b82d07</span>, <span class="number">0x90bf1d91</span>,</span><br><span class="line">    ...                          </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//源码文件</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span>  calc_table[] = &#123;</span><br><span class="line"><span class="meta">#  <span class="keyword">include</span> <span class="string">&quot;calc_values.inc&quot;</span>        <span class="comment">// 非常大的一个数组，细节被隐藏</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>宏定义（#define&#x2F;#undef）：</p>
<ul>
<li><p>宏的展开、替换发生在预处理阶段，对于一些调用频繁的小代码片段，用宏来封装的效果比inline关键字要好，因为其是源码级别的无条件内联，比如Nginx中的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ngx_tolower(c)      ((c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>) ? (c | 0x20) : c)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ngx_toupper(c)      ((c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>) ? (c &amp; ~0x20) : c)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ngx_memzero(buf, n)       (void) memset(buf, 0, n)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>宏没有作用域概念，永远生效，因此对于一些用于简化代码、起临时作用的宏，用完后尽快#undef取消定义，避免冲突：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CUBE(a) (a) * (a) * (a)  <span class="comment">// 定义一个简单的求立方的宏</span></span></span><br><span class="line">cout &lt;&lt; <span class="built_in">CUBE</span>(<span class="number">10</span>) &lt;&lt; endl;        <span class="comment">// 使用宏简化代码</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">CUBE</span>(<span class="number">15</span>) &lt;&lt; endl;        <span class="comment">// 使用宏简化代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> CUBE                      <span class="comment">// 使用完毕后立即取消定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> AUTH_PWD                  <span class="comment">// 检查是否已经有宏定义</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">undef</span> AUTH_PWD                <span class="comment">// 取消宏定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>                           <span class="comment">// 宏定义检查结束</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AUTH_PWD <span class="string">&quot;xxx&quot;</span>           <span class="comment">// 重新宏定义</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>宏也被常用来做<strong>文本替换</strong>，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BEGIN_NAMESPACE(x)  namespace x &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> END_NAMESPACE(x)    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">BEGIN_NAMESPACE</span>(my_own)</span><br><span class="line"></span><br><span class="line">...      <span class="comment">// functions and classes</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">END_NAMESPACE</span>(my_own)</span><br></pre></td></tr></table></figure>

<p>此处只是简单的文本替换，但是全大写的形式非常醒目，可以更容易识别出命名空间开始和结束的位置。</p>
</li>
</ul>
</li>
<li><p>条件编译（#if&#x2F;#else&#x2F;#endif）：</p>
<p>在预处理阶段实现分支处理，通过判断宏的数值来产生不同的源码，从而改变源文件的形态。#if后的判断依据，也就是定义好的各种宏。</p>
<ul>
<li><p>C++版本号宏：<code>__cplusplus</code>，利用该宏来判断当前的环境，从而使用相应的处理方式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus                      <span class="comment">// 定义了这个宏就是在用C++编译</span></span></span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;                        <span class="comment">// 函数按照C的方式去处理</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">a_c_function</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus                      <span class="comment">// 检查是否是C++编译</span></span></span><br><span class="line">    &#125;                                   <span class="comment">// extern &quot;C&quot; 结束</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus &gt;= 201402                <span class="comment">// 检查C++标准的版本号</span></span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c++14 or later&quot;</span> &lt;&lt; endl;    <span class="comment">// 201402就是C++14</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __cplusplus &gt;= 201103              <span class="comment">// 检查C++标准的版本号</span></span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c++11 or before&quot;</span> &lt;&lt; endl;   <span class="comment">// 201103是C++11</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span>   <span class="comment">// __cplusplus &lt; 201103          // 199711是C++98</span></span></span><br><span class="line"><span class="meta">#   <span class="keyword">error</span> <span class="string">&quot;c++ is too old&quot;</span>               <span class="comment">// 太低则预处理报错</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// __cplusplus &gt;= 201402         // 预处理语句结束</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>C++语言特性宏：可以在预处理阶段判断系统是否支持某些语法特性，若支持就用特性，不支持就用老写法</p>
<ul>
<li><p>C++标准提供的宏：C++有很多预定义的宏，如源文件信息的“FILE”“LINE”“DATE”，以及一些测试语言特性是否被支持的宏，如“__cpp_decltype”“__cpp_decltype_auto”“__cpp_lib_make_unique”等。</p>
</li>
<li><p>编译器提供的宏：C++标准里很多宏未定义，但编译器提供，可用<code>g++ -E -dM - &lt; /dev/null</code>查看。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__cpp_decltype_auto)        <span class="comment">//检查是否支持decltype(auto)</span></span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;decltype(auto) enable&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;decltype(auto) disable&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">//__cpp_decltype_auto</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __GNUC__ &lt;= 4</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;gcc is too old&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span>   <span class="comment">// __GNUC__ &gt; 4</span></span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;gcc is good enough&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// __GNUC__ &lt;= 4</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__SSE4_2__) &amp;&amp; defined(__x86_64)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;we can do more optimization&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// defined(__SSE4_2__) &amp;&amp; defined(__x86_64)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>自定义的宏：可以用自定义的宏来实现条件编译，比如Nginx使用Shell脚本检测外部环境，生成一个包含若干宏的源码配置文件，再条件编译包含不同的头文件，实现操作系统定制化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> (NGX_FREEBSD)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">include</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> (NGX_LINUX)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">include</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> (NGX_SOLARIS)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">include</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> (NGX_DARWIN)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">include</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>代码禁用启用：</p>
<p>使用<code>#if 1</code>或<code>#if 0</code>来显式启用或者禁用大段代码，要比<code>/*...*/</code>的注释方式安全且清晰：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 0          <span class="comment">// 0即禁用下面的代码，1则是启用</span></span></span><br><span class="line">  ...          <span class="comment">// 任意的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>         <span class="comment">// 预处理结束</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1          <span class="comment">// 1启用代码，用来强调下面代码的必要性</span></span></span><br><span class="line">  ...          <span class="comment">// 任意的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>         <span class="comment">// 预处理结束</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>属性：编译期指令</strong></p>
<p>前面的#include、#define都是预处理指令，用于控制预处理器。类似的，还有“<strong>编译指令</strong>”来控制编译器。</p>
<p>C++11之前标准里没有编译指令，但编译器提供了，比如GCC里的<code>__attribute__</code>，VC里的<code>__declspec</code></p>
<p>C++11开始，官方将编译指令正式命名为“<strong>属性</strong>”，用两对方括号的形式<code>[[...]]</code>表示，相当于给变量、函数、类等贴上一个编译阶段的标签，让编译器识别。</p>
<p>虽然官方将属性的语法加进来了，但是标准里定义的属性还是十分有限的，最有用的当属C++14的deprecated：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[[<span class="built_in">deprecated</span>(<span class="string">&quot;deadline:2020-12-31&quot;</span>)]]</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">old_func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用此函数的程序编译时会报出一条警告：</span></span><br><span class="line"><span class="comment">//warning: ‘int old_func()’ is deprecated: deadline:2020-12-31 [-Wdeprecated-declarations]</span></span><br></pre></td></tr></table></figure>

<p>属性支持非标准扩展，也就是允许使用编译器提供的非官方属性，比如GCC的属性在<code>gnu::</code>中：</p>
<ul>
<li><p><code>gnu::deprecated</code>：与C++14的deprecated相同，但是可以用在C++11里。</p>
</li>
<li><p><code>gnu::unused</code>：抑制对变量、类、函数的未使用警告，与”(void) var”效果一样。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[[gnu::unused]] <span class="comment">//声明下面的变量暂不使用，不是错误，不需要warning</span></span><br><span class="line"><span class="type">int</span> nouse;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>gnu::constructor</code>：函数会在main()函数之前执行，效果类似对全局对象的构造函数</p>
</li>
<li><p><code>gnu::destructor</code>：函数会在main()函数结束之后执行，效果类似对全局对象的析构函数</p>
</li>
<li><p><code>gnu::always_inline</code>：要求编译器强制内联函数，作用比inline关键字强</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[[gnu::always_inline]] <span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_num</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>gnu::hot</code>：标记热点函数，要求编译器对其进行更积极的优化</p>
</li>
</ul>
<blockquote>
<p>📌constructor和destructor必须使用C语言的语法，比如只能用printf()而不能用cout。</p>
</blockquote>
<p>下面两种写法是等价的：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">__attribute__((constructor)) <span class="function"><span class="type">void</span> <span class="title">load_file</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Constructor is called.\n&quot;</span>);</span><br><span class="line">    g_count = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (g_count == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Failed to malloc memory.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">__attribute__((destructor)) <span class="function"><span class="type">void</span> <span class="title">unload_file</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;destructor is called.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (g_count)</span><br><span class="line">    <span class="built_in">free</span>(g_count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[[gnu::constructor]] </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">load_file</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Constructor is called.\n&quot;</span>);</span><br><span class="line">    g_count = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (g_count == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Failed to malloc memory.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[[gnu::destructor]] </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unload_file</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;destructor is called.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (g_count)</span><br><span class="line">    <span class="built_in">free</span>(g_count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>函数：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回值类型 函数名字（函数参数）</span></span><br><span class="line"><span class="function"><span class="type">double</span>     <span class="title">sqrt</span>    <span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span>     <span class="title">sqrt</span>    <span class="params">(<span class="type">double</span> d)</span></span>;</span><br></pre></td></tr></table></figure>

<p>1.对于类成员函数来说，类名字也是函数名字的一部分<code>char&amp; String::operator[](int index);</code></p>
<p>2.编译器会检查实参的类型，并且会在必要的时候执行隐式实参类型转换 <code>sqrt(2);</code></p>
<p>3.函数重载可能会因为二义性报错：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">user</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="number">0</span>,<span class="number">0</span>); <span class="comment">//此时会报错，因为两个print都可以用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>📌C++和C编译文件的区别：<br>C语言不支持重载，而C++支持。如一个函数声明为<code>void function(float x,float y)</code>，在C语言中，编译器进行编译之后，在库中的名字为<code>_function</code>；在C++中，编译器进行编译后，在库中的名字为<code>_function_float_float</code>。<br>编译器在链接的阶段，都是找到相应的函数名，进行链接。<br>在C语言中，两个函数的名字一样，就会在链接时报错；<br>在C++中 ，两个函数名字不相同，就不会报错。</p>
</blockquote>
</li>
<li><p><strong>变量类型与算术：</strong></p>
<p>基本类型：<code>bool</code>，<code>int</code>，<code>double</code>，<code>char</code>，<code>unsigned</code>，等</p>
</li>
</ul>
<p>算术运算符</p>
<p>比较运算符</p>
<p>逻辑运算符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">x+y  <span class="comment">//二元加法</span></span><br><span class="line">+x   <span class="comment">//一元正（结果没区别）</span></span><br><span class="line">x-y  <span class="comment">//二元减法</span></span><br><span class="line">-y   <span class="comment">//一元负（结果取负）</span></span><br><span class="line">x*y  <span class="comment">//乘法</span></span><br><span class="line">x/y  <span class="comment">//除法</span></span><br><span class="line">x%y  <span class="comment">//取模</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">x==y</span><br><span class="line">x!=y</span><br><span class="line">x&lt;y</span><br><span class="line">x&gt;y</span><br><span class="line">x&lt;=y</span><br><span class="line">x&gt;=y</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">x&amp;y  <span class="comment">//按位与</span></span><br><span class="line">x|y  <span class="comment">//按位或</span></span><br><span class="line">x^y  <span class="comment">//按位异或</span></span><br><span class="line">~x   <span class="comment">//按位求补</span></span><br><span class="line">x&amp;&amp;y <span class="comment">//逻辑与</span></span><br><span class="line">x||y <span class="comment">//逻辑或</span></span><br></pre></td></tr></table></figure>

<p><strong>初始化</strong>的两种方式：&#x3D;赋值运算符 和 {}初始值列表，二者区别在于前者允许隐式类型转换，而后者不允许</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> x = <span class="number">2.4</span></span><br><span class="line">complex &lt;<span class="type">double</span>&gt; test = &#123;<span class="number">2.4</span>,<span class="number">2</span>&#125;;<span class="comment">//正确，会转换</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> x &#123;<span class="number">2.4</span>&#125;;<span class="comment">//正确</span></span><br><span class="line">complex &lt;<span class="type">double</span>&gt; test &#123;<span class="number">2.4</span>, <span class="number">2</span>&#125;<span class="comment">//错误，2是int</span></span><br></pre></td></tr></table></figure>

<p>由于不允许隐式类型转换，所以一般建议初始值列表的方式初始化变量，可以避免一些导致部分信息丢失的类型转换</p>
<ul>
<li><p>还可以使用auto关键字根据初始值自动推断类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">auto</span> ch = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line"><span class="keyword">auto</span> i = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">auto</span> d = <span class="number">1.2</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<!---->

<ul>
<li><p><strong>常量：</strong></p>
<ul>
<li><p>const：保证变量不变 <code>const int dmv = 17;</code></p>
</li>
<li><p>constexpr：编译时求值 <code>constexpr double max1=square(dmv);</code></p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>📌constexpr若要用在编译时求值场景，右式必须是常量表达式！</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//常量表达式函数必须有constexpr声明</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">double</span> <span class="title">square</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;<span class="keyword">return</span> x*x;&#125;</span><br></pre></td></tr></table></figure>

<p>由constexpr声明的函数可以接受非常量实参，但此时将不再是常量表达式；若接受的是常量实参，此时是常量表达式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">constexpr</span> result1 = <span class="built_in">square</span>(var);</span><br><span class="line"><span class="comment">//报错！因为square(var)非常量表达式，不可编译时求值</span></span><br></pre></td></tr></table></figure>

<p>↑错误  →正确</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> dmv = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">constexpr</span> result2 = <span class="built_in">square</span>(dmv);</span><br><span class="line"><span class="comment">//正确！square(dmv)是常量表达式，此时编译时求值</span></span><br><span class="line"><span class="type">const</span> result3 = <span class="built_in">square</span>(var);</span><br><span class="line"><span class="comment">//正确！result3仍是常量，此为运行时求值</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>作用域与生命周期：</strong></p>
<ul>
<li><p>局部作用域：</p>
</li>
<li><p>类作用域：</p>
</li>
<li><p>命名空间作用域：</p>
</li>
</ul>
</li>
<li><p><strong>循环与条件：</strong></p>
</li>
</ul>
<!---->

<ul>
<li><input disabled="" type="checkbox"> 普通for</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)&#123;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><input disabled="" type="checkbox"> 普通while</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(i++ != <span class="number">10</span>)&#123;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for循环的执行顺序：先auto i&#x3D;0，再判断i≠10，若满足，执行{ }中的内容，再进行++i，然后判断i≠10，满足则执行{ }，再++i，循环往复。</p>
<ul>
<li><input disabled="" type="checkbox"> for…range（类似于Python里的for）</li>
</ul>
<p>拷贝形式的for…range（x是v中元素的拷贝值）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> v[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x:v)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;%d&quot;</span>, x);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x:&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;%d&quot;</span>, x);</span><br></pre></td></tr></table></figure>

<p><strong>引用形式的for…range</strong>（x是v中元素的引用）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x:v)</span><br><span class="line">  ++x;</span><br></pre></td></tr></table></figure>

<ul>
<li><input disabled="" type="checkbox"> switch</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>switch的限制：</p>
<p>ch必须是一个整形或枚举类型，或者是一个class（class中有转换函数将其转换为整型或枚举类型）</p>
</li>
</ul>
<!---->

<ul>
<li><p><strong>内联函数：</strong></p>
<ul>
<li><p>内联函数以空间换时间，省去调用函数的额外开销。所以代码很长或有循环的时候不适合使用内联；</p>
</li>
<li><p>inline对编译器而言只是一个建议，如果定义的函数体内有递归&#x2F;循环等，编译器优化时自动忽视内联；</p>
</li>
<li><p>inline必须与函数定义放在一起，仅将内联放在声明前是不起作用的；</p>
</li>
<li><p>定义在类内的成员函数默认为内联函数；</p>
</li>
<li><p>内联与宏函数的区别：</p>
<ul>
<li><p>宏：</p>
<ul>
<li><p>没有类型检测，不安全</p>
</li>
<li><p>不能进行调试</p>
</li>
<li><p>不可以访问类的成员变量</p>
</li>
</ul>
</li>
<li><p>内联函数：</p>
<ul>
<li><p>有类型检测，较安全</p>
</li>
<li><p>进行参数传递，可在运行时调试</p>
</li>
<li><p>可以访问类的成员变量</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>指针与引用：</strong></p>
<p>空指针尽量用<code>nullptr</code>，使用<code>NULL</code>可能会导致与整数0的混淆。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* p = &amp;v[<span class="number">3</span>];   <span class="comment">//p指向v数组中的第四个元素的地址</span></span><br><span class="line"><span class="type">char</span> x = *p;       <span class="comment">//v是p指向地址的变量的值</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>📌前置&amp;表示一个变量的地址；<br>后置&amp;表示声明一个引用</p>
</blockquote>
<ul>
<li><p>将引用传入作为函数实参</p>
<p>一般来说，函数实参的传递是一个拷贝的过程，将变量的值拷贝到函数的栈中，不会带来对原变量的影响。</p>
<p>而若将引用作为参数传递<code>void sort(vector&lt;double&gt;&amp; vec);</code>，sort函数将直接操纵vec向量，没有拷贝的过程。这样可以加快速度，节省空间，但带来了操作原变量，误改动值的风险。</p>
<p>若想加快传入大数组参数的速度，又不改变值，可以加入const限定！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">sum</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">double</span>&gt;&amp; vec)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>二级指针与指针的引用</p>
<ul>
<li><p>二级指针</p>
<p>指针的指针，作用是改变指针本身的内容。</p>
</li>
<li><p>指针的引用</p>
<p>指针的引用，可以写为<code>int *&amp;i;</code>形式，本质是<code>((int*)&amp;) i;</code>，表示i是一个int型指针的引用，也可以像二级指针一样修改指针本身的内容。</p>
</li>
</ul>
<p>需要说明的是，没有指向引用的指针，因为引用不是变量，因此不存在指针。</p>
</li>
</ul>
<h3 id="2-用户自定义类型"><a href="#2-用户自定义类型" class="headerlink" title="2 用户自定义类型"></a>2 用户自定义类型</h3><blockquote>
<p>这是C++提供的一种抽象机制，用户可以此机制定义自己想要实现某些功能的新类型</p>
</blockquote>
<ul>
<li><p><strong>结构体：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector</span>&#123;</span><br><span class="line">  <span class="type">int</span> sz;       <span class="comment">//元素的数量</span></span><br><span class="line">  <span class="type">double</span> * elem;<span class="comment">//指向元素的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Vector_init</span><span class="params">(Vector&amp; v, <span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">  v.elem = <span class="keyword">new</span> <span class="type">double</span>[s];</span><br><span class="line">  v.sz = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问结构体的元素有两种方式，点运算符和→运算符（指针）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Vector v &#123;<span class="number">0</span>, <span class="literal">nullptr</span>&#125;;</span><br><span class="line"><span class="built_in">Vector_init</span>(v, <span class="number">3</span>);</span><br><span class="line">v.elem[<span class="number">0</span>] = <span class="number">1</span>,v.elem[<span class="number">1</span>] = <span class="number">2</span>,v.elem[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">Vector&amp; rv = v;</span><br><span class="line">Vector* pv = &amp;v; </span><br><span class="line"></span><br><span class="line">cout &lt;&lt; v.sz &lt;&lt; rv.sz &lt;&lt; pv-&gt;sz &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<ul>
<li>结构体的多种初始化方法：</li>
</ul>
<blockquote>
<p>📌结构体初始化：<br>- {}初始化：<br><code>Node b = &#123;2, nullptr&#125;</code>或 <code>Node b &#123;2, nullptr&#125;;</code><br>- 构造函数初始化：<br>&#96;struct Node{                                                                     </p>
<pre><code> int var;                                                                             
 Node* `\*\*`next;                                                                   
 Node(int value, Node next_ty)&#123;
      this→var = value;
      this→next = next_ty;
 &#125;
 //或者： Node(int value, Node* next_ty):var(value), next(next_ty)&#123;&#125;;
</code></pre>
<p>};&#96;&#96;Node c(3, nullptr)<code>  或 </code>Node* d &#x3D; new Node(4,nullptr)&#96;</p>
</blockquote>
</li>
<li><p><strong>类：</strong></p>
<p>类有一系列成员，可能是数据、函数或类型。public成员定义了该类的接口，private成员则只能从接口访问</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Vector</span>(<span class="type">int</span> s): elem&#123;<span class="keyword">new</span> <span class="type">double</span>[s]&#125;, sz&#123;&#125; &#123;&#125; <span class="comment">//构造函数的初始值列表</span></span><br><span class="line">  <span class="type">double</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> i)&#123; <span class="keyword">return</span> elem[i]; &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sz; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">double</span>* elem; <span class="comment">// 指向元素的指针</span></span><br><span class="line">  <span class="type">int</span> sz; <span class="comment">//元素的数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的一点是，虽然Vector类中elem的元素个数可能会变，但是Vector声明的对象大小是不变的。这一点也适用于所有类声明的对象。</p>
<blockquote>
<p>📌struct和class并没有太大区别，struct中也可以定义一些成员函数。唯一的区别体现在struct中的所有成员都是public的。</p>
</blockquote>
</li>
<li><p><strong>枚举：</strong></p>
<ul>
<li><p>普通枚举：<code>enum</code></p>
<p>普通枚举的枚举值都是整形，默认情况下枚举值对应的整数从0开始，依次加1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;red, green, blue&#125;;</span><br><span class="line"><span class="type">int</span> col = green; <span class="comment">//col的值变为1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>强类型枚举：（scoped enumeration，C++11引入的特性）</p>
<p>强类型中，每个<code>enum class</code>是不同的类型，其枚举值位于指定的作用域中，不得混用，可避免对常量的意外误用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123;red, blue, green&#125;;</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Traffic_light</span> &#123;green, yellow, red&#125;;</span><br><span class="line"></span><br><span class="line">Color x = red;                <span class="comment">//报错，哪个red？</span></span><br><span class="line">Color y = Traffic_light::red; <span class="comment">//报错，这个Red不是一个Color对象</span></span><br><span class="line">Color z = Color::red;         <span class="comment">//正确 </span></span><br><span class="line"><span class="type">int</span> col = Color::red;         <span class="comment">//报错，Color::Red不是一个int</span></span><br></pre></td></tr></table></figure>

<p>强类型枚举并不和普通枚举一样，枚举值并不是int。但其作为一种用户自定义类型，也可进行运算符重载</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Traffic_light&amp; <span class="keyword">operator</span>++(Traffic_light&amp; t)&#123;<span class="comment">//前置++运算符</span></span><br><span class="line">  <span class="keyword">switch</span>(t)&#123;</span><br><span class="line">    <span class="keyword">case</span> Traffic_light::green: <span class="keyword">return</span> t = Traffic_light::yellow;</span><br><span class="line">    <span class="keyword">case</span> Traffic_light::green: <span class="keyword">return</span> t = Traffic_light::yellow;</span><br><span class="line">    <span class="keyword">case</span> Traffic_light::green: <span class="keyword">return</span> t = Traffic_light::yellow;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>联合：</strong></p>
<p>union的所有成员被分配在同一片内存区域中，其实际占用的空间就是它最大的成员所占的空间。同一时刻，union中只能保存一个成员的值。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Type</span> &#123;str, num&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entry</span>&#123;</span><br><span class="line">  <span class="type">char</span>* name;</span><br><span class="line">  Type t;</span><br><span class="line">  <span class="type">char</span>* s;  <span class="comment">//如果t==str,则使用s</span></span><br><span class="line">  <span class="type">int</span> i;    <span class="comment">//如果t==num,则使用i</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Entry* p)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;t==str)</span><br><span class="line">    cout &lt;&lt; p-&gt;s;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如左边程序所示，s和i永远不会同时用到，但又同时定义了二者，所以无形中浪费了内存空间，使用联合可解决该问题。</p>
<p>命名联合和匿名联合均可！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//命名联合体</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Type</span> &#123;str,num&#125;;</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">Value</span>&#123;</span><br><span class="line">  <span class="type">char</span>* s;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entry</span>&#123;</span><br><span class="line">  <span class="type">char</span>* name;</span><br><span class="line">  Type t;</span><br><span class="line">  Value v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Entry* p)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;t==str)</span><br><span class="line">    cout&lt;&lt;p-&gt;v.s;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匿名联合体</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Type</span> &#123;str,num&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entry</span>&#123;</span><br><span class="line">  <span class="type">char</span>* name;</span><br><span class="line">  Type t;</span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="type">char</span>* s;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Entry* p)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;t==str)</span><br><span class="line">    cout&lt;&lt;p-&gt;s;<span class="comment">//匿名的优势在于，可以直接用</span></span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：初始化此结构体不能再<code>Entry test&#123;&quot;abc&quot;, num, 123&#125;</code>，{}会按{char <em>, Type, char</em>}初始化，发挥不了union优势</p>
<p>要逐个赋初值，以匿名联合体为例，要<code>Entry test;test.name=&quot;abc&quot;; test.t=str;test.s=&quot;abc&quot;;//test.t=num;test.i=123;</code></p>
<h4 id="auto-x2F-decltype"><a href="#auto-x2F-decltype" class="headerlink" title="auto&#x2F;decltype"></a>auto&#x2F;decltype</h4><blockquote>
<p>auto自动类型推到，在代码里的作用像一个占位符，写上它，让编译器自动填上变量的类型。其属于编译阶段的特殊指令，因此在泛型编程和模板元编程里有比较多的使用。<br>decltype比较像函数，来计算类型，跟auto很像。（也是编译阶段的类型推导）</p>
</blockquote>
<ul>
<li><p><strong>auto注意事项</strong>：</p>
<ul>
<li><p>auto的自动推导能力只能用在“初始化”场合</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">0L</span>;    <span class="comment">// 自动推导为long</span></span><br><span class="line"><span class="keyword">auto</span> y = &amp;x;    <span class="comment">// 自动推导为long*</span></span><br><span class="line"><span class="keyword">auto</span> z &#123;&amp;x&#125;;    <span class="comment">// 自动推导为long* </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> err;       <span class="comment">// 错误，没有赋值表达式，不知道是什么类型</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>类成员变量初始化时，不允许使用auto推导类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> <span class="keyword">final</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = <span class="number">10</span>;  <span class="comment">// 错误，类里不能使用auto推导类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>auto总是推导出“值类型”，绝不会是“引用”；但是auto可以附加上const、 *、&amp;等，得到新的类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span>        x = <span class="number">10L</span>;    <span class="comment">// auto推导为long，x是long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp;       x1 = x;     <span class="comment">// auto推导为long，x1是long&amp;</span></span><br><span class="line"><span class="keyword">auto</span>*       x2 = &amp;x;    <span class="comment">// auto推导为long，x2是long*</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; x3 = x;     <span class="comment">// auto推导为long，x3是const long&amp;</span></span><br><span class="line"><span class="keyword">auto</span>        x4 = &amp;x3;   <span class="comment">// auto推导为const long*，x4是const long*</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>decltype注意事项</strong>：decltype没有auto这么多局限，<strong>前述auto的三个事项在decltype这里均不需要注意</strong>。</p>
<ul>
<li><p>类型推导时不需要初始化（后面无需有表达式），可以直接声明变量；</p>
</li>
<li><p>decltype不仅能够推导出值类型，还能推导出引用类型，即“原始类型”</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;          <span class="comment">// 整型变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(x)     x1;      <span class="comment">// 推导为int，x1是int</span></span><br><span class="line"><span class="keyword">decltype</span>(x)&amp;    x2 = x;    <span class="comment">// 推导为int，x2是int&amp;，引用必须赋值</span></span><br><span class="line"><span class="keyword">decltype</span>(x)*    x3;      <span class="comment">// 推导为int，x3是int*</span></span><br><span class="line"><span class="keyword">decltype</span>(&amp;x)    x4;      <span class="comment">// 推导为int*，x4是int*</span></span><br><span class="line"><span class="keyword">decltype</span>(&amp;x)*   x5;      <span class="comment">// 推导为int*，x5是int**</span></span><br><span class="line"><span class="keyword">decltype</span>(x2)    x6 = x2;  <span class="comment">// 推导为int&amp;，x6是int&amp;，引用必须赋值</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>C++14引入了<code>decltype(auto)</code>，既能够精确推导类型，又可以像auto一样方便（decltype里不再每次都输入特定的表达式了）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;            <span class="comment">// 整型变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>)     x1 = (x);  <span class="comment">// 推导为int&amp;，因为(expr)是引用类型</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>)     x2 = &amp;x;   <span class="comment">// 推导为int*</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>)     x3 = x1;   <span class="comment">// 推导为int&amp;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>auto和decltype的使用</strong>：</p>
<ul>
<li><p>auto使用场景：变量声明、range-based for：<code>for(auto&amp; i : vec)</code>、函数返回值<code>auto test()&#123;&#125;</code>（C++14）</p>
</li>
<li><p>decltype的使用场景：</p>
<ul>
<li><p>当类型非常奇怪时，给奇怪类型一个别名</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UNIX信号函数的原型，看着就让人晕，你能手写出函数指针吗？</span></span><br><span class="line"><span class="built_in">void</span> (*<span class="built_in">signal</span>(<span class="type">int</span> signo, <span class="built_in">void</span> (*func)(<span class="type">int</span>)))(<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用decltype可以轻松得到函数指针类型</span></span><br><span class="line"><span class="keyword">using</span> <span class="type">sig_func_ptr_t</span> = <span class="keyword">decltype</span>(&amp;signal) ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类内成员，auto被禁，decltype可以替换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DemoClass</span> <span class="keyword">final</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> set_type      = std::set;  <span class="comment">// 集合类型别名</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    set_type      m_set;                   <span class="comment">// 使用别名定义成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用decltype计算表达式的类型，定义别名</span></span><br><span class="line">    <span class="keyword">using</span> iter_type = <span class="keyword">decltype</span>(m_set.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">    iter_type     m_pos;                   <span class="comment">// 类型别名定义成员变量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h4><p>C++中的类和结构体可以包含比内置整形类型占用更少存储空间的成员。这些成员可以指定位数大小，叫做“位域”。</p>
<p>位域可以看做内置整形类型的子集，位域成员可以指定其在结构体中占用的位数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Date</span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> nWeekDay  : <span class="number">3</span>;  <span class="comment">//3 bits</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> nMonthDay : <span class="number">6</span>;  <span class="comment">//6 bits</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> nMonth    : <span class="number">5</span>;  <span class="comment">//5 bits</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> nYear     : <span class="number">8</span>;  <span class="comment">//8 bits</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/image/image_MHylNzhysP.png"></p>
<p>声明为位域的数据从低位到高位进行排序</p>
<p>假定系统中unsigned short是16位的，nYear8位，会溢出unsigned short类型的单元边界，因此它会从新的unsigned short开始。同时，还可以有匿名位域（宽度为0），匿名位域会强制下一字段与下一个类型边界对齐</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Date</span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> nWeekDay  : <span class="number">3</span>;  <span class="comment">//3 bits</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> nMonthDay : <span class="number">6</span>;  <span class="comment">//6 bits</span></span><br><span class="line">  <span class="type">unsigned</span>                 : <span class="number">0</span>;  <span class="comment">//强制对齐到下一边界</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> nMonth    : <span class="number">5</span>;  <span class="comment">//5 bits</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> nYear     : <span class="number">8</span>;  <span class="comment">//8 bits</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/image/image_nuXGWwKUxa.png"></p>
<p>带有零长度位域的对象布局</p>
<blockquote>
<p>📌位域字段的基础类型必须是整形类型（内置的那些）</p>
</blockquote>
<h3 id="3-模块化"><a href="#3-模块化" class="headerlink" title="3 模块化"></a>3 模块化</h3><ul>
<li><p><strong>命名空间：</strong></p>
<p>一段完整的程序可能是由不同部分构成的，应对这种情况，为使结构清晰且编译加快，应该使用<strong>分离编译</strong>，即在头文件中声明，利用头文件提供接口，具体实现在不同源文件中。</p>
<p>但是若有多个开发者共同开发，把模块组装在一起构成程序并不一定是一件容易的事情，特别是当不同开发者命名了同一个函数名时。命名空间为解决此情况问题而生。</p>
<p>如要声明一个自己的complex类型，但又不想与std库中的complex类型冲突：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> My_Code&#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">complex</span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function">complex <span class="title">sort</span><span class="params">(complex)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">My_Code::complex <span class="title">My_Code::sort</span><span class="params">(My_Code::complex)</span></span>&#123;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  My_Code::complex a &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">  My_Code::complex result = My_Code::<span class="built_in">sort</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，如果不想写的像上面那样繁琐，也可以直接用using关键字<code>using namespace My_Code</code>，使得一个指定命名空间的名字在当前在当前作用域中可见。</p>
</li>
</ul>
<h3 id="4-错误处理"><a href="#4-错误处理" class="headerlink" title="4 错误处理"></a>4 错误处理</h3><ul>
<li><p><strong>异常&amp;不变式：</strong></p>
<p>异常负责报告<strong>运行时</strong>程序发射时能够的错误。由<code>throw</code>语句指定。例如在自定义Vector时，需要确保索引Vector对象时，不会有越界的情况发生。因此，可以在<code>operator[]()</code>中抛出异常：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span>&amp; Vector::<span class="keyword">operator</span>[](<span class="type">int</span> i)&#123;</span><br><span class="line">  <span class="keyword">if</span>(i&lt;<span class="number">0</span> || <span class="built_in">size</span>()&lt;=i)</span><br><span class="line">    <span class="keyword">throw</span> out_of_range&#123;<span class="string">&quot;Vector::operator[]&quot;</span>&#125;;</span><br><span class="line">  <span class="keyword">return</span> elem[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>throw</code>将程序的控制权从调用了Vector::operator[]()的函数转移到了out_of_range异常的异常处理代码。比如下面当try中的索引越界，抛出out_of_range异常后，会进入catch块中的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Vector&amp; v)</span></span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">try</span> &#123; <span class="comment">//可能发生越界错误的代码被放在了try块中</span></span><br><span class="line">    v[v.<span class="built_in">size</span>()] = <span class="number">7</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span> (out_of_range) &#123; <span class="comment">//捕捉到越界异常</span></span><br><span class="line">    <span class="comment">//处理越界错误</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，在调用构造函数构造Vector时，传入的参数也需要满足一些条件。将从调用构造函数，直到调用析构函数这一过程中，对象始终所满足的要求称为<strong>不变式</strong>(Invariant)。比如调用Vector构造函数指定包含多少个元素，却传进了一个负值，这时需要不变式来约束。这种情况下的不变式可以通过异常实现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Vector::<span class="built_in">Vector</span>(<span class="type">int</span> s)&#123;</span><br><span class="line">  <span class="keyword">if</span> (s &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> length_error&#123;&#125;;</span><br><span class="line">  elem = <span class="keyword">new</span> <span class="type">double</span>[s];</span><br><span class="line">  sz = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="function">Vector <span class="title">v</span><span class="params">(<span class="number">-27</span>)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span> (std::length_error) &#123;</span><br><span class="line">    <span class="comment">//处理负值问题</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span> (std::bad_alloc) &#123;</span><br><span class="line">    <span class="comment">//处理内存耗尽问题</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>📌当希望一个函数永远不抛出异常，可以将其声明为noexcept。这样的话当函数抛出了异常，标准库函数terminate()会立即终止当前程序的执行，避免异常的传播和扩散。<br>noexcept 等效于 noexcept(true)<br>C++11后，类的析构函数默认是noexcept，也就是析构函数不允许抛出异常。但如果人为将声明改为noexcept(false)，或者其基类的析构函数是noexcept(false)，那么此时的析构函数可以抛出异常。<br>此外，noexcept自身也可以是一个运算符，标志一个函数是否被声明成了noexcept，是否能抛出异常。&amp;#x20;</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">noexcept</span></span>; </span><br><span class="line"><span class="comment">//函数f()不抛出异常</span></span><br><span class="line"><span class="built_in">void</span> (*fp) <span class="built_in">noexcept</span>(<span class="literal">false</span>); </span><br><span class="line"><span class="comment">//fp指向可能抛出异常的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">void</span> pfa() <span class="keyword">noexcept</span>)</span></span>; </span><br><span class="line"><span class="comment">//g接收不抛出异常的函数的指针</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">noexcept</span>(f); <span class="comment">//返回值为true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//两种noexcept可配合于函数模板</span></span><br><span class="line"><span class="comment">//以声明函数对某些类型抛异常，但不对其他类型抛出</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> <span class="title">noexcpet</span><span class="params">(<span class="keyword">noexcept</span>(T()))</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>静态断言：</strong></p>
<p>上述两种方式均为运行时报错，而静态断言可以在编译时报错，从而让开发者改进代码以规避运行时的错误。<code>static_assert(A,S)</code>机制的作用是，当A不为true时，把S作为一条编译器错误信息输出。</p>
<blockquote>
<p>📌需注意，A必须是常量表达式！</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">double</span> C = <span class="number">299792.458</span>;</span><br><span class="line"><span class="type">double</span> speed = <span class="number">100000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> local_max = <span class="number">160.0</span>/(<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line"><span class="built_in">static_assert</span>(speed&lt;C,<span class="string">&quot;can&#x27;t go that fast&quot;</span>);     <span class="comment">// 报错，speed不是常量，非常量表达式</span></span><br><span class="line"><span class="built_in">static_assert</span>(local_max&lt;C,<span class="string">&quot;can&#x27;t go that fast&quot;</span>); <span class="comment">// 正确，常量表达式</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-const"><a href="#5-const" class="headerlink" title="5 const"></a>5 const</h3><h4 id="const常量与宏的区别"><a href="#const常量与宏的区别" class="headerlink" title="const常量与宏的区别"></a>const常量与宏的区别</h4><p><strong>const定义的常量在预处理阶段并不存在，而是直到运行阶段才出现</strong>。也就是说，const声明出来的是一种“只读变量”，可以用指针获取地址。既然可以获取指针，那么便可以利用指针再强制写入，从而“常量不常”。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要加上volatile修饰，运行时才能看到效果</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> <span class="type">int</span> MAX_LEN = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ptr = (<span class="type">int</span>*)(&amp;MAX_LEN);</span><br><span class="line">*ptr = <span class="number">2048</span>;</span><br><span class="line">cout &lt;&lt; MAX_LEN &lt;&lt; endl;<span class="comment">//输出2048</span></span><br></pre></td></tr></table></figure>

<p>修改时需要用volatile禁用优化。不加的话编译器看到const会采取优化手段，把所有const常量出现的地方替换成原值</p>
<h4 id="const修饰成员函数"><a href="#const修饰成员函数" class="headerlink" title="const修饰成员函数"></a>const修饰成员函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">fun</span><span class="params">(<span class="type">int</span>&amp; a)</span></span>; <span class="comment">//修饰返回值</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">fun</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a)</span></span>; <span class="comment">//修饰形参</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">fun</span><span class="params">(<span class="type">int</span>&amp; a)</span> <span class="type">const</span></span>&#123;&#125; <span class="comment">//const成员函数</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>const修饰返回值</p>
<p>const修饰返回值多是在返回类型为引用的情况下，避免返回值被修改的情况。</p>
<p>因为此时这个引用比不是临时对象的引用，必然是成员变量后函数参数。不用const修饰可能会成为左值被修改，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> num):<span class="built_in">data</span>(num)&#123;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span>&amp; <span class="title">get_data</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    a.<span class="built_in">get_data</span>()=<span class="number">3</span>;</span><br><span class="line">    cout&lt;&lt;a.<span class="built_in">get_data</span>()&lt;&lt;endl; <span class="comment">//data=3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果返回值加上了const，此时试图改变返回值的操作是不允许的，编译会报错。从而规避上述情况。</p>
</li>
<li><p>const修饰形参</p>
<p>传引用的方式可以节省内存，提高效率。但导致了函数具备修改该值的风险。如果在引用类型的形参前加const，就可以规避此风险。</p>
</li>
<li><p>const修饰成员函数</p>
<p>考虑这样一种场景：一个对象被声明成const，但是其某个成员函数非const，此时通过该对象调用该成员函数，编译器会报错</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> String <span class="title">str</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line">str.<span class="built_in">print</span>(); <span class="comment">//类内的print没有被const修饰</span></span><br></pre></td></tr></table></figure>

<p>这是因为调用成员函数时，会使用this指针。但是我们定义了一个const对象，但this指针不是const类型的，所以出现参数类型不匹配，编译无法通过的情况。</p>
<p><strong>用const修饰成员函数，实质上是修饰this所指向的对象</strong>。</p>
<p>当类内没有函数重载，即只有一个版本的成员函数时，const对象只能调用const成员函数，non-const对象既可以调用const成员函数，也可以调用non-const成员函数。</p>
<p>而如果一个成员函数同时有const和non-const两个版本的话，const对象只能调用const成员函数，non-const对象只能调用non-const成员函数。</p>
</li>
</ul>
<h4 id="const修饰指针"><a href="#const修饰指针" class="headerlink" title="const修饰指针"></a>const修饰指针</h4><ul>
<li><p>const char* ptr：* ptr是const的，即不能通过*ptr修改值，但是ptr可以修改，值也可改</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="type">char</span> ss[] = <span class="string">&quot;good game||&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* ptr = str;</span><br><span class="line"></span><br><span class="line">ptr[<span class="number">0</span>] = <span class="string">&#x27;s&#x27;</span>; <span class="comment">//报错！</span></span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;s&#x27;</span>; <span class="comment">//不报错，正常，输出会得到&quot;sello world&quot;</span></span><br><span class="line">ptr = ss;     <span class="comment">//不报错，输出*ptr会得到&quot;good game||&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>char const* ptr：与<code>const char*</code>一致。</p>
</li>
<li><p>char* const ptr：ptr是const的，即不能修改ptr，但可以通过*ptr改值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="type">char</span> ss[] = <span class="string">&quot;good game||&quot;</span>;</span><br><span class="line"><span class="type">char</span>* <span class="type">const</span> ptr = str;</span><br><span class="line"></span><br><span class="line">ptr[<span class="number">0</span>] = <span class="string">&#x27;s&#x27;</span>; <span class="comment">//正常</span></span><br><span class="line">ptr = ss;     <span class="comment">//报错</span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>📌const在*前值不变，const在*后地址不变<br>值得注意的是，有一种说法为const在前的属于<strong>底层const</strong>，而const在后的属于<strong>顶层const</strong><code>const int*</code>，<code>const int&amp;</code>这种属于底层const，使得值不可改；<code>int* const</code>属于顶层const，值可改</p>
</blockquote>
<h3 id="6-匿名函数（lambda表达式）"><a href="#6-匿名函数（lambda表达式）" class="headerlink" title="6 匿名函数（lambda表达式）"></a>6 匿名函数（lambda表达式）</h3><p>具体形式：<code>[capture](parameters)→return-type&#123;body&#125;</code></p>
<p>如最简单的形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[](<span class="type">int</span> x, <span class="type">int</span> y)-&gt;<span class="type">int</span> &#123;<span class="type">int</span> z=x+y; <span class="keyword">return</span> z;&#125;</span><br></pre></td></tr></table></figure>

<p>若想捕获外部变量，可在[ ]内输入外部参数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[]        <span class="comment">//未定义变量.试图在Lambda内使用任何外部变量都是错误的.</span></span><br><span class="line">[x, &amp;y]   <span class="comment">//x 按值捕获, y 按引用捕获.</span></span><br><span class="line">[&amp;]       <span class="comment">//用到的任何外部变量都隐式按引用捕获</span></span><br><span class="line">[=]       <span class="comment">//用到的任何外部变量都隐式按值捕获</span></span><br><span class="line">[&amp;, x]    <span class="comment">//x显式地按值捕获. 其它变量按引用捕获</span></span><br><span class="line">[=, &amp;z]   <span class="comment">//z按引用捕获. 其它变量按值捕获</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; some_list;</span><br><span class="line"><span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i) some_list.<span class="built_in">push_back</span>(i);</span><br><span class="line">std::for_each(<span class="built_in">begin</span>(some_list), <span class="built_in">end</span>(some_list), [&amp;total](<span class="type">int</span> x) </span><br><span class="line">&#123;</span><br><span class="line">    total += x;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>📌[ ]中想捕获this时，this只能按值捕获<code>[this]</code>。</p>
</blockquote>
<p>如果用户想把lambda表达式当作一个参数来传递，可以用auto关键字（转换成<code>std::function</code>对象）帮助存储：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">eval</span><span class="params">(std::function&lt;<span class="type">double</span>(<span class="type">double</span>)&gt; f, <span class="type">double</span> x = <span class="number">2.0</span>)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">f</span>(x);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     std::function&lt;<span class="type">double</span>(<span class="type">double</span>)&gt; f0    = [](<span class="type">double</span> x)&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;;</span><br><span class="line">     <span class="keyword">auto</span>                          f1    = [](<span class="type">double</span> x)&#123;<span class="keyword">return</span> x;&#125;;</span><br><span class="line">     <span class="keyword">decltype</span>(f0)                  fa[<span class="number">3</span>] = &#123;f0,f1,[](<span class="type">double</span> x)&#123;<span class="keyword">return</span> x*x;&#125;&#125;;</span><br><span class="line">     std::vector&lt;<span class="keyword">decltype</span>(f0)&gt;     fv    = &#123;f0,f1&#125;;</span><br><span class="line">     fv.<span class="built_in">push_back</span>                  ([](<span class="type">double</span> x)&#123;<span class="keyword">return</span> x*x;&#125;);</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;fv.<span class="built_in">size</span>();i++)  std::cout &lt;&lt; fv[i](<span class="number">2.0</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)          std::cout &lt;&lt; fa[i](<span class="number">2.0</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;f : fv)             std::cout &lt;&lt; <span class="built_in">f</span>(<span class="number">2.0</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;f : fa)             std::cout &lt;&lt; <span class="built_in">f</span>(<span class="number">2.0</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">     std::cout &lt;&lt; <span class="built_in">eval</span>(f0) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">     std::cout &lt;&lt; <span class="built_in">eval</span>(f1) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>📌- std::function&lt;double(double)&gt;里，括号外的double是返回类型，括号里的double是参数类型<br>- decltype()，C++11中的类型说明符，返回操作数的数据类型。</p>
</blockquote>
<blockquote>
<p>lambda表达式其实是一种闭包。</p>
</blockquote>
<h4 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h4><ul>
<li><p>修饰类内成员</p>
<p>前面说到，被const修饰的常成员函数，不会修改对象的任何属性。但是没有提到一种情况，那就是该属性由mutable修饰。mutable的作用是：可以在常成员函数中被修改其值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; m_data++ &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="type">int</span> m_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修饰匿名函数</p>
<p>当[]中采用值捕获时，是不允许在匿名函数内部修改捕获的变量的值的。但是如果有mutable修饰匿名函数，则在捕获时会创建该变量在匿名函数中的<strong>同名拷贝</strong>，而且该拷贝会一直存在，直到匿名函数作用域完结。此时，匿名函数内部可以对该“变量”（实质上是拷贝）进行修改，同时不必担心原变量被修改。而且每次进入相同的匿名函数时，该拷贝都会维持上一次调用该函数时的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> t = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//按值捕获</span></span><br><span class="line">  <span class="keyword">auto</span> f = [t]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ++t;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">auto</span> f2 = [t]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ++t;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="built_in">f</span>() &lt;&lt; endl;   <span class="comment">//11</span></span><br><span class="line">  cout &lt;&lt; <span class="built_in">f2</span>() &lt;&lt; endl;  <span class="comment">//11</span></span><br><span class="line">  cout &lt;&lt; <span class="built_in">f</span>() &lt;&lt; endl;   <span class="comment">//12</span></span><br><span class="line">  cout &lt;&lt; <span class="built_in">f2</span>() &lt;&lt; endl;  <span class="comment">//12</span></span><br><span class="line">  cout &lt;&lt; t &lt;&lt;endl;      <span class="comment">//10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-函数指针"><a href="#7-函数指针" class="headerlink" title="7 函数指针"></a>7 函数指针</h3><p>函数指针指向的是函数而非对象，其指向的函数的类型，仅由其返回值类型和形参类型决定，与函数名无关。比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>定义了一个函数<code>lengthCompare</code>，其类型为<code>bool(const string&amp;, const string&amp;)</code>。可以声明一个指针pf：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> (*pf)(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>📌*pf两端的括号<strong>必不可少</strong>。如果不写这对括号，表示一个函数，返回bool*类型的返回值</p>
</blockquote>
<p>这是一个指向<code>bool(const string&amp;, const string&amp;)</code>类型函数的<strong>函数指针</strong>，因此可以有</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pf = lengthCompare;                          <span class="comment">//pf指向lengthCompare函数</span></span><br><span class="line">pf = &amp;lengthCompare;                         <span class="comment">//等价的赋值语句：取地址符是可选的</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> b1 = <span class="built_in">pf</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;goodbye&quot;</span>);            <span class="comment">//调用lengthCompare函数</span></span><br><span class="line"><span class="type">bool</span> b2 = (*pf)(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;goodbye&quot;</span>);         <span class="comment">//一个等价的调用</span></span><br><span class="line"><span class="type">bool</span> b3 = <span class="built_in">lengthCompare</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;goodbye&quot;</span>); <span class="comment">//另一个等价的调用</span></span><br></pre></td></tr></table></figure>

<h4 id="重载函数的指针"><a href="#重载函数的指针" class="headerlink" title="重载函数的指针"></a>重载函数的指针</h4><p>如果指针指向一个函数，这个函数的函数名被很多函数共享，即出现重载，那么编译器需要通过指针类型决定选用哪个函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">(<span class="type">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> (*pf1)(<span class="type">unsigned</span> <span class="type">int</span>) = ff; <span class="comment">//pf1指向ff(unsigned)</span></span><br><span class="line"><span class="built_in">void</span> (*pf2)(<span class="type">int</span>) = ff;          <span class="comment">//错误，没有可以匹配的重载（参数角度）</span></span><br><span class="line"><span class="built_in">double</span> (*pf3)(<span class="type">int</span>*) = ff;       <span class="comment">//错误，没有可以匹配的重载（返回类型角度）</span></span><br></pre></td></tr></table></figure>

<p>可以看出，相比于一般的重载（只看形参，不看返回值），函数指针在重载的选择上要苛刻一些，既考虑了形参，又要考虑返回值类型。</p>
<h4 id="函数指针形参"><a href="#函数指针形参" class="headerlink" title="函数指针形参"></a>函数指针形参</h4><p>C++“表面上”是可以把“函数类型”作为形参传入一个函数的，即：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第三个形参是函数类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">bool</span> pf(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;))</span></span>;</span><br></pre></td></tr></table></figure>

<p>实际上，编译器偷偷地做了一个隐式转换，将所谓的函数类型给解释成了函数指针问题，即转换成了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">bool</span> (*pf)(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;))</span></span>;</span><br></pre></td></tr></table></figure>

<p>此时可以直接把函数名作为实参传入，它会被<strong>自动转换成指针</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">useBigger</span>(s1, s2, lengthCompare);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>利用类型别名和decltype简化函数指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ---- 函数类型别名 ---- */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="type">bool</span> <span class="title">Func</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;)</span></span>; <span class="comment">//定义Func为bool(const string&amp;, const string&amp;)类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> Func2</span>;           <span class="comment">//定义Func2为与lengthCompare类型一致的函数类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ---- 函数指针别名 ---- */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span><span class="params">(*FuncP)</span> <span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;)</span></span>; <span class="comment">//定义FuncP为函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> *FuncP2</span>;             <span class="comment">//decltype返回的是类型，所以要加上*才能使FuncP2指针</span></span><br></pre></td></tr></table></figure>

<p>那么在使用的时候，就可以使用下面这几种等价写法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;, Func)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;, Func2)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;, FuncP)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;, FuncP2)</span></span>;</span><br></pre></td></tr></table></figure>

<p>第1、2条语句中，编译器自动将Func、Func2类型转换成函数指针</p>
</li>
</ul>
<h4 id="返回指向函数的指针"><a href="#返回指向函数的指针" class="headerlink" title="返回指向函数的指针"></a>返回指向函数的指针</h4><p>函数不能作为另一个函数的返回值，但是函数可以返回函数指针，以达到类似效果。然而，返回值不再像形参一样，编译器不再对返回值进行自动的隐式转换，因此<strong>返回值需要显式声明为函数指针类型</strong>。而简化这种显式声明的方式仍然是别名：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> F = <span class="built_in">int</span>(<span class="type">int</span>*, <span class="type">int</span>);      <span class="comment">//F是函数类型，不是指针</span></span><br><span class="line"><span class="keyword">using</span> PF = <span class="built_in">int</span>(*)(<span class="type">int</span>*, <span class="type">int</span>);  <span class="comment">//PF是指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;                    <span class="comment">//正确：PF是指向函数的指针，f1返回指向函数的指针</span></span><br><span class="line"><span class="function">F <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;                     <span class="comment">//错误：F是函数类型，f1不能返回一个函数</span></span><br><span class="line"><span class="function">F *<span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;                    <span class="comment">//正确：显式地指定返回类型是指向F类型函数的指针</span></span><br></pre></td></tr></table></figure>

<p>此外，还有一种奇技淫巧，可以用下面的形式声明f1：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> (*<span class="built_in">f1</span>(<span class="type">int</span>)) (<span class="type">int</span>*, <span class="type">int</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">需要按照由内向外的顺序解读此代码：f1有形参列表，所以它是函数，f1前面有*，所以f1返回一个指针；</span></span><br><span class="line"><span class="comment">进一步观察发现，指针的类型本身也包含形参列表，因此指针指向函数，该函数的返回值类型是int</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>Modern C++中，也可以用尾置返回类型的方式，声明一个返回函数指针的函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> -&gt; <span class="title">int</span><span class="params">(*)</span><span class="params">(<span class="type">int</span>*, <span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="8-常用关键字"><a href="#8-常用关键字" class="headerlink" title="8 常用关键字"></a>8 常用关键字</h3><h4 id="四种cast（转换）"><a href="#四种cast（转换）" class="headerlink" title="四种cast（转换）"></a>四种cast（转换）</h4><ul>
<li><p>const_cast</p>
<p>用于将const变量转化为非const。</p>
</li>
<li><p>static_cast</p>
<p>用于各种<strong>隐式转换</strong>，比如非const转const，void*转指针等，<code>static_cast</code>能用于多态向上转化，如果向下转，不管是否非法，都会直接转而无视潜在的问题，因此不安全。</p>
</li>
<li><p>dynamic_cast</p>
<p>用于动态类型转换。<strong>只能用于含有虚函数的类</strong>，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果转化的是指针，且是非法的，返回NULL；如果转化的是引用，且是非法的，则抛出异常（相比于static_cast更安全）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我是父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tfather</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;father&#x27;s f()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我是子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tson</span> : <span class="keyword">public</span> Tfather</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;son&#x27;s f()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> data; <span class="comment">// 我是子类独有成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Tfather father;</span><br><span class="line">Tson son;</span><br><span class="line">son.data = <span class="number">123</span>;</span><br><span class="line">Tfather* pf;</span><br><span class="line">Tson* ps;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上行转换：没有问题，多态有效 */</span></span><br><span class="line">ps = &amp;son;</span><br><span class="line">pf = <span class="built_in">dynamic_cast</span>&lt;Tfather *&gt;(ps);</span><br></pre></td></tr></table></figure>
</li>
<li><p>reinterpret_cast</p>
<p>几乎什么都可以转，比如将int转为指针，可能会出问题，尽量少用。</p>
</li>
</ul>
<blockquote>
<p>📌为什么不使用C的强制转换？<br>C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。</p>
</blockquote>
<blockquote>
<p><strong>隐式转换</strong>的四种方式：<br>1. <strong>算术表达式</strong><br>int m&#x3D;10; double n&#x3D;m;                            &#x2F;&#x2F;n&#x3D;10.0，隐式把m转为double类型<br>2. <strong>赋值</strong><br>int* p &#x3D; NULL;                                          &#x2F;&#x2F;NULL(0)隐式转换为int*类型的空指针值<br>3. <strong>函数入参</strong><br>float add(float f); add(2);                         &#x2F;&#x2F;2隐式转换为float类型<br>4. <strong>函数返回值</strong><br>double minus(int a, int b) { return a-b; } &#x2F;&#x2F;返回值隐式转换为double类型</p>
</blockquote>
<h4 id="static作用"><a href="#static作用" class="headerlink" title="static作用"></a>static作用</h4><ul>
<li><p>static作用在全局变量</p>
<p>加了static之后，变量只在当前文件有效</p>
</li>
<li><p>static作用在类成员变量</p>
<p>static成员变量可以实现多个对象之间的数据共享，<strong>静态数据成员只存储一处</strong>，供所有对象共用</p>
</li>
<li><p>static作用在全局函数</p>
<p><strong>在定义该函数的文件内才能使用</strong>。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static</p>
<p>如果想要其他文件可以引用本地函数，则要在函数定义时使用关键字extern，表示该函数是外部函数，可供其他文件调用</p>
</li>
<li><p>static作用在类成员函数</p>
<p><strong>由于static修饰的类成员属于类，不属于对象</strong>，<strong>因此static类成员函数是没有this指针的</strong>，正因为没有this指针，<strong>所以static类成员函数不能访问非static的类成员，只能访问 static修饰的类成员</strong></p>
<blockquote>
<p>📌<strong>phread_create参数必须是static的，因为非static会自动加一个this指针，导致传入参数和函数不匹配</strong></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>📌C++是否允许同时用const和static修饰一个成员函数呢？<br>答案是不可以，C++编译器在实现const的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数const this *。但当一个成员为static的时候，该函数是没有this指针的。也就是说此时const的用法和static是冲突的。</p>
<p>同理，virtual和static也不能一起用，virtual也有一个隐含参数this指针。</p>
</blockquote>
<h3 id="9-再看函数重载"><a href="#9-再看函数重载" class="headerlink" title="9 再看函数重载"></a>9 再看函数重载</h3><p>函数重载<strong>取决于参数的类型、个数，而跟返回类型无关</strong>。编译器通过在<strong>编译时对函数重新命名</strong>以解决同名冲突。</p>
<p>对于普通函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Print an integer: &quot;</span> &lt;&lt; i &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Print a string: &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行<code>objdump -d a.out &gt;log.txt</code>反汇编，可以将编译结果打印到log.txt中进行分析。分析可知：</p>
<p><code>void print(int i)</code>→**_Z5printi**</p>
<p><code>void print(String s)</code>→**_Z5printSs**</p>
<p>其中Z5表示返回值类型，i表示int类型,Ss表示String类型（g++编译结果，vs的方案可能会有出入）</p>
<p>对于类内的函数重载：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;char&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>反汇编后，可知两个函数被映射为：</p>
<p><code>void print(int i)</code>→**_ZN4test5printEi**</p>
<p><code>void print(char c)</code>→**_ZN4test5printEc**</p>
<p>N4test表示作用域。</p>
<p>由以上可知，g++对函数重载的映射机制为：<strong>作用域 + 返回类型 + 函数名 + 参数列表</strong></p>
<p>虽然返回值类型也参与了函数重载的映射机制，但是编译器处理函数重载时并不考虑返回值类型，这样可使函数调用时独立于上下文，而且减少很多麻烦，如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">sqrt</span><span class="params">(<span class="type">float</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">sqrt</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">double</span> da, <span class="type">float</span> fla)</span></span>&#123;</span><br><span class="line">  <span class="type">float</span> fl = <span class="built_in">sqrt</span>(da);   <span class="comment">// 调用sqrt(double)</span></span><br><span class="line">  <span class="type">double</span> d = <span class="built_in">sqrt</span>(da);   <span class="comment">// 调用sqrt(double)</span></span><br><span class="line"></span><br><span class="line">  fl = <span class="built_in">sqrt</span>(fla); <span class="comment">//调用sqrt(float)</span></span><br><span class="line">  d = <span class="built_in">sqrt</span>(fla);  <span class="comment">//调用sqrt(float)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数重载时的匹配优先级"><a href="#函数重载时的匹配优先级" class="headerlink" title="函数重载时的匹配优先级"></a>函数重载时的匹配优先级</h4><blockquote>
<p>C++ Primer 6.6节</p>
</blockquote>
<p>C++编译器力图找最佳匹配。为了确定最佳匹配，编译器将实参类型向形参类型的转换划分为几个等级，具体排序如下：</p>
<ol>
<li><p>精确匹配，包括以下情况</p>
<ul>
<li><p>实参类型和形参类型相同</p>
</li>
<li><p>实参从数组类型或函数类型转换为对应的指针类型</p>
<ul>
<li><p>数组类型转指针：在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ia[<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span>* ip = ia;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数类型转指针：当把一个函数名传入函数时，编译器会隐式将其转换为函数指针类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string&amp; s1, <span class="type">const</span> string&amp; s2,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">bool</span> (*pf)(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">useBigger</span>(s1, s2, lengthCompare);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>向实参添加顶层const或从实参删除顶层const</p>
<p>可以理解为，顶层const不影响参数，因此下面的两个函数，是相同的参数类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>* <span class="type">const</span> a)</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>* b)</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当程序中有两个这样的函数，编译时会报错，因为发生了歧义，编译器不知道应该选择哪个函数。</p>
</li>
</ul>
</li>
<li><p>通过const转换实现的匹配</p>
<p>特指底层const转换，一般是非const转换成const形参</p>
</li>
<li><p>通过类型提升实现的匹配</p>
<ul>
<li><p>对于bool, char, signed char, unsigned char, short, unsigned short等类型，只要所有可能的值都能存在int里，它们就会被提升为int；否则，提升为unsigned int。</p>
</li>
<li><p>较大的char类型（wchar_t, char16_t, char32_t）提升成int, unsigned int, long, unsigned long, long long, unsigned long long中最小的一种类型，前提是转换后的类型能容纳原类型所有可能的值。</p>
</li>
</ul>
</li>
<li><p>通过算术类型转换和指针转换实现的匹配</p>
<ul>
<li><p>算术类型转换就是不同数值类型间的相互转换，如int,short,double之类，但不再局限于类型提升，double也可隐式转为int，也能匹配到。</p>
</li>
<li><p>指针转换：</p>
<ol>
<li><p>常量整数值0或者字面值nullptr能转换成任意指针类型</p>
</li>
<li><p>指向任意非常量的指针能转换成void*</p>
</li>
<li><p>指向任意对象的指针能转换成const void*</p>
</li>
<li><p>继承关系：编译器会隐式地执行派生类到基类的转换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Bulk_quote继承自Quote</span></span><br><span class="line">Quote item;</span><br><span class="line">Bulk_quote bulk;</span><br><span class="line">Quote *p = &amp;item;</span><br><span class="line">p = &amp;bulk;</span><br><span class="line">Quote &amp;r = bulk;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>算术类型&#x2F;指针类型自动转换成bool类型</p>
<p>存在一种从算术类型或指针类型向布尔类型自动转换的机制。如果指针或算术类型的值为0，转换结果为false；否则转换结果是true。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* cp = <span class="built_in">get_string</span>();</span><br><span class="line"><span class="keyword">if</span>(cp)    <span class="comment">/*...*/</span>   <span class="comment">//如果指针cp不是0，条件为真</span></span><br><span class="line"><span class="keyword">while</span>(*cp) <span class="comment">/*...*/</span>   <span class="comment">//如果*cp不是空字符，条件为真</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>通过类类型转换实现的匹配：见“类”章。</p>
<p>类类型转换的一个例子就是，char*转换成string类型</p>
</li>
</ol>
<p>考虑这样一个场景</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Employee* <span class="title">findEmployee</span><span class="params">(<span class="type">const</span> std::string&amp; surname, <span class="type">const</span> std::string&amp; givenName, <span class="type">bool</span> retired=<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="function">Employee* <span class="title">findEmployee</span><span class="params">(<span class="type">const</span> std::string&amp; fullName, <span class="type">bool</span> retired = <span class="literal">false</span>)</span></span></span><br><span class="line"><span class="function">Employee* e </span>= <span class="built_in">findEmployee</span>(<span class="string">&quot;Chen&quot;</span>, <span class="string">&quot;Shuo&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>一般可能认为，执行第3行时，会调用第1行对应的函数。实则不然，实际情况下会调用第2行对应的函数。这就涉及上面所说的优先级问题。”chen”这种字符串字面量，作为参数时，是const char*类型，两种重载都没有考虑const char*，因此需要进行隐式转换。从const char*转换为string，是一个类类型转换，而从const char*转换为bool，是一个指针类型转换，后者优先级高于前者，因此会调用第2行对应的函数重载。</p>
<h4 id="引入模板的重载"><a href="#引入模板的重载" class="headerlink" title="引入模板的重载"></a>引入模板的重载</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T a)</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="number">3</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">foo</span>(<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后会输出3，也就是使用了有模板的foo函数重载。因为编译器力图精确匹配，而T可以被推断为double&#x2F;float类型，比int更精确，所以会使用有模板的foo函数重载。</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="10-类"><a href="#10-类" class="headerlink" title="10 类"></a>10 类</h3><blockquote>
<p>C++中的类可大致分为三种：具体类、抽象类和类层次漫游中的类。大部分类可归为这三种之一，或某种的简单变形，或某几种的组合。</p>
</blockquote>
<ul>
<li><p><strong>具体类：</strong></p>
<p>具体类可以有与内置类型相似的行为，同时为了提高灵活性，还可以把成员变量的主体部分放在自由存储中（动态内存、堆）。一个经典的用户自定义类型是complex：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span>&#123;</span><br><span class="line">  <span class="type">double</span> re,im;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">complex</span>(<span class="type">double</span> r, <span class="type">double</span> i): re&#123;r&#125;, im&#123;i&#125;&#123;&#125;</span><br><span class="line">  <span class="built_in">complex</span>(<span class="type">double</span> r): re&#123;r&#125;, im&#123;<span class="number">0</span>&#125;&#123;&#125;</span><br><span class="line">  <span class="built_in">complex</span>(): re&#123;<span class="number">0</span>&#125;, im&#123;<span class="number">0</span>&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">real</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> re;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">real</span><span class="params">(<span class="type">double</span> d)</span> </span>&#123;re = d;&#125;</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">imag</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> im;&#125;                     <span class="comment">//const 常量函数，函数不会改变所调用的对象</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">imag</span><span class="params">(<span class="type">double</span> d)</span> </span>&#123;im = d;&#125;</span><br><span class="line"></span><br><span class="line">  complex&amp; <span class="keyword">operator</span>+=(complex z)&#123;re+=z.re, im+=z.im; <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">  complex&amp; <span class="keyword">operator</span>-=(complex z)&#123;re-=z.re, im-=z.im; <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line"></span><br><span class="line">  complex&amp; <span class="keyword">operator</span>*=(complex);<span class="comment">//在类外的某处进行定义</span></span><br><span class="line">  complex&amp; <span class="keyword">operator</span>/=(complex);<span class="comment">//在类外的某处进行定义</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//很多函数并不需要访问complex的成员变量，因此其定义可以与类的定义分离开来</span></span><br><span class="line">complex <span class="keyword">operator</span>+(complex a, complex b)&#123; <span class="keyword">return</span> a += b; &#125;</span><br><span class="line">complex <span class="keyword">operator</span>-(complex a, complex b)&#123; <span class="keyword">return</span> a -= b; &#125;</span><br><span class="line">complex <span class="keyword">operator</span>-(complex a)&#123; <span class="keyword">return</span> &#123;-a.<span class="built_in">real</span>(), -a.<span class="built_in">imag</span>()&#125;; &#125;</span><br><span class="line">complex <span class="keyword">operator</span>*(complex a, complex b)&#123; <span class="keyword">return</span> a *= b; &#125;</span><br><span class="line">complex <span class="keyword">operator</span>/(complex a, complex b)&#123; <span class="keyword">return</span> a /= b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==()&#123;</span><br><span class="line">  <span class="keyword">return</span> a.<span class="built_in">real</span>() == b.<span class="built_in">real</span>() &amp;&amp; a.<span class="built_in">imag</span>() == b.<span class="built_in">imag</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=()&#123;</span><br><span class="line">  <span class="keyword">return</span> !(a==b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>complex必须足够高效，否则专门定义一个类没有意义，因此简单的操作必须设置成内联的。</p>
<blockquote>
<p>📌定义在类里面的函数默认是内联的，也可以在声明前加上inline关键字显式指定。</p>
</blockquote>
<ul>
<li><p>当给自定义类型使用运算符重载时，应该尊重其常规使用习惯：</p>
<ul>
<li><p>比如不能定义一元运算符&#x2F;，因为其语法在语言中已固定；</p>
</li>
<li><p>也不能改变内置类型的运算符的含义，如不能重新定义+执行int的减法</p>
</li>
</ul>
</li>
<li><p>数据句柄模型(handle-to-data model)：</p>
<blockquote>
<p>构造函数负责为元素分配空间并正确初始化成员，析构函数负责释放空间。</p>
</blockquote>
<p>这也是<strong>资源获取即初始化(Resource Acquisition Is Initialization, RAII)</strong> 技术，可以防止在普通代码中利用“裸new”和“裸delete”分配内存，而是将分配操作隐藏在行为良好的抽象的实现内部，规避资源泄露的潜在风险。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">double</span>* elem; <span class="comment">//elem指向含有sz个double型元素的数组</span></span><br><span class="line">  <span class="type">int</span> sz;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Vector</span>(<span class="type">int</span> s): elem&#123;<span class="keyword">new</span> <span class="type">double</span>[s]&#125;,sz&#123;s&#125; &#123;   <span class="comment">// 构造函数，获取资源</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i!=s;++i)</span><br><span class="line">      elem[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Vector</span>()&#123;<span class="keyword">delete</span>[] elem;&#125;                    <span class="comment">// 析构函数，释放资源</span></span><br><span class="line"></span><br><span class="line">  <span class="type">double</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> i);</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的构造函数，先建立了一定数目的存储，然后给存储中的各个元素赋值，用户使用时再向其中填值。这不是很好的初始化方法。更简洁的途径是;</p>
<ul>
<li><p>利用元素列表进行初始化：</p>
<p>先重载一个构造函数<code>Vector(std::initializer_list&lt;double&gt;)</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Vector::<span class="built_in">Vector</span>(std::initializer_list&lt;<span class="type">double</span>&gt; lst):</span><br><span class="line">  elem&#123;<span class="keyword">new</span> <span class="type">double</span>[lst.<span class="built_in">size</span>()]&#125;, sz&#123;<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(lst.<span class="built_in">size</span>())&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">copy</span>(lst.<span class="built_in">begin</span>(), lst.<span class="built_in">end</span>(), elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::initializer_list</code>是一种标准库类型，使用{1,2,3,4}列表时，编译器会创建一个该类型的对象。</p>
<p><code>static_cast</code>负责强制类型转换，旨在避免特别严重的错误。</p>
<p>因此此时可以采用初始值列表来做初始化：<code>Vector v1 = &#123;1,2,3,4,5&#125;;</code></p>
</li>
<li><p>push_back()：在序列的末尾添加一个元素，容器长度加1.</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>抽象类：</strong></p>
<p>抽象类的作用更类似于提供一个接口，将使用者与类的实现细节完全隔离开来。如设计一个比Vector更抽象的Container类：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> <span class="type">double</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span>) = <span class="number">0</span>;<span class="comment">//纯虚函数</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;       <span class="comment">//常量成员函数</span></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Container</span>()[]              <span class="comment">//析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">(Container&amp; c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> sz = c.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i!=sz;++i)</span><br><span class="line">    cout&lt;&lt;c[i]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>virtual</code>关键字声明虚函数（可能在派生类中被重新定义），<code>=0</code>表示虚函数是纯虚函数，即Container的派生类必须定义这个函数。抽象类中不需要自行定义构造函数，因为不需要初始化数据，而且析构函数也是虚函数。</p>
<blockquote>
<p>📌抽象类应放弃包含局部成员。</p>
</blockquote>
<p><strong>多态模型</strong>：<code>use()</code>完全忽视Container的实现细节，而使用Container接口。这种为其他类型提供接口的类，一般称为多态模型(polymorphic type)。use函数可以使用所有派生自Container的有这样接口的派生类。</p>
<ul>
<li><p>派生类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vector_container</span>: <span class="keyword">public</span> Container&#123;      <span class="comment">//:public表示继承关系</span></span><br><span class="line">  Vector v;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Vector_container</span>(<span class="type">int</span> s): <span class="built_in">v</span>(s) &#123;&#125;</span><br><span class="line">  ~<span class="built_in">Vector_container</span>() &#123;&#125;</span><br><span class="line">  <span class="type">double</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> i) &#123; <span class="keyword">return</span> v[i]; &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> v.<span class="built_in">size</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Vector_container vc &#123;<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="built_in">use</span>(vc);                                      <span class="comment">//使用多态模型，可以直接使用所有派生类</span></span><br></pre></td></tr></table></figure>

<p>需要注意：使用多态模型会带来灵活性，但是必须通过引用或指针操作对象！</p>
<p>这里的<code>~Vector_container()</code>隐式调用了<code>~Vector()</code></p>
</li>
<li><p>虚函数的编译器实现：</p>
<p><img src="/image/image_6jwbJcI4f8.png"></p>
<p>当使用Vector_container作为Container对象时，use将必须使用Vector_container的operator[]()，而其他派生类则会使用那些派生类实现的operator[]()。因此Container的对象必须包含一些信息，使得运行时能够选择正确的虚函数实现。</p>
<p>做法如上图，编译器将虚函数名字转换成虚函数表(virtual function table, vtbl)，每个含有虚函数的类都有自己的vtbl用于辨识虚函数，从而确保对象被正确使用。调用Container对象时只需要知道vtbl指针位置和各虚函数索引即可。</p>
<blockquote>
<p>📌这种方式，会使虚函数的调用多一些开销，如每个类都需要一个vtbl，并且保留其指针。但是函数调用的效率还是非常接近“普通函数调用”的（相差不超过25%）。</p>
</blockquote>
</li>
<li><p>派生类的构造函数：</p>
<p>考虑这样的基类和派生类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quote</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Quote</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">Quote</span>(<span class="type">const</span> std::string &amp;book, <span class="type">double</span> sales_price):</span><br><span class="line">    <span class="built_in">bookNo</span>(book), <span class="built_in">price</span>(sales_price) &#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string bookNo;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">double</span> price = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span> : <span class="keyword">public</span> Quote&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Bulk_quote</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">Bulk_quote</span>(<span class="type">const</span> std::string &amp;book, <span class="type">double</span> p, std::<span class="type">size_t</span> qty, <span class="type">double</span> disc);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::<span class="type">size_t</span> min_qty = <span class="number">0</span>;</span><br><span class="line">  <span class="type">double</span> discount = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>派生类对象中含有从基类继承的成员，但是派生类并不能直接初始化这些成员。<strong>派生类必须使用基类的构造函数来初始化它的基类部分</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Bulk_quote::<span class="built_in">Bulk_quote</span>(<span class="type">const</span> std::string&amp; book, <span class="type">double</span> p, std::<span class="type">size_t</span> qty, <span class="type">double</span> disc)</span><br><span class="line">  : <span class="built_in">Quote</span>(book, p), <span class="built_in">min_qty</span>(qty), <span class="built_in">discount</span>(disc) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这是由C++实例化对象时的内存分配导致的，一个派生类对象包含多个组成部分：一个含有派生类自己定义成员（对应minqty和discount）的子对象，以及一个基类对应的子对象（子对象中包含）。如果有多个基类，那么这样的子对象也有多个。因此在利用构造函数实例化派生类的对象时，也必须调用基类的构造函数，实例化子对象。</p>
</li>
</ul>
<!---->

<ul>
<li><strong>类层次漫游：</strong></li>
</ul>
<blockquote>
<p>类层次就是结构就是，一个子类继承一个基类，另一个子类继承相同的基类，一个子子类继承子类等等</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Point <span class="title">center</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">move</span><span class="params">(Point to)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> angle)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">shape</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>: <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Circle</span>(Point p, <span class="type">int</span> rr);</span><br><span class="line"></span><br><span class="line">  <span class="function">Point <span class="title">center</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(Point to)</span> </span>&#123; x=to; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span>)</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Point x;</span><br><span class="line">  <span class="type">int</span> r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Smiley</span>: <span class="keyword">public</span> Circle &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Smiley</span>(Point p, <span class="type">int</span> r) : Circle&#123;p,r&#125;, mouth&#123;<span class="literal">nullptr</span>&#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Smiley</span>()&#123;</span><br><span class="line">    <span class="keyword">delete</span> mouth;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p:eyes)</span><br><span class="line">      <span class="keyword">delete</span> p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(Point to)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add_eye</span><span class="params">(Shape* s)</span></span>&#123;eyes.<span class="built_in">push_back</span>(s);&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set_mouth</span><span class="params">(Shape* s)</span></span>;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  vector&lt;Shape*&gt; eyes;</span><br><span class="line">  Shape* mouth;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Smiley::draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Circle::<span class="built_in">draw</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> p:eyes)</span><br><span class="line">    p-&gt;<span class="built_in">draw</span>();</span><br><span class="line">  mouth-&gt;<span class="built_in">draw</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Smiley继承了Circle，Circle继承了Shape</p>
<ul>
<li><p>对于抽象类来说，其派生类的对象通常是通过抽象基类的接口操纵的，所以基类中必须有一个虚析构函数。</p>
</li>
<li><p><code>rotate_all</code>可以调用任何Shape的派生类，如Smiley，这体现了<strong>接口继承</strong>的益处，即：派生类可以用在任何需要基类对象的地方。</p>
</li>
<li><p>Smiley可以使用Circle的构造函数和<code>Circle::draw()</code>，这体现了<strong>实现继承</strong>的益处，即：基类可以提供简化派生类实现的函数或数据。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate_all</span><span class="params">(vector&lt;Shape*&gt;&amp; v, <span class="type">int</span> angle)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> p:v)</span><br><span class="line">    p-&gt;<span class="built_in">rotate</span>(angle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&amp;#x20;    - 当某个函数需要使用特定派生类的成员函数时，可以使用<code>dynamic_cast</code>运算符询问类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Shape* <span class="title">ps</span><span class="params">(read_shape(cin))</span></span>; <span class="comment">//根据cin指定的类型生成特定派生类的Shape</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Smiley* p = <span class="built_in">dynamic_cast</span>&lt;Smiley*&gt;(ps)) &#123; <span class="comment">//或者引用: if(Smiley&amp; p = dynamic_cast&lt;Smiley&amp;&gt;(*ps))</span></span><br><span class="line">  <span class="comment">//...指针p所指的对象类型是Smiley</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">//...指针p所指的对象类型不是Smiley，执行其他操作...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>当不能直接使用候选的派生类时，可以用引用替代，用于<code>dynamic_cast</code></p>
</li>
<li><p>若<code>dynamic_cast</code>的参数(ps)与期望类型(Smiley)不符时，则会返回<code>nullptr</code>。</p>
</li>
</ul>
<blockquote>
<p>📌private、public、protected：<br>- 访问范围的差异：<br>private：只能由该类中的函数、其友元函数访问，不能被任何其他访问，该类的对象也不能访问；<br>protected：可以被该类中的函数、子类的函数、以及其友元函数访问，但不能被该类的对象访问；<br>public：可以被该类中的函数、子类的函数、其友元函数访问，也可以由该类的对象访问。<br>- 继承后的方法属性变化：<br>使用private继承，父类的所有方法在子类中变为private；<br>使用protected继承，父类的protected和public方法在子类中变为protected，private方法不变；<br>使用public继承，父类中的方法属性不发生改变。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关于子类访问父类的private成员：</span></span><br><span class="line"><span class="comment">//×！编译器报错</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">set_x</span><span class="params">()</span></span>&#123;x = <span class="number">10</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set_x</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;x = <span class="number">10</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关于子类访问父类的protected成员：</span></span><br><span class="line"><span class="comment">//√！编译器不报错</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">set_x</span><span class="params">()</span></span>&#123;x = <span class="number">10</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set_x</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;x = <span class="number">10</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>📌explicit关键字：<br>声明为explicit的构造函数不能在隐式转换中使用。<br>当类构造函数<strong>只有一个参数或除了第一个参数外其余参数都有默认值时</strong>，则此类有隐含的类型转换操作符（隐式转换），但有时隐式转换并不是我们想要的，可在构造函数前加上关键字explicit，来指定显式调用。<br>class Demo{<br>&amp;#x20;  public:<br>&amp;#x20;      explicit Demo(double a);<br>};<br>由于构造函数使用了explicit关键字，因此调用它时无法进行隐式转换，即Demo test; test&#x3D;12.2; 是无效的！<br>然而，此时可以进行显式转换<br>Demo test;<br>test &#x3D; Demo(12.2); 或者<br>test &#x3D; (Demo)12.2;</p>
</blockquote>
<h4 id="override、final、default、delete"><a href="#override、final、default、delete" class="headerlink" title="override、final、default、delete"></a>override、final、default、delete</h4><ul>
<li><p>override</p>
<p>有virtual就允许多态，即允许继承基类的子类重新virtual的方法。然而存在两种情况：</p>
<ol>
<li><p>子类并不想重写基类的函数，只是碰巧写的新函数与基类中的某一个方法重名了；</p>
</li>
<li><p>子类想重写基类的函数，但是把函数名写错了，此时编译器将该函数判定为新函数，不会报错，但运行时可能会出很多问题。</p>
</li>
</ol>
<p>针对以上场景，C++11引入了<code>override</code>关键字，以起到标记作用。override表示，此成员函数就是要重写基类的同名函数，而且函数签名一致。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : A&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而以下两种情况会导致编译器报错：原函数不存在，以及重新函数的函数签名不一致。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原函数不存在（函数名写错了）                     //函数签名不一致（返回值写错了）                   </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : A&#123;                                  <span class="keyword">class</span> <span class="title class_">B</span> : A&#123;</span><br><span class="line"><span class="keyword">protected</span>:                                    <span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">funa</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> d)</span></span>&#123;                      <span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">  &#125;                                             &#125;</span><br><span class="line">&#125;;                                            &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>final</p>
<p>有一种情况，类A继承了一个基类，但是类A不希望被其他类所继承。或者说类A重写了基类的虚函数，但当类A被继承时，不再希望这个虚函数被重写。</p>
<blockquote>
<p>值得一提的是，没有final时虚函数会传递，只要基类有virtual，即使类A重写时对这个函数不加virtual，类B继承类A时也能重写该函数，该函数仍然是一个虚函数。</p>
</blockquote>
<ul>
<li><p>final修饰类：不能再被继承</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> <span class="keyword">final</span>&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时不能再继承Base类，下述代码会编译期报错</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : Base&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>final修饰虚函数，虚函数不能再被重写（注：final只能修饰虚函数，不能修饰其他成员函数）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">final</span></span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : Base&#123;</span><br><span class="line">  <span class="comment">//此时不能再重写func方法，下述代码会编译期报错</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>=default</p>
<p>当手动写了一个<strong>有参数</strong>的构造&#x2F;析构函数时，编译器会把默认的构造&#x2F;析构函数优化掉，即<strong>不生成那些默认无参数</strong>的构造&#x2F;析构函数。如果想要保留这些默认函数，使得编译器能够生成默认函数从而保留无参数时的行为，可以用<code>=default</code></p>
<ul>
<li><p>报错场景：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">int</span> i)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  A a;      <span class="comment">//可以编译通过，但是会运行时报错，因为已经没有无参数的构造函数了，A a这句又没传参数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不报错场景：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">int</span> i)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  A a;      <span class="comment">//运行时不会出错，因为默认无参数的构造函数得到了保留</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>=delete</p>
<p><code>=delete</code>与<code>=default</code>的作用相反，它会禁用掉类中的某个成员函数。比如不想要默认的构造函数、析构函数、拷贝构造函数或operator&#x3D;，可以用<code>=delete</code>禁用掉。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">test</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">test</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">test</span>(<span class="type">const</span> test&amp; a) = <span class="keyword">delete</span>;</span><br><span class="line">    test&amp; <span class="keyword">operator</span>=(<span class="type">const</span> test&amp; a) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="菱形继承与虚继承"><a href="#菱形继承与虚继承" class="headerlink" title="菱形继承与虚继承"></a>菱形继承与虚继承</h4><p><img src="/image/image_OQknyX-tPz.png"></p>
<p>菱形继承的情况如图所示，B和C都继承了A，也就都继承了cnt属性。而D同时继承了B和C，此时D的对象内部将会有两份cnt，存在二义性。此时若要让D的对象访问或修改cnt属性，会因二义性（编译器不知道应该使用哪个cnt）使得编译器报错。</p>
<p>D:</p>
<p>&amp;#x20;  - B: cnt</p>
<p>&amp;#x20;  - C: cnt</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;           <span class="comment">//间接基类A</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A&#123; <span class="comment">//直接基类B</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> cnt_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">public</span> A&#123; <span class="comment">//直接基类C</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> cnt_c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123; <span class="comment">//派生类D</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set_a</span><span class="params">(<span class="type">int</span> i)</span></span>&#123; cnt = i; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set_b</span><span class="params">(<span class="type">int</span> i)</span></span>&#123; cnt_b = i; &#125; </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set_c</span><span class="params">(<span class="type">int</span> i)</span></span>&#123; cnt_c = i; &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  D d;</span><br><span class="line">  d.<span class="built_in">set_a</span>(<span class="number">3</span>);  <span class="comment">//报错！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决菱形继承的二义性问题，一种方式是直接使用::B或::C，强制编译器使用来自某个基类的属性。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;           <span class="comment">//间接基类A</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A&#123; <span class="comment">//直接基类B</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> cnt_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">public</span> A&#123; <span class="comment">//直接基类C</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> cnt_c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123; <span class="comment">//派生类D</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  D d;</span><br><span class="line">  d.B::cnt = <span class="number">3</span>; <span class="comment">//强制指定使用哪个基类的cnt属性，规避二义性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的方案不能根治菱形继承的问题，因为属性在类D中本就应该只有一个。更有效方案是利用<strong>虚继承</strong>。虚继承会使得派生类中只保留一份来自间接基类的属性，有效防止二义性问题。此时的间接基类A，被称为虚基类。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;                     <span class="comment">//间接基类A</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;   <span class="comment">//虚继承，直接基类B</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> cnt_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;   <span class="comment">//虚继承，直接基类C</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> cnt_c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123; <span class="comment">//派生类D</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set_a</span><span class="params">(<span class="type">int</span> i)</span></span>&#123; cnt = i; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set_b</span><span class="params">(<span class="type">int</span> i)</span></span>&#123; cnt_b = i; &#125; </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set_c</span><span class="params">(<span class="type">int</span> i)</span></span>&#123; cnt_c = i; &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  D d;</span><br><span class="line">  d.<span class="built_in">set_a</span>(<span class="number">3</span>);  <span class="comment">//正确！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标准库中也有利用虚继承解决菱形继承问题的案例。如iostream类同时继承了istream类和ostream类，而istream和ostream都继承了base_ios类。此时istream和ostream必须虚继承base_ios，否则会导致iostream类中包含两份来自base_ios的属性，导致二义性。</p>
<h4 id="RAII：资源获取即初始化"><a href="#RAII：资源获取即初始化" class="headerlink" title="RAII：资源获取即初始化"></a>RAII：资源获取即初始化</h4><blockquote>
<p>Resource Acquisition is Initialization</p>
</blockquote>
<p>RAII主要利用<strong>对象离开作用域会自动调用析构函数</strong>的特性，在设计一个类时，于构造函数申请资源，在析构函数释放资源，即可避免内存泄露问题，并将程序员从内存管理的泥潭中释放出来。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CTest</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CTest</span>()&#123;</span><br><span class="line">    m_pInt = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">CTest</span>()&#123;</span><br><span class="line">    <span class="keyword">if</span>( m_pInt != <span class="literal">nullptr</span> )</span><br><span class="line">      <span class="keyword">delete</span> m_pInt;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span>* m_pInt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="对象隐式销毁"><a href="#对象隐式销毁" class="headerlink" title="对象隐式销毁"></a>对象隐式销毁</h4><p>考虑这样的函数，<code>user()</code>函数在退出前会delete掉所有的Shape，<code>delete</code>运算符依赖于Shape的析构函数，而该函数是虚函数，所以<code>delete</code>会调用最终的派生类的析构函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">user</span><span class="params">()</span></span>&#123;</span><br><span class="line">  std::vector&lt;Shape*&gt; v;</span><br><span class="line">  <span class="keyword">while</span>(cin)</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">read_shape</span>(cin));</span><br><span class="line">  <span class="built_in">draw_all</span>(v);</span><br><span class="line">  <span class="built_in">rotate_all</span>(v,<span class="number">45</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> p : v)    <span class="comment">//最后删除元素</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是“显式”地销毁对象。然而若对所有函数都执行这样的显式操作的话，可能总有漏网之鱼。解决方案便是“隐式”对象销毁，让编译器自己来做delete操作。</p>
<p>对象若要隐式销毁，需要避免“裸指针”，而是尽量用智能指针<code>unique_ptr</code>，此时可以修改代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Kind</span> &#123; Circle, triangle, smiley &#125;;</span><br><span class="line"><span class="function">unique_ptr&lt;Shape&gt; <span class="title">read_shape</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//...从is中读取描述信息，找到对应形状种类</span></span><br><span class="line">  <span class="keyword">switch</span>(k)&#123;</span><br><span class="line">    <span class="keyword">case</span> Kind::circle:</span><br><span class="line">      <span class="keyword">return</span> unique_ptr&lt;Shape&gt;&#123;<span class="keyword">new</span> Circle&#123;p,r&#125;&#125;;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">user</span><span class="params">()</span></span>&#123;</span><br><span class="line">  vector&lt;unique_ptr&lt;Shape&gt;&gt; v;</span><br><span class="line">  <span class="keyword">while</span>(cin)</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">read_shape</span>(cin));</span><br><span class="line">  <span class="built_in">draw_all</span>(v);</span><br><span class="line">  <span class="built_in">rotate_all</span>(v,<span class="number">45</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象由<code>unique_ptr</code>拥有，当对象离开作用域时，<code>unique_ptr</code>将释放掉所指的对象。</p>
<h4 id="友元函数-amp-友元类"><a href="#友元函数-amp-友元类" class="headerlink" title="友元函数&amp;友元类"></a>友元函数&amp;友元类</h4><ul>
<li><p>普通友元函数</p>
<p>突破类内成员访问权限的限制，使得外部的函数仍能访问到类内的私有成员。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">  ~<span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>; <span class="comment">//声明foo函数是类A的好朋友</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">  A aObj;</span><br><span class="line">  aObj.m_data = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>友元成员函数</p>
<p>令类B的成员函数有权限访问类A的私有成员。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">B</span>()&#123;&#125;;</span><br><span class="line">  ~<span class="built_in">B</span>()&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">  ~<span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">B::foo</span><span class="params">()</span></span>; <span class="comment">//声明类B的foo成员函数是类A的好朋友</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B::foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">  A aObj;</span><br><span class="line">  aObj.m_data = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>友元类</p>
<p>若类B是类A的友元类，那么类B的所有成员函数均能访问到类A的私有成员。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">B</span>()&#123;&#125;;</span><br><span class="line">  ~<span class="built_in">B</span>()&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">  ~<span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">  <span class="keyword">friend</span> B;          <span class="comment">//声明类B是类A的好朋友</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B::foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">  A aObj;</span><br><span class="line">  aObj.m_data = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><blockquote>
<p>可以重载的运算符：<br>+   -   *   &#x2F;   %   ^   &amp;   |   ~   !   &#x3D;   &lt;   &gt;  +&#x3D;  -&#x3D;  *&#x3D;  &#x2F;&#x3D;  %&#x3D;  ^&#x3D;  &amp;&#x3D;  |&#x3D;  &lt;&lt;  &gt;&gt;  &lt;&lt;&#x3D;  &gt;&gt;&#x3D;  &#x3D;&#x3D;  !&#x3D;  &lt;&#x3D;  &gt;&#x3D;<br>&amp;&amp;  ||  ++  –  []  ()  -&gt;  ,  new  new[]  delete  delete[]&amp;#x20;</p>
</blockquote>
<ul>
<li><p>一元运算符重载：++、–、-（负号）、!</p>
<p>一元运算符往往不需要传形参，传形参说明是后缀++或后缀–</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> i;</span><br><span class="line">    <span class="type">double</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">int</span> = <span class="number">0</span>, <span class="type">int</span> = <span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">    Complex <span class="keyword">operator</span> ++();<span class="comment">//前缀自增</span></span><br><span class="line">    Complex <span class="keyword">operator</span> ++(<span class="type">int</span>);<span class="comment">//后缀自增，参数需要加int</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex::<span class="built_in">Complex</span>(<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">    i = a;</span><br><span class="line">    j = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Complex::display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&#x27;+&#x27;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27;i&#x27;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complex Complex::<span class="keyword">operator</span> ++() &#123;</span><br><span class="line">    ++i;</span><br><span class="line">    ++j;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Complex Complex::<span class="keyword">operator</span> ++(<span class="type">int</span>) &#123;</span><br><span class="line">    Complex temp =*<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>二元运算符重载：+、-、 *、&#x2F;</p>
<p>this是左值，形参是右值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test_minus</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> val1, val2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">test_minus</span>(<span class="type">int</span> a, <span class="type">int</span> b): <span class="built_in">val1</span>(a), <span class="built_in">val2</span>(b) &#123;&#125;</span><br><span class="line">  test_minus <span class="keyword">operator</span>-(<span class="type">const</span> test_minus&amp; right)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">test_minus</span>(right.val1 - val1, right.val2 - val2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; val1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; val2 &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">test_minus <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">  <span class="function">test_minus <span class="title">b</span><span class="params">(<span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  test_minus c = a - b;</span><br><span class="line">  c.<span class="built_in">Print</span>();            <span class="comment">//输出 1 -3</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>还可以友元函数的方式重载：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test_minus</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> val1, val2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">test_minus</span>(<span class="type">int</span> a, <span class="type">int</span> b): <span class="built_in">val1</span>(a), <span class="built_in">val2</span>(b) &#123;&#125;</span><br><span class="line">  <span class="keyword">friend</span> test_minus <span class="keyword">operator</span>- (<span class="type">const</span> test_minus&amp;, <span class="type">const</span> test_minus&amp;); <span class="comment">//友元函数</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; val1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; val2 &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">test_minus <span class="keyword">operator</span>-(<span class="type">const</span> test_minus&amp; left, <span class="type">const</span> test_minus&amp; right)&#123;<span class="comment">//友元函数运算符重载</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">test_minus</span>(right.val1 - left.val1, right.val2 - left.val2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">test_minus <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">  <span class="function">test_minus <span class="title">b</span><span class="params">(<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  test_minus c = a-b;</span><br><span class="line">  c.<span class="built_in">Print</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>关系运算符重载：&lt;、&gt;、&lt;&#x3D;、&gt;&#x3D;、&#x3D;&#x3D;、!&#x3D;</p>
<p>和二元运算符一样，this是左值，形参是右值。可以在形参加上const以规避修改</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Distance</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> feet;</span><br><span class="line">    <span class="type">int</span> inches;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> Distance&amp; d)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span>(feet &lt; d.feet)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">if</span>(feet == d.feet &amp;&amp; inches &lt; d.inches)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>流运算符重载：&lt;&lt;、&gt;&gt;</p>
<p>见“I&#x2F;O流”章，需要注意区分一元运算符中的左移右移。</p>
</li>
<li><p>赋值运算符重载：&#x3D;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Distance</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="type">int</span> feet;             <span class="comment">// 0 到无穷</span></span><br><span class="line">      <span class="type">int</span> inches;           <span class="comment">// 0 到 12</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> Distance &amp;D )</span><br><span class="line">      &#123; </span><br><span class="line">         feet = D.feet;</span><br><span class="line">         inches = D.inches;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数调用运算符重载：()</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Distance</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="type">int</span> feet;             <span class="comment">// 0 到无穷</span></span><br><span class="line">      <span class="type">int</span> inches;           <span class="comment">// 0 到 12</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Distance</span>(<span class="type">int</span> f, <span class="type">int</span> i)&#123;</span><br><span class="line">         feet = f;</span><br><span class="line">         inches = i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 重载函数调用运算符</span></span><br><span class="line">      <span class="function">Distance <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         Distance D;</span><br><span class="line">         <span class="comment">// 进行随机计算</span></span><br><span class="line">         D.feet = a + c + <span class="number">10</span>;</span><br><span class="line">         D.inches = b + c + <span class="number">100</span> ;</span><br><span class="line">         <span class="keyword">return</span> D;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">Distance <span class="title">D1</span><span class="params">(<span class="number">11</span>, <span class="number">10</span>)</span>, D2</span>;</span><br><span class="line"></span><br><span class="line">   D2 = <span class="built_in">D1</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>); <span class="comment">// invoke operator()</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下标运算符重载：[]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> SIZE = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">safearay</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="type">int</span> arr[SIZE];</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">safearay</span>() </span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">register</span> <span class="type">int</span> i;</span><br><span class="line">         <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; SIZE; i++)</span><br><span class="line">         &#123;</span><br><span class="line">           arr[i] = i;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> i)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span>( i &gt;= SIZE )</span><br><span class="line">          &#123;</span><br><span class="line">              cout &lt;&lt; <span class="string">&quot;索引超过最大值&quot;</span> &lt;&lt;endl; </span><br><span class="line">              <span class="comment">// 返回第一个元素</span></span><br><span class="line">              <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> arr[i];</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   safearay A;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;A[2] 的值为 : &quot;</span> &lt;&lt; A[<span class="number">2</span>] &lt;&lt;endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;A[5] 的值为 : &quot;</span> &lt;&lt; A[<span class="number">5</span>]&lt;&lt;endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;A[12] 的值为 : &quot;</span> &lt;&lt; A[<span class="number">12</span>]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>📌C++的register关键字作用是，建议编译器使用CPU寄存器来存储变量，旨在提高访问变量的速度</p>
</blockquote>
</li>
<li><p>类成员访问运算符重载：-&gt; 和 解引用运算符：*</p>
</li>
</ul>
<p>成员访问-&gt;和解引用*的重载都只能由对象使用，而不能由指针使用，因此，出现<code>pointer-&gt;mem;</code>时，可能有两种情况：</p>
<ol>
<li><p>指针，原原本本的成员访问和解引用功能：mem就是指针指向的对象，所属类型的成员</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pointer-&gt;mem;</span><br><span class="line"><span class="comment">//等价于   (*pointer).mem;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对象，调用的重载的运算符：mem不一定是pointer所属类型的成员，可能是其它类型的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pointer.<span class="built_in">operator</span>()-&gt;mem;</span><br><span class="line"><span class="comment">//等价于   (pointer.operator*()).mem;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>重载时，一般要求解引用*重载，返回引用，要求成员访问-&gt;重载，返回指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test_arrow_1</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> val1, val2;</span><br><span class="line">  <span class="built_in">test_arrow_1</span>(<span class="type">int</span> a, <span class="type">int</span> b) : <span class="built_in">val1</span>(a), <span class="built_in">val2</span>(b) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; val1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; val2 &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test_arrow_2</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> val3, val4, val5;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  test_arrow_1* val6;</span><br><span class="line">  <span class="built_in">test_arrow_2</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d, <span class="type">int</span> e) </span><br><span class="line">    : <span class="built_in">val6</span>(<span class="keyword">new</span> <span class="built_in">test_arrow_1</span>(a,b)), <span class="built_in">val3</span>(c), <span class="built_in">val4</span>(d), <span class="built_in">val5</span>(e) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; val6-&gt;val1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; val6-&gt;val2 &lt;&lt; <span class="string">&#x27; &#x27;</span> </span><br><span class="line">         &lt;&lt; val3 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; val4 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; val5 &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  test_arrow_1&amp; <span class="keyword">operator</span>*() <span class="type">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*val6);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  test_arrow_1* <span class="keyword">operator</span>-&gt;() <span class="type">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val6;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">test_arrow_2 <span class="title">t1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">  t1-&gt;val1 = <span class="number">6</span>;</span><br><span class="line">  t1-&gt;<span class="built_in">Print1</span>();</span><br><span class="line">  t1.<span class="built_in">Print2</span>();</span><br><span class="line"></span><br><span class="line">  (*t1).val2 = <span class="number">7</span>;</span><br><span class="line">  t1.<span class="built_in">Print2</span>();</span><br><span class="line"></span><br><span class="line">  test_arrow_2* t2 = <span class="keyword">new</span> <span class="built_in">test_arrow_2</span>(<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">  t2-&gt;<span class="built_in">Print2</span>();</span><br><span class="line">  (*t2).<span class="built_in">Print2</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对象调用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">test_arrow_2 <span class="title">t1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">  t1-&gt;val1 = <span class="number">6</span>;</span><br><span class="line">  t1-&gt;<span class="built_in">Print1</span>();</span><br><span class="line">  t1.<span class="built_in">Print2</span>();</span><br><span class="line"></span><br><span class="line">  (*t1).val2 = <span class="number">7</span>;</span><br><span class="line">  t1.<span class="built_in">Print2</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>t1是重载了*和-&gt;的对象，而不是指针，因此，当t1调用*t1和t1-&gt;时，会使用重载的运算符函数。</p>
<p>因此t1-&gt;可以使用属于<code>test_arrow_1</code>类的属性和方法，</p>
<p>(*t1)也可以使用属于改类的属性和方法。而“点运算符”仍然只能使用<code>test_arrow_2</code>类的。</p>
<ul>
<li>指针调用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">test_arrow_2* t2 = &amp;t1;</span><br><span class="line">t2-&gt;<span class="built_in">Print2</span>();</span><br><span class="line">(*t2).<span class="built_in">Print2</span>();</span><br></pre></td></tr></table></figure>

<p>t2是指针，因此调用*和-&gt;时，不能再调用重载的运算符函数，而是和平时的操作无异。因此t2-&gt;只能使用<code>test_arrow_2</code>的属性和方法，而且(*t2)也只能使用<code>test_arrow_2</code>的。</p>
<p>值得注意的是，解引用运算符 *，可以自定义任何逻辑，上面的代码中，也可以让解引用的重载返回一个int常数。</p>
<p>但是成员访问运算符无论怎么改，都<strong>必须保留成员访问的功能</strong>，虽然可能不再是当前类的成员了。</p>
<blockquote>
<p>📌取地址符&amp;也可以重载，但一般不需要手动重载，类会默认生成&amp;和&amp; const</p>
</blockquote>
<h4 id="类类型转换（特殊运算符重载）"><a href="#类类型转换（特殊运算符重载）" class="headerlink" title="类类型转换（特殊运算符重载）"></a>类类型转换（特殊运算符重载）</h4><p><strong>类型转换运算符</strong>，负责将一个类的类型转换成其他类型：<code>operator type() const;</code>，由于其通常不应该改变待转换对象的内容，因此，一般被定义为const成员。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmallInt</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">SmallInt</span>(<span class="type">int</span> i = <span class="number">0</span>):<span class="built_in">val</span>(i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt; <span class="number">255</span>)</span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Bad SmallInt value&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123;&#125;;          <span class="comment">//类型转换运算符</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::<span class="type">size_t</span> val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里SmallInt类中定义了向int类型的转换符，因此，可以显式&#x2F;<strong>隐式</strong>的将SmallInt对象转换成int类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SmallInt si;</span><br><span class="line">si = <span class="number">4</span>; <span class="comment">// 首先将4隐式转换成SmallInt，然后调用SmallInt operator=</span></span><br><span class="line">si + <span class="number">3</span>; <span class="comment">// 首先将si隐式转换成int，然后执行整数的加法</span></span><br></pre></td></tr></table></figure>

<p>除此之外，如果转换后的类型又有其它内置转换方案，实际情况中，也可以出现转换传递的情况。比如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SmallInt si = <span class="number">3.14</span>; <span class="comment">// 调用SmallInt(int)构造函数</span></span><br><span class="line">si + <span class="number">3.14</span>;          <span class="comment">// SmallInt类型转换成int，int又继续隐式转换成double</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>📌一个类型转换函数必须是类的成员函数。<br><strong>不能声明返回类型！</strong>（其名字就已说明返回）<br><strong>形参列表必须为空！****通常应该为const！</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmallInt</span>;</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">(SmallInt&amp;)</span></span>;            <span class="comment">//错,不是成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmallInt</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span></span>;         <span class="comment">//错,有返回类型</span></span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">(<span class="type">int</span>=<span class="number">0</span>)</span> <span class="type">const</span></span>;        <span class="comment">//错,有形参</span></span><br><span class="line">  <span class="keyword">operator</span> <span class="type">int</span>*() <span class="type">const</span> &#123;<span class="keyword">return</span> <span class="number">42</span>;&#125;<span class="comment">//错,42不是一个指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>老版本C++，类型转换运算符的不足：</p>
<p>早期版本C++中，类中定义一个向bool转换的类型转换运算符，是比较普遍的。比如经常用的<code>while(cin&gt;&gt;i)</code>就是cin中内置了一个operator bool( )。然而，这样会有意想不到的效果，比如下面的语句：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line">cin &lt;&lt; i;</span><br></pre></td></tr></table></figure>

<p>流运算符&lt;&lt;是cout特有的，istream本身没有定义&lt;&lt;，所以这段代码本应报错。然而，istream内置了bool类型转换，由此将cin转换成了bool，接着bool会被提升为int，后面的&lt;&lt;成为了左移运算符。因此，这段代码不会报错，还会出现与预期大相径庭的结果。</p>
</li>
<li><p>C++11带来的解决方案：<strong>显式的类型转换运算符</strong></p>
<p>为了防止上面现象的发生，C++引入了解决方案：explicit operator type()，即<strong>通过explicit关键字</strong>，<strong>要求显式转换</strong></p>
<p>比如下面代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmallInt</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">SmallInt</span>(<span class="type">int</span> i = <span class="number">0</span>):<span class="built_in">val</span>(i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt; <span class="number">255</span>)</span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Bad SmallInt value&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SmallInt si = <span class="number">3</span>;        <span class="comment">//正确：SmallInt的构造函数不是显式的</span></span><br><span class="line">si + <span class="number">3</span>;                 <span class="comment">//错误：此处需要隐式的类型转换，但类的运算符不是显式的</span></span><br><span class="line"><span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(si)+<span class="number">3</span>; <span class="comment">//正确：显式地请求类型转换</span></span><br></pre></td></tr></table></figure>

<p>这种规定还是有例外的，标准规定：如果表达式被用作了条件，则编译器会<strong>自动</strong>（即“隐式”）进行显式类型转换，</p>
<p>因此istream内部的bool()成为explicit的了，但是while(cin&gt;&gt;i)依然能用，因为是条件，会自动转成bool类型。</p>
<ul>
<li><p>成为条件的几个位置：</p>
<p>if, while, do…while, for</p>
<p>逻辑运算符<code>!, ||, &amp;&amp;</code></p>
<p>条件运算符<code>? :</code>&amp;#x20;</p>
</li>
</ul>
</li>
<li><p>类类型转换带来的二义性：（这里的类型转换不再局限于类型转换运算符，还包括构造函数）</p>
<p>有几种情况可能会带来二义性，出现二义性之后会编译报错，因为编译器不知道该使用哪种实现方式。</p>
<ol>
<li><p>两个类提供了“互相指向”的类型转换：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">const</span> B&amp;);           <span class="comment">//把一个B转换为A</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">A</span><span class="params">()</span> <span class="type">const</span></span>;    <span class="comment">//把一个A转换为B</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A <span class="title">f</span><span class="params">(<span class="type">const</span> A&amp;)</span></span>;           <span class="comment">//定义一个接收A的函数</span></span><br><span class="line">B b;</span><br><span class="line">A a = <span class="built_in">f</span>(b);              <span class="comment">//二义性错误：含义是 调用B中转换为A的类型转换运算符 f(b.operator A())</span></span><br><span class="line">                         <span class="comment">//             还是调用A中可以把B类型转换为A的构造函数 f(A(b))</span></span><br></pre></td></tr></table></figure>

<p>如果想执行上面的调用，必须显式地调用类型转换运算符或转换构造函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">A a1 = <span class="built_in">f</span>(b.<span class="keyword">operator</span> <span class="built_in">A</span>()); <span class="comment">//正确：使用B的类型转换运算符</span></span><br><span class="line">A a2 = <span class="built_in">f</span>(<span class="built_in">A</span>(b));           <span class="comment">//正确：使用A的构造函数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>类定义了多个转换规则：</p>
<p>最困扰的情况是类中定义了多个参数都是算术类型的构造函数，或者转换目标都是算术类型的类型转换运算符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">int</span> = <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">double</span> = <span class="number">0</span>);</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">long</span> <span class="type">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line"><span class="built_in">f2</span>(a);    <span class="comment">//二义性错误，不知道是 f(a.operator int()) 还是 f(a.operator double())</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> lg;</span><br><span class="line"><span class="function">A <span class="title">a2</span><span class="params">(lg)</span></span>; <span class="comment">//二义性错误，不知道是 A::A(int) 还是 A::A(double)</span></span><br></pre></td></tr></table></figure>

<p>f2的调用中，哪个类型转换都无法精确匹配long double，然而却都存在向long double的隐式转换（而且转换级别还一致）。因此出现了二义性。</p>
<blockquote>
<p>📌C++ primer中建议，<br>最好不要创建两个转换源都是算术类型的类型转换！<br>最好不要创建两个转换对象都是算术类型的类型转换！</p>
</blockquote>
<p>如果这种情况中，转换级别不一致，就不存在二义性问题。比如从short提升到int，级别高于long到double。</p>
</li>
<li><p>函数重载过程中，不同重载的形参，都定义了同一种类型转换运算符：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span>&#123;</span><br><span class="line">  <span class="built_in">C</span>(<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span>&#123;</span><br><span class="line">  <span class="built_in">D</span>(<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manip</span><span class="params">(<span class="type">const</span> C&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manip</span><span class="params">(<span class="type">const</span> D&amp;)</span></span>;</span><br><span class="line"><span class="built_in">manip</span>(<span class="number">10</span>);     <span class="comment">//二义性错误：含义是 manip(C(10)) 还是 manip(D(10))</span></span><br></pre></td></tr></table></figure>

<p>可以显式调用构造函数，以消除二义性：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">manip</span>(<span class="built_in">C</span>(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>

<p>但这种情况并没有结束，10可以精确匹配int，那么下面的代码是否就没有二义性了呢？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span>&#123;</span><br><span class="line">  <span class="built_in">C</span>(<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">  <span class="built_in">E</span>(<span class="type">double</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manip</span><span class="params">(<span class="type">const</span> C&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manip</span><span class="params">(<span class="type">const</span> E&amp;)</span></span>;</span><br><span class="line"><span class="built_in">manip</span>(<span class="number">10</span>);     <span class="comment">//二义性错误：含义是 manip(C(10)) 还是 manip(E(double(10)))</span></span><br></pre></td></tr></table></figure>

<p>还是会编译报错，还是会有二义性，这是因为在调用重载时，类类型转换都是最低级别的匹配度。即使int比double更能匹配10，但是现在不是int和double的比较，而是C(10)：int→C，和E(double(10))：int→E的比较，而二者是平级的。而且二者都是可行匹配。因此导致了二义性。</p>
</li>
</ol>
</li>
</ul>
<p>虽然，类型转换运算符可以在某些程度上简化操作，但还是要慎用，非常容易出现二义性问题！</p>
<h4 id="new-x2F-delete的重载"><a href="#new-x2F-delete的重载" class="headerlink" title="new&#x2F;delete的重载"></a>new&#x2F;delete的重载</h4><p>new operator&#x2F;delete operator就是new和delete操作符，而operator new&#x2F;operator delete是函数。 placement new是operator new的全局重载。</p>
<p>new运算分两阶段：（1）调用::operator new配置内存；（2）调用对象构造函数构造对象内容。</p>
<p>delete运算分为两个阶段：（1）调用对象析构函数；（2）调用::operator delete释放内存。</p>
<ul>
<li><p>operator new函数</p>
<p>默认的::operator new与malloc无明显区别。只分配所要求的空间，不调用相关对象的构造函数。当无法满足所要求分配的空间时，则：</p>
<p>→如果有<code>new_handler</code>，则调用其，否则</p>
<p>→如果允许抛出异常（即<code>nothrow</code>参数未被设置），则执行<code>bad_alloc</code>异常，否则</p>
<p>→返回0</p>
<p>需要注意的是，::operator new是可以被重载的，也就是说可以自定义operator new的行为</p>
<ul>
<li><p>operator new重载</p>
<p>重载时，返回类型必须声明为void*</p>
<p>重载时，第一个参数类型必须为表达要求分配空间的大小（字节），类型为size_t</p>
<p>重载时，可以带其它参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>() &#123; cout&lt;&lt;<span class="string">&quot;constructor of X&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line">    ~<span class="built_in">X</span>() &#123; cout&lt;&lt;<span class="string">&quot;destructor of X&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size,string str)</span>  <span class="comment">//重载::operator new</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;operator new size &quot;</span>&lt;&lt;size&lt;&lt;<span class="string">&quot; with string &quot;</span>&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pointee)</span>         <span class="comment">//重载::operator delete</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;operator delete&quot;</span>&lt;&lt;endl;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pointee)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X *px = <span class="built_in">new</span>(<span class="string">&quot;A new class&quot;</span>) X;</span><br><span class="line">    <span class="keyword">delete</span> px;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>缺省的operator new具有非常好的通用性，这也使得其在某些场合下牺牲了性能。针对性优化的operator new可以提升效率。</p>
</li>
<li><p>placement new函数</p>
<p>前面重载的operator new只能作为类内函数，无法全局使用。而placement new是一种全局的重载的operator new。</p>
<p>placement new的使用：</p>
<p>operator new会分配内存，但是placement new不分配。相反地，placement new的参数就是一个预先分配好的内存，而placement new会在其上构造对象。（placement new不接收size_t类型参数，即不接收待分配内存大小参数），函数返回值是对象的地址。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string* sp=<span class="built_in">static_cast</span>&lt;string*&gt;(::<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(string)));</span><br><span class="line">mystr = <span class="built_in">new</span> (sp) <span class="built_in">string</span>(<span class="string">&quot;hello world&quot;</span>); <span class="comment">//使用placement new构造对象</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>placement new的使用步骤：</p>
<ol>
<li><p>内存提前分配</p>
</li>
<li><p>调用placement new构造对象</p>
</li>
<li><p>使用对象<code>mystr</code></p>
</li>
<li><p>析构对象<code>mystr→~string();</code></p>
</li>
<li><p>释放内存：内存<code>sp</code>可以被反复使用，反复通过placement new分配给新的对象，但若不想使用该内存，可以用<code>delete [] buf;</code>释放它。</p>
</li>
</ol>
</li>
<li><p>为什么要有placement new：</p>
<ol>
<li><p>确实有要在预分配内存上创建对象的需求。比如硬件中有一个内存映射的IO计时器设备，想建立一个clock对象在那个内存位置，但用。</p>
</li>
<li><p>增大时空效率。使用new操作符需要在堆中查找足够大的剩余空间，这个操作速度较慢，而且可能出现无法分配内存的异常（空间不够）。placement new可以解决，预先分配好的内存确保不会出现内存不足的异常，同时也省下了查找可用内存的时间。</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>📌申请内存和释放内存的操作符需要配套使用，比如new和delete一起用，new[]和delete[]一起用。<br>int* ptr &#x3D; new int[10];<br>delete [] ptr;</p>
</blockquote>
<h4 id="拷贝和移动"><a href="#拷贝和移动" class="headerlink" title="拷贝和移动"></a>拷贝和移动</h4><ul>
<li><strong>拷贝构造</strong>：定义拷贝构造函数和拷贝赋值运算符&amp;#x20;</li>
</ul>
<blockquote>
<p>📌对于大容量的容器来说，拷贝过程可能耗费巨大。举例来说，<br>而事实上，我们并不真的想要一个副本，而是想将计算结果从函数中取出来，相比于<em>拷贝</em>，更希望的操作的<em>移动</em>。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/******* 声明一个Vector类 *******/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">double</span>* elem;</span><br><span class="line">  <span class="type">int</span> sz;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Vector</span>(<span class="type">int</span> s);                          <span class="comment">//构造函数：建议不变式，获取资源</span></span><br><span class="line">  ~<span class="built_in">Vector</span>() &#123; <span class="keyword">delete</span>[] elem; &#125;            <span class="comment">//析构函数：释放资源</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">Vector</span>(<span class="type">const</span> Vector&amp; a);                <span class="comment">//拷贝构造函数</span></span><br><span class="line">  Vector&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Vector&amp; a);     <span class="comment">//拷贝赋值运算符</span></span><br><span class="line"></span><br><span class="line">  <span class="type">double</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> i);</span><br><span class="line">  <span class="type">const</span> <span class="type">double</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/****拷贝构造函数****/</span></span><br><span class="line">Vector::<span class="built_in">Vector</span>(<span class="type">const</span> Vector&amp; a)</span><br><span class="line">  :elem&#123;<span class="keyword">new</span> <span class="type">double</span>[a.sz]&#125;,     <span class="comment">//为元素分配空间</span></span><br><span class="line">   sz&#123;a.sz&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i != sz; ++i) <span class="comment">//复制元素</span></span><br><span class="line">    elem[i] = a.elem[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是<strong>深拷贝</strong>。拷贝构造函数的输入参数是被拷贝的对象，也就是a &#x3D; b中右面的b。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/****拷贝赋值运算符****/</span></span><br><span class="line">Vector&amp; Vector::<span class="keyword">operator</span>=(<span class="type">const</span> Vector&amp; a)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">double</span>* p = <span class="keyword">new</span> <span class="type">double</span>[a.sz];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i != a.sz; ++i)</span><br><span class="line">    p[i]=a.elem[i];</span><br><span class="line">  <span class="keyword">delete</span>[] elem;       <span class="comment">//删除旧元素</span></span><br><span class="line">  elem = p;</span><br><span class="line">  sz = a.sz;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>深拷贝与浅拷贝：</strong></li>
</ul>
<p>如果类中的属性均为基本类型变量，全部在栈上分配，不涉及深&#x2F;浅拷贝问题。深拷贝与浅拷贝仅在，类中存在需要在堆上分配内存的属性时，才需要加以区分。考虑上面的Vector类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//拷贝构造函数：深拷贝</span></span><br><span class="line">Vector::<span class="built_in">Vector</span>(<span class="type">const</span> Vector&amp; a)</span><br><span class="line">  :elem&#123;<span class="keyword">new</span> <span class="type">double</span>[a.sz]&#125;,     <span class="comment">//为元素分配空间</span></span><br><span class="line">   sz&#123;a.sz&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i != sz; ++i) <span class="comment">//复制元素</span></span><br><span class="line">    elem[i] = a.elem[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//拷贝构造函数：浅拷贝</span></span><br><span class="line">Vector::<span class="built_in">Vector</span>(<span class="type">const</span> Vector&amp; a)</span><br><span class="line">  :elem&#123;a.elem&#125;,     <span class="comment">//不分配空间，直接赋值</span></span><br><span class="line">   sz&#123;a.sz&#125;</span><br><span class="line">&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>也就是构造的Vector对象的elem指针，直接指向&#x3D;右边的Vector对象的elem数组。</p>
<p>可以看出，深拷贝会重新开辟一片内存，并且对内存中的值逐个拷贝。而浅拷贝的话，不会开辟内存，对象的指针直接等于右值对象内的指针。换言之，深拷贝过程中，左值的堆内存和右值的堆内存是两片内存，而浅拷贝的话共同使用一片内存。</p>
<p><img src="/image/image__v58OY9wwk.png"></p>
<p>C++的默认拷贝构造函数<code>=default</code>采用的是<strong>浅拷贝</strong>方式。</p>
<p>但是，<strong>一般遇到有属性需要从堆内存分配时，应该自己手写深拷贝方式的拷贝构造函数</strong>。浅拷贝涉及这样多次析构的问题，考虑上面的Vector类，如果采用了浅拷贝的拷贝构造函数，禁用operator&#x3D;，main函数进行最基本的赋值操作时：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Vector <span class="title">lv</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    Vector rv = lv;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时程序会在运行时崩溃，崩溃在析构函数上。在执行return 0之前，作用域内有两个Vector变量：lv和rv，二者的elem指向了同一片内存elem。然而，执行return 0，离开作用域时，会调用两个变量的析构函数。假设先调用了lv的析构函数，那么lv的elem会在析构时释放内存，此时的elem成为了野指针。而在调用rv的析构函数时，还会delete [] elem，此时要delete一个野指针，就会导致程序崩溃。</p>
<p>由此可见，对象中涉及堆时，应该尽量手写深拷贝形式的拷贝构造函数。</p>
<blockquote>
<p>📌在C++标准中，NULL和nullptr都被认为是0，尤其nullptr指向的是0x0地址，可以重复delete。<br>因此，当一个对象被delete了，指针未归为nullptr，再调用该指针时会因野指针而使得程序崩溃。但如果delete后归为nullptr，再delete并不会出现问题。</p>
</blockquote>
<ul>
<li><p><strong>右值引用：</strong></p>
<p>通常写的引用<code>int a=0; int &amp;b=a;</code>，b是一个左值引用，它引用了一个左值a，但它不能引用右值，即<code>int &amp;b=0;</code>会报错。C++11之前，强行通过左值引用，引用一个右值的方式，只有一个，那就是常引用<code>const int&amp;b=0;</code>，但是如此并不能修改右值的值。</p>
<p>前面提到，浅拷贝比深拷贝效率更高（不用开辟新空间），但是存在重复析构的问题，那么是否可以通过下面的代码解决析构野指针的问题呢？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">demo</span>(demo &amp;d):<span class="built_in">num</span>(d.num)&#123;        <span class="comment">//拷贝构造函数，入参去掉const，让d可修改</span></span><br><span class="line">    d.num = <span class="literal">nullptr</span>;             <span class="comment">//修改原对象对应指针为空指针</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;copy construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不可以的，运行会报错。因为<code>num=d.num</code>表示<code>d.num</code>是右值，右值不可修改，但<code>d.num=nullptr</code>又让其成为可修改的左值，发生了冲突。</p>
<p>解决这个问题的方法，就是希望函数参数d是一个右值引用，右值引用的特定在于，既反映右值，又可以修改右值。</p>
<p>C++定义了<code>T&amp;&amp; param</code>这样语法，表示<code>param</code>是一个右值引用，其可以引用一个右值，那么<code>int &amp;&amp;b=0;</code>就可行了，而且可以通过b来修改右值。与此同时，C++11引入了<code>std::move()</code>函数，作用在于，不管输入的是左值还是右值，move出来的都是右值。</p>
<p>然而这样的语法，也不一定能保证引用到的必然是右值，以一个函数传参的例子进行说明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span>&amp; lvalue)</span>          <span class="comment">// 接收左值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;lvalue = &quot;</span> &lt;&lt; lvalue &lt;&lt; std::endl; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span>&amp;&amp; rvalue)</span>         <span class="comment">// 接收右值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rvalue = &quot;</span> &lt;&lt; rvalue &lt;&lt; std::endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(T&amp;&amp; param)</span>       <span class="comment">// 不能确保是右值引用，但是是万能引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>(param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">function</span>(x);               <span class="comment">// 左值</span></span><br><span class="line">    <span class="built_in">function</span>(std::<span class="built_in">move</span>(x));    <span class="comment">// 右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先看function函数，其明明标明入参应该是右值引用，为何还能通过<code>function(x)</code>传一个左值引用进去呢？</p>
<p>这是<strong>引用折叠</strong>的原因导致的：</p>
<p>虽然是<code>T&amp;&amp; param</code>，但若传进去一个<code>int&amp;</code>，实际相当于传入的类型为<code>int&amp; &amp;&amp;</code>，等价于<code>int&amp;</code>，即左值引用。《Effective Modern C++》的作者将这种，由引用折叠导致的，<strong>既可以表示右值引用，又可以表示左值引用的语法称为万能引用</strong>。</p>
<ul>
<li><p>引用折叠的规则：</p>
<table>
<thead>
<tr>
<th>first</th>
<th>second</th>
<th>result</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>&amp;</td>
<td>左值引用</td>
</tr>
<tr>
<td>&amp;</td>
<td>&amp;&amp;</td>
<td>左值引用</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>&amp;</td>
<td>左值引用</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>&amp;&amp;</td>
<td>右值引用</td>
</tr>
</tbody></table>
<p>即，只有两个引用均为右值引用时，才会折叠成右值引用。</p>
</li>
<li><p>万能引用的规律：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget&amp;&amp; var1 = <span class="built_in">Widget</span>();       <span class="comment">// rvalue reference</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = var1;             <span class="comment">// universal reference</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::vector&lt;T&gt;&amp;&amp; param)</span></span>; <span class="comment">// rvalue reference</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;              <span class="comment">// universal reference</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(T&amp;&amp; x)</span></span>;      <span class="comment">// rvalue reference</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果<code>T</code>不是模板参数，而是具体的类型，如上面的第一个例子Widget，<code>T&amp;&amp;</code>一定是右值引用。</p>
</li>
<li><p>如果<code>T</code>是模板参数，<code>T&amp;&amp;</code>一般情况下是通用引用。除了下面两种例外情况：</p>
</li>
<li><p>如果<code>T</code>是模板参数，但<code>param</code>的类型不直接是<code>T</code>，比如<code>std::vector&lt;T&gt;&amp;&amp;</code>，那么<code>std::vector&lt;T&gt;&amp;&amp;</code>是右值引用。</p>
</li>
<li><p>如果<code>T</code>是模板参数，但不需要自动推导，比如已经在类实例化的时候手动指定过了，那么<code>T&amp;&amp;</code>是右值引用。</p>
</li>
</ul>
</li>
</ul>
<p>但是，如果执行上面的代码，会发现输出结果为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">lvalue = 10</span><br><span class="line">lvalue = 10</span><br></pre></td></tr></table></figure>

<p>也就是，左值和右值都被判定为左值。这是因为右值引用接收的值既可以是左值，也可以是右值，存在这样一个对应关系：</p>
<table>
<thead>
<tr>
<th></th>
<th>左值引用</th>
<th>右值引用</th>
<th>非引用</th>
</tr>
</thead>
<tbody><tr>
<td>什么时候是左值</td>
<td>always</td>
<td>显式声明为变量时</td>
<td>显式声明为变量时</td>
</tr>
<tr>
<td>什么时候是右值</td>
<td>never</td>
<td>作为临时变量时</td>
<td>作为临时变量时</td>
</tr>
</tbody></table>
<p>虽然move函数强行使得第二个function函数传入右值，但是，function函数内部调用fun函数时，涉及传参，又把param显式化了。这样就使得param变为一个左值。</p>
<p>那么如何保留右值的特点，使得调用fun函数也传入右值呢，C++11同时提供了<strong>完美转发</strong><code>std::forward</code>特性。</p>
<p><code>std::forward</code>的返回值既可能是左值，也可能是右值，当传入参数是右值引用时，返回右值，否则就返回左值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收左值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span>&amp; lvalue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;lvalue = &quot;</span> &lt;&lt; lvalue &lt;&lt; std::endl; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接收右值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span>&amp;&amp; rvalue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rvalue = &quot;</span> &lt;&lt; rvalue &lt;&lt; std::endl; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 万能引用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(T&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//fun(param);</span></span><br><span class="line">    <span class="built_in">fun</span>(std::forward&lt;T&gt;(param)); <span class="comment">// 使用std::forward进行完美转发</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">function</span>(x);     <span class="comment">// 左值</span></span><br><span class="line">    <span class="built_in">function</span>(std::<span class="built_in">move</span>(x));    <span class="comment">// 右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再执行通过完美转发改进的程序，可以得到这样的输出结果：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">lvalue = 10</span><br><span class="line">rvalue = 10</span><br></pre></td></tr></table></figure>

<p>也就是，左值是左值的行为，右值是右值的行为，不再混乱，泾渭分明。</p>
<p>事实上，使用<code>std::forward</code>处理万能引用，也是官方推荐的开发方式！</p>
</li>
</ul>
<p>合理运用右值引用，达到提速效果的案例：</p>
<p>在做矩阵加法时，可以这样写，即入参是两个左值引用以避免拷贝</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Matrix <span class="keyword">operator</span>+(<span class="type">const</span> Matrix&amp; lhs, <span class="type">const</span> Matrix&amp; rhs) &#123;</span><br><span class="line">    Matrix sum = ...        <span class="comment">// Sum all elements in lhs and rhs here.</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这么做美中不足的地方在于，需要创建一个额外的Matrix对象。如果说，lhs和rhs有一个操作数可以是右值，也就是算完之后调用者不会再使用它，那便可以复用它的内存空间，不必创建新的Matrix对象，达到提高效率的目的。假设这个右值是lhs，那么便可以设置它为右值引用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Matrix <span class="keyword">operator</span>+(Matrix&amp;&amp; lhs, <span class="type">const</span> Matrix&amp; rhs) &#123;</span><br><span class="line">    lhs = ...               <span class="comment">// Sum all elements in lhs and rhs and assign to lhs.</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(lhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里要用<code>std::move</code>返回值，避免让lhs成为显式变量，成为左值（成为左值的话，会返回对象的拷贝构造）。此时的返回值变成了右值引用，编译器自动为右值调用移动构造函数。</p>
<p>那么进行矩阵加法便可以：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Matrix sum1 = m1 + m2;                  <span class="comment">// 调用第一种实现</span></span><br><span class="line">Matrix sum3 = std::<span class="built_in">move</span>(m1) + m2;       <span class="comment">// 调用第二种实现</span></span><br></pre></td></tr></table></figure>

<p><strong>一般不建议函数返回右值引用！</strong></p>
<blockquote>
<p>C++中的左右值：<br>- lvalue：通常可以放在等号左边的表达式，左值<br>- rvalue：通常只能放在等号右边的表达式，右值<br>- glvalue：generalized lvalue，广义左值<br>- xvalue：expiring lvalue，将亡值，也就是std::move(ptr1)的值<br>- prvalue：pure rvalue，纯右值<br>对于包含右值的内存位置来说，其本质就是：它虽然没有名称，但是可以从程序的其他部分访问到它。<br>而右值引用便可以用来表示这个本应没有名称的临时对象。</p>
<p>C++11之后编译器开始支持RVO(Return Value Optimization)技术，RVO可以把函数返回时创建的临时对象优化掉，达到少调用拷贝构造函数的目标。如果函数返回一个仅在函数内的局部变量，而且变量类型支持移动构造函数，比如：<br>std::vector&lt;int&gt; return_vector(void){<br>&amp;#x20;  std::vector&lt;int&gt; tmp {1,2,3,4,5};<br>&amp;#x20;  return tmp;<br>}<br>std::vector&lt;int&gt; rval_ref &#x3D; return_vector();<br>那么编译器发现tmp是局部变量，离开return_vector函数后就会死亡时，会把tmp当做将亡值（xvalue），编译器会为将亡值调用移动构造函数。</p>
</blockquote>
<p><img src="/image/image_M99Hn4BKd-.png"></p>
<ul>
<li><p><strong>移动构造：</strong></p>
<p>虽然深拷贝很稳定，使得出错的风险降低，但是带来了效率的牺牲。考虑下面的深拷贝构造函数代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">demo</span>():<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>))&#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">demo</span>(<span class="type">const</span> demo &amp;d):<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*(d.num)))&#123;  <span class="comment">//拷贝构造函数</span></span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;copy construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br><span class="line">   ~<span class="built_in">demo</span>()&#123;</span><br><span class="line">      <span class="keyword">delete</span> num;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;class destruct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="type">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">demo <span class="title">get_demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">demo</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    demo a = <span class="built_in">get_demo</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>g++ demo.cpp -o demo.exe -std=c++0x -fno-elide-constructors</code>命令禁用优化，看最原始情况的输出，有：</p>
<p><img src="/image/image_59GclcE4Cr.png"></p>
<ol>
<li><p>首先在get_demo里调用了构造函数</p>
</li>
<li><p>离开get_demo时，return语句对函数内创建的对象进行拷贝，从而提供返回值</p>
</li>
<li><p>执行完return后，离开作用域，之前函数内创建的对象销毁，但是拷贝的作为返回值来到了main</p>
</li>
<li><p>返回值被&#x3D;赋给了a，执行了拷贝构造（深拷贝，此时有两个demo对象）</p>
</li>
<li><p>return 0之后，离开作用域，调用析构函数销毁对象，由于两个对象都要销毁，因此调用了两次析构函数</p>
</li>
</ol>
<p>可以看出来，在第2步和第4步时执行了两次深拷贝，对于仅申请少量堆空间的临时对象来说，深拷贝的执行效率依旧可以接受，但如果临时对象中的指针成员申请了大量的堆空间，那么 2 次深拷贝操作势必会影响 a 对象初始化的执行效率。针对此，C++11引入了移动构造函数方案以避免深拷贝导致的效率问题。</p>
<p>移动构造函数与浅拷贝类似，但是区别在于：1. 参数要求是右值引用，而非左值引用；2. 函数内将原指针置为0</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加移动构造函数</span></span><br><span class="line"><span class="built_in">demo</span>(demo &amp;&amp;d):<span class="built_in">num</span>(d.num)&#123;</span><br><span class="line">    d.num = <span class="literal">NULL</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;move construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出来，上面的main在执行过程中，return返回和&#x3D;赋值，都是将右值赋给左值，因此对应上了移动构造函数中的右值引用。所以再执行代码时，将会通过两次移动替代两次拷贝：</p>
<p><img src="/image/image_w9TrPipfr5.png"></p>
<p>实际开发中，通常在类中自定义移动构造函数的同时，会再为其自定义一个适当的拷贝构造函数，由此当用户利用右值初始化类对象时，会调用移动构造函数；使用左值（非右值）初始化类对象时，会调用拷贝构造函数。</p>
<p><strong>但是</strong>，也可以完全用移动构造函数，也就是完全用右值引用，方法是采用<code>std::move()</code>函数，强行将左值转为右值。</p>
</li>
</ul>
<blockquote>
<p>📌C++定义类class A，类内包含的默认8个成员函数：<br>- 默认构造函数：                                   A();<br>- 默认拷贝构造函数：                            A(const A&amp;);<br>- 默认析构函数：                                   ~A();<br>- 默认重载赋值运算符：                         A&amp; operator &#x3D; (const A&amp;);<br>- 默认重载取址运算符：                         A* operator &amp; ();<br>- 默认const修饰的重载取址运算符：     const A* operator &amp; () const;<br>- （C++11）默认移动构造函数：          A(A&amp;&amp;);<br>- （C++11）默认重载移动赋值运算符：A&amp; operator &#x3D; (const A&amp;&amp;);</p>
<p>unique_ptr就是通过移动构造函数实现的所有权转移。unique_ptr类中只有移动构造函数，禁用拷贝构造。<br>移动构造函数还有一个典型案例就是，vector容器中的emplace_back函数采用移动构造，push_back函数采用拷贝构造，前者比后者高效很多。</p>
</blockquote>
<h4 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h4><p>智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，智能指针是一个类，当超出类的作用域时，会自动调用析构函数，析构函数会自动释放资源。因此<strong>智能指针在函数结束时自动释放内存空间，不需要手动释放</strong>（严格践行RAII）。而且智能指针重载了*和→操作符，使用起来和原始指针一样。不要试图delete智能指针。</p>
<ul>
<li><p>auto_ptr（已被C++11弃用）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">p1</span> <span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;I reigned lonely as a cloud&quot;</span>))</span></span>;</span><br><span class="line">auto_ptr&lt;string&gt; p2;</span><br><span class="line">p2 = p1; <span class="comment">//auto_ptr不会报错</span></span><br></pre></td></tr></table></figure>

<p>auto_ptr采用所用权模式。上述代码执行时不会报错，但p2剥夺了p1的所有权，当程序访问p1时将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃风险。</p>
</li>
<li><p>unique_ptr</p>
<p>unique_ptr实现独占式拥有，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露（如“new创建对象后因异常而忘记调用delete”）特别有用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> string (<span class="string">&quot;auto&quot;</span>))</span></span>;</span><br><span class="line">unique_ptr&lt;string&gt; p4;</span><br><span class="line">p4 = p3; <span class="comment">//报错！</span></span><br></pre></td></tr></table></figure>

<p>编译器认为p4&#x3D;p3非法，因此避免了p3不再指向有效数据，成为野指针的问题。因此unique_ptr比auto_ptr更为安全。</p>
<p>智能指针没有定义加减运算，<strong>不能随意移动指针地址</strong>，从而<strong>避免指针越界</strong>等危险操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ptr1++;   <span class="comment">//导致编译错误</span></span><br><span class="line">ptr2+=<span class="number">2</span>;  <span class="comment">//导致编译错误</span></span><br></pre></td></tr></table></figure>

<p>需要注意，使用智能指针也要避免未初始化的空指针问题。比如下面的代码会导致core dump：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unique_ptr ptr3;  <span class="comment">//未初始化智能指针</span></span><br><span class="line">*ptr3 = <span class="number">42</span>;       <span class="comment">//错误！操作了空指针</span></span><br></pre></td></tr></table></figure>

<p>为了避免这种低级错误，可以调用工厂函数**make_unique()**，强制要求创建指针的时候必须初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unique_ptr&lt;string&gt; ptr5;</span><br><span class="line">ptr5 = <span class="built_in">unique_ptr</span>&lt;string&gt;(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">&quot;You&quot;</span>)); <span class="comment">//不用工厂函数，而是构造函数，临时右值初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ptr3 = <span class="built_in">make_unique</span>(<span class="number">42</span>);                   <span class="comment">//工厂函数创建智能指针</span></span><br><span class="line"><span class="built_in">assert</span>(ptr3 &amp;&amp; *ptr3 == <span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ptr4 = <span class="built_in">make_unique</span>(<span class="string">&quot;god of war&quot;</span>);         <span class="comment">//工厂函数创建智能指针</span></span><br><span class="line"><span class="built_in">assert</span>(!ptr4-&gt;<span class="built_in">empty</span>());</span><br></pre></td></tr></table></figure>

<blockquote>
<p>📌make_unique()要求C++14，但是如果使用C++11，可以自己实现一个简化版的make_unqiue()</p>
<p>template&lt;typename T, typename… Ts&gt;                                                &#x2F;&#x2F;可变参数模板    &amp;#x20;<br>std::unique_ptr&lt;T&gt; make_unique(Ts&amp;&amp;… params)                             &#x2F;&#x2F;返回智能指针，入口参数<br>{<br>&amp;#x20;   return std::unique_ptr&lt;T&gt;(new T(std::foward&lt;Ts&gt;(params)…));   &#x2F;&#x2F;构造智能指针，完美转发<br>}</p>
<p>（标准库的工厂函数内部是有优化的，会比手写类型构造的效率更高）</p>
</blockquote>
<p>前面提到unique_ptr不允许直接进行“所有权”转移，这是因为其禁用了拷贝赋值，仅保留了移动构造和移动赋值。因此，若想要进行所有权转移，必须用<code>std::move</code>函数显式地声明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr1 = <span class="built_in">make_unique</span>(<span class="number">42</span>);   <span class="comment">//工厂函数创建智能指针</span></span><br><span class="line"><span class="built_in">assert</span>(ptr1 &amp;&amp; *ptr1 ==<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ptr2 = std::<span class="built_in">move</span>(ptr1);   <span class="comment">//使用move()转移所有权</span></span><br><span class="line"><span class="built_in">assert</span>(!ptr1 &amp;&amp; ptr2);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>get()和release()：</p>
<p>bar是一个智能指针，p是一个普通指针，<code>p=bar.get()</code>，bar并未被释放，此时相当于指针p和智能指针bar共同管理一个对象。也就是说，*p&#x3D;做的事情，会反映到bar指向的对象。</p>
<p>release()会释放当前指针对对象的所有权，其返回值用于新的指针（普通指针或智能指针）接管对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">                                           <span class="comment">// foo   bar    p</span></span><br><span class="line">                                           <span class="comment">// ---   ---   ---</span></span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; foo;                  <span class="comment">// null</span></span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; bar;                  <span class="comment">// null  null</span></span><br><span class="line"><span class="type">int</span>* p = <span class="literal">nullptr</span>;                          <span class="comment">// null  null  null</span></span><br><span class="line"></span><br><span class="line">foo = std::<span class="built_in">unique_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>));   <span class="comment">//  10   null  null</span></span><br><span class="line">bar = std::<span class="built_in">move</span>(foo);                      <span class="comment">// null   10   null</span></span><br><span class="line">p = bar.<span class="built_in">get</span>();                             <span class="comment">// null   10    10</span></span><br><span class="line">*p = <span class="number">20</span>;                                   <span class="comment">// null   20    20</span></span><br><span class="line">p = <span class="literal">nullptr</span>;                               <span class="comment">// null   20   null</span></span><br><span class="line"></span><br><span class="line">foo = std::<span class="built_in">unique_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">30</span>));   <span class="comment">//  30    20   null</span></span><br><span class="line">p = foo.<span class="built_in">release</span>();                         <span class="comment">// null   20    30</span></span><br><span class="line">*p = <span class="number">40</span>;                                   <span class="comment">// null   20    40</span></span><br></pre></td></tr></table></figure>

<p>此外还有reset()方法，不仅会释放所有权，还会释放对象，即释放内存。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> std::string(<span class="string">&quot;1&quot;</span>))</span></span>;</span><br><span class="line"><span class="function">std::unique_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(p1.release())</span></span>;    <span class="comment">//p1置空,p2接管</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;string&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> std::string(<span class="string">&quot;3&quot;</span>))</span></span>;</span><br><span class="line">p2.<span class="built_in">reset</span>(p3.<span class="built_in">release</span>());                      <span class="comment">//p2会释放原来指向的对象，接管p3原来的对象</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>shared_ptr</p>
<p>shared_ptr实现共享式拥有概念。多个智能指针指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时释放。采用计数机制表明资源被几个指针共享，可通过成员函数<code>use_count()</code>查看资源所得者个数。</p>
<ul>
<li><p>构造方式：</p>
<p>可通过new来构造，也可通过传入<code>auto_ptr</code>，<code>unique_ptr</code>，<code>weak_ptr</code>来构造，还可通过<code>std::make_shared</code>函数构造，如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sptr3</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sptr4 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>由于所有权是可以被安全共享的，所以允许拷贝赋值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">auto</span> ptr2 = ptr1;</span><br></pre></td></tr></table></figure>
</li>
<li><p>销毁方式：</p>
<p>对某个指针调用release()时，当前指针会释放资源所有权，计数减1。当计数等于0，资源被释放</p>
</li>
<li><p>关键成员函数：</p>
<p>use_count：返回引用计数的个数</p>
<p>unique：返回是否是独占所有权（use_count为1）</p>
<p>swap：交换两个shared_ptr对象</p>
<p>reset：放弃内部对象的所有权或拥有对象的变更，会引起原有对象的引用计数的减少</p>
<p>get：返回内部对象（指针），如<code>shared_ptr&lt;int&gt;sp (new int(1))</code>后，<code>sp</code>与<code>sp.get()</code>是等价的</p>
</li>
</ul>
</li>
<li><p>weak_ptr</p>
<p>weak_ptr指向由shared_ptr管理的对象，但不控制对象的生命周期。考虑这样一种情况，两个shared_ptr相互引用，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  shared_ptr&lt;B&gt; pb_;</span><br><span class="line">  ~<span class="built_in">A</span>()&#123; cout&lt;&lt;<span class="string">&quot;A delete\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  shared_ptr&lt;A&gt; pa_;</span><br><span class="line">  ~<span class="built_in">B</span>()&#123; cout&lt;&lt;<span class="string">&quot;B delete\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">shared_ptr&lt;B&gt; <span class="title">pb</span> <span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line"><span class="function">shared_ptr&lt;A&gt; <span class="title">pa</span> <span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">pb-&gt;pa_ = pa;</span><br><span class="line">pa-&gt;pb_ = pb;</span><br><span class="line">cout &lt;&lt; pb.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; pa.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>此时两个指针互相引用，形成了死锁，计数不可能下降为0（两个的计数都为2），资源永远不会释放。而weak_ptr旨在解决这一问题，weak_ptr不会引起计数的增加或减少，但可指向shared_ptr管理的对象，因此在例子中，两shared_ptr中的一个降级为weak_ptr即可解决死锁问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  weak_ptr&lt;B&gt; pb_;</span><br><span class="line">  ~<span class="built_in">A</span>()&#123; cout&lt;&lt;<span class="string">&quot;A delete\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>weak_ptr基本用法：</p>
<p>&amp;#x20;如果要使用weak_ptr指向的对象，首先要用expired成员函数检查对象是否存在且是否能引用，之后再用lock成员函数升格为shared_ptr，才能使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">3</span>))</span></span>;  <span class="comment">//strong ref = 1</span></span><br><span class="line">  std::shared_ptr&lt;<span class="type">int</span>&gt; sptr2 = sptr;      <span class="comment">//strong ref = 2</span></span><br><span class="line"></span><br><span class="line">  std::weak_ptr&lt;<span class="type">int</span>&gt; wptr = sptr;         <span class="comment">//strong ref = 2, weak ref = 1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!wptr.<span class="built_in">expired</span>())&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; sptr3 = wptr.<span class="built_in">lock</span>();<span class="comment">//strong ref = 3, weak ref = 1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，使用weak_ptr是有强弱引用计数的</p>
</li>
</ul>
</li>
<li><p>智能指针是否会有内存泄漏</p>
<p>当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，退出作用域时未能释放内存，从而导致内存泄露。</p>
</li>
<li><p>智能指针的内存泄露如何处理</p>
<p>为了解决循环引用导致的内存泄漏，引入了weak_ptr弱指针，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。</p>
</li>
</ul>
<h4 id="写时拷贝（COW-Copy-On-Write）"><a href="#写时拷贝（COW-Copy-On-Write）" class="headerlink" title="写时拷贝（COW, Copy On Write）"></a>写时拷贝（COW, Copy On Write）</h4><p>&amp;#x20;深拷贝和浅拷贝各有优劣，前者可以避免重复析构的问题，后者可以提高代码效率。写时拷贝即是融合了二者优点的改良方案，类似于shared_ptr。</p>
<p>其特点为：<strong>写之前→浅拷贝</strong>，多个对象可以指向一片内存；<strong>修改时→深拷贝</strong>，哪个对象要修改内存的值，就为其新开辟一块空间。当要释放掉某片内存时，只在<strong>最后一个对象销毁时</strong>释放该内存。</p>
<ul>
<li><p>如何知道当前析构的是否是最后一个对象？</p>
<p>利用计数器（<strong>引用计数</strong>），当新增了一个指向这片内存的对象时，该计数器加1，当销毁了一个指向这片内存的对象时，计数器减1。减到0时，说明在销毁最右一个对象，此时可以释放内存。</p>
<p>计数器位置的选取是此方案最重要的问题。</p>
<ul>
<li><p>引用计数作为成员变量？</p>
<p>难以做到多个对象之间的同步。</p>
</li>
<li><p>引用计数作为静态变量？</p>
<p>所有对象共享该引用计数，如果都指向了相同内存，可以达到计数目的。然而，如果出现了写操作，会导致问题。举例说明，类中有一个string指针属性，实例化对象时需要开辟内存。当前三个对象都指向”hello”字符串时，计数器会加到3，但是如果第四个对象指向了”world”字符串，那么第四个对象会将计数器置1。那么前三个对象的计数器也会被修改为1，从而无法释放掉”hello”字符串。</p>
</li>
<li><p><strong>引用计数放在堆内存中</strong>：</p>
<p>将引用计数变量放在堆内存中，是写时拷贝的惯用方案。当开辟内存时，多留4字节的裕量，将引用计数放在堆内存起始位置。之后再将类的属性（指针）指向堆内存起始位置+4。</p>
<p><img src="/image/image_pNRhIJgYeq.png"></p>
</li>
</ul>
</li>
</ul>
<p>以自定义一个CString类型为例：</p>
<ol>
<li><p>查看引用计数函数：</p>
<p>引用计数在堆内存中，需要查看或修改时，返回该内存的引用。因为堆内存开辟时是char类型，指针需强制转为int*</p>
<p>不应暴露出可以外部修改引用计数的接口，所以引用计数和查看函数均应是私有的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mptr是类CString中，指向堆内存的指针成员</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">getRefCount</span><span class="params">(<span class="type">char</span>* ptr)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">int</span>*)(ptr<span class="number">-4</span>);         <span class="comment">//ptr指向的是字符串，想查看引用计数需地址回退四个字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>释放内存函数：</p>
<p>释放内存涉及的问题是判断是否销毁到了指向这片内存的最后一个对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Release</span><span class="params">(<span class="type">char</span>* ptr)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(--<span class="built_in">getRefCount</span>(mptr) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] (mptr<span class="number">-4</span>);                <span class="comment">//释放内存的时候还要释放保存引用计数的四个字节</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数：</p>
<p>构造函数需从一个字符串常量构造，由于事先并无开辟的堆内存，所以需要开辟新内存，并将引用计数置1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CString</span>(<span class="type">char</span>* ptr=<span class="literal">NULL</span>) : <span class="built_in">mptr</span>(<span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(ptr) + <span class="number">1</span> + <span class="number">4</span>])&#123;     <span class="comment">//从字符串常量构造CString对象</span></span><br><span class="line">  mptr += <span class="number">4</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(mptr, ptr);</span><br><span class="line">  <span class="built_in">getRefCount</span>(mptr) = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>拷贝构造函数和重载赋值运算符：</p>
<p>拷贝构造函数用浅拷贝，同时给引用计数加1。</p>
<p>而赋值运算符需要注意的是，如果左值是原内存的最后一个对象，则需要销毁原内存（或者不是最后一个对象，要引用计数减1），再进行浅拷贝。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CString</span>(<span class="type">const</span> CString&amp; rhs):<span class="built_in">mptr</span>(rhs.mptr)&#123;</span><br><span class="line">  ++<span class="built_in">getRefCount</span>(mptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CString&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CString&amp; rhs)&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;rhs)&#123;</span><br><span class="line">    <span class="built_in">Release</span>(mptr);</span><br><span class="line">    mptr = rhs.mptr;</span><br><span class="line">    ++<span class="built_in">getRefCount</span>(mptr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重载[]运算符函数：</p>
<p>[ ]运算符涉及的问题是，CSting定义的对象str，往往是通过[ ]来修改值的，比如str[1]&#x3D;’a’。所以这里不应采用浅拷贝，而应是深拷贝。这也对应了<strong>写时拷贝</strong>的概念，即只有发生修改时，才用深拷贝。</p>
<p>但也不是所有情况下都必须用深拷贝，如果引用计数为1，说明只有一个对象独占资源，那么可以直接在原内存上进行修改，不需要深拷贝。如果引用计数大于1，说明多个对象共享堆内存，那么一个对象动了堆，其他对象也会跟着改变，但是其他对象本来的堆内存的值本就不应改变，这时需要采用深拷贝。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index)&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">getRefCount</span>(mptr) &gt; <span class="number">1</span>)&#123;                   <span class="comment">//判断引用计数是否大于1</span></span><br><span class="line">    <span class="type">char</span>* ptr = mptr;</span><br><span class="line">    mptr = <span class="keyword">new</span> <span class="built_in">char</span>(<span class="built_in">strlen</span>(mptr) + <span class="number">1</span> + <span class="number">4</span>);     <span class="comment">//深拷贝</span></span><br><span class="line">    --<span class="built_in">getRefCount</span>(ptr);</span><br><span class="line">    mptr += <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(mptr, ptr);</span><br><span class="line">    <span class="built_in">getRefCount</span>(mptr) = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mptr[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样写也存在问题，很多时候调用[ ]只希望访问值，而非修改，但访问时也采用了深拷贝，导致了效率的损失。<strong>这也是写时拷贝的缺点所在</strong>。</p>
</li>
</ol>
<ul>
<li><p>整体代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CString</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CString</span>(<span class="type">char</span>* ptr=<span class="literal">NULL</span>) : <span class="built_in">mptr</span>(<span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(ptr) + <span class="number">1</span> + <span class="number">4</span>])&#123;</span><br><span class="line">    mptr += <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(mptr, ptr);</span><br><span class="line">    <span class="built_in">getRefCount</span>(mptr) = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">CString</span>(<span class="type">const</span> CString&amp; rhs):<span class="built_in">mptr</span>(rhs.mptr)&#123;</span><br><span class="line">    ++<span class="built_in">getRefCount</span>(mptr);</span><br><span class="line">  &#125;</span><br><span class="line">  CString&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CString&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;rhs)&#123;</span><br><span class="line">      <span class="built_in">Release</span>(mptr);</span><br><span class="line">      mptr = rhs.mptr;</span><br><span class="line">      ++<span class="built_in">getRefCount</span>(mptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">getRefCount</span>(mptr) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">      <span class="type">char</span>* ptr = mptr;</span><br><span class="line">      mptr = <span class="keyword">new</span> <span class="built_in">char</span>(<span class="built_in">strlen</span>(mptr) + <span class="number">1</span> + <span class="number">4</span>);</span><br><span class="line">      --<span class="built_in">getRefCount</span>(ptr);</span><br><span class="line">      mptr += <span class="number">4</span>;</span><br><span class="line">      <span class="built_in">strcpy</span>(mptr, ptr);</span><br><span class="line">      <span class="built_in">getRefCount</span>(mptr) = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mptr[index];</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">CString</span>()&#123;</span><br><span class="line">    <span class="built_in">Release</span>(mptr);                      <span class="comment">//析构时调用释放内存函数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; mptr &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">char</span>* mptr;</span><br><span class="line">  <span class="function"><span class="type">int</span>&amp; <span class="title">getRefCount</span><span class="params">(<span class="type">char</span>* ptr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">int</span>*)(ptr<span class="number">-4</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Release</span><span class="params">(<span class="type">char</span>* ptr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(--<span class="built_in">getRefCount</span>(mptr) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">delete</span>[] (mptr<span class="number">-4</span>);                <span class="comment">//释放内存的时候还要释放保存引用计数的四个字节</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">CString <span class="title">str1</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;<span class="comment">//构造</span></span><br><span class="line">  <span class="function">Cstring <span class="title">str2</span><span class="params">(str1)</span></span>;<span class="comment">//拷贝构造</span></span><br><span class="line">  <span class="function">CString <span class="title">str3</span><span class="params">(<span class="string">&quot;world&quot;</span>)</span></span>;<span class="comment">//构造</span></span><br><span class="line">  str1 = str3;</span><br><span class="line">  str1[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  str1.<span class="built_in">Print</span>();</span><br><span class="line">  str2.<span class="built_in">Print</span>();</span><br><span class="line">  str3.<span class="built_in">Print</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p>aorld</p>
<p>hellow</p>
<p>world</p>
</li>
</ul>
<h3 id="11-模板"><a href="#11-模板" class="headerlink" title="11 模板"></a>11 模板</h3><blockquote>
<p>更高深的模板知识移步《泛型编程》笔记，泛型编程本身就是C++几大编程风格之一，可以说非常复杂</p>
</blockquote>
<ul>
<li><p>类模板</p>
<p>编译时的机制，并不会产生额外的运行时开销</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T* elem;</span><br><span class="line">  <span class="type">int</span> sz;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Vector</span><span class="params">(<span class="type">int</span> s)</span></span>;</span><br><span class="line">  ~<span class="built_in">Vector</span>() &#123;<span class="keyword">delete</span>[] elem;&#125;</span><br><span class="line"></span><br><span class="line">  T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> i);</span><br><span class="line">  <span class="type">const</span> T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> sz;&#125;</span><br><span class="line">  <span class="function">T* <span class="title">begin</span><span class="params">(Vector&lt;T&gt;&amp; x)</span></span>;</span><br><span class="line">  <span class="function">T* <span class="title">end</span><span class="params">(Vector&lt;T&gt;&amp; x)</span></span></span><br><span class="line"><span class="function">&#125;</span>;</span><br></pre></td></tr></table></figure>

<p>成员函数的定义方式与之类似</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Vector&lt;T&gt;::<span class="built_in">Vector</span>(<span class="type">int</span> s)&#123;</span><br><span class="line">  <span class="keyword">if</span>(s &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> Negative_size&#123;&#125;;</span><br><span class="line">  elem = <span class="keyword">new</span> T[s];</span><br><span class="line">  sz = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> T&amp; Vector&lt;T&gt;::<span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i&lt;<span class="number">0</span> || <span class="built_in">size</span>()&lt;=i)</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;Vector::operator[]&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> elem[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T* <span class="title">begin</span><span class="params">(Vector&lt;T&gt;&amp; x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x.<span class="built_in">size</span>() ? &amp;x[<span class="number">0</span>] : <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T* <span class="title">end</span><span class="params">(Vector&lt;T&gt;&amp; x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">begin</span>(x) + x.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义了begin 和end就可以使用for循环了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(Vector&lt;string&gt;&amp; vs)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; s : vs)</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了类型参数外，还接受普通的值参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Buffer</span>&#123;</span><br><span class="line">  <span class="keyword">using</span> value_type = T;</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> N;&#125;</span><br><span class="line">  T[N];</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数模板</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Value&gt;</span></span><br><span class="line"><span class="function">Value <span class="title">sum</span><span class="params">(<span class="type">const</span> Container&amp; c, Value v)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> x : c)</span><br><span class="line">    v += x;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的函数相当于针对不同的类型实现了一个累加器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">user</span><span class="params">(Vector&lt;<span class="type">int</span>&gt;&amp; vi, std::list)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="built_in">sum</span>(vi, <span class="number">0</span>);</span><br><span class="line">  <span class="type">double</span> d = <span class="built_in">sum</span>(vi, <span class="number">0.0</span>);</span><br><span class="line">  <span class="type">double</span> dd = <span class="built_in">sum</span>(ld, <span class="number">0.0</span>);</span><br><span class="line">  <span class="keyword">auto</span> z = <span class="built_in">sum</span>(vc, complex&lt;<span class="type">double</span>&gt;&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>📌模板也可以跟函数参数一样，有默认值。<br>template &lt;typename ty&#x3D;string&gt;<br>int test(ty x) {<br>&amp;#x20;&#x2F;&#x2F;……<br>}<br>如果没有显式说明ty的类型，也没有自动推断，那么编译时就会让ty成为默认类型string。</p>
</blockquote>
<h4 id="静态多态：CRTP"><a href="#静态多态：CRTP" class="headerlink" title="静态多态：CRTP"></a>静态多态：CRTP</h4><blockquote>
<p><strong>C</strong>uriously <strong>R</strong>ecurring <strong>T</strong>emplate <strong>P</strong>attern</p>
</blockquote>
<p>一般意义上的使用virtual实现的多态均为动态多态，在运行时实现多态。在C++中也可以使用<strong>静态多态</strong>，在编译时实现多态。动态多态由于存储虚表指针和虚表，以及有查询虚函数地址的一系列操作，会带来较大的开销。静态多态可以<strong>提升效率（降低开销）</strong>，就像内联函数一样。</p>
<ul>
<li><p>动态多态：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;unset&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Dog&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Cat&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">My_Print</span><span class="params">(<span class="type">const</span> Animal&amp; animal)</span></span>&#123;</span><br><span class="line">  animal.<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Dog d;</span><br><span class="line">  <span class="built_in">My_Print</span>(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<!---->

<ul>
<li><p>最简单的静态多态：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Animal_Type</span>&#123;</span><br><span class="line">  unset, Dog, Cat,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Animal</span>(Animal_Type animal_type) </span><br><span class="line">    : <span class="built_in">animal_type</span>(animal_type) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(animal_type)&#123;</span><br><span class="line">      <span class="keyword">case</span> unset:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;unset&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Dog:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Dog&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Cat:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Cat&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Animal_Type animal_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">My_Print</span><span class="params">(<span class="type">const</span> Animal&amp; animal)</span></span>&#123;</span><br><span class="line">  animal.<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">Animal <span class="title">dog</span><span class="params">(Animal_Type::Dog)</span></span>;</span><br><span class="line">  <span class="built_in">My_Print</span>(dog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>然而这种最简单的静态多态方法导致的问题是明显的，Animal类非常难以维护，要加一个新类别或新动作，要直接修改Animal类和Animal_Type类的源码。于是可以采用模板来进行改进（需要说明的是，既不用virtual，也不用模板，达不到多态的目的）：</p>
<ul>
<li><p>不用virtual和模板无法实现多态：</p>
<p>打印的结果是unset，因为调用My_Print时会把Dog类隐式转换为Animal类（因为My_Print函数接收的参数要求是Animal类）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;unset&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="comment">//覆盖原Print</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Dog&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="comment">//覆盖原Print</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Cat&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">My_Print</span><span class="params">(<span class="type">const</span> Animal&amp; animal)</span></span>&#123;</span><br><span class="line">  animal.<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Dog d;</span><br><span class="line">  <span class="built_in">My_Print</span>(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<!---->

<ul>
<li><p>利用模板改进的静态多态：</p>
<p>打印Dog，My_Print是模板函数，自动推断类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;unset&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Dog&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Cat&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A_T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">My_Print</span><span class="params">(<span class="type">const</span> A_T&amp; animal)</span></span>&#123;</span><br><span class="line">  animal.<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Dog d;</span><br><span class="line">  <span class="built_in">My_Print</span>(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>可以在上面的静态多态实现方案的基础上，进一步改良。现在是有三个Print函数，可以进一步降到只有两个函数以降低开销。改良的方案是CRTP。</p>
<p>CRTP一般的套路如下，在基类上用模板，基类只保留接口，子类负责接口的具体实现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Derived</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Interface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="built_in">static_cast</span>&lt;Derived*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">Implementation</span>();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base&lt;Derived&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Implementation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>针对上面的例子，则可以改写为CRTP实现的静态多态：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Derived&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="built_in">static_cast</span>&lt;Derived*&gt;(<span class="keyword">this</span>) -&gt; <span class="built_in">Print</span>(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal&lt;Dog&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Dog&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal&lt;Cat&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Cat&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A_T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">My_Print</span><span class="params">(<span class="type">const</span> A_T&amp; animal)</span></span>&#123;</span><br><span class="line">  animal.<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Dog d;</span><br><span class="line">  <span class="built_in">My_Print</span>(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，表面上Dog和Cat类都在继承Animal，但事实上它们继承的类是不同的，Dog继承的是Animal&lt;Dog&gt;类，Cat继承的是Animal&lt;Cat&gt;类。因此即使基类中有static变量，它们是不共享的。除此之外，由于继承的不是同一个基类，Dog和Cat的对象也无法放在同一个STL容器中，这也给CRTP的使用带来了局限。</p>
<h4 id="函数对象（function-object-x2F-functor）"><a href="#函数对象（function-object-x2F-functor）" class="headerlink" title="函数对象（function object&#x2F;functor）"></a>函数对象（function object&#x2F;functor）</h4><p>函数对象，顾名思义，就是将函数视作一个类的对象。调用函数对象时与调用函数无异，而函数对象的一个好处就是比较灵活，可以作为其他函数的参数被调用。</p>
<p>模板的一个特殊用途就是泛化函数对象，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Less_than</span>&#123;</span><br><span class="line">  <span class="type">const</span> T val; <span class="comment">//待比较的值</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Less_than</span>(<span class="type">const</span> T&amp; v) : <span class="built_in">val</span>(v) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x &lt; val; &#125; <span class="comment">//调用运算符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时，可以像调用函数一样调用函数对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Less_than&lt;<span class="type">int</span>&gt; LT_i &#123;<span class="number">42</span>&#125;;</span><br><span class="line">Less_than&lt;string&gt; LT_s &#123;<span class="string">&quot;Backus&quot;</span>&#125;;</span><br><span class="line"><span class="type">bool</span> b1 = <span class="built_in">LT_i</span>(n);  <span class="comment">//如果n&lt;42则为真</span></span><br><span class="line"><span class="type">bool</span> b2 = <span class="built_in">LT_s</span>(s);  <span class="comment">//如果s&lt;&quot;Backus&quot;则为真</span></span><br></pre></td></tr></table></figure>

<p>函数对象经常作为算法的参数出现，例如下面例子中pred就是函数对象作为的参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//统计容器中有多少个小于某数的值</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> P&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">const</span> C&amp; c, P pred)</span></span>&#123;    <span class="comment">//C假定为容器类型，P为函数对象类型</span></span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; x : c)</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pred</span>(x))</span><br><span class="line">      ++cnt;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> Vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">count</span>(vec, Less_than&lt;<span class="type">int</span>&gt;&#123;x&#125;) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了用类和模板定义函数对象，还<strong>可以用匿名函数(lambda表达式)定义函数对象</strong>。</p>
<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><ul>
<li><p>省略符形参：</p>
<p>省略符形参应该仅仅用于C和C++通用的类型。特别应该注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> count, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//为了实现可变参数列表，首先需要声明一个va_list类型的指针</span></span><br><span class="line">  <span class="comment">//va_list类型是在cstdarg头文件里面定义的，该指针用来依次指向各个参数</span></span><br><span class="line">  <span class="comment">//va_start是一个宏，用来初始化arg_ptr，使其指向列表的第一个参数</span></span><br><span class="line">  <span class="comment">//这个宏的第二个参数是sum函数参数列表省略号前得固定参数的名称，用来确定第一个参数的位置 </span></span><br><span class="line">  va_list arg_ptr;</span><br><span class="line">  <span class="built_in">va_start</span>(arg_ptr, count);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> CountSum = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//va_arg是一个宏，返回arg_ptr指向的参数位置，并使arg_ptr递增来指向下一个参数值</span></span><br><span class="line">  <span class="comment">//va_arg宏的第二个参数是需要统计的第一个参数的类型，</span></span><br><span class="line">  <span class="comment">//如果类型不正确，程序也可能会执行，但得到的是无用的数据，arg_ptr将被错误地递增</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    CountSum += <span class="built_in">va_arg</span>(arg_ptr, <span class="type">int</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将va_list类型的指针复位成空值</span></span><br><span class="line">  <span class="comment">//就是清空可变参数列表</span></span><br><span class="line">  <span class="built_in">va_end</span>(arg_ptr);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> CountSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sum</span>(<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);<span class="comment">//return 15</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>可变参数模板</strong>（实用）：</p>
<p>实现可变参数模板的关键是：当你传给它多个参数时，谨记把第一个参数和其他参数<strong>区分对待</strong>。此处，首先处理第一个参数head，然后使用剩余参数<strong>递归</strong>地调用f()。省略号…表示列表地“剩余部分”。最终，tail将为空。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">//不执行任何操作</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Tail&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T head, Tail... tail)</span></span>&#123;          <span class="comment">//f()类似于printf()的简单变形</span></span><br><span class="line">  <span class="built_in">g</span>(head);                             <span class="comment">//对head做某些操作</span></span><br><span class="line">  <span class="built_in">f</span>(tail...);                          <span class="comment">//再次处理tail</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;first: &quot;</span>;</span><br><span class="line">  <span class="built_in">f</span>(<span class="number">1</span>,<span class="number">2.2</span>,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;\n second: &quot;</span>;</span><br><span class="line">  <span class="built_in">f</span>(<span class="number">0.2</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&quot;yuck!&quot;</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//first: 1 2.2 hello</span></span><br><span class="line"><span class="comment">//second: 0.2 c yuck! 0 1 2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可变参数initializer_list：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//initializer_list相对vector更轻量化 而且元素是常量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_msg</span><span class="params">(initializer_list&lt;string&gt; il)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> beg = il.<span class="built_in">begin</span>(); beg != il.<span class="built_in">end</span>(); ++beg)</span><br><span class="line">    cout &lt;&lt; *beg &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">error_msg</span>(&#123;<span class="string">&quot;im&quot;</span>,<span class="string">&quot;da&quot;</span>,<span class="string">&quot;gong&quot;</span>&#125;);<span class="comment">//&quot;im da gong&quot;</span></span><br></pre></td></tr></table></figure>

<p>这种方式局限性很大，列表里只能同类型，而且元素是常量。</p>
<p>这种方式的一个典型例子就是vector初始化赋值，可用下面代码模拟：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyNumber</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">MyNumber</span>(<span class="type">const</span> std::initializer_list&lt;<span class="type">int</span>&gt;&amp; v)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> itm : v)</span><br><span class="line">      mVec.<span class="built_in">push_back</span>(itm);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> itm : mVec)</span><br><span class="line">      std::cout &lt;&lt; itm &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; mVec;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  MyNumber m = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">  m.<span class="built_in">print</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>宏：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> debug(...) print(cout,__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug2(os, ...) print(os, __VA_ARGS__)</span></span><br><span class="line"><span class="comment">//#define debug2(format, args...) print(format, ##args)//win32不支持</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">debug2</span>(cout,<span class="string">&quot;this &quot;</span>, <span class="string">&quot; year&quot;</span>);<span class="comment">//&quot;this  year&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>__VA_ARGS__</code>表示可变参数列表。</p>
</li>
</ul>
<h4 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h4><p>泛型编程中的别名可以有很多用途，</p>
<ul>
<li><p>写出通用代码：</p>
<p>比如，每个标准库容器都提供了value_type作为其值类型的名字（如vector&lt;int&gt;::value_type为int），因此可以利用这点写出代码，使代码能够在任何一个服从这种规范的容器上工作，如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="keyword">using</span> Element_type = <span class="keyword">typename</span> C::value_type; <span class="comment">//C的元素类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">algo</span><span class="params">(Container&amp; c)</span></span>&#123;</span><br><span class="line">  Vector&lt;Element_type&lt;Container&gt;&gt; vec; <span class="comment">//保存结果</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现algo函数，就可以将如stack&lt;int&gt;的变量转换成vector&lt;int&gt;，Element_type&lt;Container&gt;会等于int。</p>
</li>
<li><p>绑定某些模板实参，定义新的模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Map</span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Value&gt;</span><br><span class="line"><span class="keyword">using</span> String_map = Map&lt;string, Value&gt;;</span><br><span class="line"></span><br><span class="line">String_map&lt;<span class="type">int</span>&gt; m; <span class="comment">//m是一个Map&lt;string, int&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>📌typedef 和using 的区别：typedef 只能针对特定的类型，而using 可以生成别名模板。<br>比如可以<code>template&lt;class T&gt; using remove_const_t = typename remove_const&lt;T&gt;::type</code>，而typedef则不行。</p>
</blockquote>
<h4 id="模板特化"><a href="#模板特化" class="headerlink" title="模板特化"></a>模板特化</h4><p>当定义一个类模板或函数模板时，往往希望所有会用到的模板参数类型，都能够满足类模板或函数模板对其功能的要求，举例来说，函数模板template&lt;typename T&gt; …希望所有可能实例化的T，都能够实现取模运算<code>%</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function">E <span class="title">my_gcd</span><span class="params">(E a, E b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(b != <span class="built_in">E</span>(<span class="number">0</span>))&#123;</span><br><span class="line">    E r = a % b;</span><br><span class="line">    a = b;</span><br><span class="line">    b = r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，并不是所有的类型都有取模函数，比如一些第三方库的高精度数字库（如CLN的<code>cl_I</code>高精度整数类型就不支持），那么实例化会失败，编译出错。</p>
<p>针对这种情况，有三种解决方案，其中后面两种最常用，即<strong>重载</strong>和<strong>特化</strong>。1</p>
<ol>
<li><p>方案1：添加代码，让类型支持所需要的操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cln::cl_I</span><br><span class="line"><span class="keyword">operator</span>%(<span class="type">const</span> cln::cl_I&amp; lhs,</span><br><span class="line">          <span class="type">const</span> cln::cl_I&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">mod</span>(lhs, rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方案2：<strong>函数重载</strong>，不直接使用%运算符，替换成my_mod函数，再重载cl_I类型的my_mod函数</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//%替换成my_mod</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function">E <span class="title">my_gcd</span><span class="params">(E a, E b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (b != <span class="built_in">E</span>(<span class="number">0</span>)) &#123;</span><br><span class="line">    E r = <span class="built_in">my_mod</span>(a, b);</span><br><span class="line">    a = b;</span><br><span class="line">    b = r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一般情况下的my_mod函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function">E <span class="title">my_mod</span><span class="params">(<span class="type">const</span> E&amp; lhs,</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="type">const</span> E&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> lhs % rhs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//针对cl_I类重载的my_mod函数</span></span><br><span class="line"><span class="function">cln::cl_I</span></span><br><span class="line"><span class="function"><span class="title">my_mod</span><span class="params">(<span class="type">const</span> cln::cl_I&amp; lhs,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="type">const</span> cln::cl_I&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">mod</span>(lhs, rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&amp;#x20;  3. 方案3：<strong>模板特化</strong>，同方案2类似，但是my_mod不针对cl_I类型重载，而是特化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line">cln::cl_I <span class="built_in">my_mod</span>&lt;cln::cl_I&gt;(<span class="type">const</span> cln::cl_I&amp; lhs, <span class="type">const</span> cln::cl_I&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">mod</span>(lhs, rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>📌特化是一种更加通用的技巧，因为特化既可以用在类模板也可以用在函数模板，而重载只能用于函数。<br>然而，一般的建议是：对函数模板使用重载，对类模板进行特化。</p>
</blockquote>
<ul>
<li><p>特化的经典例子：static_assert</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">compile_time_error</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">compile_time_error</span>&lt;<span class="literal">true</span>&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STATIC_ASSERT(Expr, Msg)   \</span></span><br><span class="line"><span class="meta">  &#123;                                \</span></span><br><span class="line"><span class="meta">    compile_time_error<span class="string">&lt;bool(Expr)&gt;</span> \</span></span><br><span class="line"><span class="meta">      ERROR_##_Msg;                \</span></span><br><span class="line"><span class="meta">    (void)ERROR_##_Msg;            \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面的代码声明了一个struct模板，但仅对true的情况进行了特化，产生了compile_tme_error&lt;true&gt;的定义。这样，如果Expr是错的（比如3&gt;5），此时就遇到了compile_time_error&lt;false&gt;的情况，缺少定义编译不出来，所以就会编译报错，起到编译期检查的作用。<code>(void)ERROR_##_Msg</code>是在抑制编译器unused警告（当成功编译时）。</p>
</li>
<li><p><strong>为什么遇到类型不满足条件时，对函数模板更倾向于重载</strong>？</p>
<blockquote>
<p>资料：<a href="http://www.gotw.ca/publications/mill17.htm" title="Why not specialize Function Templates?">Why not specialize Function Templates?</a></p>
</blockquote>
<blockquote>
<p>偏特化：多个模板参数，仅特化其中的一部分</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="编译时计算（浅述模板元编程）"><a href="#编译时计算（浅述模板元编程）" class="headerlink" title="编译时计算（浅述模板元编程）"></a>编译时计算（浅述模板元编程）</h4><ul>
<li>最大公约数（辗转相除gcd）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> n&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">factorial</span>&#123;</span><br><span class="line">  <span class="built_in">static_assert</span>( n &gt;= <span class="number">0</span>, <span class="string">&quot;Arg must be non-negative&quot;</span>);</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = n * factorial&lt;n<span class="number">-1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">factorial</span>&lt;<span class="number">0</span>&gt;&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; factorial&lt;<span class="number">10</span>&gt;::value &lt;&lt; std::endl; </span><br><span class="line">    <span class="comment">//3628800</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的代码进行反汇编，可以看到3628800直接出现了，中间的递归、计算过程完全没有。这便体现了编译期计算，即计算步骤完全由编译器完成了，而不在运行时进行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">.LC0:</span><br><span class="line">        .string <span class="string">&quot;%d\n&quot;</span></span><br><span class="line">main:</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        mov     esi, <span class="number">3628800</span></span><br><span class="line">        mov     edi, OFFSET FLAT:.LC0</span><br><span class="line">        mov     eax, <span class="number">0</span></span><br><span class="line">        call    printf</span><br><span class="line">        mov     eax, <span class="number">0</span></span><br><span class="line">        pop     rbp</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<p>从中可以一窥编译期计算的核心：<strong>将计算转变成类型推导</strong>。</p>
<ul>
<li>条件语句（C++98）：右边两种写法是等价的</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> cond, <span class="keyword">typename</span> Then, <span class="keyword">typename</span> Else&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">If</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Then, <span class="keyword">typename</span> Else&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">If</span>&lt;<span class="literal">true</span>, Then, Else&gt;&#123;</span><br><span class="line">  <span class="keyword">typedef</span> Then type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Then, <span class="keyword">typename</span> Else&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">If</span>&lt;<span class="literal">false</span>, Then, Else&gt;&#123;</span><br><span class="line">  <span class="keyword">typedef</span> Else type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, T v&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">integral_constant</span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> T value = v;</span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> integral_constant type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>( n==<span class="number">2</span> || n==<span class="number">3</span> || n==<span class="number">5</span> ) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> n&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> If&lt;</span><br><span class="line">    ( n==<span class="number">2</span> || n==<span class="number">3</span> || n==<span class="number">5</span>),</span><br><span class="line">    integral_constant&lt;<span class="type">int</span>, <span class="number">1</span>&gt;,</span><br><span class="line">    integral_constant&lt;<span class="type">int</span>, <span class="number">2</span>&gt;&gt;::type</span><br><span class="line">  type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用<code>::</code>取一个成员类型，且<code>::</code>左边有模板参数的话，得额外加上typename关键字来标明结果是一个类型。使用如下：</p>
<p><code>std::cout&lt;&lt;Foo&lt;1&gt;::type::value&lt;&lt;std::endl</code></p>
<p>定义两项分支Then和Else，用类型来代表执行状态。</p>
<p>cond：条件（真或假）</p>
<p>Then：条件为真时的状态</p>
<p>Else：条件为假时的状态</p>
<ul>
<li>循环语句（C++98）：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> condition, <span class="keyword">typename</span> body&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WhileLoop</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Body&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WhileLoop</span>&lt;<span class="literal">true</span>, Body&gt;&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> WhileLoop&lt;</span><br><span class="line">    Body::cond_value,</span><br><span class="line">    <span class="keyword">typename</span> Body::next_type&gt;::type</span><br><span class="line">  type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Body&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WhileLoop</span>&lt;<span class="literal">false</span>, Body&gt;&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Body::res_type type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Body&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">While</span> &#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> WhileLoop&lt;</span><br><span class="line">    Body::cond_value, Body&gt;::type</span><br><span class="line">  type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, T v&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">integral_constant</span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> T value = v;</span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> integral_constant type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">  result = result + n;</span><br><span class="line">  n = n<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> result, <span class="type">int</span> n&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SumLoop</span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">bool</span> cond_value = n!=<span class="number">0</span>;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> res_value = result;</span><br><span class="line">  <span class="keyword">typedef</span> integral_constant&lt;<span class="type">int</span>, res_value&gt; res_type;</span><br><span class="line">  <span class="keyword">typedef</span> SumLoop&lt;result + n, n <span class="number">-1</span>&gt; next_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> n&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sum</span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> SumLoop&lt;<span class="number">0</span>,n&gt; type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>↑上面两种写法的效果是等价的。使用时执行：</p>
<p><code>While&lt;Sum&lt;10&gt;::type&gt;::type::value</code></p>
<p>可得到1~10累加结果</p>
<p>前面说到，编译期计算用类型推导表示分支状态。因此需要三个成员：cond_value表示循环判断的条件（真假）、res_type表示退出循环时的状态、next_type表示下面循环执行一次的状态。</p>
<p>这样的循环过程可以通过展开来理解，以累加到2为例：</p>
<p>While&lt; Sum&lt;2&gt;::type &gt;::type::value 实例化(instantiation)过程<br>--&gt; While&lt; SumLoop&lt;0, 2&gt; &gt;::type::value<br>--&gt; WhileLoop&lt;SumLoop&lt;0, 2&gt;::cond_value, SumLoop&lt;0, 2&gt;&gt;::type::value<br>--&gt; WhileLoop&lt;true, SumLoop&lt;0, 2&gt;&gt;::type::value</p>
<p>--&gt; WhileLoop&lt;SumLoop&lt;0, 2&gt;::cond_value, SumLoop&lt;0, 2&gt;::next_type&gt;::type::value<br>--&gt; WhileLoop&lt;true, SumLoop&lt;2, 1&gt;&gt;::type::value</p>
<p>--&gt; WhileLoop&lt;SumLoop&lt;2, 1&gt;::cond_value, SumLoop&lt;2, 1&gt;::next_type&gt;::type::value<br>--&gt; WhileLoop&lt;true, SumLoop&lt;3, 0&gt;&gt;::type::value</p>
<p>--&gt; WhileLoop&lt;SumLoop&lt;3, 0&gt;::cond_value, SumLoop&lt;3, 0&gt;::next_type&gt;::type::value<br>--&gt; WhileLoop&lt;false, SumLoop&lt;3, -1&gt;&gt;::type::value</p>
<p>--&gt; SumLoop&lt;3, -1&gt;::res_type::value</p>
<p>--&gt;integral_constant&lt;int, 3&gt;::value<br>--&gt;3</p>
<h4 id="type-traits"><a href="#type-traits" class="headerlink" title="type_traits"></a>type_traits</h4><p><a href="https://en.cppreference.com/w/cpp/header/type_traits">https://en.cppreference.com/w/cpp/header/type_traits</a></p>
<p>顾名思义，&lt;type_traits&gt;头文件定义了一些工具类模板，用来提取某个类型（type）在某方面的特点（trait）。它可以实现在编译期的判断、转换、查询等功能，并且提供了编译期的true和false。比如上面提到的integral_constant类，就被定义在了type_traits中，它可以称作type_traits的基石。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// integral_constant</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, _Tp __v&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">integral_constant</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> _Tp                  value = __v;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp                           value_type;</span><br><span class="line">    <span class="keyword">typedef</span> integral_constant&lt;_Tp, __v&gt;   type;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">operator</span> <span class="title">value_type</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus &gt; 201103L</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __cpp_lib_integral_constant_callable 201304</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> value_type <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, _Tp __v&gt;</span><br><span class="line"><span class="keyword">constexpr</span> _Tp integral_constant&lt;_Tp, __v&gt;::value;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::integral_constant&lt;</span><br><span class="line">  <span class="type">bool</span>, <span class="literal">true</span>&gt; true_type;</span><br><span class="line"><span class="keyword">typedef</span> std::integral_constant&lt;</span><br><span class="line">  <span class="type">bool</span>, <span class="literal">false</span>&gt; false_type;</span><br></pre></td></tr></table></figure>

<p>为方便使用，type_traits还针对布尔值有两个额外的类型定义。于是调用<code>std::true_type::value</code>可以得到<code>true</code></p>
<p>type_traits头文件中凡是带前缀<code>is_*</code>类的偏特化或特化均继承自<code>true_type</code>和<code>false_type</code>，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__is_pointer_helper</span> : \</span><br><span class="line">  <span class="keyword">public</span> false_type &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__is_pointer_helper</span> &lt;_Tp*&gt; : \</span><br><span class="line">  <span class="keyword">public</span> true_type &#123; &#125;;</span><br></pre></td></tr></table></figure>

<p>而这些<code>is_*</code>前缀的便是<strong>用来标注某类型是否有某特点</strong>的模板元。比如<code>is_trivially_destructible</code>模板可用于判断类是否可平凡析构（即，不调用析构函数，不会造成任何资源泄露问题）。模板返回的要么是<code>true_type</code>要么是<code>false_type</code>。使用operator()重载或::value都可以得到背后的true或false。因此，可以在删除某对象前，用它来判断是否需要析构函数，这样在优化编译时，编译器可以把不需要的析构操作全部删除。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeContainer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(T* ptr)</span></span>&#123;</span><br><span class="line">    _destroy(ptr, <span class="built_in">is_trivially_destructible</span>&lt;T&gt;());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">void</span> _destroy(T* ptr, true_type) &#123;&#125;</span><br><span class="line">  <span class="type">static</span> <span class="type">void</span> _destroy(T* ptr, false_type) &#123;</span><br><span class="line">    ptr-&gt;~<span class="built_in">T</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的代码便是很多容器类都会有的destroy函数，通过<code>is_trivially_destructible</code>来最大程度优化。类似的<code>is_*</code>还有：（具体可查看cppreference官网）</p>
<p><code>is_void, is_null_pointer, is_integral, is_class, is_function, is_pointer, is_lvalue_reference, is_rvalue_reference, is_const, is_move_constructble, is_copy_constructible, has_virtual_destructor</code>等等</p>
<hr>
<p>同时，type_traits还可以做类型转换，以<code>std::remove_const</code>为例，来去除类型里的const修饰。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">remove_const</span> &#123;</span><br><span class="line">  <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">remove_const</span>&lt;<span class="type">const</span> T&gt;&#123;</span><br><span class="line">  <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">remove_const&lt;<span class="type">const</span> string&gt;::type str;<span class="comment">//string类型</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>📌如果对const char* 应用remove_const的话，结果还是const char <em>。因为const char</em> 是指向const chat的指针，而不是指向char的const指针。如果对char * const应用remove_const的话，可得到char*</p>
</blockquote>
<p>&lt;type_traits&gt;中类似的类型转换元还有：（具体可查看cppreference官网）</p>
<p><code>remove_cv</code>（同时去除const和volatile）、<code>remove_volatile</code>、<code>remove_pointer</code>、<code>add_const</code>、<code>remove_extent</code>、<code>make_signed</code>等等。</p>
<p>C++14和C++17还针对&lt;type_traits&gt;提供了一些简易写法，比如写<code>is_trivially_destructible&lt;T&gt;::value</code>和<code>is_trivially_destructible&lt;T&gt;::type</code>会比较啰嗦，那么可以简化写成_v（C++17）和_t（C++14）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="type">bool</span></span><br><span class="line">  is_trivially_destructible_v =</span><br><span class="line">    is_trivially_destructible&lt;</span><br><span class="line">      T&gt;::value;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">remove_const_t</span> =</span><br><span class="line">  <span class="keyword">typename</span> remove_const&lt;T&gt;::type;</span><br></pre></td></tr></table></figure>

<p>类型转换模板元中，最重要的模板元是<code>std::decay</code>，decay可以对于普通类型移除引用和cv符（const和volatile）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::decay&lt;<span class="type">int</span>&gt;::type Normal;      <span class="comment">//int</span></span><br><span class="line"><span class="keyword">typedef</span> std::decay&lt;<span class="type">int</span>&amp;&gt;::type Ref;        <span class="comment">//int</span></span><br><span class="line"><span class="keyword">typedef</span> std::decay&lt;<span class="type">int</span>&amp;&amp;&gt;::type RefRef;    <span class="comment">//int</span></span><br><span class="line"><span class="keyword">typedef</span> std::decay&lt;<span class="type">const</span> <span class="type">int</span>&amp;&gt;::type cnst; <span class="comment">//int</span></span><br><span class="line"><span class="keyword">typedef</span> std::decay&lt;<span class="type">int</span>[<span class="number">2</span>]&gt;::type Array;    <span class="comment">//int*，数组类型变成指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----decay一般会和decltype搭配-----*/</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">typedef</span> std::decay&lt;<span class="keyword">decltype</span>(arr)&gt;::type myArray;</span><br></pre></td></tr></table></figure>

<p>decay比较常用的一点在于其可以方便地获得函数指针，即其可以实现从函数对象提取出函数指针类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add_2</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add_3</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(add_2)&gt; add_ptr = add_3;   <span class="comment">//add_ptr是函数指针</span></span><br><span class="line"><span class="keyword">decltype</span>&lt;add_2&gt; * add_func = add2_3;             <span class="comment">//直接使用decltype推断不出函数指针</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">add_ptr</span>(<span class="number">7</span>) &lt;&lt; endl;                      <span class="comment">//10</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">add_func</span>(<span class="number">7</span>) &lt;&lt; endl;                     <span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>decay本意就是退化，移除引用和cv，从函数对象到函数指针，都可以看做是一种退化行为。</p>
</blockquote>
<p>但是需要注意，decay_t&lt;decltype&lt;func&gt;&gt;和decay_t&lt;decltype&lt;func()&gt;&gt;是不同的，看上去后者只是加了一个括号。但是后者是将func的返回类型退化，而前者是与func一致入参返回值的函数指针。比如下面的例子，进行map-reduce中的map操作，就是进行返回类型退化decay_t&lt;decltype&lt;func()&gt;&gt;。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>&gt;<span class="keyword">class</span> <span class="title class_">OutContainer</span> = vector, <span class="keyword">typename</span> F, <span class="keyword">class</span> R&gt;</span><br><span class="line">        <span class="keyword">auto</span> <span class="built_in">fmap</span>(F&amp;&amp; f, R&amp;&amp; inputs)&#123;</span><br><span class="line">            <span class="keyword">typedef</span> <span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(<span class="built_in">f</span>(*inputs.<span class="built_in">begin</span>()))&gt; result_type;</span><br><span class="line">            OutContainer&lt;result_type, allocator&lt;result_type&gt;&gt; result;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; item : inputs)&#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(<span class="built_in">f</span>(item));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> add_1 = [](<span class="type">int</span> x)&#123;</span><br><span class="line">        <span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> result = <span class="built_in">fmap</span>(add_1, v);   <span class="comment">//v变成：2,3,4,5,6</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>其他的&lt;type_traits&gt;中常用模板元有：<code>std::conditional, std::enable_if, std::void_t</code>等。</p>
<ul>
<li><p><code>std::conditional</code>：在编译期根据一个判断式选择两个类型中的一个，类似三元表达式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> B, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">F</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">conditional</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> std::conditional&lt;<span class="literal">true</span>, <span class="type">int</span>, <span class="type">char</span>&gt;::type A;</span><br><span class="line">  <span class="keyword">typedef</span> std::conditional&lt;<span class="literal">false</span>, <span class="type">int</span>, <span class="type">char</span>&gt;::type B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>type_traits最常用的<code>std::enable_if</code>会在下一小节阐述。</p>
</li>
</ul>
<hr>
<h4 id="重载歧义消除（traits）"><a href="#重载歧义消除（traits）" class="headerlink" title="重载歧义消除（traits）"></a>重载歧义消除（traits）</h4><p>多个同名函数做重载时，偶尔会发生歧义的情况。即调用函数时的参数，同时满足两个及以上的重载函数，那么编译器无从选择，就会出现编译报错。因此需要歧义消除机制，有两种常用方案，SFINAE和type_traits。</p>
<blockquote>
<p>SFINAE其实是C++中的一种机制，即“如果模板实例化发生了失败，没有理由让编译就此出错终止，因为还可能有其他可用的函数重载”，标准库通过这种机制提出了歧义消除的解决方案。</p>
</blockquote>
<ul>
<li><p>SFINAE（Substitution Failure Is Not An Error）</p>
<p>考虑要实现一个Buffer类，希望在Buffer中添加元素，可以有三种形式：</p>
<ul>
<li><p>第一种重载：传入一个字符，和一个size_t，向Buffer中添加n个相同的c</p>
</li>
<li><p>第二种重载：直接传入一个字符串，并传入字符串大小</p>
</li>
<li><p>第三种重载：STL风格添加，即可以<code>buf.append(str.begin(), str.end());</code>和<code>buf.append(str.rbegin(),str.rend());</code>，需要注意前者的参数类型是string::iterator，后者的参数类型是string::reverse_iterator。想用一个函数接受两类迭代器，需要用到模板。</p>
</li>
</ul>
<p>因此，Buffer类可以设计成下面的形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">char</span> c, <span class="type">size_t</span> n = <span class="number">1</span>)</span></span>;    <span class="comment">//第一种重载</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> n)</span></span>; <span class="comment">//第二种重载</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iter&gt;</span></span><br><span class="line"><span class="function">  <span class="type">void</span> <span class="title">append</span><span class="params">(Iter bp, Iter ep)</span></span>;        <span class="comment">//第三种重载</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Buffer buf;</span><br><span class="line"></span><br><span class="line">  buf.<span class="built_in">append</span>(<span class="string">&#x27;a&#x27;</span>);                     <span class="comment">//[1]</span></span><br><span class="line">  buf.<span class="built_in">append</span>(<span class="string">&#x27;b&#x27;</span>,<span class="number">10</span>);                  <span class="comment">//[1]</span></span><br><span class="line"></span><br><span class="line">  <span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">  buf.<span class="built_in">append</span>(str.<span class="built_in">data</span>(), str.<span class="built_in">size</span>());  <span class="comment">//[2]</span></span><br><span class="line"></span><br><span class="line">  buf.<span class="built_in">append</span>(str.<span class="built_in">rbegin</span>(), str.<span class="built_in">rend</span>());<span class="comment">//[3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样的写法是有错误的，考虑下面的情况</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  Buffer buf;</span><br><span class="line">  buf.<span class="built_in">append</span>(ch, <span class="number">10</span>);  <span class="comment">//int,int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法下，按理说是想用第一种重载方式，然而由于两个类型都是int，所以会调用原本为迭代器设计的模板重载，即调用了第三种方式的重载，那么就会导致运行时的错误。</p>
<p>SFINAE可用于解决这种问题，它的思路是<strong>对模板参数T的类型加以限制</strong>，从而避免所有情况下模板都能精准匹配。</p>
<p>SFINAE的关键在于std::enable_if。<code>std::enable_if&lt;BOOL,??&gt;::type</code>的使用方式：第一个模板参数接收一个bool类型，第二个模板参数接收一个任意类型，当前面的bool条件为true时，enable_if的成员变量type就会是第二个模板参数??的类型。而enable_if&lt;BOOL,void&gt;默认第二个模板参数是void。bool条件为false时，表达式解析失败，即不会编译false对应的内容。</p>
<p>用SFINAE，规避Iter为int类型：</p>
<ul>
<li><p>写法：(可以写的形式有很多，跟这种写法都是一个思想)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">char</span> c, <span class="type">size_t</span> n = <span class="number">1</span>)</span></span>;    <span class="comment">//第一种重载</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> n)</span></span>; <span class="comment">//第二种重载</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> = </span><br><span class="line">      std::enable_if&lt;!std::is_integral&lt;Iter&gt;::value&gt;::type&gt;</span><br><span class="line">  <span class="type">void</span> <span class="built_in">append</span>(Iter bp, Iter ep);        <span class="comment">//第三种重载</span></span><br><span class="line">  <span class="comment">//当非整数时就相当于template&lt;typename Iter, typename = void&gt; void append(...)</span></span><br><span class="line">  <span class="comment">//整数时就会解析失败，SFINAE机制此时会选择其他函数重载</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>上面的写法是针对函数重载歧义消除时的enable_if用法，事实上enable_if还可以有别的用法：</p>
<ol>
<li><p>模板偏特化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Enable=<span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> check;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">check</span>&lt;T, <span class="keyword">typename</span> std::enable_if&lt;T::value&gt;::type&gt; &#123;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = T::value;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>check只选择<code>value==true</code>的T，否则就报编译错误（因为没有其他重载的定义了）。</p>
<blockquote>
<p>📌只有类模板是可以偏特化的，函数模板不可以偏特化。</p>
</blockquote>
</li>
<li><p>控制函数返回类型：典型的例子就是C++的tuple中，获取k个元素的get方法的实现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;std::<span class="type">size_t</span> k, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span>... Ts&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;k==<span class="number">0</span>, <span class="keyword">typename</span> element_type_holder&lt;<span class="number">0</span>, T, Ts...&gt;::type&amp;&gt;::type</span><br><span class="line"><span class="built_in">get</span>(tuple&lt;T, Ts...&gt; &amp;t) &#123;</span><br><span class="line">  <span class="keyword">return</span> t.tail; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::<span class="type">size_t</span> k, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span>... Ts&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;k!=<span class="number">0</span>, <span class="keyword">typename</span> element_type_holder&lt;k, T, Ts...&gt;::type&amp;&gt;::type</span><br><span class="line"><span class="built_in">get</span>(tuple&lt;T, Ts...&gt; &amp;t) &#123;</span><br><span class="line">  tuple&lt;Ts...&gt; &amp;base = t;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">get</span>&lt;k<span class="number">-1</span>&gt;(base); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过enable_if可以根据不同k的值选择调用哪个get，实现函数模板的多态。这个例子也体现了“编译时计算”思想。进行了一个编译期的递归。</p>
</li>
<li><p>在进行歧义消除的同时，控制返回类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_integral&lt;T&gt;::value, <span class="type">bool</span>&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">is_odd</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">bool</span>(t % <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>除了利用enable_if关键字和SFINAE机制，还有另一种更有效的歧义消除方案。</p>
<ul>
<li><p>添加参数（标签分发，tag dispatch）</p>
<p>现在希望实现一个to_string函数，把数值（整数、浮点数）转换为标准库string类型变量，可以先这么写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">long</span> <span class="type">long</span> value)</span></span>&#123;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">64</span>];</span><br><span class="line">  <span class="type">int</span> len = <span class="built_in">sprintf</span>(str, <span class="string">&quot;%lld&quot;</span>, value);</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">string</span>(str, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> value)</span></span>&#123;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">64</span>];</span><br><span class="line">  <span class="type">int</span> len = <span class="built_in">sprintf</span>(str, <span class="string">&quot;%llu&quot;</span>, value);</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">string</span>(str, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">long</span> <span class="type">double</span> value)</span></span>&#123;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">64</span>];</span><br><span class="line">  <span class="type">int</span> len = <span class="built_in">sprintf</span>(str, <span class="string">&quot;%Lg&quot;</span>, value);</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">string</span>(str, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  std::string str;</span><br><span class="line"></span><br><span class="line">  str = <span class="built_in">to_string</span>(<span class="number">1234</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str = %s\n&quot;</span>, str.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">  str = <span class="built_in">to_string</span>(<span class="number">-1234</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str = %s\n&quot;</span>, str.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">  str = <span class="built_in">to_string</span>(<span class="number">56.789</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;str = %s\n&quot;</span>, str.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此代码考虑了long long 类型整数和非负整数，以及double浮点类型。然而，<strong>编译会报错</strong>。因为传1234这个字面量时，1234会作为一个整数变量进入函数栈，然而重载的函数中没一个是精确匹配int类型的，因此编译器会找类型提升，即隐式转换。然而，int对于long long , unsigned long long, long double都存在隐式转换，由此产生歧义，编译器不知道该选择哪个函数重载，所以会有编译报错。</p>
<ul>
<li><p>解决方案一：把所有类型的参数，都写一遍，即列举所有可能的函数重载</p>
<p>缺点：写太多了，费时费力</p>
</li>
<li><p>解决方案二：用SFINAE</p>
<p>缺点：当前的重载主要判断两个条件，一个是“参数是否为整数”，另一个是“参数是否为有符号数”。当重载的判断条件大于等于2时，使用SFINAE会将代码写得较乱，难以维护和拓展。</p>
</li>
<li><p><strong>解决方案三</strong>：添加参数，确保所有情况都有重载可以匹配，而且至多有一个匹配。</p>
<p>实现方式类似于，<strong>通过函数参数，实现if语句</strong>。当前函数重载主要判断两个条件：参数是否为整数，参数是否为有符号数。因为浮点数不存在有无符号的问题，所以类型总共可以分为三个分支：</p>
<ol>
<li><p>整数，有符号数</p>
</li>
<li><p>整数，无符号数</p>
</li>
<li><p>浮点数</p>
</li>
</ol>
<p>因此，可以加上模板，利用std::is_integral&lt;T&gt;判断参数类型是否为整数，利用std::is_signed&lt;T&gt;判断类型是否为有符号数。</p>
<p>is_integral&lt;T&gt;事实上是C++标准库中的一个类，继承自integral_constant&lt;bool, true&gt;，该基类是一个bool类型常量。而bool类型在C++标准库中存在两个别名，分别对应true和false：<code>std::true_type</code>和<code>std::false_type</code>，因此可以将函数重载调整为以下代码，即利用重载实现对类型和符号的if判断。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span> <span class="comment">//is_integral, is_signed都归属于type_traits头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//既是整数，又是有符号数的情况</span></span><br><span class="line"><span class="function">std::string <span class="title">do_to_string</span><span class="params">(std::true_type,   <span class="comment">//integral</span></span></span></span><br><span class="line"><span class="params"><span class="function">                         std::true_type,   <span class="comment">//signed</span></span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">long</span> <span class="type">long</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">64</span>];</span><br><span class="line">  <span class="type">int</span> len = <span class="built_in">sprintf</span>(str, <span class="string">&quot;%lld&quot;</span>, value);</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">string</span>(str, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是整数，但不是有符号数的情况</span></span><br><span class="line"><span class="function">std::string <span class="title">do_to_string</span><span class="params">(std::true_type,   <span class="comment">//integral</span></span></span></span><br><span class="line"><span class="params"><span class="function">                         std::false_type,   <span class="comment">//!signed</span></span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">64</span>];</span><br><span class="line">  <span class="type">int</span> len = <span class="built_in">sprintf</span>(str, <span class="string">&quot;%llu&quot;</span>, value);</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">string</span>(str, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不是整数，但是是有符号数</span></span><br><span class="line"><span class="function">std::string <span class="title">do_to_string</span><span class="params">(std::false_type,  <span class="comment">//!integral</span></span></span></span><br><span class="line"><span class="params"><span class="function">                         std::true_type,   <span class="comment">//signed</span></span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">long</span> <span class="type">double</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">64</span>];</span><br><span class="line">  <span class="type">int</span> len = <span class="built_in">sprintf</span>(str, <span class="string">&quot;%Lg&quot;</span>, value);</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">string</span>(str, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">const</span> T&amp; t)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">do_to_string</span>(std::<span class="built_in">is_integral</span>&lt;T&gt;(),</span><br><span class="line">                      std::<span class="built_in">is_signed</span>&lt;T&gt;(),</span><br><span class="line">                      t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="declval"><a href="#declval" class="headerlink" title="declval"></a>declval</h4><p>declval是C++11引入的一种<strong>函数模板</strong>，其作用在于为一些类型返回它的右值引用类型。官方代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>,</span><br><span class="line">    <span class="keyword">class</span> = <span class="type">void</span>&gt;</span><br><span class="line">    <span class="keyword">struct</span> _Add_reference</span><br><span class="line">    &#123;   <span class="comment">// add reference</span></span><br><span class="line">    <span class="keyword">using</span> _Lvalue = _Ty;</span><br><span class="line">    <span class="keyword">using</span> _Rvalue = _Ty;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">add_rvalue_reference</span></span><br><span class="line">    &#123;   <span class="comment">// add rvalue reference</span></span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> _Add_reference&lt;_Ty&gt;::_Rvalue;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line">    <span class="keyword">using</span> <span class="type">add_rvalue_reference_t</span> = <span class="keyword">typename</span> _Add_reference&lt;_Ty&gt;::_Rvalue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// FUNCTION TEMPLATE declval</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> _Ty&gt;</span></span><br><span class="line"><span class="function">    <span class="type">add_rvalue_reference_t</span>&lt;_Ty&gt; <span class="title">declval</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<p>std::declval&lt;T&gt;，传入的T为int时返回int&amp;&amp;，T为int&amp;时返回int&amp;（引用折叠），T为int&amp;&amp;时返回int&amp;&amp;。declval返回右值引用的操作均在编译期完成，不管T类型是否有public的默认构造函数，都能造出右值引用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> YT = <span class="keyword">decltype</span>(std::<span class="built_in">declval</span>&lt;A&gt;());<span class="comment">//不要丢到declval&lt;A&gt;() 后的括号，因为是函数，否则代码含义发生变化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;YT = &quot;</span> &lt;&lt; <span class="built_in">type_id_with_cvr</span>&lt;YT&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; endl;<span class="comment">//显示YT类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：YT = class A &amp;&amp;</span></span><br></pre></td></tr></table></figure>

<p>declval和decltype经常配合在一块，用于进行函数指针、成员方法返回类型的推导。</p>
<ul>
<li><strong>成员方法返回值类型推导</strong>：</li>
</ul>
<p>传统方案：必须构造对象，才能用decltype</p>
<blockquote>
<p>📌decltype()中出现的是 变量、对象、表达式、函数名、函数指针等，而不可以出现类型名</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//想获得普通函数 myfunc的返回值类型</span></span><br><span class="line">    <span class="function">A <span class="title">myobj</span><span class="params">(<span class="number">1</span>)</span></span>;<span class="comment">//创建对象</span></span><br><span class="line">    <span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;返回值类型:= &quot;</span> &lt;&lt;</span><br><span class="line">    <span class="built_in">type_id_with_cvr</span>&lt;</span><br><span class="line">    <span class="keyword">decltype</span>(myobj.<span class="built_in">myfunc</span>())&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">     &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现代方法：decltype配合declval，无需创建对象</p>
<blockquote>
<p>📌declval()获得右值引用，可以“骗过”编译器，相当于创建了一个假的对象，从而直接使用该类型的成员函数</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;返回值类型:= &quot;</span> &lt;&lt;</span><br><span class="line">    type_id_with_cvr&lt;</span><br><span class="line">    <span class="keyword">decltype</span>(std::<span class="built_in">declval</span>&lt;A&gt;().<span class="built_in">myfunc</span>())&gt;()</span><br><span class="line">    .<span class="built_in">pretty_name</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>函数指针推导</strong>：刚刚的成员方法返回类型推导比较简单，考虑这样一种情况，函数模板内使用了一个函数指针，返回的就是函数指针的返回值。但是这个函数模板是通用的，也就是各种各样的函数指针它都能接收，那么这个时候返回值类型是不确定的，此时的函数模板该如何定义呢？</p>
<p>解决方案就是，推导函数指针的返回值类型，推导出的类型来作为函数模板的返回类型。</p>
<p>有两种方式实现这一思路，其中一个就是decltype搭配declval。</p>
</li>
</ul>
<p>方式一：decltype + declval</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">myfunc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T_F, <span class="keyword">typename</span>... U_Args&gt;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">declval</span>&lt;T_F&gt;()  (<span class="built_in">declval</span>&lt;U_Args&gt;()...))</span><br><span class="line"><span class="built_in">TestFnRtnTmp1</span>(T_F func, U_Args... args) &#123;</span><br><span class="line">    <span class="keyword">auto</span> rtnvalue = <span class="built_in">func</span>(args...);</span><br><span class="line">    <span class="keyword">return</span> rtnvalue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> result = <span class="built_in">TestFnRtnTmp1</span>(myfunc, <span class="number">5</span>, <span class="number">8</span>);</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式二：尾置返回类型 + auto关键字</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">myfunc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T_F, <span class="keyword">typename</span>... U_Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">TestFnRtnTmp2</span><span class="params">(T_F func, U_Args... args)</span></span></span><br><span class="line"><span class="function"> -&gt; <span class="title">decltype</span><span class="params">(func(args...))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> rtnvalue = <span class="built_in">func</span>(args...);</span><br><span class="line">    <span class="keyword">return</span> rtnvalue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> result = <span class="built_in">TestFnRtnTmp2</span>(myfunc, <span class="number">5</span>, <span class="number">8</span>);</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处主要解释方式一。<code>declval&lt;T_F&gt;()</code>：T_F是函数指针<code>int(*)(int, int)</code>类型，那么在编译期declval可以推断出其是函数指针并返回<code>int(*&amp;&amp;)(int,int)</code>，即函数指针的右值类型，相当于实例化了一个假的函数指针对象，可以输入参数。所以在<code>decltype(函数指针右值引用())</code>，就可以得到返回值类型。也就是</p>
<p><code>decltype(declval&lt;T_F&gt;() (declval&lt;U_Args&gt;()...))</code></p>
<p>而直接用<code>decltype(T_F(U_Args)...)</code>是不行的，会报错，因为decltype()只能接收实例，不能接收类型。</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用加号+进行字符串拼接</span></span><br><span class="line"><span class="function">string <span class="title">compose</span><span class="params">(<span class="type">const</span> string&amp;name, <span class="type">const</span> string&amp; domain)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> name + <span class="string">&#x27;@&#x27;</span> + domain;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//常用操作</span></span><br><span class="line">string name = <span class="string">&quot;Niels Stroustrup&quot;</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">m3</span>()&#123;</span><br><span class="line">  string s = name.<span class="built_in">substr</span>(<span class="number">6</span>,<span class="number">10</span>);   <span class="comment">//s=&quot;Stroustrup&quot;                   取子串，从索引6开始的10个字符</span></span><br><span class="line">  name.<span class="built_in">replace</span>(<span class="number">0</span>,<span class="number">5</span>,<span class="string">&quot;nicholas&quot;</span>);   <span class="comment">//name变为&quot;nicholas Stroustrup&quot;     替换，从索引0开始的5个字符</span></span><br><span class="line">  name[<span class="number">0</span>] = <span class="built_in">toupper</span>(name[<span class="number">0</span>]);     <span class="comment">//name变为&quot;Nicholas Stroustrup&quot;     大写</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//string与字符串字面值的比较</span></span><br><span class="line">string incantation;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">respond</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(answer == incantation)&#123;</span><br><span class="line">    <span class="comment">//执行一些操作</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (answer == <span class="string">&quot;yes&quot;</span>)&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只读形式的C风格字符串</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">print</span>(<span class="type">const</span> string&amp; s)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;For people who like printf: %s\n&quot;</span>, s.<span class="built_in">c_str</span>());</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;For people who like streams: &quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>📌标准库string定义了一个移动构造函数，因此，即使是以传值方式而不是传引用方式返回一个很长的string也会很高效。</p>
</blockquote>
<p>string对象除了有begin()和end()之外，还有rbegin()，rend()。同时还有cbegin()，cend()，表示的是const iterator。相应的，crbegin()，crend()表示const reverse iterator。</p>
<ul>
<li><p>短字符串优化(short-string optimization)技术：</p>
<blockquote>
<p>短字符串直接保存在string对象内部，而长字符串则保存在自由存储区中。</p>
</blockquote>
<p>因此对于这样的两个字符串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s1 &#123;<span class="string">&quot;Annemarie&quot;</span>&#125;;             <span class="comment">//短字符串</span></span><br><span class="line">string s2 &#123;<span class="string">&quot;Annemarie Stroustrup&quot;</span>&#125;;  <span class="comment">//长字符串</span></span><br></pre></td></tr></table></figure>

<p>s1对象内部直接存在该字符串，而s2对象内部仅存储该字符串的地址，需要用到时则根据地址取值。</p>
<p>之所以采用这种实现方式，是因为运行时环境中内存分配代价较高，而大量长度不一的字符串会产生堆的内存碎片。</p>
<p>短字符串优化可以让栈承担短字符串，加快运行，同时规避长度过于分散的状况。</p>
</li>
<li><p>basic_string：</p>
<p>C++标准库中定义了通用字符串模板<code>basic_string</code>，string实际上是此模板用char类型实例化的一个别名</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Char&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">basic_string</span>&#123;</span><br><span class="line">  <span class="comment">//...类的功能实现</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> string = basic_string&lt;<span class="type">char</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>用户可以不局限于ascii码，利用basic_string定义任意字符类型的字符串。例如，我们有一个日文字符类型Jchar，则可以定义为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Jstring = basic_string&lt;Jchar&gt;;</span><br></pre></td></tr></table></figure>

<p>现在，就可以在Jstring——日文字符串上执行常见的字符串操作。</p>
</li>
<li><p>字符串转换函数</p>
<p>C函数atoi()、atol()面向的是C字符串，而不是C++的string类型。C++11增加了几个新的转换函数：</p>
<ul>
<li><p>stoi()、stol()、stoll()等把string转换成整数；</p>
</li>
<li><p>stof()、stod()等把string转换成浮点数；</p>
</li>
<li><p>to_string()把整数、浮点数转换成字符串。</p>
</li>
</ul>
</li>
</ul>
<h3 id="正则表达式的模式"><a href="#正则表达式的模式" class="headerlink" title="正则表达式的模式"></a>正则表达式的模式</h3><ul>
<li><p>正则表达式的特殊字符</p>
<table>
<thead>
<tr>
<th>.</th>
<th>任意单个字符（“通配符”）</th>
</tr>
</thead>
<tbody><tr>
<td>[</td>
<td>字符集开始</td>
</tr>
<tr>
<td>]</td>
<td>字符集结束</td>
</tr>
<tr>
<td>{</td>
<td>指定重复次数开始</td>
</tr>
<tr>
<td>}</td>
<td>指定重复次数结束</td>
</tr>
<tr>
<td>(</td>
<td>分组开始</td>
</tr>
<tr>
<td>)</td>
<td>分组结束</td>
</tr>
<tr>
<td>\</td>
<td>下一个字符有特殊含义</td>
</tr>
<tr>
<td>*</td>
<td>零或多次重复（后缀操作）</td>
</tr>
<tr>
<td>+</td>
<td>一或多次重复（后缀操作）</td>
</tr>
<tr>
<td>?</td>
<td>零或一次（后缀操作）</td>
</tr>
<tr>
<td>|</td>
<td>或</td>
</tr>
<tr>
<td>^</td>
<td>行开始；非</td>
</tr>
<tr>
<td>$</td>
<td>行结束</td>
</tr>
</tbody></table>
</li>
<li><p>重复</p>
<table>
<thead>
<tr>
<th>{n}</th>
<th>严格重复n次</th>
</tr>
</thead>
<tbody><tr>
<td>{n,}</td>
<td>重复n次或更多次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>至少重复n次，最多m次</td>
</tr>
<tr>
<td>*</td>
<td>零次或多次，即{0,}</td>
</tr>
<tr>
<td>+</td>
<td>一次或多次，即{1,}</td>
</tr>
<tr>
<td>?</td>
<td>零次或一次，即{0,1}</td>
</tr>
</tbody></table>
<p>模式匹配在遇见重复字符串时，还涉及贪心匹配和懒惰匹配。</p>
<ul>
<li><p>贪心匹配：默认情况下就是贪心匹配</p>
<p>原字符串：ababab，现在用模式(ab)*来匹配，模式匹配器总是查找最长匹配，会匹配到整个字符串ababab</p>
</li>
<li><p>懒惰匹配：在任何重复符号（?、 *、+及{ }）之后放一个后缀?，会使模式匹配器进入懒惰状态。</p>
<p>原字符串：ababab，现在用模式(ab) *?来匹配，模式匹配器会查找最短匹配，匹配到字符串中第一个ab</p>
</li>
</ul>
</li>
<li><p>字符集与字符集简写</p>
<p>正则表达式中，字符集必须用[: :]包围起来。例如[:digit:]匹配一个十进制数字。同时，如果是定义一个字符集，外边必须再包围一对方括号[ ]，比如，[^[:digit:]]匹配一个非十进制数字。</p>
<table>
<thead>
<tr>
<th>字符集</th>
<th>简写</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>alnum</td>
<td></td>
<td>任意字符数字字符</td>
</tr>
<tr>
<td>alpha</td>
<td></td>
<td>任意字母</td>
</tr>
<tr>
<td>blank</td>
<td></td>
<td>任意空白符，但不能是行分隔符</td>
</tr>
<tr>
<td>cntrl</td>
<td></td>
<td>任意控制字符</td>
</tr>
<tr>
<td>d</td>
<td>\d&#x3D;[[:d:]]</td>
<td>任意十进制数字</td>
</tr>
<tr>
<td>digit</td>
<td>\d&#x3D;[[:digit:]], \D&#x3D;[^[:digit:]]非十进制数字</td>
<td>任意十进制数字</td>
</tr>
<tr>
<td>graph</td>
<td></td>
<td>任意图形字符</td>
</tr>
<tr>
<td>lower</td>
<td>\l&#x3D;[[:lower:]]，\L&#x3D;[^[:lower:]]非大写字符，均非标准但常见</td>
<td>任意小写字符</td>
</tr>
<tr>
<td>print</td>
<td></td>
<td>任意可打印字符</td>
</tr>
<tr>
<td>punct</td>
<td></td>
<td>任意标点</td>
</tr>
<tr>
<td>s</td>
<td>\s&#x3D;[[:s:]]</td>
<td>任意空白符（空格、制表符等等）</td>
</tr>
<tr>
<td>space</td>
<td>\s&#x3D;[[:space:]], \S&#x3D;[^[:space:]]非空白符</td>
<td>任意空白符</td>
</tr>
<tr>
<td>upper</td>
<td>\u&#x3D;[[:upper:]]，\U&#x3D;[^[:upper:]]非大写字符，均非标准但常见</td>
<td>任意大写字符</td>
</tr>
<tr>
<td>w</td>
<td>\w&#x3D;[[:w:]]，</td>
<td>任意单词字符（字母、数字字符再加下划线）</td>
</tr>
<tr>
<td>xdigit</td>
<td></td>
<td>任意十六进制数字字符</td>
</tr>
</tbody></table>
</li>
<li><p>正则表达式分组</p>
<p>( )引发了分组的概念，也就是正则表达式中被( )包起来的内容构成了一个group，匹配时作为一个子模式匹配。</p>
<p>比如想匹配XML语言，模式可以设计为<code>&lt;(.*?)&gt;(.*?)&lt;/\1&gt;</code>，这里有三个分组，其中\1是第三个，含义为“与分组1一样”。而且使用了懒惰匹配<code>.*?</code>，这样，当面临下面的输入：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Always look for the &lt;b&gt;bright&lt;/b&gt; side of &lt;b&gt;life&lt;/b&gt;.</span><br></pre></td></tr></table></figure>

<p>不使用 <em>?，而是单独</em>的话，贪心匹配会将第一个&lt;和最后一个&gt;配对。</p>
<p>但懒惰匹配的结果将是&lt;b&gt;bright&lt;&#x2F;b&gt;和&lt;b&gt;life&lt;&#x2F;b&gt;这两个符合程序员预期的结果。</p>
<p>然而，如果<strong>想要括号，但是不需要完全匹配到括号中的内容</strong>，可以用<code>(?</code></p>
<ul>
<li><p>(?:pattern)：匹配pattern但不获取结果，即非获取匹配。例如“industr(?:y|ies)”可以用来替代”industry|industries”。</p>
</li>
<li><p>(?&#x3D;pattern)：正向肯定预查，例如”Windows(?&#x3D;95|98|NT|2000)”能匹配”Windows2000”中的Windows，但不能匹配”Windows3.1”中的Windows。</p>
</li>
<li><p>(?!pattern)：正向否定预查，例如”Windows(?!95|98|NT|2000)”能匹配”Windows3.1”中的Windows，但不能匹配”Windows2000”中的Windows。</p>
</li>
<li><p>(?&lt;&#x3D;pattern)：反向肯定预查，与正向肯定预查类似，但方向相反，例如“(?&lt;&#x3D;95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”</p>
</li>
<li><p>(?&lt;!pattern)：反向否定预查，与正向否定预查类似，但方向相反，例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”</p>
</li>
</ul>
</li>
</ul>
<h3 id="C-中的正则API"><a href="#C-中的正则API" class="headerlink" title="C++中的正则API"></a>C++中的正则API</h3><p>标准库提供了&lt;regex&gt;类，从而支持正则表达式。比如可以用下面代码定义一个正则表达式模式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">regex <span class="title">pat</span> <span class="params">(<span class="string">R&quot;(\w&#123;2&#125;\s*\d&#123;5&#125;(-\d&#123;4&#125;)?)&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>上面代码定义了一个美国邮政编码模式：XXddddd-dddd。其中后面的-dddd是可有可无的。以两个字母开始<code>\w&#123;2&#125;</code>，后面是任意个空白符<code>\s*</code>，再接下来是5个数字<code>\d&#123;5&#125;</code>，然后是可选的破折号加四位数字<code>-\d&#123;4&#125;</code>。</p>
<ul>
<li><p>常用正则匹配函数</p>
<ul>
<li><p>regex_match( )：将正则表达式与一个（已知长度的）字符串进行匹配，判断是否完全匹配。如果完全匹配则返回true，否则false。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string str = <span class="string">&quot;twinkle1993&quot;</span>;</span><br><span class="line"><span class="function">regex <span class="title">r</span><span class="params">(<span class="string">&quot;[a-z0-9]+&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> is_match = <span class="built_in">regex_match</span>(str, r); <span class="comment">//true</span></span><br><span class="line">is_match = <span class="built_in">regex_match</span>(str.<span class="built_in">begin</span>()+<span class="number">7</span>, str.<span class="built_in">end</span>(), <span class="built_in">regex</span>(<span class="string">&quot;\\d+&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">smatch sm;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">regex_match</span>(str.<span class="built_in">cbegin</span>()+<span class="number">5</span>, str.<span class="built_in">cend</span>(), sm, <span class="built_in">regex</span>(<span class="string">&quot;([a-z]+)(\\d+)&quot;</span>)))</span><br><span class="line">&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;字符串: &quot;</span> &lt;&lt; &amp;str[<span class="number">5</span>] &lt;&lt; <span class="string">&quot; 匹配成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;匹配字符串个数: &quot;</span> &lt;&lt; sm.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;分别为: &quot;</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> aa : sm)</span><br><span class="line">    cout &lt;&lt; aa.<span class="built_in">str</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  cout &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出结果：</span></span><br><span class="line"><span class="comment">    字符串: le1993匹配成功</span></span><br><span class="line"><span class="comment">    匹配字符串个数：3</span></span><br><span class="line"><span class="comment">    分别为：le1993 le 1993</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">cmatch cm;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">regex_match</span>(str.<span class="built_in">c_str</span>(), cm, <span class="built_in">regex</span>(<span class="string">&quot;([a-z]+)(\\d+)&quot;</span>))) </span><br><span class="line">&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;字符串：&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot; 匹配成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;匹配字符串个数：&quot;</span> &lt;&lt; cm.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;分别为：&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> aa : cm)</span><br><span class="line">    cout &lt;&lt; aa.<span class="built_in">str</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出结果：</span></span><br><span class="line"><span class="comment">    字符串：twinkle1993 匹配成功！</span></span><br><span class="line"><span class="comment">    匹配字符串个数：3</span></span><br><span class="line"><span class="comment">    分别为：twinkle1993 twinkle 1993</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>其中，smatch相当于vector&lt;string&gt;，其中存储所有匹配的结果。而cmatch则是C风格的smatch。</p>
<p>sm中的第一个元素sm[0]，是贪心的最长匹配（即输入字符串），之后的则是字符串中依据正则表达式group的分组。</p>
<p>smatch对象除了有size()，能索引之外，还有两个比较重要的成员函数：</p>
<p><code>::prefix()</code>：用于获取输入目标字符串中，匹配字符串之前的字符串</p>
<p><code>::suffix()</code>：用于获取输入目标字符串中，匹配字符串之后的字符串</p>
</li>
<li><p>regex_search( )：在一个（任意长）数据流中搜索与正则表达式匹配的字符串</p>
<p>匹配到一个子字符串即返回。sm中第一个元素sm[0]，是匹配到的子字符串，之后的元素则是子字符串中，依据正则表达式group的分组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  string str = <span class="string">&quot;twinkle1993winkle1993inkle1993&quot;</span>;</span><br><span class="line">  smatch sm;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = str.<span class="built_in">cbegin</span>(); <span class="built_in">regex_search</span>(it, str.<span class="built_in">cend</span>(), sm, <span class="built_in">regex</span>(<span class="string">&quot;([a-z]+)1&quot;</span>)); it = sm.<span class="built_in">suffix</span>().first) </span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;字符串：&quot;</span> &lt;&lt; &amp;*it &lt;&lt; <span class="string">&quot; 匹配成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;匹配字符子串个数：&quot;</span> &lt;&lt; sm.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;分别为：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> aa : sm)</span><br><span class="line">      cout &lt;&lt; aa.<span class="built_in">str</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;字符串 &quot;</span> &lt;&lt; sm.<span class="built_in">str</span>() &lt;&lt; <span class="string">&quot; 前的字符串为：&quot;</span> &lt;&lt; sm.<span class="built_in">prefix</span>().<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;字符串 &quot;</span> &lt;&lt; sm.<span class="built_in">str</span>() &lt;&lt; <span class="string">&quot; 后的字符串为：&quot;</span> &lt;&lt; sm.<span class="built_in">suffix</span>().<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">字符串：twinkle1993winkle1993inkle1993 匹配成功！</span></span><br><span class="line"><span class="comment">匹配字符子串个数：2</span></span><br><span class="line"><span class="comment">分别为：twinkle1 twinkle</span></span><br><span class="line"><span class="comment">字符串 twinkle1 前的字符串为：</span></span><br><span class="line"><span class="comment">字符串 twinkle1 后的字符串为：993winkle1993inkle1993</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">字符串：993winkle1993inkle1993 匹配成功！</span></span><br><span class="line"><span class="comment">匹配字符子串个数：2</span></span><br><span class="line"><span class="comment">分别为：winkle1 winkle</span></span><br><span class="line"><span class="comment">字符串 winkle1 前的字符串为：993</span></span><br><span class="line"><span class="comment">字符串 winkle1 后的字符串为：993inkle1993</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">字符串：993inkle1993 匹配成功！</span></span><br><span class="line"><span class="comment">匹配字符子串个数：2</span></span><br><span class="line"><span class="comment">分别为：inkle1 inkle</span></span><br><span class="line"><span class="comment">字符串 inkle1 前的字符串为：993</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>当regex_search返回后，借助sm中的sm[0]].first和sm[0].second迭代器可以得到这个字符串在源字符串中出现的准确位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  string str = <span class="string">&quot;twinkle1993winkle1993inkle1993&quot;</span>;</span><br><span class="line">  smatch sm;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;正则表达式：([a-z]+)1&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = str.<span class="built_in">cbegin</span>(); <span class="built_in">regex_search</span>(it, str.<span class="built_in">cend</span>(), sm, <span class="built_in">regex</span>(<span class="string">&quot;([a-z]+)1&quot;</span>)); it = sm.<span class="built_in">suffix</span>().first) </span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;匹配字符子串：&quot;</span> &lt;&lt; sm[<span class="number">0</span>].<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;在源串对应索引：[&quot;</span> &lt;&lt; sm[<span class="number">0</span>].first-str.<span class="built_in">begin</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; sm[<span class="number">0</span>].second-str.<span class="built_in">begin</span>() &lt;&lt; <span class="string">&#x27;)&#x27;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">匹配字符子串：twinkle1</span></span><br><span class="line"><span class="comment">在源串对应索引：[0 8)</span></span><br><span class="line"><span class="comment">匹配字符子串：winkle1</span></span><br><span class="line"><span class="comment">在源串对应索引：[11 18)</span></span><br><span class="line"><span class="comment">匹配字符子串：inkle1</span></span><br><span class="line"><span class="comment">在源串对应索引：[21 27)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>regex_replace( )：在一个（任意长）数据流中搜索与正则表达式匹配的字符串并将其替换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> data[] = <span class="string">&quot;he...ll..o, worl..d!&quot;</span>;</span><br><span class="line"><span class="function">std::regex <span class="title">reg</span><span class="params">(<span class="string">&quot;\\.&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// output: hello, world!</span></span><br><span class="line">std::cout &lt;&lt; std::<span class="built_in">regex_replace</span>(data, reg, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> data[] = <span class="string">&quot;001-Neo,002-Lucia&quot;</span>;</span><br><span class="line"><span class="function">std::regex <span class="title">reg</span><span class="params">(<span class="string">&quot;(\\d+)-(\\w+)&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// output: 001 name=Neo,002 name=Lucia</span></span><br><span class="line">std::cout &lt;&lt; std::<span class="built_in">regex_replace</span>(data, reg, <span class="string">&quot;$1 name=$2&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>regex_iterator：遍历匹配结果和子匹配</p>
<p>上面的regex_search()函数可以让我们逐一迭代正则查找的所有匹配结果，而regex_iterator是达到相同目的的另一种方式。</p>
<p>regex_iterator不同于其它容器的迭代器，不需要.begin()，.end()来进行迭代。regex_iterator只有一个end值，只需要用默认的构造函数声明一个regex_iterator，就可以获得这个尾迭代器：尾迭代器会被隐式地初始化为end值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  string str = <span class="string">&quot;twinkle1993twink1993le1993&quot;</span>;</span><br><span class="line">  <span class="function">regex <span class="title">reg</span><span class="params">(<span class="string">&quot;([a-z]+)1&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (sregex_iterator <span class="built_in">it</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>(), reg), end; it != end; it++) </span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;匹配字符子串：&quot;</span> &lt;&lt; (*it)[<span class="number">0</span>].<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;在源串对应索引：[&quot;</span> &lt;&lt; (*it)[<span class="number">0</span>].first-str.<span class="built_in">begin</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; (*it)[<span class="number">0</span>].second-str.<span class="built_in">begin</span>() &lt;&lt; <span class="string">&#x27;)&#x27;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果：</span></span><br><span class="line"><span class="comment">    匹配字符子串：twinkle1</span></span><br><span class="line"><span class="comment">    在源串对应索引：[0 8)</span></span><br><span class="line"><span class="comment">    匹配字符子串：twink1</span></span><br><span class="line"><span class="comment">    在源串对应索引：[11 17)</span></span><br><span class="line"><span class="comment">    匹配字符子串：le1</span></span><br><span class="line"><span class="comment">    在源串对应索引：[20 23)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>regex_token_iterator：遍历未遍历部分</p>
<p>相比于regex_iterator，regex_token_iterator还可用于迭代正则表达式中的每个group。这里将这种正则中的子序列称为token。regex_token_iterator在有参数构造时比regex_iterator多一个参数，此参数用于指示要匹配哪个group。</p>
<ul>
<li><p>如果该参数为-1，表示感兴趣的是能够匹配正则表达式的子字符串之间的字符串。</p>
</li>
<li><p>如果该参数为0，表示还是要完整匹配整个正则表达式（该参数默认值为0，因此可以构造时不赋值）。</p>
</li>
<li><p>如果该参数为其它数字，则表示要匹配的是正则表达式中的第几个组，如1就是匹配第一个group。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  string str = <span class="string">&quot;11twinkle1993teink1992le1994&quot;</span>;</span><br><span class="line">  <span class="function">regex <span class="title">reg</span><span class="params">(<span class="string">&quot;([a-z]+)1&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (sregex_token_iterator <span class="built_in">it</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>(), reg), end; it != end; it++) <span class="comment">//default=0</span></span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;匹配到的字符串为：&quot;</span> &lt;&lt; it-&gt;<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (sregex_token_iterator <span class="built_in">it</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>(), reg, <span class="number">1</span>), end; it != end; it++) </span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;匹配到的字符串为：&quot;</span> &lt;&lt; it-&gt;<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (sregex_token_iterator <span class="built_in">it</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>(), reg, <span class="number">-1</span>), end; it != end; it++) </span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;匹配到的字符串为：&quot;</span> &lt;&lt; it-&gt;<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果：</span></span><br><span class="line"><span class="comment">    匹配到的字符串为：twinkle1</span></span><br><span class="line"><span class="comment">    匹配到的字符串为：teink1</span></span><br><span class="line"><span class="comment">    匹配到的字符串为：le1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    匹配到的字符串为：twinkle</span></span><br><span class="line"><span class="comment">    匹配到的字符串为：teink</span></span><br><span class="line"><span class="comment">    匹配到的字符串为：le</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    匹配到的字符串为：11</span></span><br><span class="line"><span class="comment">    匹配到的字符串为：993</span></span><br><span class="line"><span class="comment">    匹配到的字符串为：992</span></span><br><span class="line"><span class="comment">    匹配到的字符串为：994</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="I-x2F-O流"><a href="#I-x2F-O流" class="headerlink" title="I&#x2F;O流"></a>I&#x2F;O流</h2><ul>
<li><p>ostream对象将有类型的对象转换为一个字符（字节）流</p>
<p>cout是ostream类的一个对象，ofstream，ostringstream均继承自ostream类型</p>
</li>
<li><p>istream对象将一个字符（字节）流转换为有类型的对象</p>
<p>cin是istream类的一个对象，ifstream，istringstream均继承自istream类型</p>
</li>
</ul>
<p>所以，ifstream, istringstream和cin的用法区别不大，ofstream，ostringstream和cout的用法也区别不大。</p>
<blockquote>
<p>📌IO对象是不能进行拷贝和赋值的。<br>ofstream out1,ou2;<br>out1 &#x3D; out2;                        &#x2F;&#x2F;错误：不能对流对象赋值<br>ofstream print(ofstream);    &#x2F;&#x2F;错误：不能初始化ofstream参数<br>out2 &#x3D; print(out2);              &#x2F;&#x2F;错误：不能拷贝流对象<br>由于不能拷贝IO对象，因此<strong>不能把函数参数和返回类型设置为流类型</strong>，通常以引用方式传递和返回。同时，读写一个IO对象会改变其状态，因此<strong>传递和返回的引用不能是const的</strong>。</p>
</blockquote>
<h3 id="cin-cout"><a href="#cin-cout" class="headerlink" title="cin cout"></a>cin cout</h3><ul>
<li><p>cout标准输出流</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">7000</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;the value is &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cout也可以格式化输出</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">double</span> d = <span class="number">123.456</span>;</span><br><span class="line">cout &lt;&lt; d &lt;&lt; <span class="string">&quot;;&quot;</span>                     <span class="comment">//默认格式</span></span><br><span class="line">     &lt;&lt; scientific &lt;&lt; d &lt;&lt; <span class="string">&quot;;&quot;</span>       <span class="comment">//1.23e2，科学计数法风格</span></span><br><span class="line">     &lt;&lt; hexfloat &lt;&lt; d &lt;&lt; <span class="string">&quot;;&quot;</span>         <span class="comment">//十六进制</span></span><br><span class="line">     &lt;&lt; fixed &lt;&lt; d &lt;&lt; <span class="string">&quot;;&quot;</span>            <span class="comment">//定点数</span></span><br><span class="line">     &lt;&lt; defaultfloat &lt;&lt; d &lt;&lt; <span class="string">&quot;\n&quot;</span>;   <span class="comment">//默认float格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//想让浮点数截断输出，可以用precision()，会自动四舍五入</span></span><br><span class="line">cout.<span class="built_in">precision</span>(<span class="number">8</span>);<span class="comment">//一个数最多显示8个数字，如果整数部分超过8个，就仅保留整数</span></span><br><span class="line">cout &lt;&lt; <span class="number">1234.56789</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">123456</span> &lt;&lt; endl; <span class="comment">//输出结果：1234.5679 123456</span></span><br><span class="line"></span><br><span class="line">cout.<span class="built_in">precision</span>(<span class="number">8</span>);<span class="comment">//一个数最多显示8个数字，如果整数部分超过8个，就仅保留整数</span></span><br><span class="line">cout &lt;&lt; <span class="number">1234.56789</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">123456</span> &lt;&lt; endl; <span class="comment">//输出结果：1235 123456</span></span><br></pre></td></tr></table></figure>

<p>需要小心这样一种可能不符合预期的情况</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">k</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> b = <span class="string">&#x27;b&#x27;</span>;           <span class="comment">//此处char被隐式转换成了int，&#x27;b&#x27;的ASCII码值为98</span></span><br><span class="line">  <span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&#x27;a&#x27;</span> &lt;&lt; b &lt;&lt; c; <span class="comment">//输出结果：a98c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>cin标准输入流</p>
<p>cin将字符串读为特定类型的值，并会忽略起始的空白符。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello_line</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Please enter your name\n&quot;</span>;</span><br><span class="line">  string str;</span><br><span class="line">  cin &gt;&gt; str;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Hello,&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入Eric</span></span><br><span class="line"><span class="comment">//输出Hello, Eric!</span></span><br></pre></td></tr></table></figure>

<p>但是，默认情况下，空白符（如空格或换行）会终止输入。因此输入Eric Bloodaxe，仍然只会回应Hello, Eric！</p>
<p>这种情况下，可以用函数getline()来读取一整行（包括结束的换行符），例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello_line</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Please enter your name\n&quot;</span>;</span><br><span class="line">  string str;</span><br><span class="line">  <span class="built_in">getline</span>(cin, str);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Hello,&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入Eric Bloodaxe</span></span><br><span class="line"><span class="comment">//输出Hello, Eric Bloodaxe!</span></span><br></pre></td></tr></table></figure>

<p>行尾的换行符被丢掉了，因此接下来cin会从下一行开始。</p>
</li>
</ul>
<h4 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h4><p>ostream对象可以通过tie( )函数关联在一个istream对象上。关联的作用在于缓冲区的实时刷新。考虑这样的场景，通过一个istream获取一些字符，之后想将其放入ostream对象中。而且在这个过程中，希望做到每通过istream接收一个字符，就会让ostream对象输出一个字符，也就是实时刷新。</p>
<p>如果不用关联的话，由于一级二级缓存的存在，istream接收的字符不会实时出现在ostream对象中，而是程序结束时一股脑放入其中。但如果用tie关联，可以实时刷新缓冲区。ostream对象能够在istream对象有动作之前刷新缓冲区。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有关联版本代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  std::ofstream ofs;</span><br><span class="line">  ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(&amp;ofs);</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="keyword">while</span>(cin &gt;&gt; c)&#123;</span><br><span class="line">    ofs &lt;&lt; c;</span><br><span class="line">  &#125;</span><br><span class="line">  ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无关联版本代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  std::ofstream ofs;</span><br><span class="line">  ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="keyword">while</span>(cin &gt;&gt; c)&#123;</span><br><span class="line">    ofs &lt;&lt; c;</span><br><span class="line">  &#125;</span><br><span class="line">  ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tie()的两个重载：<br>ostream* tie ( ) const;                &#x2F;&#x2F;返回指向绑定的输出流的指针。<br>ostream* tie ( ostream* tiestr ); &#x2F;&#x2F;将tiestr指向的输出流绑定到该对象上，并返回一个绑定的输出流指针。</p>
</blockquote>
<p>无参形态的关联：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*cin.<span class="built_in">tie</span>() &lt;&lt; <span class="string">&quot;There will be some new words&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="I-x2F-O状态"><a href="#I-x2F-O状态" class="headerlink" title="I&#x2F;O状态"></a>I&#x2F;O状态</h3><p>IO操作可能发生错误。而条件状态可以帮助我们访问当前流的状态，以及发生了何种错误，是否可修正。</p>
<table>
<thead>
<tr>
<th><code>::iostate</code></th>
<th>iostate是表示当前流状态的类型，下面的badbit,failbit,eofbit,goodbit都属于iostate</th>
</tr>
</thead>
<tbody><tr>
<td><code>::badbit</code></td>
<td>指出流已崩溃，是四种状态中唯一不可恢复的错误</td>
</tr>
<tr>
<td><code>::failbit</code></td>
<td>指出IO操作失败了，如期望读取数值却读出一个字符这样的错误</td>
</tr>
<tr>
<td><code>::eofbit</code></td>
<td>指出流到达了文件结束，如果到达文件结束位置，eofbit和failbit都会被置位</td>
</tr>
<tr>
<td><code>::goodbit</code></td>
<td>指出流未处于错误状态。值为0.</td>
</tr>
<tr>
<td><code>s.eof()</code></td>
<td>若流s的eofbit置位，则返回true</td>
</tr>
<tr>
<td><code>s.fail()</code></td>
<td>若流s的failbit置位，则返回true</td>
</tr>
<tr>
<td><code>s.bad()</code></td>
<td>若流s的badbit置位，则返回true</td>
</tr>
<tr>
<td><code>s.good()</code></td>
<td>若流s处于有效状态，则返回true</td>
</tr>
<tr>
<td><code>s.clear()</code></td>
<td>将流s中所有条件状态位复位，则流的状态设置为有效，返回void</td>
</tr>
<tr>
<td><code>s.clear(flags)</code></td>
<td>根据flags标志位，将流s中对应条件状态位复位。flags类型为<code>::iostate</code>，返回void</td>
</tr>
<tr>
<td><code>s.setstate(flags)</code></td>
<td>根据flags标志位，将流s中对应条件状态位置位。flags类型为<code>::iostate</code>，返回void</td>
</tr>
<tr>
<td><code>s.rdstate()</code></td>
<td>返回流s的当前条件状态，返回类型为<code>::iostate</code></td>
</tr>
<tr>
<td><code>cin.sync()</code></td>
<td>清除输入缓冲区，成功时返回0，失败时barbit置位，函数返回-1</td>
</tr>
<tr>
<td><code>cin.ignore(numeric_limits&lt;std::streamsize&gt;::max(), &#39;\n&#39;)</code></td>
<td>清除输入缓冲区的当前行。其中<code>cin.ignore()</code>不输入参数，会清楚一个字符，<code>numeric_limits&lt;std::streamsize&gt;::max()</code>是climits头文件定义的流规格最大值，也可以用一个足够大的整数代替它。</td>
</tr>
</tbody></table>
<ul>
<li><p>判断流是否发生错误</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  cin &gt;&gt; a;</span><br><span class="line">  <span class="keyword">if</span>(cin.<span class="built_in">rdstate</span>() == ios::goodbit)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入数据的类型正确&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(cin.<span class="built_in">rdstate</span>() == ios_base::failbit)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入数据的类型错误，非致命错误，可清除输入缓冲区挽回&quot;</span> &lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而如果不判断出错类型，只想判断这个流是否处于良好状态，可以直接将其用作条件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(cin &gt;&gt; word)&#123;</span><br><span class="line">  <span class="comment">// ok: 读操作成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>管理条件状态</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> old_state = cin.<span class="built_in">rdstate</span>();  <span class="comment">//记住cin的当前状态</span></span><br><span class="line">cin.<span class="built_in">clear</span>();                     <span class="comment">//使cin有效</span></span><br><span class="line"><span class="built_in">process_input</span>(cin);              <span class="comment">//使用cin</span></span><br><span class="line">cin.<span class="built_in">setstate</span>(old_state);         <span class="comment">//将cin置为原有状态</span></span><br></pre></td></tr></table></figure>

<p>为了复位单一的条件状态位，首先用rdstate读出当前状态，然后用位操作将所需位复位，来生成新的状态。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将failbit和badbit复位，但保持eofbit不变</span></span><br><span class="line">cin.<span class="built_in">clear</span>(cin.<span class="built_in">rdstate</span>() &amp; ~cin.failbit &amp; ~cin.badbit);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="流运算符重载"><a href="#流运算符重载" class="headerlink" title="流运算符重载"></a>流运算符重载</h3><p>类型可以自定义输入流和输出流操作。比如自己写了一个Entry类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line">  string name;</span><br><span class="line">  <span class="type">int</span> number;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>&lt;&lt;仅对应ostream</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> Entry&amp; e)&#123;</span><br><span class="line">  <span class="keyword">return</span> os &lt;&lt; <span class="string">&quot;&#123;\&quot;&quot;</span> &lt;&lt; e.name &lt;&lt; <span class="string">&quot;\&quot;,&quot;</span> &lt;&lt; e.number &lt;&lt; <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出运算符重载接受一个输出流（引用）作为第一个参数，输出完毕后，返回此流的引用</strong>。</p>
</li>
<li><p>&gt;&gt;仅对应istream</p>
<p>输入运算符要复杂的多，因为必须检查格式是否正确。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入了&#123;&quot;name&quot;, number&#125;，希望把“name”赋值给name，number赋值给number</span></span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; is, Entry&amp; e)</span><br><span class="line">  <span class="comment">//读取&#123;&quot;name&quot;,number&#125;，注意，正确格式包含&#123;&quot; &quot;, 和&#125;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> c,c2;</span><br><span class="line">  <span class="keyword">if</span>(is&gt;&gt;c &amp;&amp; c==<span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; is&gt;&gt;c2 &amp;&amp; c2==<span class="string">&#x27;&quot;&#x27;</span>)<span class="comment">//以一个&#123;&quot;开始</span></span><br><span class="line">  &#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">while</span>(is.<span class="built_in">get</span>(c) &amp;&amp; c!=<span class="string">&#x27;&quot;&#x27;</span>)            <span class="comment">//is&gt;&gt;c默认跳过空白字符，但是get()不会</span></span><br><span class="line">      name+=c;</span><br><span class="line">    <span class="keyword">if</span>(is&gt;&gt;c &amp;&amp; c==<span class="string">&#x27;,&#x27;</span>)&#123;</span><br><span class="line">      <span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(is&gt;&gt;number&gt;&gt;c &amp;&amp; c==<span class="string">&#x27;&#125;&#x27;</span>)         <span class="comment">//读取数和一个&#125;</span></span><br><span class="line">      &#123;</span><br><span class="line">        e = &#123;name, number&#125;;               <span class="comment">//读入的值赋予Entry对象</span></span><br><span class="line">        <span class="keyword">return</span> is;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  is.<span class="built_in">setstate</span>(ios_base::failbit);         <span class="comment">//格式不对，将流状态置为fail</span></span><br><span class="line">  <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输入运算符重载接受一个输入流（引用）作为第一个参数，输入完毕后，返回此流的引用</strong>。</p>
</li>
</ul>
<h3 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h3><p>在&lt;fstream&gt;中，标准库提供了读写文件数据的流：</p>
<ol>
<li><p>ifstream用于从文件中读取数据</p>
</li>
<li><p>ofstream用于向文件写入数据</p>
</li>
<li><p>fstream用于读写文件</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>fstream fstrm;</th>
<th>创建一个未绑定的文件流</th>
</tr>
</thead>
<tbody><tr>
<td>fstream fstrm(s);</td>
<td>创建一个fstream，并打开名为s的文件。构造函数是explicit的，s可以是string类型或指向C风格字符串的指针。</td>
</tr>
<tr>
<td>fstream fstrm(s, mode);</td>
<td>与上面的构造函数类似，但按指定mode打开文件</td>
</tr>
<tr>
<td>fstrm.open(s)</td>
<td>打开名为s的文件，并将文件与fstrm绑定。构造函数是explicit的，s可以是string类型或指向C风格字符串的指针。如果调用open失败，会导致failbit被置位</td>
</tr>
<tr>
<td>fstrm.close( )</td>
<td>关闭fstrm绑定的文件。返回void。关闭完，fstrm就可以去打开其它文件了</td>
</tr>
<tr>
<td>fstrm.is_open( )</td>
<td>返回bool类型，指出与fstrm关联的文件是否成功打开，且是否尚未关闭</td>
</tr>
</tbody></table>
<ul>
<li><p>自动构造和析构</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对每个传递给程序的文件执行循环操作</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p = argv+<span class="number">1</span>; p != argv + argc; ++p)&#123;</span><br><span class="line">  <span class="function">ifstream <span class="title">input</span><span class="params">(*p)</span></span>;       <span class="comment">//创建输入流并打开文件</span></span><br><span class="line">  <span class="keyword">if</span>(input) &#123;</span><br><span class="line">    <span class="built_in">process</span>(input);         <span class="comment">//如果文件打开成功，“处理”此文件</span></span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;couldn&#x27;t open: &quot;</span> + <span class="built_in">string</span>(*p);</span><br><span class="line">&#125; <span class="comment">//每个循环步input都会离开作用域，因此会被销毁</span></span><br></pre></td></tr></table></figure>

<p>因为input是while循环的局部变量，它在每个循环步中都要创建和销毁一次。当一个fstream对象离开作用域时，与之关联的文件会自动关闭。</p>
</li>
<li><p>文件模式：打开文件时指定的mode</p>
<table>
<thead>
<tr>
<th>in</th>
<th>以读方式打开。只可以对ifstream或fstream对象设定。</th>
</tr>
</thead>
<tbody><tr>
<td>out</td>
<td>以写方式打开。只可以对ofstream或fstream对象设定。</td>
</tr>
<tr>
<td>trunc</td>
<td>截断文件。只有当out被设定时，才能设定trunc。此模式打开文件，文件的原内容会被丢弃</td>
</tr>
<tr>
<td>app</td>
<td>每次写操作前均定位到文件末尾。与trunc相悖</td>
</tr>
<tr>
<td>ate</td>
<td>打开文件后立即定位到文件末尾。可用于任何文件流对象。</td>
</tr>
<tr>
<td>binary</td>
<td>以二进制方式进行IO。可用于任何文件流对象。</td>
</tr>
</tbody></table>
<p>默认情况下，用out模式打开会自动trunc（即使没有显式写），所以会丢弃文件的原始内容。阻止一个ofstream清空文件内容的方法是out模式下指定app模式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在这几条语句中，file1都被截断</span></span><br><span class="line"><span class="function">ofstream <span class="title">out</span> <span class="params">(<span class="string">&quot;file1&quot;</span>)</span></span>; <span class="comment">//隐含以输出模式打开文件并截断文件</span></span><br><span class="line"><span class="function">ofstream <span class="title">out2</span> <span class="params">(<span class="string">&quot;file1&quot;</span>, ofstream::out)</span></span>; <span class="comment">//隐含地截断文件</span></span><br><span class="line"><span class="function">ofstream <span class="title">out3</span> <span class="params">(<span class="string">&quot;file1&quot;</span>, ofstream::out | ofstream::trunc)</span></span>;</span><br><span class="line"><span class="comment">//为了保留文件内容，必须显式指定app模式</span></span><br><span class="line"><span class="function">ofstream <span class="title">app</span><span class="params">(<span class="string">&quot;file2&quot;</span>, ofstream::app)</span></span>; <span class="comment">//隐含为输出模式</span></span><br><span class="line"><span class="function">ofstream <span class="title">app2</span><span class="params">(<span class="string">&quot;file2&quot;</span>, ofstream::out | ofstream::app)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="字符串流"><a href="#字符串流" class="headerlink" title="字符串流"></a>字符串流</h3><p>在sstream中，标准库提供了从string读取数据以及向string写入数据的流：</p>
<ul>
<li><p>istringstream用于从string中读取数据</p>
</li>
<li><p>ostringstream用于向string写入数据</p>
</li>
<li><p>stringstream用于读写string</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>sstream strm;</th>
<th>strm是一个未绑定的stringstream对象</th>
</tr>
</thead>
<tbody><tr>
<td>sstream strm(s);</td>
<td>strm是一个stringstream对象，保存string s的一个拷贝，此构造函数是explicit的</td>
</tr>
<tr>
<td>strm.str();</td>
<td>返回strm所保存的string的拷贝</td>
</tr>
<tr>
<td>strm.str(s);</td>
<td>将string s拷贝到strm中。返回void</td>
</tr>
</tbody></table>
<h4 id="istringstream"><a href="#istringstream" class="headerlink" title="istringstream"></a>istringstream</h4><p>考虑有这样一个文件，内容记录着一些人和他们的若干电话号码</p>
<blockquote>
<p>morgan 2015552368 8625550123<br>drew 9735550130<br>lee 6095550132 2015550175 8005550000</p>
</blockquote>
<p>现在希望提取这个文件，提取出每个人的人名和相应的电话号码。可以先每次第一行的字符串，之后将字符串交由istringstream，通过istringstream逐元素提取。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PersonInfo</span> &#123;</span><br><span class="line">  string name;</span><br><span class="line">  vector&lt;string&gt; phones;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">string line, word;</span><br><span class="line">vector&lt;PersonInfo&gt; people;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(cin, line))&#123;</span><br><span class="line">  PersonInfo info;</span><br><span class="line">  <span class="function">istringstream <span class="title">record</span><span class="params">(line)</span></span>;</span><br><span class="line">  record &gt;&gt; info.name;</span><br><span class="line">  <span class="keyword">while</span>(record &gt;&gt; word)</span><br><span class="line">    info.phones.<span class="built_in">push_back</span>(word);</span><br><span class="line">  people.<span class="built_in">push_back</span>(info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ostringstream"><a href="#ostringstream" class="headerlink" title="ostringstream"></a>ostringstream</h4><p>ostringstream可应用于想逐步构造输出，最后一起打印的场景。比如上面的例子，想要验证电话号码并改变其格式，并输出到一个新文件。其中，新文件只包含有效电话，无效的电话会被打印到错误信息中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假设事先已经有了valid和format函数，valid验证电话号码，format改变其格式</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;entry : people) &#123;</span><br><span class="line">  ostringstream formatted, badNums;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;nums : entry.phones)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">valid</span>(nums))&#123;</span><br><span class="line">      badNums &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; nums;</span><br><span class="line">    &#125; <span class="keyword">else</span>  </span><br><span class="line">      formatted &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; format(nums);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (badNums.<span class="built_in">str</span>().<span class="built_in">empty</span>())</span><br><span class="line">    os &lt;&lt; entry.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; formatted.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;input error: &quot;</span> &lt;&lt; entry.name &lt;&lt; <span class="string">&quot; invalid number(s) &quot;</span> &lt;&lt; badNums.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实用工具"><a href="#实用工具" class="headerlink" title="实用工具"></a>实用工具</h2><h3 id="12-常用内置算法"><a href="#12-常用内置算法" class="headerlink" title="12 常用内置算法"></a>12 常用内置算法</h3><h3 id="12-特殊容器"><a href="#12-特殊容器" class="headerlink" title="12 特殊容器"></a>12 特殊容器</h3><p>C++标准库中提供了若干种容器，它们与STL框架并非完全契合，比如</p>
<table>
<thead>
<tr>
<th>array&lt;T,N&gt;</th>
<th>是一段固定尺寸且连续分配的序列，包含N个T类型的元素；隐式地转换成T*</th>
</tr>
</thead>
<tbody><tr>
<td>pair&lt;T,U&gt;</td>
<td>两个元素，类型分别是T和U</td>
</tr>
<tr>
<td>tuple&lt;T…&gt;</td>
<td>是一段序列，存放着任意类型地任意个元素</td>
</tr>
<tr>
<td>basic_string&lt;C&gt;</td>
<td>是一段字符的序列，字符的类型是C；提供字符串操作</td>
</tr>
<tr>
<td>valarray&lt;T&gt;</td>
<td>是一个数组，包含T类型的数值；提供数值操作</td>
</tr>
</tbody></table>
<h4 id="array"><a href="#array" class="headerlink" title="array"></a>array</h4><p>array可以理解为一个<strong>增强版的内置数组</strong>，元素数量在编译期指定，位于栈中或者对象内，也可以位于静态存储空间中。因此，使用array的时空代价并不比使用内置数组大。</p>
<p>增强的体现在于：1. 不会隐式地转换成指针（因为很多时候开发者并不希望自动转换）；2. 提供了一些便于操作的函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>,3&gt; a1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; <span class="comment">//初始值的数量不能多于array指定的元素数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//编译器不允许省略array的元素数量</span></span><br><span class="line">array&lt;<span class="type">int</span>&gt; ax = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;   <span class="comment">//错误！没有指定元素的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//元素的数量必须是一个常量表达式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  array&lt;string, n&gt; aa = &#123;<span class="string">&quot;John&#x27;s&quot;</span>, <span class="string">&quot;Queens&#x27;&quot;</span>&#125;;<span class="comment">//错误！array的元素数量必须是常量表达式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>避免隐式转换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Circle a1[<span class="number">10</span>];</span><br><span class="line">  array&lt;Circle, 10&gt; a2;</span><br><span class="line"></span><br><span class="line">  Shape* p1 = a1; <span class="comment">// 语法上正确，但是存在严重的隐患</span></span><br><span class="line">  Shape* p2 = a2; <span class="comment">// 报告语法错误；禁止&lt;Circle,10&gt;自动转换成Shape*类型，从而避免了风险</span></span><br><span class="line">  p1[<span class="number">3</span>].draw;     <span class="comment">// 程序极易发生错误，如果sizeof(Shape)&lt;sizeof(Circle)，</span></span><br><span class="line">                  <span class="comment">// 则通过Shape*指针调用Circle[]的下标运算会导致访问内存时产生错误的偏移量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>传递给需要指针的C风格函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>* p, <span class="type">int</span> sz)</span></span>;                    <span class="comment">// C风格的接口</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">  array&lt;<span class="type">int</span>,10&gt; a;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">f</span>(a, a.<span class="built_in">size</span>());                          <span class="comment">// 错误：此处不存在期望的隐式类型转换</span></span><br><span class="line">  <span class="built_in">f</span>(&amp;a[<span class="number">0</span>], a.<span class="built_in">size</span>());                      <span class="comment">// C风格的写法</span></span><br><span class="line">  <span class="built_in">f</span>(a.<span class="built_in">data</span>(), a.<span class="built_in">size</span>());                   <span class="comment">// C风格的写法</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> p = <span class="built_in">find</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">777</span>);  <span class="comment">// C++ STL风格德写法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h4><p>二进制位的数组，提高存储效率。</p>
<ul>
<li><p>可以用整数或者字符串来初始化bitset</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">bitset&lt;9&gt; bs1 &#123;<span class="string">&quot;110001111&quot;</span>&#125;;</span><br><span class="line">bitset&lt;9&gt; bs2 &#123;<span class="number">399</span>&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>各种位运算可以用在bitset上</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">bitset&lt;9&gt; bs3 = ~bs1;       <span class="comment">//求反：bs3 == &quot;001110000&quot;</span></span><br><span class="line">bitset&lt;9&gt; bs4 = bs1 &amp; bs3;  <span class="comment">//所有位都为0</span></span><br><span class="line">bitset&lt;9&gt; bs5 = bs3 &lt;&lt; <span class="number">2</span>;   <span class="comment">//左移：bs5 == &quot;111000000&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>反其道而行，可用成员函数<code>to_ullong()</code>或<code>to_string()</code>将bitset转为整数或者字符串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">binary</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">  bitset&lt;8*<span class="keyword">sizeof</span>(<span class="type">int</span>)&gt; b = i; <span class="comment">//一个字节8位，int占sizeof(int)个字节</span></span><br><span class="line">  cout &lt;&lt; b.<span class="built_in">to_string</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者也可以直接使用bitset的流运算符重载：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">binary2</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">  bitset&lt;8*<span class="keyword">sizeof</span>(<span class="type">int</span>)&gt; b = i;</span><br><span class="line">  cout &lt;&lt; b &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">tuple&lt;string,<span class="type">int</span>,<span class="type">double</span>&gt; t2 &#123;<span class="string">&quot;Sild&quot;</span>, <span class="number">123</span>, <span class="number">3.14</span>&#125;;  <span class="comment">// 显式地指定了类型</span></span><br><span class="line"><span class="keyword">auto</span> t = <span class="built_in">make_tuple</span>(string&#123;<span class="string">&quot;Herring&quot;</span>&#125;, <span class="number">10</span>, <span class="number">1.23</span>); <span class="comment">// 隐式地推断出类型是 tuple&lt;string, int, double&gt;</span></span><br><span class="line"></span><br><span class="line">string s = <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(t); <span class="comment">// 获取tuple的第一个元素：&quot;Herring&quot;</span></span><br><span class="line"><span class="type">int</span> x = <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(t);    <span class="comment">// 获取tuple的第二个元素：10</span></span><br><span class="line"><span class="type">double</span> d = <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(t); <span class="comment">// 获取tuple的第三个元素：1.23</span></span><br></pre></td></tr></table></figure>

<p>tuple的每一个元素对应一个编号，从0开始依次排列。要想**在编译时从tuple中选取元素，只能使用get&lt;1&gt;(t)的方式，而不能写成get(t,1)或t[1]**。</p>
<h3 id="13-时间"><a href="#13-时间" class="headerlink" title="13 时间"></a>13 时间</h3><p>标准库提供了chrono，负责处理时间，可以完成一些与时间有关的任务，比如可以用下面的程序完成最基本的计时：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> t0 = high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="built_in">do_work</span>();</span><br><span class="line"><span class="keyword">auto</span> t1 = high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">cout &lt;&lt; <span class="built_in">duration_cast</span>&lt;milliseconds&gt;(t1-t0).<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;msec\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>duration_cast将C++的time_point类型转换为公认的单位。</p>
<h3 id="14-函数适配器"><a href="#14-函数适配器" class="headerlink" title="14 函数适配器"></a>14 函数适配器</h3><blockquote>
<p>函数适配器接受一个函数作为它的参数，返回的结果是一个函数对象，可以通过这个函数对象调用原来的函数</p>
</blockquote>
<ul>
<li><p>bind( )：</p>
<p>顾名思义，此函数要将一些参数，绑定在函数上，以构造一个函数对象。可以通过bind实现偏函数，如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">cube</span><span class="params">(<span class="type">double</span>)</span></span>;          <span class="comment">//cube是一个函数</span></span><br><span class="line"><span class="keyword">auto</span> cube2 = <span class="built_in">bind</span>(cube, <span class="number">2</span>);   <span class="comment">//通过bind创建函数对象cube2</span></span><br><span class="line"><span class="comment">//因此，调用cube2()时，相当于调用了cube(2)</span></span><br></pre></td></tr></table></figure>

<p>而且，不必每次都绑定函数的全部参数，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> placeholds;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> string&amp;)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> g = <span class="built_in">bind</span>(f, <span class="number">2</span>, _1);    <span class="comment">//把f的第一个参数绑定为2</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">2</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="built_in">g</span>(<span class="string">&quot;hello&quot;</span>);                 <span class="comment">//等同于调用f(2, &quot;hello&quot;);</span></span><br></pre></td></tr></table></figure>

<p>其中，<code>_1</code>表示一个占位符，其在<code>std::placeholds</code>命名空间中。占位符指定了调用函数对象时的参数，对应了原函数的哪几个位置的参数。</p>
<ul>
<li><p>为重载函数绑定参数，<strong>必须显式</strong>地指定被绑定的是重载函数的哪个版本：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pow</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">pow</span><span class="params">(<span class="type">double</span>, <span class="type">double</span>)</span></span>;    <span class="comment">//重载了函数pow</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pow2 = <span class="built_in">bind</span>(pow, _1, <span class="number">2</span>);  <span class="comment">//错误：绑定的是哪个pow()?</span></span><br><span class="line"><span class="keyword">auto</span> pow2 = <span class="built_in">bind</span>((<span class="built_in">double</span>(*)(<span class="type">double</span>,<span class="type">double</span>))pow, _1, <span class="number">2</span>);<span class="comment">//正确，确切地指定了选用第二个pow</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>mem_fn( )：</p>
<p>将名字拉长，就是member function。这个函数的目的在于，将类中的成员函数提取出来，构造出一个函数对象。通过调用普通函数的方式，调用此函数对象，可以达到调用类成员函数的效果。换言之，<code>mem_fn()</code>可以被看作是一种从面向对象的调用到面向函数的调用的映射。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">user</span><span class="params">(Shape* p)</span></span>&#123;</span><br><span class="line">  p-&gt;<span class="built_in">draw</span>();</span><br><span class="line">  <span class="keyword">auto</span> draw = <span class="built_in">mem_fn</span>(&amp;Shape::draw);</span><br><span class="line">  <span class="built_in">draw</span>(p); <span class="comment">//等价于p-&gt;draw()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>某些算法需要它的操作以非成员函数的方式调用，mem_fn()通常用在这些算法中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">draw_all</span><span class="params">(vector&lt;Shape*&gt;&amp; v)</span></span>&#123;</span><br><span class="line">  for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">mem_fn</span>(&amp;Shape::draw));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，lambda表达式出现后，可以替代这样的绑定方式（因为匿名函数本质是函数对象），而且更为简单直观：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">draw_all</span><span class="params">(vector&lt;Shape*&gt;&amp; v)</span></span>&#123;</span><br><span class="line">  for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](Shape* p)&#123;p-&gt;<span class="built_in">draw</span>();&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>function：</p>
<p>前面的代码中，函数对象都被用auto关键字声明，也就是让编译器自己去推断函数对象的类型。实际上，标准库中是有办法手动制定函数对象的准确类型的，那就是使用<code>function</code>。要通过指定返回类型和参数类型，来确定一个function：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f1</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">double</span>)&gt; fct &#123;f1&#125;;<span class="comment">//初始化为f1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f2</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">user</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fct = [](<span class="type">double</span> d)&#123;<span class="keyword">return</span> <span class="built_in">round</span>(d);&#125;;</span><br><span class="line">  fct = f1;</span><br><span class="line">  fct = f2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="对象模型"><a href="#对象模型" class="headerlink" title="对象模型"></a>对象模型</h1><h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><h2 id="std-thread"><a href="#std-thread" class="headerlink" title="std::thread"></a>std::thread</h2><p>线程在<code>std::thread</code>对象创建时启动，对象里面的函数执行完毕后，线程也随之结束。使用C++线程库启动线程，就是构造<code>std::thread</code>对象。创建thread对象时需要传入有函数操作符（也就是括号运算符）的类型实例（即函数对象）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">background_task</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="built_in">do_something</span>();</span><br><span class="line">    <span class="built_in">do_something_else</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">background_task f;</span><br><span class="line"><span class="function">std::thread <span class="title">my_thread</span><span class="params">(f)</span></span>;</span><br></pre></td></tr></table></figure>

<p>函数对象会被复制到新线程的存储空间中，函数对象的执行和调用都在线程的内存空间中进行</p>
<h2 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a>共享数据</h2><h2 id="内存模型和原子操作"><a href="#内存模型和原子操作" class="headerlink" title="内存模型和原子操作"></a>内存模型和原子操作</h2><h1 id="代码技巧"><a href="#代码技巧" class="headerlink" title="代码技巧"></a>代码技巧</h1><h2 id="引用计数智能指针（WebRTC）"><a href="#引用计数智能指针（WebRTC）" class="headerlink" title="引用计数智能指针（WebRTC）"></a>引用计数智能指针（WebRTC）</h2><blockquote>
<p>WebRTC内实现了与shared_ptr相似的，支持引用计数的智能指针scoped_refptr。与shared_ptr不同之处在于，其把引用计数留给了资源对象来实现，因此更加灵活。</p>
</blockquote>
<p><a href="https://blog.csdn.net/ice_ly000/article/details/105629297">https://blog.csdn.net/ice_ly000/article/details/105629297</a></p>
<h2 id="pybind11"><a href="#pybind11" class="headerlink" title="pybind11"></a>pybind11</h2>]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
