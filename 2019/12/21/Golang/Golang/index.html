<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.12.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="记录Go语言的基础语法知识">
<meta property="og:type" content="article">
<meta property="og:title" content="Go语言基础">
<meta property="og:url" content="http://example.com/2019/12/21/Golang/Golang/index.html">
<meta property="og:site_name" content="OliverPai">
<meta property="og:description" content="记录Go语言的基础语法知识">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/golang-basic/image_-v0q2QWlX3.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/golang-basic/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86_tZ5L5K7RyB.jpg">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/golang-basic/image_klHnHNaXk-.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/golang-basic/image_Rjj_29L3So.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/golang-basic/image_xlY7fDYo9I.png">
<meta property="og:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/golang-basic/image__3aWsdTgIN.png">
<meta property="article:published_time" content="2019-12-21T05:22:57.000Z">
<meta property="article:modified_time" content="2022-07-23T12:40:20.807Z">
<meta property="article:author" content="OliverPai">
<meta property="article:tag" content="golang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/golang-basic/image_-v0q2QWlX3.png">


<link rel="canonical" href="http://example.com/2019/12/21/Golang/Golang/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2019/12/21/Golang/Golang/","path":"2019/12/21/Golang/Golang/","title":"Go语言基础"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Go语言基础 | OliverPai</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="OliverPai" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">OliverPai</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">落叶本就是假的</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#golang"><span class="nav-number">1.</span> <span class="nav-text"> Golang</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text"> 基础语法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-workspace"><span class="nav-number">2.1.</span> <span class="nav-text"> 1. Workspace</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-hello-world"><span class="nav-number">2.2.</span> <span class="nav-text"> 2. Hello World !</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.3.</span> <span class="nav-text"> 3. 变量与数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%8C%85package"><span class="nav-number">2.4.</span> <span class="nav-text"> 4. 包package</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E6%95%B0%E7%BB%84arrayslice"><span class="nav-number">2.5.</span> <span class="nav-text"> 5 数组array&amp;slice</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E5%87%BD%E6%95%B0%E5%BC%82%E5%B8%B8"><span class="nav-number">2.6.</span> <span class="nav-text"> 6 函数+异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E6%9D%A1%E4%BB%B6"><span class="nav-number">2.7.</span> <span class="nav-text"> 7 条件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E5%BE%AA%E7%8E%AF"><span class="nav-number">2.8.</span> <span class="nav-text"> 8 循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-map"><span class="nav-number">2.9.</span> <span class="nav-text"> 9 Map</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%E8%8C%83%E5%9B%B4range"><span class="nav-number">2.10.</span> <span class="nav-text"> 10 范围range</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-%E6%8C%87%E9%92%88"><span class="nav-number">2.11.</span> <span class="nav-text"> 11 指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-%E9%97%AD%E5%8C%85closure"><span class="nav-number">2.12.</span> <span class="nav-text"> 12 闭包closure</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">2.13.</span> <span class="nav-text"> 13 结构体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-%E6%8E%A5%E5%8F%A3interface"><span class="nav-number">2.14.</span> <span class="nav-text"> 14 接口interface</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-%E5%8F%8D%E5%B0%84"><span class="nav-number">2.15.</span> <span class="nav-text"> 15 反射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-%E5%B9%B6%E5%8F%91"><span class="nav-number">2.16.</span> <span class="nav-text"> 16 并发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-io%E7%BC%96%E7%A8%8B"><span class="nav-number">2.17.</span> <span class="nav-text"> 17 IO编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#171-%E6%96%87%E4%BB%B6io"><span class="nav-number">2.17.1.</span> <span class="nav-text"> 17.1 文件IO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#172-log%E5%8C%85%E8%BE%93%E5%87%BA%E6%97%A5%E5%BF%97"><span class="nav-number">2.17.2.</span> <span class="nav-text"> 17.2 log包输出日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#173-fmt%E5%8C%85"><span class="nav-number">2.17.3.</span> <span class="nav-text"> 17.3 fmt包</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">2.18.</span> <span class="nav-text"> 18 正则表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-go%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93"><span class="nav-number">2.19.</span> <span class="nav-text"> 19 go语言常用标准库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#191-time"><span class="nav-number">2.19.1.</span> <span class="nav-text"> 19.1 time</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#192-flag"><span class="nav-number">2.19.2.</span> <span class="nav-text"> 19.2 flag</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#193-strconv"><span class="nav-number">2.19.3.</span> <span class="nav-text"> 19.3 strconv</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#go%E8%AF%AD%E8%A8%80%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text"> Go语言底层原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#gmp%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.1.</span> <span class="nav-text"> GMP模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%83%E9%80%B8%E7%8E%B0%E8%B1%A1"><span class="nav-number">3.2.</span> <span class="nav-text"> 逃逸现象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#make%E5%92%8Cnew-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.3.</span> <span class="nav-text"> make和new 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">3.4.</span> <span class="nav-text"> 内存分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">3.5.</span> <span class="nav-text"> 垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#go%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%AD%E7%9A%84%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0"><span class="nav-number">3.5.1.</span> <span class="nav-text"> Go垃圾回收中的三色标记：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#go%E6%89%A7%E8%A1%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="nav-number">3.5.2.</span> <span class="nav-text"> Go执行垃圾回收具体流程：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#defer"><span class="nav-number">3.6.</span> <span class="nav-text"> defer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#defer%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">3.6.1.</span> <span class="nav-text"> defer的执行顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">3.6.2.</span> <span class="nav-text"> 函数的返回值初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#return%E5%92%8Cdefer%E8%B0%81%E5%85%88%E8%B0%81%E5%90%8E-%E6%9C%89%E5%90%8D%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E9%81%87%E8%A7%81defer%E6%83%85%E5%86%B5"><span class="nav-number">3.6.3.</span> <span class="nav-text"> return和defer谁先谁后 &amp; 有名函数返回值遇见defer情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#defer%E9%81%87%E8%A7%81panic"><span class="nav-number">3.6.4.</span> <span class="nav-text"> defer遇见panic</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#defer%E4%B8%AD%E5%8C%85%E5%90%ABpanic"><span class="nav-number">3.6.5.</span> <span class="nav-text"> defer中包含panic</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#defer%E4%B8%8B%E7%9A%84%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%8C%85%E5%90%AB%E5%AD%90%E5%87%BD%E6%95%B0"><span class="nav-number">3.6.6.</span> <span class="nav-text"> defer下的函数参数包含子函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7"><span class="nav-number">4.</span> <span class="nav-text"> 相关工具</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#grpc"><span class="nav-number">4.1.</span> <span class="nav-text"> gRPC</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="OliverPai"
      src="/images/avatar-star.png">
  <p class="site-author-name" itemprop="name">OliverPai</p>
  <div class="site-description" itemprop="description">求索与记录</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/OliverPai" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;OliverPai" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/12/21/Golang/Golang/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar-star.png">
      <meta itemprop="name" content="OliverPai">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OliverPai">
      <meta itemprop="description" content="求索与记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Go语言基础 | OliverPai">
      <meta itemprop="description" content="记录Go语言的基础语法知识">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Go语言基础
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-21 13:22:57" itemprop="dateCreated datePublished" datetime="2019-12-21T13:22:57+08:00">2019-12-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-23 20:40:20" itemprop="dateModified" datetime="2022-07-23T20:40:20+08:00">2022-07-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">记录Go语言的基础语法知识</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="golang"><a class="markdownIt-Anchor" href="#golang"></a> Golang</h1>
<h1 id="基础语法"><a class="markdownIt-Anchor" href="#基础语法"></a> 基础语法</h1>
<h2 id="1-workspace"><a class="markdownIt-Anchor" href="#1-workspace"></a> 1. Workspace</h2>
<ul>
<li>
<p>go(workspace)</p>
<p>-bin        存放二进制</p>
<p>-src         存放源文件</p>
<p><a target="_blank" rel="noopener" href="http://github.com" title="github.com">github.com</a></p>
<p>username</p>
<p>go_project_1</p>
<p>file_1</p>
<p>…</p>
<p>go_project_2</p>
<p>file_1</p>
<p>…</p>
<p>-pkg       存放安装的包</p>
</li>
<li>
<p>建立go语言的workspace前提是将GOPATH设置成了环境变量，可用go env查看GOPATH</p>
</li>
<li>
<p>go语言的工程结构比较严格，参见上面的文件树</p>
</li>
<li>
<p>可通过<a target="_blank" rel="noopener" href="http://godoc.org" title="godoc.org">godoc.org</a>查看可安装包，利用go get安装</p>
</li>
</ul>
<h2 id="2-hello-world"><a class="markdownIt-Anchor" href="#2-hello-world"></a> 2. Hello World !</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文件结构：包声明 → 导入包 → 函数</p>
<ul>
<li>
<p>包声明：指明文件属于哪个包，package main执行入口，每个应用程序都有package main</p>
</li>
<li>
<p>导入包需双引号，单引号会报错</p>
</li>
<li>
<p>无需分号</p>
</li>
</ul>
<h2 id="3-变量与数据类型"><a class="markdownIt-Anchor" href="#3-变量与数据类型"></a> 3. 变量与数据类型</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//MAIN TYPES</span></span><br><span class="line">  <span class="comment">//string</span></span><br><span class="line">  <span class="comment">//bool</span></span><br><span class="line">  <span class="comment">//int(对应CPU平台字长) int8 int16 int32 int64</span></span><br><span class="line">  <span class="comment">//uint(对应CPU平台字长) uint8 uint16 uint32 uint64 uintptr</span></span><br><span class="line">  <span class="comment">//byte - alias for uint8</span></span><br><span class="line">  <span class="comment">//rune - alias for int32</span></span><br><span class="line">  <span class="comment">//float32 float64</span></span><br><span class="line">  <span class="comment">//complex64 complex128</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*---------定义变量 第一种方法：var关键字---------*/</span></span><br><span class="line">  <span class="comment">/*格式：var + 变量名 + 数据类型 = 赋值*/</span></span><br><span class="line">  <span class="keyword">var</span> name_1 <span class="type">string</span> = <span class="string">&quot;oliver&quot;</span><span class="comment">//这里的string可省略，编译器可推断出它是string类型</span></span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">32</span><span class="comment">//编译器推断出是int类型</span></span><br><span class="line">  name_1 = <span class="string">&quot;Peter&quot;</span><span class="comment">//使用var关键字定义后可修改变量值</span></span><br><span class="line">  <span class="comment">/*使用const关键字*/</span></span><br><span class="line">  <span class="keyword">const</span> isCool = <span class="literal">true</span><span class="comment">//省略bool</span></span><br><span class="line">  <span class="comment">//isCool = false 不注释会报错</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*---------定义变量 第二种方法：冒号---------*/</span></span><br><span class="line">  <span class="comment">/*格式：变量名 := 赋值*/</span></span><br><span class="line">  name_2 := <span class="string">&quot;Pai&quot;</span></span><br><span class="line">  <span class="comment">/*多变量定义的简便写法*/</span></span><br><span class="line">  name_3,email := <span class="string">&quot;oliverPai&quot;</span>,<span class="string">&quot;oliver@gmail.com&quot;</span></span><br><span class="line"></span><br><span class="line">  fmt.Println(name_1,name_2,name_3,age,isCool,email)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>go语言中，变量声明不使用会报错</p>
</li>
<li>
<p>获取类型方法：fmt.Printf(“%T”,variables)</p>
</li>
<li>
<p>第一种方法可以在函数外声明变量，第二种方法只能用于函数内，且无法指定类型</p>
</li>
<li>
<p>go语言中没有专门的字符类型，字符串由一个个字节构成</p>
</li>
<li>
<p>注意，go语言不支持隐式做int和bool类型间的转换，需要自己写btoi或itob函数</p>
</li>
<li>
<p>go、string与float64之间的转换</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-------------------------- int转string ------------------------------</span></span><br><span class="line">i := <span class="built_in">int64</span>(<span class="number">123</span>)</span><br><span class="line">s := strconv.<span class="built_in">Itoa</span>(i)</span><br><span class="line">s := strconv.<span class="built_in">FormatInt</span>(i, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------- string转int ------------------------------</span></span><br><span class="line">i, err := strconv.<span class="built_in">Atoi</span>(s)</span><br><span class="line">i, err := strconv.<span class="built_in">ParseInt</span>(s, <span class="number">10</span>, <span class="number">64</span>)<span class="comment">//转int64</span></span><br><span class="line"><span class="comment">//第二个参数为基数，第三个参数位大小表示期望转换的结果类型，其值可以为0, 8, 16, 32和64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//float转string</span></span><br><span class="line">v := <span class="number">3.1415926535</span></span><br><span class="line">s1 := strconv.<span class="built_in">FormatFloat</span>(v, <span class="string">&#x27;E&#x27;</span>, <span class="number">-1</span>, <span class="number">32</span>)</span><br><span class="line"><span class="comment">//&#x27;e&#x27;&amp;&#x27;E&#x27;: 表示10进制指数</span></span><br><span class="line"><span class="comment">//&#x27;b&#x27;: 表示2进制指数</span></span><br><span class="line"><span class="comment">//&#x27;f&#x27;: 无指数，正常形式</span></span><br><span class="line"><span class="comment">//&#x27;g&#x27;&amp;&#x27;G&#x27;: 大数用&#x27;e&#x27;表示，否则用&#x27;f&#x27;</span></span><br><span class="line"><span class="comment">//&#x27;x&#x27;&amp;&#x27;X&#x27;: 16进制表示的二进制指数</span></span><br><span class="line"><span class="comment">//-1是精度</span></span><br><span class="line">float32s2 := strconv.<span class="built_in">FormatFloat</span>(v, <span class="string">&#x27;E&#x27;</span>, <span class="number">-1</span>, <span class="number">64</span>)<span class="comment">//float64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//string转float</span></span><br><span class="line">s := <span class="string">&quot;3.1415926535&quot;</span></span><br><span class="line">v1, err := strconv.<span class="built_in">ParseFloat</span>(v, <span class="number">32</span>)</span><br><span class="line">v2, err := strconv.<span class="built_in">ParseFloat</span>(v, <span class="number">64</span>)</span><br></pre></td></tr></table></figure>
<h2 id="4-包package"><a class="markdownIt-Anchor" href="#4-包package"></a> 4. 包package</h2>
<ul>
<li>导入多个包：包之间无需逗号，空格间隔即可。不同包需写在不同行，需要圆括号</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>新建自己的包</p>
<ol>
<li>
<p>新建文件夹，新建函数的文件</p>
</li>
<li>
<p>在文件顶部声明包名（不需要与文件夹同名）</p>
</li>
<li>
<p>在文件内写函数</p>
</li>
</ol>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建strutil文件夹，新建reverse.go文件</span></span><br><span class="line"><span class="keyword">package</span> strutil</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  runes := []<span class="type">rune</span>(s)</span><br><span class="line">  <span class="keyword">for</span> i,j := <span class="number">0</span>,<span class="built_in">len</span>(runes)<span class="number">-1</span> ; i&lt;j ; i,j = i+<span class="number">1</span>, j<span class="number">-1</span>&#123;</span><br><span class="line">    runes[i],runes[j] = runes[j],runes[i]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">string</span>(runes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建后，导入包路径需从src开始，如reverse.go存在/src/github.com/oliverPai/strutil/reverse.go，则导入包时为import “<a target="_blank" rel="noopener" href="http://github.com/oliverPai/strutil" title="github.com/oliverPai/strutil">github.com/oliverPai/strutil</a>”</p>
<ul>
<li>
<p>导入go get获取的包，与导入自己的包一样操作，如aws包</p>
<p>import “<a target="_blank" rel="noopener" href="http://github.com/aws" title="github.com/aws">github.com/aws</a>”</p>
</li>
</ul>
<h2 id="5-数组arrayslice"><a class="markdownIt-Anchor" href="#5-数组arrayslice"></a> 5 数组array&amp;slice</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*------Array 定长数组------*/</span></span><br><span class="line"><span class="comment">/*先声明后赋值*/</span></span><br><span class="line"><span class="keyword">var</span> fruitArr [<span class="number">2</span>] <span class="type">string</span></span><br><span class="line">fruitArr[<span class="number">0</span>] = <span class="string">&quot;Apple&quot;</span></span><br><span class="line">fruitArr[<span class="number">1</span>] = <span class="string">&quot;Orange&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*声明并赋值*/</span></span><br><span class="line">fruitArr_1 := [<span class="number">2</span>]<span class="type">string</span>&#123;<span class="string">&quot;Apple&quot;</span>,<span class="string">&quot;Orange&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*------Slice 不定长数组------*/</span></span><br><span class="line">fruitSlice := []<span class="type">string</span>&#123;<span class="string">&quot;Apple&quot;</span>,<span class="string">&quot;Orange&quot;</span>,<span class="string">&quot;Grape&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>统计数组元素个数可用len函数</p>
</li>
<li>
<p>数组支持切片操作，如fmt.Println(fruitSlice[1:2])输出Orange，从索引1开始，在索引2之前结束</p>
</li>
<li>
<p>make函数构造slice</p>
</li>
</ul>
<p>slice本质上是引用类型，可用make构造</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式：make([]T, size, cap)</span></span><br><span class="line"><span class="comment">//T:切片的元素类型</span></span><br><span class="line"><span class="comment">//size:切片中元素的数量</span></span><br><span class="line"><span class="comment">//cap:切片的容量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line">  fmt.Println(a)      <span class="comment">//[0 0]</span></span><br><span class="line">  fmt.Println(<span class="built_in">len</span>(a)) <span class="comment">//2</span></span><br><span class="line">  fmt.Println(<span class="built_in">cap</span>(a)) <span class="comment">//10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是make([]int,2),则len为2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>slice元素的增删</li>
</ul>
<p>append函数可以用来在slice末尾追加元素</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">  s = <span class="built_in">append</span>(s, <span class="number">1</span>)        <span class="comment">// [1]</span></span><br><span class="line">  s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)  <span class="comment">// [1 2 3 4]</span></span><br><span class="line">  s2 := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;  </span><br><span class="line">  <span class="comment">//对一个slice添加另一个slice的元素时，需要加上...</span></span><br><span class="line">  s = <span class="built_in">append</span>(s, s2...)    <span class="comment">// [1 2 3 4 5 6 7]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>go语言中没有专门的删减slice元素的函数，但是可以通过赋值完成这一目标</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对a中删掉索引为index的元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:index], a[index+<span class="number">1</span>:]...)</span><br></pre></td></tr></table></figure>
<ul>
<li>slice的拷贝</li>
</ul>
<p>slice的拷贝分为两种情况，一种是两个slice共享一片内存区域，二者完全相同，修改一个会更改另一个的值；另一种情况是二者只是数值相同而已，修改一个不会对另一个造成影响</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种情况，直接赋值拷贝，二者共享内存</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  s1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>) <span class="comment">//[0 0 0]</span></span><br><span class="line">  s2 := s1             <span class="comment">//将s1直接赋值给s2，s1和s2共用一个底层数组</span></span><br><span class="line">  s2[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">  fmt.Println(s1) <span class="comment">//[100 0 0]</span></span><br><span class="line">  fmt.Println(s2) <span class="comment">//[100 0 0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二种情况，使用copy函数，不共享内存</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// copy()复制切片</span></span><br><span class="line">  a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">  c := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">  <span class="built_in">copy</span>(c, a)     <span class="comment">//使用copy()函数将切片a中的元素复制到切片c</span></span><br><span class="line">  fmt.Println(a) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">  fmt.Println(c) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">  c[<span class="number">0</span>] = <span class="number">1000</span></span><br><span class="line">  fmt.Println(a) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">  fmt.Println(c) <span class="comment">//[1000 2 3 4 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>判断slice为空应该通过len(slice)<mark>0判断，而不是slice</mark>nil</li>
</ul>
<h2 id="6-函数异常"><a class="markdownIt-Anchor" href="#6-函数异常"></a> 6 函数+异常</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*格式：func 函数名(参数1 参数1类型, 参数2 参数2类型,...)(返回值1类型, 返回值2类型 ,...)&#123;&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greeting</span><span class="params">(name <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span>+name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*某些参数若同类型，可写在一起，只保留一个数据类型*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plus</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*可给返回值命名，也可不命名*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumAndProduct</span><span class="params">(A, B <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> A+B, A*B</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(a, b <span class="type">int</span>)</span></span> (x, y <span class="type">int</span>) &#123;<span class="comment">//命名可使代码阅读和书写更清晰</span></span><br><span class="line">  x = a + <span class="number">100</span><span class="comment">//101</span></span><br><span class="line">  y = b + <span class="number">100</span><span class="comment">//102</span></span><br><span class="line">  <span class="keyword">return</span><span class="comment">//101 102</span></span><br><span class="line">  <span class="comment">//return x, y  //同上</span></span><br><span class="line">  <span class="comment">//return y, x  //102 101</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*匿名函数*/</span></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(a,b <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//直接执行匿名函数——加括号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Anonymous&quot;</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<ul>
<li>匿名函数可以用来做异常处理，通过defer+recover</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;function a\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//仅用panic做异常处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">&quot;panic in b&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">c</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;function c\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  a()</span><br><span class="line">  b()</span><br><span class="line">  c()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出 function a</span></span><br><span class="line"><span class="comment">//     panic: panic in b</span></span><br><span class="line"><span class="comment">//由于在b函数终止，因此未全部执行完</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用匿名函数+defer+recover的异常处理</span></span><br><span class="line"><span class="comment">//defer+recover可暂时跳过出错地方</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    err := <span class="built_in">recover</span>()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;<span class="comment">//检测到错误</span></span><br><span class="line">      fmt.Println(<span class="string">&quot;function b error&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">&quot;panic in b&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出 function a</span></span><br><span class="line"><span class="comment">//     function b error</span></span><br><span class="line"><span class="comment">//     function c</span></span><br><span class="line"><span class="comment">//defer会在函数要退出前执行，所以在执行到</span></span><br><span class="line"><span class="comment">//panic时，由于出错即将退出，触发匿名函数</span></span><br><span class="line"><span class="comment">//执行匿名函数后，不再执行panic、</span></span><br><span class="line"><span class="comment">//defer必须写在可能引发panic的语句之前,</span></span><br><span class="line"><span class="comment">//否则未注册defer，无法执行匿名函数</span></span><br><span class="line"><span class="comment">//如果多个defer函数，它们会逆序执行</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌除了匿名函数+defer+recover做异常处理，还可以使用go内置的error类型</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//error类型定义</span></span><br><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span>&#123;</span><br><span class="line">  Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用errors.New可返回一个错误信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrt</span><span class="params">(f <span class="type">float64</span>)</span></span> (<span class="type">float64</span>,<span class="type">error</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span> f &lt; <span class="number">0</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;math: square root of negative number&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-条件"><a class="markdownIt-Anchor" href="#7-条件"></a> 7 条件</h2>
<ul>
<li>if语句</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go里面的if不需要圆括号</span></span><br><span class="line"><span class="keyword">if</span> color == <span class="string">&quot;red&quot;</span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;color is red&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> color == <span class="string">&quot;blue&quot;</span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;color is blue&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;color is not red or blue&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>switch语句</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go语言在每个case会自动加上一个break，即go里switch不需要break，同时无法控制执行case的数量</span></span><br><span class="line"><span class="keyword">switch</span> color&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;red&quot;</span>:</span><br><span class="line">  fmt.Println(<span class="string">&quot;color is red&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;blue&quot;</span>:</span><br><span class="line">  fmt.Println(<span class="string">&quot;color is blue&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  fmt.Println(<span class="string">&quot;color is not red or blue&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-循环"><a class="markdownIt-Anchor" href="#8-循环"></a> 8 循环</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写法1</span></span><br><span class="line">i := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i &lt;= <span class="number">10</span> &#123;</span><br><span class="line">  fmt.Println(i)</span><br><span class="line">  i++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写法2</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++&#123;</span><br><span class="line">  fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//无限循环</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"> <span class="comment">//content</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>for是go语言提供的唯一循环方式</p>
</li>
<li>
<p>go语言也可以在循环中用continue和break</p>
</li>
</ul>
<h2 id="9-map"><a class="markdownIt-Anchor" href="#9-map"></a> 9 Map</h2>
<p>go语言的Map是键-值对，类似于python的字典</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-------先声明后赋值-------*/</span></span><br><span class="line"><span class="comment">/*格式：make(map[键数据类型][值数据类型])*/</span></span><br><span class="line">emails := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">emails[<span class="string">&quot;Bob&quot;</span>] = <span class="string">&quot;bob@gmail.com&quot;</span></span><br><span class="line">emails[<span class="string">&quot;Sharon&quot;</span>] = <span class="string">&quot;sharon@gmail.com&quot;</span></span><br><span class="line">emails[<span class="string">&quot;Mike&quot;</span>] = <span class="string">&quot;mike@gmail.com&quot;</span></span><br><span class="line"><span class="comment">//从map中删除</span></span><br><span class="line"><span class="built_in">delete</span>(emails,<span class="string">&quot;Bob&quot;</span>)<span class="comment">//格式：delete(map名，键名)</span></span><br><span class="line"><span class="comment">//索引</span></span><br><span class="line">fmt.Println(emails[<span class="string">&quot;Sharon&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------声明的同时赋值-------*/</span></span><br><span class="line"><span class="comment">/*格式：:=map[键数据类型]值数据类型&#123;键1:值1,键2:值2,...&#125;*/</span></span><br><span class="line">emails := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;Bob&quot;</span>:<span class="string">&quot;bob@gmail.com&quot;</span>,<span class="string">&quot;Sharon&quot;</span>:<span class="string">&quot;sharon@gmail.com&quot;</span>&#125;</span><br><span class="line"><span class="comment">//依然可以添加东西</span></span><br><span class="line">emails[<span class="string">&quot;Mike&quot;</span>] = <span class="string">&quot;mike@gmail.com&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="10-范围range"><a class="markdownIt-Anchor" href="#10-范围range"></a> 10 范围range</h2>
<p>range用于遍历数组、map、channel等，能够使for循环成为foreach</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-------遍历数组-------*/</span></span><br><span class="line">ids := []<span class="type">int</span>&#123;<span class="number">33</span>,<span class="number">76</span>,<span class="number">25</span>,<span class="number">89</span>,<span class="number">14</span>,<span class="number">71</span>&#125;</span><br><span class="line"><span class="comment">//range需要传入两个变量，第一项是index，第二项是index对应的元素</span></span><br><span class="line"><span class="keyword">for</span> i,id := <span class="keyword">range</span> ids &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%d - ID: %d&quot;</span>, i, id)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当不想要index时，可用_代替</span></span><br><span class="line"><span class="keyword">for</span> _,id := <span class="keyword">range</span> ids &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;ID: %d&quot;</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------遍历Map-------*/</span></span><br><span class="line">emails := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;Bob&quot;</span>:<span class="string">&quot;bob@gmail.com&quot;</span>,<span class="string">&quot;Sharon&quot;</span>:<span class="string">&quot;sharon@gmail.com&quot;</span>&#125;</span><br><span class="line"><span class="comment">//range需要传入两个变量，第一项是键，第二项是值</span></span><br><span class="line"><span class="keyword">for</span> k,v := <span class="keyword">range</span> emails&#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%s: %s&quot;</span>,k,v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当只想要键不想要值时，可以省略第二项</span></span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> emails&#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Name: &quot;</span> + k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>range对数组的操作同样可以应用到字符串上，第一项index，第二项字符</li>
</ul>
<h2 id="11-指针"><a class="markdownIt-Anchor" href="#11-指针"></a> 11 指针</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  a := <span class="number">5</span></span><br><span class="line">  b := &amp;a<span class="comment">//b是指向a的指针</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;%T&quot;</span>,b)<span class="comment">//输出*int</span></span><br><span class="line">  <span class="comment">//取值</span></span><br><span class="line">  fmt.Println(*b)<span class="comment">//输出5</span></span><br><span class="line">  <span class="comment">//改值</span></span><br><span class="line">  *b = <span class="number">10</span></span><br><span class="line">  fmt.Println(a)<span class="comment">//输出10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>go语言中指针的好处在于，对于操作某连续地址的一大片数据，使用指针可以提高执行效率</p>
</li>
<li>
<p>可以利用指针对特殊地址修改数值</p>
</li>
</ul>
<h2 id="12-闭包closure"><a class="markdownIt-Anchor" href="#12-闭包closure"></a> 12 闭包closure</h2>
<p>闭包是函数作为返回值时，匿名函数内部访问外层变量的行为</p>
<ul>
<li>核心在于，被访问的外层变量相当于被访问了引用，其修改后的值被一直保留</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*------例1------*/</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">//..(..1...).(....2.......)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  sum := <span class="number">0</span><span class="comment">//被访问的外层变量</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    sum += x</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//将函数赋给变量时，需和1处一致</span></span><br><span class="line">  sum := adder()</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt; <span class="number">10</span>; i++&#123;</span><br><span class="line">    <span class="comment">//调用函数变量时，需和2处一致</span></span><br><span class="line">    fmt.Println(sum(i))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//0 1 3 6 10 15 21 28 36 45</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*------例2------*/</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(base <span class="type">int</span>)</span></span>(<span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span><span class="type">int</span>,</span><br><span class="line">                    <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span><span class="type">int</span>)&#123;</span><br><span class="line">  add := <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span><span class="type">int</span>&#123;</span><br><span class="line">    base += i</span><br><span class="line">    <span class="keyword">return</span> base</span><br><span class="line">  &#125;</span><br><span class="line">  sub := <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span><span class="type">int</span>&#123;</span><br><span class="line">    base -= i</span><br><span class="line">    <span class="keyword">return</span> base</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  x,y := calc(<span class="number">100</span>)</span><br><span class="line">  ret1 := x(<span class="number">200</span>)</span><br><span class="line">  <span class="comment">//base已被改成300</span></span><br><span class="line">  fmt.Println(ret1)<span class="comment">//输出100+200=300</span></span><br><span class="line">  <span class="comment">//由于base得以保留，此处base是300</span></span><br><span class="line">  ret2 := y(<span class="number">200</span>)</span><br><span class="line">  fmt.Println(ret2)<span class="comment">//输出300-200=100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>闭包的用处</li>
</ul>
<blockquote>
<p>📌A代码： func (o *Once) Do2(f func()) {}<br />
B代码： func Do1（参数）<br />
需求：   B要调用A写的o对象里的方法Do2，并把自己的Do1当作参数传到Do2   中，但是B写的Do1有传参，而A写的Do2中传入的方法参数是不能带参数的<br />
解决办法：闭包<br />
编写一个func Do3（参数）（func (o *Once) Do2(f func())），也就是新的Do3函数中的参数是Do1中要传入的参数，返回值是Do2，那么在Do2中就能调用Do3中传入的参数，也就是Do1中期望的参数，Do3返回的是一个函数，那这个函数调用了这个函数之外的一个变量，所以形成了一个闭包。</p>
</blockquote>
<h2 id="13-结构体"><a class="markdownIt-Anchor" href="#13-结构体"></a> 13 结构体</h2>
<p>go里没有类，结构体可以有属性和方法，结构体就是类</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个结构体</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">  firstName <span class="type">string</span></span><br><span class="line">  lastName <span class="type">string</span></span><br><span class="line">  city <span class="type">string</span></span><br><span class="line">  gender <span class="type">string</span></span><br><span class="line">  age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//初始化结构体</span></span><br><span class="line">  person1:=Person&#123;firstName:<span class="string">&quot;Samantha&quot;</span>,</span><br><span class="line">  lastName:<span class="string">&quot;Smith&quot;</span>,</span><br><span class="line">  city:<span class="string">&quot;Boston&quot;</span>,</span><br><span class="line">  gender:<span class="string">&quot;f&quot;</span>,</span><br><span class="line">  age:<span class="number">25</span>&#125;</span><br><span class="line">  fmt.Println(person1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左边代码的简便写法</span></span><br><span class="line"><span class="comment">//同类型可以写一起</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">  firstName,lastName,city,gender <span class="type">string</span></span><br><span class="line">  age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//不需要指定属性名</span></span><br><span class="line">  person1 := Person&#123;<span class="string">&quot;Samantha&quot;</span>,<span class="string">&quot;Smith&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Boston&quot;</span>,<span class="string">&quot;f&quot;</span>,<span class="number">25</span>&#125;</span><br><span class="line">  fmt.Println(person1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取属性</span></span><br><span class="line">fmt.Println(person1.firstName)</span><br><span class="line"><span class="comment">//改变属性\</span></span><br><span class="line">person1.age++</span><br><span class="line">fmt.Println(person1.age)</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-------value receiver方法：不改变任何数值-------*/</span></span><br><span class="line"><span class="comment">//格式：func (identifier 结构体名) 函数名 返回值类型&#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> greet() <span class="type">string</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hello, my name is &quot;</span>+p.firstName+<span class="string">&quot; &quot;</span>+p.lastName+<span class="string">&quot; and I am &quot;</span>+strconv.Itoa(p.age)</span><br><span class="line">  <span class="comment">//这里的strconv.Itoa用来int转字符串，否则会报错，需事先导入strconv包</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------pointer receiver方法：改变数值-------*/</span></span><br><span class="line"><span class="comment">//格式：func (identifier *结构体名) 函数名 返回值类型&#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> hasBirthday() &#123;</span><br><span class="line">  p.age++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>identifier相当于this指针，go语言没有- &gt;</p>
</li>
<li>
<p>结构体的方法不能写在结构体内，要写在外面</p>
</li>
<li>
<p>匿名字段——实现结构体的“继承”</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">  Province <span class="type">string</span></span><br><span class="line">  City     <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name    <span class="type">string</span></span><br><span class="line">  Gender  <span class="type">string</span></span><br><span class="line">  Address <span class="comment">//匿名字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当需要访问User中的Address中的Province时可有两种方式</span></span><br><span class="line"><span class="keyword">var</span> user1 User</span><br><span class="line"><span class="comment">//方式1：匿名字段默认按类型名索引</span></span><br><span class="line">user1.Address.Province = Hubei</span><br><span class="line"><span class="comment">//方式2：继承，直接索引，go的struct查找属性顺序：自身属性-&gt;匿名字段属性</span></span><br><span class="line">user1.Province = Hubei</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>一个结构体包含多个匿名字段时，若这些匿名字段包含同名属性，会导致访问报错</p>
</li>
<li>
<p>方法也可以被继承，包含匿名字段结构体时，可选类型为指针</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/Animal 动物</span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Animal)</span></span> move() &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%s会动！\n&quot;</span>, a.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dog 狗</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">  Feet    <span class="type">int8</span></span><br><span class="line">  *Animal <span class="comment">//通过嵌套匿名结构体实现继承</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span></span> wang() &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%s会汪汪汪~\n&quot;</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  d1 := &amp;Dog&#123;</span><br><span class="line">    Feet: <span class="number">4</span>,</span><br><span class="line">    Animal: &amp;Animal&#123; <span class="comment">//注意嵌套的是结构体指针</span></span><br><span class="line">      name: <span class="string">&quot;乐乐&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  d1.wang() <span class="comment">//乐乐会汪汪汪~</span></span><br><span class="line">  d1.move() <span class="comment">//乐乐会动！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>结构体内的标识符（变量名、函数名）首字母大写，则对外可见（别的包可以拿到），否则只能在当前包使用</p>
</li>
<li>
<p>对结构体中的slice赋值</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  name   <span class="type">string</span></span><br><span class="line">  age    <span class="type">int8</span></span><br><span class="line">  act []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  p1 := Person&#123;name: <span class="string">&quot;小王子&quot;</span>, age: <span class="number">18</span>&#125;</span><br><span class="line">  data := []<span class="type">string</span>&#123;<span class="string">&quot;吃饭&quot;</span>, <span class="string">&quot;睡觉&quot;</span>&#125;</span><br><span class="line">  p1.SetAct(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式1：指针赋值</span></span><br><span class="line"><span class="comment">//main中data和p.act共同变化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(p *Person)</span></span>SetAct(dreams[]<span class="type">string</span>)&#123;</span><br><span class="line">  p.act = dreams</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式2：拷贝赋值</span></span><br><span class="line"><span class="comment">//改变data不会改变p.act</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(p *Person)</span></span>SetAct(dreams[]<span class="type">string</span>)&#123;</span><br><span class="line">  p.dreams = <span class="built_in">make</span>([]<span class="type">string</span>,<span class="built_in">len</span>(dreams))</span><br><span class="line">  <span class="built_in">copy</span>(p.act, dreams)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="14-接口interface"><a class="markdownIt-Anchor" href="#14-接口interface"></a> 14 接口interface</h2>
<p>interface是多种结构体共性方法的集合</p>
<p>interface定义命名一个类型，使得不管最初是什么类型的struct，只要实现了interface中的方法，都可以被算作被interface命名的类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  type 接口名 interface&#123;</span></span><br><span class="line"><span class="comment">    方法名1(参数列表1)返回值列表1</span></span><br><span class="line"><span class="comment">    ......</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义interface</span></span><br><span class="line"><span class="keyword">type</span> Shape <span class="keyword">interface</span> &#123;</span><br><span class="line">  area() <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现Circle结构体的area方法</span></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">  x, y, radius <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span></span> area() <span class="type">float64</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> math.Pi * c.radius * c.radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现Rectangle结构体的area方法</span></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">  width, height <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span></span> area() <span class="type">float64</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> r.width * r.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为实现了area方法，Rectangle和Circle都是Shape类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getArea</span><span class="params">(s Shape)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> s.area()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  circle := Circle&#123;x: <span class="number">0</span>, y: <span class="number">0</span>, radius: <span class="number">5</span>&#125;</span><br><span class="line">  rectangle := Rectangle&#123;width: <span class="number">10</span>, height: <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">  fmt.Printf(<span class="string">&quot;Circle Area: %f\n&quot;</span>, getArea(circle))</span><br><span class="line">  fmt.Printf(<span class="string">&quot;Rectangle Area: %f\n&quot;</span>, getArea(rectangle))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>interface是一种类型，一种抽象的类型</p>
</li>
<li>
<p>利用slice和interface可以实现函数参数可变，格式：变量名…类型</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同类型可变参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">functest1</span><span class="params">(values ...<span class="type">int</span>)</span></span>(sum <span class="type">int</span>)&#123;</span><br><span class="line">  sum = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> _,i:=<span class="keyword">range</span> values&#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">    sum += i</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//参数传入方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//参数可以为空</span></span><br><span class="line">  fmt.Println(functest1())</span><br><span class="line">  <span class="comment">//参数可以是1个</span></span><br><span class="line">  fmt.Println(functest1(<span class="number">1</span>))</span><br><span class="line">  <span class="comment">//参数可以是多个</span></span><br><span class="line">  fmt.Println(functest1(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">  <span class="comment">//参数可以是slice，必须有...</span></span><br><span class="line">  <span class="keyword">var</span> tmp []<span class="type">int</span> = []<span class="type">int</span>&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">  fmt.Println(functest1(tmp...))</span><br><span class="line">  <span class="comment">//**可变参函数和以slice为参数的函数不一样**</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不同类型可变参数</span></span><br><span class="line"><span class="comment">//类型必须是空的interface</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">functest2</span><span class="params">(values ... <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> _,i := <span class="keyword">range</span> values&#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;function test2:Type %T,</span></span><br><span class="line"><span class="string">    i %v\n&quot;</span>,i,i)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数传入方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//**方式1：传入interface的slice**</span></span><br><span class="line">  <span class="keyword">var</span> d[] <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  d = <span class="built_in">append</span>(d,<span class="number">1</span>)</span><br><span class="line">  d = <span class="built_in">append</span>(d,<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">  d = <span class="built_in">append</span>(d,<span class="number">3.14</span>)</span><br><span class="line">  functest2(d...)<span class="comment">//一定要有...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//**方式2：直接传不同类型参数**</span></span><br><span class="line">  functest2(<span class="string">&quot;hello&quot;</span>,<span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>go认为，任何类型都实现了空接口，所以空接口可接受任何类型值，也可用于函数参数，接收任何类型。同时可用于map的value，扩展map功能</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var m = make(map[string]interface&#123;&#125;)</span><br><span class="line">m[&#x27;name&#x27;] = &#x27;oliver&#x27;</span><br><span class="line">m[&#x27;age&#x27;] = age</span><br><span class="line">m[&#x27;hobby&#x27;] = []string&#123;&quot;篮球&quot;,&quot;羽毛球&quot;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>数值接收与指针接收实现接口的区别</li>
</ul>
<p>值接收实现的接口，即可用实现接口的结构体，也可以用该结构体的指针调用接口方法</p>
<p>指针接收实现的接口，只能用结构体的指针调用接口方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现Mover接口</span></span><br><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">  move()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结构体dog，将会使用dog实现值接收接口，也将使用&amp;dog实现指针接收接口</span></span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//值实现的接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span></span> move() &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;狗会动&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> x Mover</span><br><span class="line">  <span class="keyword">var</span> val_rec = dog&#123;&#125; <span class="comment">// dog类型</span></span><br><span class="line">  x = val_rec         </span><br><span class="line">  <span class="comment">// x可以接收dog类型</span></span><br><span class="line">  <span class="keyword">var</span> poi_rec = &amp;dog&#123;&#125;<span class="comment">// *dog类型</span></span><br><span class="line">  x = poi_rec         </span><br><span class="line">  <span class="comment">// x可以接收*dog类型</span></span><br><span class="line">  x.move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指针实现的接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *dog)</span></span> move() &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;狗会动&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> x Mover</span><br><span class="line">  <span class="keyword">var</span> poi_rec = &amp;dog&#123;&#125; <span class="comment">// *dog类型</span></span><br><span class="line">  x = poi_rec         </span><br><span class="line">  <span class="comment">// x只能接收*dog类型</span></span><br><span class="line">  x.move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>接口类型变量</li>
</ul>
<p>接口类型变量可以接收任何实现了该接口的类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果有一个Sayer接口，其内部有say方法</span></span><br><span class="line"><span class="comment">//cat结构体和dog结构体都实现了say方法</span></span><br><span class="line"><span class="keyword">var</span> x Sayer</span><br><span class="line">a := cat&#123;&#125; </span><br><span class="line">b := dog&#123;&#125;</span><br><span class="line">x = a       <span class="comment">// 可以把cat实例直接赋值给x</span></span><br><span class="line">x.say()   </span><br><span class="line">x = b       <span class="comment">// 可以把dog实例直接赋值给x</span></span><br><span class="line">x.say()    </span><br></pre></td></tr></table></figure>
<ul>
<li>接口嵌套</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sayer 接口</span></span><br><span class="line"><span class="keyword">type</span> Sayer <span class="keyword">interface</span> &#123;</span><br><span class="line">  say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mover 接口</span></span><br><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">  move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口嵌套，生成新的animal接口</span></span><br><span class="line"><span class="keyword">type</span> animal <span class="keyword">interface</span> &#123;</span><br><span class="line">  Sayer</span><br><span class="line">  Mover</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让一个结构体同时实现say()方法和move()方法，即为实现animal接口</p>
<ul>
<li>接口类型断言</li>
</ul>
<p>接口类型断言用于空接口存储变量时，推断出变量的类型，格式x.(T)：x是空接口变量，T是推断类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x.(T)返回两个变量，第一个是x转换为T类型后的值，第二个是bool值，反映是否推断正确</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  x = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">  v, ok := x.(<span class="type">string</span>)</span><br><span class="line">  <span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;类型断言失败&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="15-反射"><a class="markdownIt-Anchor" href="#15-反射"></a> 15 反射</h2>
<blockquote>
<p>📌补充知识：结构体标签(tag)，只用于反射机制，格式为 <code>key1:&quot;value1&quot; key2:&quot;value2&quot;</code></p>
</blockquote>
<ul>
<li>静态编译语言在编译时，会将变量转换成内存地址，关于变量的信息将消失不见，也无从获取；</li>
</ul>
<p>但是go语言引入了反射机制，可以将变量的信息(变量名、变量类型等)整合到可执行文件中，从而能够实现在程序运行时对变量信息的访问。采用reflect包的API进行反射操作！</p>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/golang-basic/image_-v0q2QWlX3.png" alt="" /></p>
<ul>
<li>reflect.TypeOf()：获取变量类型</li>
</ul>
<p>返回的变量是reflect.Type实例，该实例含有两个重要方法Name和Kind，前者返回类型名(包括自定义类型名)，后者是更加底层的类型，比如Name会返回结构体名，而Kind则是struct</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myInt <span class="type">int64</span></span><br><span class="line"><span class="comment">//获取类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectType</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  t := reflect.TypeOf(x)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;type:%v kind:%v\n&quot;</span>, t.Name(), t.Kind())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a *<span class="type">float32</span> <span class="comment">// 指针</span></span><br><span class="line">  <span class="keyword">var</span> b myInt    <span class="comment">// 自定义类型</span></span><br><span class="line">  <span class="keyword">var</span> c <span class="type">rune</span>     <span class="comment">// 类型别名</span></span><br><span class="line">  reflectType(a) <span class="comment">// type:      kind:ptr</span></span><br><span class="line">  reflectType(b) <span class="comment">// type:myInt kind:int64</span></span><br><span class="line">  reflectType(c) <span class="comment">// type:int32 kind:int32</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age  <span class="type">int</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> d = person&#123;</span><br><span class="line">    name: <span class="string">&quot;Oliver&quot;</span>,</span><br><span class="line">    age:  <span class="number">18</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  reflectType(d) <span class="comment">// type:person kind:struct</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组、切片、Map、指针等类型的变量，Name都是返回空</p>
<ul>
<li>reflect.ValueOf()：获取值信息，即可读值，又可改值</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectValue</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  v := reflect.ValueOf(x)</span><br><span class="line">  k := v.Kind()</span><br><span class="line">  <span class="keyword">switch</span> k &#123;</span><br><span class="line">  <span class="keyword">case</span> reflect.Int64:</span><br><span class="line">    <span class="comment">// v.Int()从反射中获取整型的原始值，然后通过int64()强制类型转换</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;type is int64, value is %d\n&quot;</span>, <span class="type">int64</span>(v.Int()))</span><br><span class="line">  <span class="keyword">case</span> reflect.Float32:</span><br><span class="line">    <span class="comment">// v.Float()从反射中获取浮点型的原始值，然后通过float32()强制类型转换</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;type is float32, value is %f\n&quot;</span>, <span class="type">float32</span>(v.Float()))</span><br><span class="line">  <span class="keyword">case</span> reflect.Float64:</span><br><span class="line">    <span class="comment">// v.Float()从反射中获取浮点型的原始值，然后通过float64()强制类型转换</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;type is float64, value is %f\n&quot;</span>, <span class="type">float64</span>(v.Float()))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a <span class="type">float32</span> = <span class="number">3.14</span></span><br><span class="line">  <span class="keyword">var</span> b <span class="type">int64</span> = <span class="number">100</span></span><br><span class="line">  reflectValue(a) <span class="comment">// type is float32, value is 3.140000</span></span><br><span class="line">  reflectValue(b) <span class="comment">// type is int64, value is 100</span></span><br><span class="line">  <span class="comment">// 将int类型的原始值转换为reflect.Value类型</span></span><br><span class="line">  c := reflect.ValueOf(<span class="number">10</span>)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;type c :%T\n&quot;</span>, c) <span class="comment">// type c :reflect.Value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>reflect.Value可用转换类型方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Int() int64</td>
<td>将值以 int 类型返回，所有有符号整型均可以此方式返回</td>
</tr>
<tr>
<td>Uint() uint64</td>
<td>将值以 uint 类型返回，所有无符号整型均可以此方式返回</td>
</tr>
<tr>
<td>Float() float64</td>
<td>将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回</td>
</tr>
<tr>
<td>Bool() bool</td>
<td>将值以 bool 类型返回</td>
</tr>
<tr>
<td>Bytes() []byts</td>
<td>将值以字节数组 []bytes 类型返回</td>
</tr>
<tr>
<td>String() string</td>
<td>将值以字符串类型返回</td>
</tr>
<tr>
<td>Interface() interface{}</td>
<td>将值以 interface{} 类型返回，可以通过类型断言转换为指定类型</td>
</tr>
</tbody>
</table>
<p>修改值的时候需要注意！</p>
<p>必须用Elem才能修改地址对应的值，不用Elem最后只能修改拷贝值，会引起panic！</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//改值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectSetValue1</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  v := reflect.ValueOf(x)</span><br><span class="line">  <span class="keyword">if</span> v.Kind() == reflect.Int64 &#123;</span><br><span class="line">    v.SetInt(<span class="number">200</span>) <span class="comment">//修改的是副本，reflect包会引发panic</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectSetValue2</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  v := reflect.ValueOf(x)</span><br><span class="line">  <span class="comment">// 反射中使用 Elem()方法获取指针对应的值</span></span><br><span class="line">  <span class="keyword">if</span> v.Elem().Kind() == reflect.Int64 &#123;</span><br><span class="line">    v.Elem().SetInt(<span class="number">200</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a <span class="type">int64</span> = <span class="number">100</span></span><br><span class="line">  <span class="comment">// reflectSetValue1(a) //panic: reflect: reflect.Value.SetInt using unaddressable value</span></span><br><span class="line">  reflectSetValue2(&amp;a)</span><br><span class="line">  fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>结构体反射</li>
</ul>
<p>结构体反射可以用来在运行时获取结构体的属性和方法</p>
<p>reflect.Type可用结构体反射方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NumField() int</td>
<td>返回结构体成员字段数量。</td>
</tr>
<tr>
<td>FieldByName(name string) (StructField, bool)</td>
<td>根据给定字符串返回字符串对应的结构体字段的信息。</td>
</tr>
<tr>
<td>FieldByIndex(index []int) StructField</td>
<td>多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息。</td>
</tr>
<tr>
<td>FieldByNameFunc(match func(string) bool) (StructField,bool)</td>
<td>根据传入的匹配函数匹配需要的字段。</td>
</tr>
<tr>
<td>NumMethod() int</td>
<td>返回该类型的方法集中方法的数目</td>
</tr>
<tr>
<td>Method(int) Method</td>
<td>返回该类型方法集中的第i个方法</td>
</tr>
</tbody>
</table>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用Field方法获取的是一个StructField实例，该结构体结构为</span></span><br><span class="line"><span class="keyword">type</span> StructField <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Name是字段的名字。PkgPath是非导出字段的包路径，对导出字段该字段为&quot;&quot;。</span></span><br><span class="line">    <span class="comment">// 参见http://golang.org/ref/spec#Uniqueness_of_identifiers</span></span><br><span class="line">    Name    <span class="type">string</span></span><br><span class="line">    PkgPath <span class="type">string</span></span><br><span class="line">    Type      Type      <span class="comment">// 字段的类型</span></span><br><span class="line">    Tag       StructTag <span class="comment">// 字段的标签</span></span><br><span class="line">    Offset    <span class="type">uintptr</span>   <span class="comment">// 字段在结构体中的字节偏移量</span></span><br><span class="line">    Index     []<span class="type">int</span>     <span class="comment">// 用于Type.FieldByIndex时的索引切片</span></span><br><span class="line">    Anonymous <span class="type">bool</span>      <span class="comment">// 是否匿名字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取方法</span></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name  <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">  Score <span class="type">int</span>    <span class="string">`json:&quot;score&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  stu1 := student&#123;</span><br><span class="line">    Name:  <span class="string">&quot;小王子&quot;</span>,</span><br><span class="line">    Score: <span class="number">90</span>,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  t := reflect.TypeOf(stu1)</span><br><span class="line">  fmt.Println(t.Name(), t.Kind()) <span class="comment">// student struct</span></span><br><span class="line">  <span class="comment">// 通过for循环遍历结构体的所有字段信息</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">    field := t.Field(i)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;name:%s index:%d type:%v json tag:%v\n&quot;</span>, field.Name, field.Index, field.Type, field.Tag.Get(<span class="string">&quot;json&quot;</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过字段名获取指定结构体字段信息</span></span><br><span class="line">  <span class="keyword">if</span> scoreField, ok := t.FieldByName(<span class="string">&quot;Score&quot;</span>); ok &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;name:%s index:%d type:%v json tag:%v\n&quot;</span>, scoreField.Name, scoreField.Index, scoreField.Type, scoreField.Tag.Get(<span class="string">&quot;json&quot;</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取方法</span></span><br><span class="line"><span class="comment">// 给student添加两个方法 Study和Sleep(注意首字母大写)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s student)</span></span> Study() <span class="type">string</span> &#123;</span><br><span class="line">  msg := <span class="string">&quot;好好学习，天天向上。&quot;</span></span><br><span class="line">  fmt.Println(msg)</span><br><span class="line">  <span class="keyword">return</span> msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s student)</span></span> Sleep() <span class="type">string</span> &#123;</span><br><span class="line">  msg := <span class="string">&quot;好好睡觉，快快长大。&quot;</span></span><br><span class="line">  fmt.Println(msg)</span><br><span class="line">  <span class="keyword">return</span> msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMethod</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  t := reflect.TypeOf(x)</span><br><span class="line">  v := reflect.ValueOf(x)</span><br><span class="line"></span><br><span class="line">  fmt.Println(t.NumMethod())</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumMethod(); i++ &#123;</span><br><span class="line">    methodType := v.Method(i).Type()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;method name:%s\n&quot;</span>, t.Method(i).Name)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;method:%s\n&quot;</span>, methodType)</span><br><span class="line">    <span class="comment">// 通过反射调用方法传递的参数必须是 []reflect.Value 类型</span></span><br><span class="line">    <span class="keyword">var</span> args = []reflect.Value&#123;&#125;</span><br><span class="line">    v.Method(i).Call(args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意上面右边的代码虽然获取了方法的信息，但也有陌生的调用方法的操作method.Call()</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用反射调用函数或方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn</span><span class="params">(p1, p2 <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> p1 + p2</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  valueFunc := reflect.ValueOf(fn)<span class="comment">//reflect.Value实例是函数，输入值和返回值都是[]reflect.Value类型</span></span><br><span class="line">  paramList := []reflect.Value&#123;</span><br><span class="line">    reflect.ValueOf(<span class="number">22</span>),<span class="comment">//设置第一个参数</span></span><br><span class="line">    reflect.ValueOf(<span class="number">20</span>),<span class="comment">//设置第二个参数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 反射调用函数</span></span><br><span class="line">  resultList := valueFunc.Call(paramList)</span><br><span class="line">  <span class="comment">// 获取第一个返回值, 取整数值</span></span><br><span class="line">  fmt.Println(resultList[<span class="number">0</span>].Int()) <span class="comment">// 42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌反射的优劣<br />
优点：搭配接口实现泛型，代码更灵活<br />
缺点：性能低下，使用反射的代码通常比正常代码慢一两个数量级<br />
          代码脆弱，引起panic是真正运行时，代码写完很长时间后</p>
</blockquote>
<h2 id="16-并发"><a class="markdownIt-Anchor" href="#16-并发"></a> 16 并发</h2>
<ul>
<li>goroutine协程</li>
</ul>
<p>go调用协程只需要在被调用的函数前加上go即可</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span>&#123;</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;sync&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup                 <span class="comment">//信号量，计数器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Hello Goroutine!&quot;</span>, i)</span><br><span class="line">  wg.Done()                           <span class="comment">//每当一个协程执行完，需要计数器减一</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  wg.Add(<span class="number">10000</span>)                       <span class="comment">//因为有10000个协程，所以要给计数器加10000</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> hello(i)                       <span class="comment">//执行10000个协程</span></span><br><span class="line">  &#125;</span><br><span class="line">  wg.Wait()                           <span class="comment">// 等待所有登记的goroutine都结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>goroutine调用匿名函数，需要注意闭包情形</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*错误写法*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  wg.Add(<span class="number">10000</span>)                       </span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span>&#123;<span class="comment">//匿名函数</span></span><br><span class="line">      fmt.Println(<span class="string">&quot;Hello Goroutine!&quot;</span>,i)</span><br><span class="line">      wg.Done()                  </span><br><span class="line">    &#125;()<span class="comment">//此时形成了闭包</span></span><br><span class="line">  &#125;</span><br><span class="line">  wg.Wait()                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*正确写法*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  wg.Add(<span class="number">10000</span>)                       </span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">(i <span class="type">int</span>)</span></span>&#123;<span class="comment">//匿名函数</span></span><br><span class="line">      fmt.Println(<span class="string">&quot;Hello Goroutine!&quot;</span>,i)</span><br><span class="line">      wg.Done()                  </span><br><span class="line">    &#125;(i)<span class="comment">//将参数直接传入线程，避免闭包</span></span><br><span class="line">  &#125;</span><br><span class="line">  wg.Wait()                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面左边的写法构成了闭包，也就是i自增时，参数并未传入对应协程，而对应协程将要执行时 才从外部获取i的值，而此时i可能已经自增很多。所以左边的代码最后会输出大量的10000</p>
<p>此外，可以通过GOMAXPROCS参数设置要将协程分配给多少个OS线程，默认使用全部物理线程</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span>&#123;</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;sync&quot;</span></span><br><span class="line">  <span class="string">&quot;runtime&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;A:&quot;</span>, i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;B:&quot;</span>, i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  runtime.GOMAXPROCS(<span class="number">1</span>)<span class="comment">//只有一个物理核心，并行也串行</span></span><br><span class="line">  <span class="keyword">go</span> a()</span><br><span class="line">  <span class="keyword">go</span> b()</span><br><span class="line">  time.Sleep(time.Second)<span class="comment">//等待所有线程结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>channel</li>
</ul>
<p>channel就是消息队列(先入先出)，用于协程之间的通信，格式为：var 变量 chan 数据类型</p>
<p>或：make(chan 元素类型, [缓冲大小])</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新建channel</span></span><br><span class="line"><span class="keyword">var</span> ch1 <span class="keyword">chan</span> <span class="type">int</span>   <span class="comment">// 声明一个传递整型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch2 <span class="keyword">chan</span> <span class="type">bool</span>  <span class="comment">// 声明一个传递布尔型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch3 <span class="keyword">chan</span> []<span class="type">int</span> <span class="comment">// 声明一个传递int切片的通道</span></span><br><span class="line">ch4 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">ch5 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">ch6 := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="type">int</span>)</span><br></pre></td></tr></table></figure>
<p>对于channel，有发送、接收、关闭三种操作，前两者使用&lt; - 符号传递数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送</span></span><br><span class="line">ch &lt;- <span class="number">10</span>   <span class="comment">// 把10发送到ch中</span></span><br><span class="line"><span class="comment">//接收</span></span><br><span class="line">x := &lt;- ch <span class="comment">// 从ch中接收值并赋值给变量x</span></span><br><span class="line">&lt;-ch       <span class="comment">// 从ch中接收值，忽略结果</span></span><br><span class="line"><span class="comment">//关闭</span></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure>
<p>需要注意的是，当channel关闭后，不可再向channel关闭值，可以接收，如果全部接收完，再接收就是该类型的零值。channel不能重复关闭。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无缓冲channel</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="comment">//无缓冲channel如果没有接收操作时就执行发送，最后程序会进入死锁，所以对于无缓冲必须要有接收</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//有缓冲channel</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)<span class="comment">//指定缓冲区大小为1</span></span><br><span class="line"><span class="comment">//发送后无接收会阻塞下一次发送，直至接收完</span></span><br></pre></td></tr></table></figure>
<p>无缓冲可以实现goroutine同步</p>
<ul>
<li>channel被关闭后，若一直接收最后会无限接收零值，所以需要机制判断channel为空</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******机制1：利用接收操作时返回的布尔值*******/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">  <span class="comment">// 开启goroutine将0~100的数发送到ch1中</span></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">      ch1 &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(ch1)</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    i, ok := &lt;-ch1 <span class="comment">// 通道关闭后再取值时，ok=false</span></span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******机制2：使用for range*******/</span></span><br><span class="line"><span class="comment">// channel 练习</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">  <span class="comment">// 开启goroutine将0~100的数发送到ch1中</span></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">      ch1 &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(ch1)</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="comment">// 在主goroutine中从ch1中接收值打印</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="keyword">range</span> ch1 &#123; <span class="comment">// 通道关闭后会退出for range循环</span></span><br><span class="line">    fmt.Println(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>单向通道</li>
</ul>
<p>单向通道就是只能发送或接收，只有单项操作的通道，比如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">chan</span>&lt;- <span class="type">int</span> <span class="comment">//只写通道，只能向该通道输入int值</span></span><br><span class="line">&lt;-<span class="keyword">chan</span> <span class="type">int</span> <span class="comment">//只读通道，只能从该通道读取int值</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">    out &lt;- i</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squarer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="type">int</span>, in &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="keyword">range</span> in &#123;</span><br><span class="line">    out &lt;- i * i</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="keyword">range</span> in &#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">  ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">  <span class="keyword">go</span> counter(ch1)</span><br><span class="line">  <span class="keyword">go</span> squarer(ch2, ch1)</span><br><span class="line">  printer(ch2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Select语句</li>
</ul>
<p>select类似于switch，有很多case和一个default，用来在一个语句块对多个channel进行收发操作，每个case对应一个收和发</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> x := &lt;-ch:</span><br><span class="line">      fmt.Println(x)</span><br><span class="line">    <span class="keyword">case</span> ch &lt;- i:</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次可处理一个case，若有多个case可执行操作，会随机选取一个执行</p>
<p>没有case的select会一直等待，阻塞程序</p>
<ul>
<li>同步</li>
</ul>
<p>当多个goroutine同时操作一个资源(临界区)时，就有竞态问题，此时需要利用锁实现同步</p>
<p>互斥锁sync.Mutex：当一个协程将资源锁住，进行操作时，其它协程必须等待解锁才能访问资源</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">int64</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">    lock.Lock() <span class="comment">// 加锁</span></span><br><span class="line">    x = x + <span class="number">1</span></span><br><span class="line">    lock.Unlock() <span class="comment">// 解锁</span></span><br><span class="line">  &#125;</span><br><span class="line">  wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  wg.Add(<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">go</span> add()</span><br><span class="line">  <span class="keyword">go</span> add()</span><br><span class="line">  wg.Wait()</span><br><span class="line">  fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读写互斥锁sync.RWMutex：资源被一个goroutine上了写锁后，其它协同都必须等待解锁才能进行读写操作；而被上了读锁时，其它要进行读操作的协同可以读，写操作的协程需要等待</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  x      <span class="type">int64</span></span><br><span class="line">  wg     sync.WaitGroup</span><br><span class="line">  lock   sync.Mutex</span><br><span class="line">  rwlock sync.RWMutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">()</span></span> &#123;</span><br><span class="line">  rwlock.Lock() <span class="comment">// 加写锁</span></span><br><span class="line">  x = x + <span class="number">1</span></span><br><span class="line">  time.Sleep(<span class="number">10</span> * time.Millisecond) <span class="comment">// 假设读操作耗时10毫秒</span></span><br><span class="line">  rwlock.Unlock()                   <span class="comment">// 解写锁</span></span><br><span class="line">  wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">()</span></span> &#123;</span><br><span class="line">  rwlock.RLock()               <span class="comment">// 加读锁</span></span><br><span class="line">  time.Sleep(time.Millisecond) <span class="comment">// 假设读操作耗时1毫秒</span></span><br><span class="line">  rwlock.RUnlock()             <span class="comment">// 解读锁</span></span><br><span class="line">  wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  start := time.Now()</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> write()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> read()</span><br><span class="line">  &#125;</span><br><span class="line">  wg.Wait()</span><br><span class="line">  end := time.Now()</span><br><span class="line">  fmt.Println(end.Sub(start))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用读写互斥锁执行上面代码要比用互斥锁快十倍</p>
<ul>
<li>并发中的单例：sync.Once</li>
</ul>
<p>针对高并发情形下只执行一次的操作，可以使用sync.Once避免一系列问题，比如下面例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="type">string</span>]image.Image</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">  icons = <span class="keyword">map</span>[<span class="type">string</span>]image.Image&#123;</span><br><span class="line">    <span class="string">&quot;left&quot;</span>:  loadIcon(<span class="string">&quot;left.png&quot;</span>),</span><br><span class="line">    <span class="string">&quot;up&quot;</span>:    loadIcon(<span class="string">&quot;up.png&quot;</span>),</span><br><span class="line">    <span class="string">&quot;right&quot;</span>: loadIcon(<span class="string">&quot;right.png&quot;</span>),</span><br><span class="line">    <span class="string">&quot;down&quot;</span>:  loadIcon(<span class="string">&quot;down.png&quot;</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Icon被多个goroutine调用不是并发安全的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="type">string</span>)</span></span> image.Image &#123;</span><br><span class="line">  <span class="keyword">if</span> icons == <span class="literal">nil</span> &#123;</span><br><span class="line">    loadIcons()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">  icons = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]image.Image)</span><br><span class="line">  icons[<span class="string">&quot;left&quot;</span>] = loadIcon(<span class="string">&quot;left.png&quot;</span>)</span><br><span class="line">  icons[<span class="string">&quot;up&quot;</span>] = loadIcon(<span class="string">&quot;up.png&quot;</span>)</span><br><span class="line">  icons[<span class="string">&quot;right&quot;</span>] = loadIcon(<span class="string">&quot;right.png&quot;</span>)</span><br><span class="line">  icons[<span class="string">&quot;down&quot;</span>] = loadIcon(<span class="string">&quot;down.png&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种情况下，可能会出现一个协程调用Icon时，写icons这个map只写到一半，还没写到right，就有另一个协程调用Icon了。</p>
<p>此时icons不是nil，但是要调用icons[“right”]，导致错误。</p>
<p>使用sync.Once的Do方法执行if里的操作可以解决这一问题</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/****************正确写法*****************/</span></span><br><span class="line"><span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="type">string</span>]image.Image</span><br><span class="line"><span class="keyword">var</span> loadIconsOnce sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">  icons = <span class="keyword">map</span>[<span class="type">string</span>]image.Image&#123;</span><br><span class="line">    <span class="string">&quot;left&quot;</span>:  loadIcon(<span class="string">&quot;left.png&quot;</span>),</span><br><span class="line">    <span class="string">&quot;up&quot;</span>:    loadIcon(<span class="string">&quot;up.png&quot;</span>),</span><br><span class="line">    <span class="string">&quot;right&quot;</span>: loadIcon(<span class="string">&quot;right.png&quot;</span>),</span><br><span class="line">    <span class="string">&quot;down&quot;</span>:  loadIcon(<span class="string">&quot;down.png&quot;</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Icon 是并发安全的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="type">string</span>)</span></span> image.Image &#123;</span><br><span class="line">  loadIconsOnce.Do(loadIcons)</span><br><span class="line">  <span class="keyword">return</span> icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sync.Once相当于有一个互斥锁和布尔值，前者上锁保护临界资源和布尔值，后者标记是否执行过</p>
<ul>
<li>面向并发的map：sync.Map</li>
</ul>
<p>多个协程同时写map是不被允许也是不安全的，若想不加锁的前提下使用map，可以用sync.Map</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = sync.Map&#123;&#125;</span><br><span class="line"><span class="comment">//sync.Map的读操作是Load方法，写操作是Store方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">      key := strconv.Itoa(n)</span><br><span class="line">      m.Store(key, n)</span><br><span class="line">      value, _ := m.Load(key)<span class="comment">//第二个返回值是布尔类型，判断是否被找到</span></span><br><span class="line">      fmt.Printf(<span class="string">&quot;k=:%v,v:=%v\n&quot;</span>, key, value)</span><br><span class="line">      wg.Done()</span><br><span class="line">    &#125;(i)</span><br><span class="line">  &#125;</span><br><span class="line">  wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得一提的是，sync.Map的键值都是空接口类型，也就是说可以在同一个sync.Map存储任意类型的键-值对，而不是像传统map要把类型写死</p>
<ul>
<li>原子操作</li>
</ul>
<p>原子操作操作数据时是不可被分割的，所以不会被其它协程抢占，并发安全，而且性能比互斥锁优异</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;sync&quot;</span></span><br><span class="line">  <span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Counter <span class="keyword">interface</span> &#123;</span><br><span class="line">  Inc()</span><br><span class="line">  Load() <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原子操作版</span></span><br><span class="line"><span class="keyword">type</span> AtomicCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">  counter <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AtomicCounter)</span></span> Inc() &#123;</span><br><span class="line">  atomic.AddInt64(&amp;a.counter, <span class="number">1</span>)<span class="comment">//原子方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AtomicCounter)</span></span> Load() <span class="type">int64</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> atomic.LoadInt64(&amp;a.counter)<span class="comment">//原子方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(c Counter)</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">  start := time.Now()</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      c.Inc()</span><br><span class="line">      wg.Done()</span><br><span class="line">    &#125;()</span><br><span class="line">  &#125;</span><br><span class="line">  wg.Wait()</span><br><span class="line">  end := time.Now()</span><br><span class="line">  fmt.Println(c.Load(), end.Sub(start))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c3 := AtomicCounter&#123;&#125; <span class="comment">// 并发安全且比互斥锁效率更高</span></span><br><span class="line">  test(&amp;c3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="17-io编程"><a class="markdownIt-Anchor" href="#17-io编程"></a> 17 IO编程</h2>
<h3 id="171-文件io"><a class="markdownIt-Anchor" href="#171-文件io"></a> 17.1 文件IO</h3>
<p>文件读和写分别至少有三种方式，并且读文件和写文件时文件的打开方式也是不同的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读---打开文件:os.Open(文件名)</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 只读方式打开当前目录下的main.go文件</span></span><br><span class="line">  file, err := os.Open(<span class="string">&quot;./main.go&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;open file failed!, err:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 关闭文件</span></span><br><span class="line">  <span class="keyword">defer</span> file.Close()<span class="comment">//用defer保证最后一定会关闭文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写---打开文件：os.OpenFile(文件名,模式,权限设置)</span></span><br><span class="line"><span class="comment">//模式：os.O_WRONLY(只写)、os.O_CREATE(创建文件)、</span></span><br><span class="line"><span class="comment">//os.O_RDONLY(只读)、os.O_RDWR(读写)、os.O_TRUNC(清空)、os.O_APPEND(追加)</span></span><br><span class="line"><span class="comment">//权限：r（读）04，w（写）02，x（执行）01</span></span><br><span class="line"><span class="comment">//   owner   group   other</span></span><br><span class="line"><span class="comment">//0 - rwx  -  rwx  -  rwx</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  file, err := os.OpenFile(<span class="string">&quot;xx.txt&quot;</span>, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;open file failed, err:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> file.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>读文件的三种方式</li>
</ul>
<p>方式一：file.Read()，优势：原生读文件方式，可以精准把控读到的字节数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Read()函数会接收一个字节数组做参数</span></span><br><span class="line"><span class="comment">//返回字节数和error类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 只读方式打开当前目录下的main.go文件</span></span><br><span class="line">  file, err := os.Open(<span class="string">&quot;./main.go&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Failed!, err:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> file.Close()</span><br><span class="line">  <span class="comment">// 使用Read方法读取数据</span></span><br><span class="line">  <span class="keyword">var</span> tmp = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">128</span>)</span><br><span class="line">  n, err := file.Read(tmp)</span><br><span class="line">  <span class="keyword">if</span> err == io.EOF &#123;<span class="comment">//读取少于128字节，读完了</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;文件读完了&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Failed, err:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;读取了%d字节数据\n&quot;</span>, n)</span><br><span class="line">  fmt.Println(<span class="type">string</span>(tmp[:n]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环读取</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 只读方式打开当前目录下的main.go文件</span></span><br><span class="line">  file, err := os.Open(<span class="string">&quot;./main.go&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;open failed!, err:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> file.Close()</span><br><span class="line">  <span class="comment">// 循环读取文件</span></span><br><span class="line">  <span class="keyword">var</span> content []<span class="type">byte</span></span><br><span class="line">  <span class="keyword">var</span> tmp = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">128</span>)</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    n, err := file.Read(tmp)</span><br><span class="line">    <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;文件读完了&quot;</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;read failed, err:&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    content = <span class="built_in">append</span>(content, tmp[:n]...)</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="type">string</span>(content))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方式二：bufio读取文件，优势：提供大量函数，读文件更加灵活，而且会先从磁盘读到缓存，然后使用时可直接从缓存取数据，减少了磁盘IO带来的瓶颈效应，速度快</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;bufio&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;io&quot;</span></span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// bufio按行读取示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  file, err := os.Open(<span class="string">&quot;./xx.txt&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;open file failed, err:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> file.Close()</span><br><span class="line">  reader := bufio.NewReader(file)<span class="comment">//需要new一个reader对象</span></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    line, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>) <span class="comment">//注意是字符</span></span><br><span class="line">    <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">len</span>(line) != <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Println(line)</span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Println(<span class="string">&quot;文件读完了&quot;</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;read file failed, err:&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Print(line)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方式三：io/ioutil包的ReadFile方法，优势：可以一次读取完整文件内容，不需要Open、Close</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ioutil.ReadFile读取整个文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  content, err := ioutil.ReadFile(<span class="string">&quot;./main.go&quot;</span>)<span class="comment">//返回的是字节数组</span></span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;read file failed, err:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="type">string</span>(content))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>写文件的三种方式</li>
</ul>
<p>方式一：os包的write和writeString函数，前者写字节数组，后者写字符串</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  file, err := os.OpenFile(<span class="string">&quot;xx.txt&quot;</span>, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;open file failed, err:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> file.Close()</span><br><span class="line">  str := <span class="string">&quot;hello 沙河&quot;</span></span><br><span class="line">  file.Write([]<span class="type">byte</span>(str))       <span class="comment">//写入字节切片数据</span></span><br><span class="line">  file.WriteString(<span class="string">&quot;hello 小王子&quot;</span>) <span class="comment">//直接写入字符串数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方式二：bufio的writer对象，需要注意的是，这种方式先写到缓存里，再刷新到磁盘中，所以写完后，需要执行Flush函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  file, err := os.OpenFile(<span class="string">&quot;xx.txt&quot;</span>, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;open file failed, err:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> file.Close()</span><br><span class="line">  writer := bufio.NewWriter(file)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    writer.WriteString(<span class="string">&quot;hello沙河\n&quot;</span>) <span class="comment">//将数据先写入缓存</span></span><br><span class="line">  &#125;</span><br><span class="line">  writer.Flush() <span class="comment">//将缓存中的内容写入文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方式三：io/ioutil包的WriteFile方法，其最后一个参数与OpenFile的最后一个参数一致</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不需要OpenFile、Close</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  str := <span class="string">&quot;hello 沙河&quot;</span></span><br><span class="line">  err := ioutil.WriteFile(<span class="string">&quot;./xx.txt&quot;</span>, []<span class="type">byte</span>(str), <span class="number">0666</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;write file failed, err:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="172-log包输出日志"><a class="markdownIt-Anchor" href="#172-log包输出日志"></a> 17.2 log包输出日志</h3>
<p>go语言中的log包与python中的logging非常相似，都有logger，可以指定输出到控制台或文件，有fomatter，不同信息有不同等级。</p>
<p><a target="_blank" rel="noopener" href="https://golang.org/pkg/log/" title="https://golang.org/pkg/log/">https://golang.org/pkg/log/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1QJ411X7CN?from=search&amp;seid=2882714410354221537" title="https://www.bilibili.com/video/BV1QJ411X7CN?from=search&amp;seid=2882714410354221537">https://www.bilibili.com/video/BV1QJ411X7CN?from=search&amp;seid=2882714410354221537</a></p>
<h3 id="173-fmt包"><a class="markdownIt-Anchor" href="#173-fmt包"></a> 17.3 fmt包</h3>
<h2 id="18-正则表达式"><a class="markdownIt-Anchor" href="#18-正则表达式"></a> 18 正则表达式</h2>
<p>Go语言的正则表达式用到了&quot;regexp&quot;包，正则格式和python中的无异。</p>
<p>有两种方式进行正则表达式匹配，一种是正则字符串直接拿来匹配，另一种是将正则表达式字符串通过函数优化成go语言的regexp对象，再利用该对象的方法。后者是线程安全的！</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方式：正则字符串直接匹配</span></span><br><span class="line">matched, err := regexp.MatchString(<span class="string">`a.b`</span>, <span class="string">&quot;aaxbb&quot;</span>)<span class="comment">//注意需要用反引号</span></span><br><span class="line">fmt.Println(matched) <span class="comment">// true</span></span><br><span class="line">fmt.Println(err)     <span class="comment">// nil (regexp is valid)</span></span><br><span class="line"></span><br><span class="line">matched, _ := regexp.MatchString(<span class="string">`^a.b$`</span>, <span class="string">&quot;aaxbb&quot;</span>)</span><br><span class="line">fmt.Println(matched) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二种方式：正则字符串先编译成regexp对象</span></span><br><span class="line"><span class="comment">//两种编译方式</span></span><br><span class="line">re1, err := regexp.Compile(<span class="string">`regexp`</span>) <span class="comment">// error if regexp invalid</span></span><br><span class="line">re2 := regexp.MustCompile(<span class="string">`regexp`</span>)  <span class="comment">// panic if regexp invalid</span></span><br><span class="line"><span class="comment">//后者可直接配合defer recover</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Find：find有两种，一种用字符串，一种用字节数组，没有String字样的find方法都是字节数组</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到第一个匹配的子串</span></span><br><span class="line"><span class="comment">//方法的参数是待匹配的字符串</span></span><br><span class="line">re := regexp.MustCompile(<span class="string">`foo.?`</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, re.FindString(<span class="string">&quot;seafood fool&quot;</span>)) <span class="comment">// &quot;food&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, re.FindString(<span class="string">&quot;meat&quot;</span>))         <span class="comment">// &quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//找到第一个匹配的子串的位置</span></span><br><span class="line">re := regexp.MustCompile(<span class="string">`ab?`</span>)</span><br><span class="line">fmt.Println(re.FindStringIndex(<span class="string">&quot;tablett&quot;</span>))    <span class="comment">// [1 3]</span></span><br><span class="line">fmt.Println(re.FindStringIndex(<span class="string">&quot;foo&quot;</span>) == <span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//找到所有匹配的子串</span></span><br><span class="line">re := regexp.MustCompile(<span class="string">`a.`</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, re.FindAllString(<span class="string">&quot;paranormal&quot;</span>, <span class="number">-1</span>)) <span class="comment">// [&quot;ar&quot; &quot;an&quot; &quot;al&quot;]</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, re.FindAllString(<span class="string">&quot;paranormal&quot;</span>, <span class="number">2</span>))  <span class="comment">// [&quot;ar&quot; &quot;an&quot;]</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, re.FindAllString(<span class="string">&quot;graal&quot;</span>, <span class="number">-1</span>))      <span class="comment">// [&quot;aa&quot;]</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, re.FindAllString(<span class="string">&quot;none&quot;</span>, <span class="number">-1</span>))       <span class="comment">// [] (nil slice)</span></span><br><span class="line"><span class="comment">//FindAllString方法最后一个参指定返回多少子串</span></span><br><span class="line"><span class="comment">//小于0：返回所有；等于0：不返回；大于0：返回这个数量的子串</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Replace：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">re := regexp.MustCompile(<span class="string">`ab*`</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, re.ReplaceAllString(<span class="string">&quot;-a-abb-&quot;</span>, <span class="string">&quot;T&quot;</span>)) <span class="comment">// &quot;-T-T-&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Split：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a := regexp.MustCompile(<span class="string">`a`</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, a.Split(<span class="string">&quot;banana&quot;</span>, <span class="number">-1</span>)) <span class="comment">// [&quot;b&quot; &quot;n&quot; &quot;n&quot; &quot;&quot;]</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, a.Split(<span class="string">&quot;banana&quot;</span>, <span class="number">0</span>))  <span class="comment">// [] (nil slice)</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, a.Split(<span class="string">&quot;banana&quot;</span>, <span class="number">1</span>))  <span class="comment">// [&quot;banana&quot;]</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, a.Split(<span class="string">&quot;banana&quot;</span>, <span class="number">2</span>))  <span class="comment">// [&quot;b&quot; &quot;nana&quot;]</span></span><br><span class="line"></span><br><span class="line">zp := regexp.MustCompile(<span class="string">`z+`</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, zp.Split(<span class="string">&quot;pizza&quot;</span>, <span class="number">-1</span>)) <span class="comment">// [&quot;pi&quot; &quot;a&quot;]</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, zp.Split(<span class="string">&quot;pizza&quot;</span>, <span class="number">0</span>))  <span class="comment">// [] (nil slice)</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, zp.Split(<span class="string">&quot;pizza&quot;</span>, <span class="number">1</span>))  <span class="comment">// [&quot;pizza&quot;]</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, zp.Split(<span class="string">&quot;pizza&quot;</span>, <span class="number">2</span>))  <span class="comment">// [&quot;pi&quot; &quot;a&quot;]</span></span><br><span class="line"><span class="comment">//Split方法最后一个参数指定返回多少子串</span></span><br><span class="line"><span class="comment">//小于0：返回所有；等于0：不返回；大于0：返回这个数量的子串</span></span><br></pre></td></tr></table></figure>
<h2 id="19-go语言常用标准库"><a class="markdownIt-Anchor" href="#19-go语言常用标准库"></a> 19 go语言常用标准库</h2>
<h3 id="191-time"><a class="markdownIt-Anchor" href="#191-time"></a> 19.1 time</h3>
<h3 id="192-flag"><a class="markdownIt-Anchor" href="#192-flag"></a> 19.2 flag</h3>
<h3 id="193-strconv"><a class="markdownIt-Anchor" href="#193-strconv"></a> 19.3 strconv</h3>
<h1 id="go语言底层原理"><a class="markdownIt-Anchor" href="#go语言底层原理"></a> Go语言底层原理</h1>
<p>《Go语言底层原理剖析》</p>
<p>Golang修养之路：<a target="_blank" rel="noopener" href="https://www.kancloud.cn/aceld/golang" title="https://www.kancloud.cn/aceld/golang">https://www.kancloud.cn/aceld/golang</a></p>
<h2 id="gmp模型"><a class="markdownIt-Anchor" href="#gmp模型"></a> GMP模型</h2>
<h2 id="逃逸现象"><a class="markdownIt-Anchor" href="#逃逸现象"></a> 逃逸现象</h2>
<h2 id="make和new-的区别"><a class="markdownIt-Anchor" href="#make和new-的区别"></a> make和new 的区别</h2>
<ul>
<li>
<p>变量声明：</p>
<p><code>var</code>关键字，不指定变量默认值时，变量的默认值会是零值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="type">int</span>    <span class="comment">//int类型的零值是0</span></span><br><span class="line"><span class="keyword">var</span> s <span class="type">string</span> <span class="comment">//string类型的零值是&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>引用类型的零值是nil</p>
</li>
<li>
<p>new内存分配</p>
</li>
</ul>
<p>使用new时必须先分配内存</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> i *<span class="type">int</span></span><br><span class="line">   *i=<span class="number">10</span></span><br><span class="line">   fmt.Println(*i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> i *<span class="type">int</span></span><br><span class="line">   i=<span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">   *i=<span class="number">10</span></span><br><span class="line">   fmt.Println(*i)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>new()只接收一个参数，就是类型。<strong>返回的是类型指针</strong>，并且分配内存后会默认给指针指向的地址赋零值。</p>
<ul>
<li>make内存分配</li>
</ul>
<p>make只用于三种类型：<code>chan</code>，<code>map</code>，<code>slice</code>的内存创建。而且<strong>返回的</strong>不是指针，而<strong>就是这三种类型</strong>（不是指针，因为它们自身就是引用类型）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(t Type, size ...IntegerType)</span></span> Type</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="type">int</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*格式：make(map[键数据类型][值数据类型])*/</span></span><br><span class="line">emails := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T:切片的元素类型</span></span><br><span class="line"><span class="comment">//size:切片中元素的数量</span></span><br><span class="line"><span class="comment">//cap:切片的容量</span></span><br><span class="line">a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>make与new的异同：</p>
<ul>
<li>
<p>相同：均为堆空间分配</p>
</li>
<li>
<p>不同：</p>
<p>make：只用于slice、map和chan的初始化，无可替代；</p>
<p>new：用于类型内存分配（初始化值为0），不常用</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>📌new不常用：<br />
现实代码通常采用短语句声明以及结构体的字面量达到分配内存目的，如：<br />
i := 0<br />
u := user{}</p>
</blockquote>
<h2 id="内存分配"><a class="markdownIt-Anchor" href="#内存分配"></a> 内存分配</h2>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/golang-basic/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86_tZ5L5K7RyB.jpg" alt="" /></p>
<h2 id="垃圾回收"><a class="markdownIt-Anchor" href="#垃圾回收"></a> 垃圾回收</h2>
<blockquote>
<p>📌<strong>为什么需要垃圾回收？</strong><br />
1. 减少错误和复杂性<br />
手动分配、释放内存等可能会带来内存泄露、野指针等问题。虽然垃圾回收不保证完全不产生内存泄露，但其提供了重要的保障，即不再被引用的对象最终将被收集。<br />
同时，可以避免悬空指针、多次释放等手动管理内存时会出现的问题。<br />
垃圾回收功能屏蔽了内存管理的复杂性，开发者可更好地关注核心业务逻辑。<br />
2. 解耦<br />
现代软件工程崇尚模块化，而模块间只提供少量接口以交互。当多个模块同时维护一个内存时，释放内存将变得非常小心。<br />
手动分配面临这样的问题：缺乏信息，难以在本地模块内做出全局的决定。<br />
垃圾回收机制将此工作托管给了具有全局视野的运行时代码，从而使业务模块间真正解耦，从而有利于开发、调试，并开发出更大规模的、高并发的项目。</p>
</blockquote>
<blockquote>
<p>📌<strong>什么场景需要垃圾回收？</strong><br />
垃圾回收带来了额外的成本，需要保存内存的状态信息并扫描内存，很多时候还需要中断整个程序来处理垃圾回收。<br />
因此，垃圾回收<strong>对于要求极致的速度和内存要求极小的场景并不适用</strong>（嵌入式、系统级程序）；<br />
却是开发大规模、分布式、微服务集群的极佳选择。</p>
</blockquote>
<h3 id="go垃圾回收中的三色标记"><a class="markdownIt-Anchor" href="#go垃圾回收中的三色标记"></a> Go垃圾回收中的三色标记：</h3>
<h3 id="go执行垃圾回收具体流程"><a class="markdownIt-Anchor" href="#go执行垃圾回收具体流程"></a> Go执行垃圾回收具体流程：</h3>
<h2 id="defer"><a class="markdownIt-Anchor" href="#defer"></a> defer</h2>
<h3 id="defer的执行顺序"><a class="markdownIt-Anchor" href="#defer的执行顺序"></a> defer的执行顺序</h3>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/golang-basic/image_klHnHNaXk-.png" alt="" /></p>
<p>栈：先进后出</p>
<h3 id="函数的返回值初始化"><a class="markdownIt-Anchor" href="#函数的返回值初始化"></a> 函数的返回值初始化</h3>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/golang-basic/image_Rjj_29L3So.png" alt="" /></p>
<p>只要函数返回值有名字（例子中为t），这个<code>t</code>会在函数起始处被初始化为对应类型的零值并且作用域为整个函数。</p>
<h3 id="return和defer谁先谁后-有名函数返回值遇见defer情况"><a class="markdownIt-Anchor" href="#return和defer谁先谁后-有名函数返回值遇见defer情况"></a> return和defer谁先谁后 &amp; 有名函数返回值遇见defer情况</h3>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/golang-basic/image_xlY7fDYo9I.png" alt="" /></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnButDefer</span><span class="params">()</span></span> (t <span class="type">int</span>) &#123;  <span class="comment">//t初始化0， 并且作用域为该函数全域</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        t = t * <span class="number">10</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(returnButDefer())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go run test.go</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>本应返回1，但是return后进入了defer，所以<code>t=t*10</code>被执行，因此最后返回给main的结果为10。</p>
<h3 id="defer遇见panic"><a class="markdownIt-Anchor" href="#defer遇见panic"></a> defer遇见panic</h3>
<p><img src="https://oliverpai-post-pics.oss-cn-hangzhou.aliyuncs.com/image/golang-basic/image__3aWsdTgIN.png" alt="" /></p>
<h3 id="defer中包含panic"><a class="markdownIt-Anchor" href="#defer中包含panic"></a> defer中包含panic</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">       <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span>&#123;</span><br><span class="line">           fmt.Println(err)</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           fmt.Println(<span class="string">&quot;fatal&quot;</span>)</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;defer panic&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;panic&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">defer panic</span><br></pre></td></tr></table></figure>
<p>触发<code>panic(&quot;panic&quot;)</code>后defer顺序出栈执行，第一个被执行的defer中的<code>panic(&quot;defer panic&quot;)</code>异常，会覆盖掉main中的<code>panic(&quot;panic&quot;)</code>，最后这个异常被第二个执行的defer捕获到。</p>
<h3 id="defer下的函数参数包含子函数"><a class="markdownIt-Anchor" href="#defer下的函数参数包含子函数"></a> defer下的函数参数包含子函数</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function</span><span class="params">(index <span class="type">int</span>, value <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    fmt.Println(index)</span><br><span class="line">    <span class="keyword">return</span> index</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> function(<span class="number">1</span>, function(<span class="number">3</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">defer</span> function(<span class="number">2</span>, function(<span class="number">4</span>, <span class="number">0</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>这里有四个函数，用第一个参数的值给它们标号为1\2\3\4。需要研究它们的先后执行顺序：</p>
<p>有两个defer，所以defer会压栈两次，先进栈1，后进栈2。压1时，由于需要连同函数地址、函数形参一同进栈，因此为了得到第二个参数的结果，需要先执行function3。同理在压2时，就需要先执行function4。</p>
<p>因此执行顺序为：3→4→2→1。</p>
<h1 id="相关工具"><a class="markdownIt-Anchor" href="#相关工具"></a> 相关工具</h1>
<h2 id="grpc"><a class="markdownIt-Anchor" href="#grpc"></a> gRPC</h2>
<blockquote>
<p>gRPC允许</p>
</blockquote>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/golang/" rel="tag"># golang</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
            </div>
            <div class="post-nav-item">
                <a href="/2020/02/24/JavaScript/" rel="next" title="JavaScript">
                  JavaScript <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">OliverPai</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.0/katex.min.css" integrity="sha256-uik/hNqHWZldXh/0K35nqOSCff9F61/ZOFReqNOBgB0=" crossorigin="anonymous">



</body>
</html>
